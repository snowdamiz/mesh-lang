# Milestone v1.0: MVP

**Status:** SHIPPED 2026-02-07
**Phases:** 1-10
**Total Plans:** 55

## Overview

Snow is a statically typed, LLVM-compiled programming language with Elixir-style syntax and BEAM-style actor concurrency. The v1.0 roadmap followed the critical dependency chain: Lexer -> Parser -> Type System -> Pattern Matching -> Codegen -> Actor Runtime -> Supervision -> Standard Library -> Tooling. Each phase delivered a verifiable capability that the next phase built on.

## Phases

### Phase 1: Project Foundation & Lexer

**Goal**: A reproducible Rust workspace with pinned LLVM 18, snapshot test infrastructure, and a lexer that tokenizes all Snow syntax with accurate span tracking
**Depends on**: Nothing (first phase)
**Requirements**: LANG-09
**Plans**: 3 plans

Plans:
- [x] 01-01-PLAN.md -- Rust workspace, shared types (TokenKind, Span, LexError), and test infrastructure
- [x] 01-02-PLAN.md -- Core lexer with Cursor, keywords, operators, numbers, identifiers, simple strings
- [x] 01-03-PLAN.md -- String interpolation, block comments, newlines, error recovery, full test suite

**Details:**
- 39 keywords, 22 operator types
- State-stack string interpolation with nested contexts
- 57 tests including snapshot tests via insta

### Phase 2: Parser & AST

**Goal**: A recursive descent parser that transforms token streams into a lossless CST and typed AST representing all Snow language constructs, with human-readable parse error messages
**Depends on**: Phase 1
**Requirements**: LANG-01, LANG-02, LANG-03, LANG-04, LANG-07, LANG-08, LANG-10, ORG-01, ORG-02, ORG-03
**Plans**: 5 plans

Plans:
- [x] 02-01-PLAN.md -- Parser crate scaffolding, SyntaxKind enum, rowan CST types, event-based Parser struct
- [x] 02-02-PLAN.md -- Pratt expression parser with operator precedence, literals, calls, field access, pipe
- [x] 02-03-PLAN.md -- Compound expressions (if/else, case/match, closures, blocks) and let/return statements
- [x] 02-04-PLAN.md -- Declarations (fn, module, import, struct), patterns, type annotations, visibility
- [x] 02-05-PLAN.md -- Typed AST wrappers, public parse() API, comprehensive snapshot tests

**Details:**
- Rowan-based lossless CST with typed AST overlay
- Pratt parsing for operator precedence
- 134 parser tests including lossless round-trip proofs

### Phase 3: Type System

**Goal**: A Hindley-Milner type inference engine that type-checks Snow programs without requiring type annotations, supporting generics, structs, traits, and Option/Result types
**Depends on**: Phase 2
**Requirements**: TYPE-01, TYPE-02, TYPE-03, TYPE-04, TYPE-05, TYPE-06, TYPE-08
**Plans**: 5 plans

Plans:
- [x] 03-01-PLAN.md -- Parser migration (angle brackets, interface/impl/type alias syntax), snow-typeck crate with type representation, unification, environment, builtins
- [x] 03-02-PLAN.md -- Algorithm J inference engine with let-polymorphism and occurs check (TDD)
- [x] 03-03-PLAN.md -- Structs, Option<T>, Result<T, E>, type aliases (TDD)
- [x] 03-04-PLAN.md -- Traits/interfaces with where-clause constraints and compiler-known operator traits (TDD)
- [x] 03-05-PLAN.md -- ariadne diagnostic rendering, fix suggestions, end-to-end phase verification

**Details:**
- ena-based union-find unification
- Let-polymorphism with level-based generalization
- Error codes E0001-E0009 with ariadne rendering
- 264 tests

### Phase 4: Pattern Matching & Algebraic Data Types

**Goal**: Exhaustive pattern matching compilation with algebraic data types (sum types), guards, and compile-time warnings for missing or redundant patterns
**Depends on**: Phase 3
**Requirements**: LANG-05, LANG-06, LANG-11
**Plans**: 5 plans

Plans:
- [x] 04-01-PLAN.md -- Lexer BAR token, parser sum type definitions, extended pattern syntax (constructor/or/as), typed AST wrappers
- [x] 04-02-PLAN.md -- Type checking for sum types, variant constructors, constructor/or/as pattern inference
- [x] 04-03-PLAN.md -- Maranget's exhaustiveness and redundancy algorithm (TDD)
- [x] 04-04-PLAN.md -- Exhaustiveness/redundancy wiring, guard validation, multi-clause functions
- [x] 04-05-PLAN.md -- Diagnostic rendering, Option/Result migration to sum types, end-to-end integration

**Details:**
- Maranget's usefulness algorithm for exhaustiveness/redundancy
- Option/Result migrated from hardcoded constructors to proper ADTs
- 389 tests

### Phase 5: LLVM Codegen & Native Binaries

**Goal**: The complete compilation pipeline from Snow source to native single-binary executables
**Depends on**: Phase 4
**Requirements**: COMP-01, COMP-02, COMP-03, TOOL-01
**Plans**: 5 plans

Plans:
- [x] 05-01-PLAN.md -- Runtime crate (snow-rt), codegen crate scaffolding, TypeckResult exposure, LLVM build config
- [x] 05-02-PLAN.md -- MIR type system, AST-to-MIR lowering, pipe/interpolation desugaring, closure conversion, monomorphization
- [x] 05-03-PLAN.md -- Pattern match compilation to decision trees (TDD)
- [x] 05-04-PLAN.md -- LLVM codegen via Inkwell (type layouts, expressions, control flow, closures, pattern matches)
- [x] 05-05-PLAN.md -- snowc build CLI, linking, end-to-end integration tests

**Details:**
- MIR intermediate representation between AST and LLVM IR
- Pattern match compilation to decision trees
- Inkwell 0.8.0 for LLVM bindings
- System cc linker with statically linked runtime
- 481 tests, 13 E2E integration tests

### Phase 6: Actor Runtime

**Goal**: Lightweight actor processes with typed message passing, a work-stealing scheduler, and per-actor isolation
**Depends on**: Phase 5
**Requirements**: CONC-01, CONC-02, CONC-03, CONC-04, TYPE-07
**Plans**: 7 plans

Plans:
- [x] 06-01-PLAN.md -- M:N work-stealing scheduler, Process Control Block, corosensei coroutines, reduction counting
- [x] 06-02-PLAN.md -- Compiler frontend: actor keyword, parser for actor/spawn/send/receive/self, MIR extensions
- [x] 06-03-PLAN.md -- Per-actor heaps, FIFO mailbox, message deep-copy, send/receive with scheduler blocking
- [x] 06-04-PLAN.md -- Typed Pid<M> in type checker, compile-time send validation, actor type errors
- [x] 06-05-PLAN.md -- AST-to-MIR lowering for actors, LLVM codegen for actor primitives, reduction check instrumentation
- [x] 06-06-PLAN.md -- Process linking, exit signal propagation, named process registry
- [x] 06-07-PLAN.md -- E2E integration tests, 100K actor benchmark, success criteria verification

**Details:**
- corosensei-based coroutines for M:N scheduling
- Typed Pid<M> with compile-time send validation (E0014-E0017)
- Per-actor heap with bump allocation
- 100K actors in ~2.78s without OOM
- 262 tests

### Phase 7: Supervision & Fault Tolerance

**Goal**: OTP-style supervision trees with restart strategies and let-it-crash semantics
**Depends on**: Phase 6
**Requirements**: CONC-05, CONC-06, CONC-07
**Plans**: 3 plans

Plans:
- [x] 07-01-PLAN.md -- Supervisor runtime: ExitReason expansion, child spec types, all four strategies, restart limits, ordered shutdown
- [x] 07-02-PLAN.md -- Compiler integration: parser, AST, type checker, MIR, LLVM codegen, intrinsics
- [x] 07-03-PLAN.md -- Typed supervision: compile-time child spec validation (E0018-E0021), E2E tests

**Details:**
- one_for_one, one_for_all, rest_for_one, simple_one_for_one strategies
- Restart limits prevent infinite crash loops
- Compile-time child spec validation (E0018-E0021)
- 126+ tests

### Phase 8: Standard Library

**Goal**: Core standard library for I/O, strings, collections, file access, HTTP, and JSON
**Depends on**: Phase 5, Phase 6
**Requirements**: STD-01, STD-02, STD-03, STD-04, STD-05, STD-06, STD-09
**Plans**: 7 plans

Plans:
- [x] 08-01-PLAN.md -- String operations, console I/O, Env access, and module/import namespace resolution
- [x] 08-02-PLAN.md -- Collections (List with map/filter/reduce, Map/HashMap, Set)
- [x] 08-03-PLAN.md -- File I/O with Result types
- [x] 08-04-PLAN.md -- JSON encoding/decoding with serde_json
- [x] 08-05-PLAN.md -- HTTP client and server with thread-per-connection model
- [x] 08-06-PLAN.md -- Gap closure: pipe chain E2E test with closures, IO.read_line E2E test
- [x] 08-07-PLAN.md -- Gap closure: HTTP server runtime E2E test

**Details:**
- Module-qualified access (String.length, List.map, etc.)
- u64 type-erased collections at runtime, typed at compile time
- tiny_http-based HTTP server
- serde_json bridge for JSON
- 28 E2E + 199 unit tests

### Phase 9: Concurrency Standard Library

**Goal**: Service (GenServer) and Job (Task) high-level concurrency abstractions
**Depends on**: Phase 7, Phase 8
**Requirements**: STD-07, STD-08
**Plans**: 5 plans

Plans:
- [x] 09-01-PLAN.md -- Service syntax: lexer keywords, parser for service blocks, AST wrappers
- [x] 09-02-PLAN.md -- Type checking: infer_service_def with state unification, per-variant reply types
- [x] 09-03-PLAN.md -- Service runtime and codegen: call/reply, MIR desugaring to actor primitives
- [x] 09-04-PLAN.md -- Job runtime and codegen: async/await/map, closure argument handling
- [x] 09-05-PLAN.md -- E2E integration tests: Service counter/state, Job async/await, type errors

**Details:**
- Service: synchronous call, asynchronous cast, functional state management
- Job: spawn/await with Result<T, String>, map for parallel work
- 10 compiler/runtime bugs fixed during integration

### Phase 10: Developer Tooling

**Goal**: Developer tools for daily use -- error messages, formatter, REPL, package manager, LSP
**Depends on**: Phase 5, Phase 8
**Requirements**: TOOL-02, TOOL-03, TOOL-04, TOOL-05, TOOL-06
**Plans**: 10 plans

Plans:
- [x] 10-01-PLAN.md -- Error message polish (multi-span diagnostics, --json output, fix suggestions)
- [x] 10-02-PLAN.md -- Formatter core (snow-fmt crate, FormatIR, CST walker, printer)
- [x] 10-03-PLAN.md -- Formatter CLI (snowc fmt, --check mode, idempotency tests)
- [x] 10-04-PLAN.md -- REPL core (snow-repl crate, JIT engine, session management, multi-line)
- [x] 10-05-PLAN.md -- REPL actor support and snowc repl CLI integration
- [x] 10-06-PLAN.md -- Package manager core (snow-pkg crate, snow.toml, dependency resolution)
- [x] 10-07-PLAN.md -- Package manager CLI (snowc init, snowc deps)
- [x] 10-08-PLAN.md -- LSP server core (snow-lsp crate, diagnostics, type-on-hover)
- [x] 10-09-PLAN.md -- LSP go-to-definition and integration tests
- [x] 10-10-PLAN.md -- E2E integration tests and human verification

**Details:**
- Wadler-Lindig formatter with idempotent output
- JIT-based REPL with actor support
- Git/path dependency resolution with lockfile
- LSP with diagnostics, hover, go-to-definition
- VS Code/Cursor extension with TextMate grammar
- 178+ tests

---

## Milestone Summary

**Decimal Phases:**
- None (no urgent insertions were needed)

**Key Decisions:**
- Rust for compiler (strong LLVM bindings, memory safe)
- LLVM as backend (proven codegen, multi-platform)
- Elixir/Ruby syntax style (expressive, readable, pattern matching native)
- Static types with Hindley-Milner inference (safety without verbosity)
- No OOP (functional-first aligns with actor model)
- Bundled runtime (single binary deployment)
- Angle brackets <T> for generics (migrated from [T] in Phase 3)
- corosensei for M:N coroutines (actor runtime)
- Thread-per-connection HTTP server (simpler than actor-per-connection for v1)
- Wadler-Lindig for formatter IR

**Issues Resolved:**
- Actor spawn functions return semantics (Unit at MIR level, runtime allocates Pid externally)
- Scheduler deadlock with interior mutability during coroutine resume
- Main thread process support for Service calls from non-coroutine context
- Eager scheduler worker startup for concurrent actor execution
- Graceful actor shutdown via wake-and-null pattern
- Rowan CST coordinate mismatch for LSP hover accuracy

**Issues Deferred:**
- Multi-clause function definitions (workaround: case expressions)
- String comparison in pattern matching (runtime fallback)
- Distributed actors across nodes (v2)
- Hot code reloading (v2)
- Macros / metaprogramming (v2)

**Technical Debt Incurred:**
- String comparison uses always-false placeholder in pattern codegen
- Pipe operator cannot be used with inline closures (parser limitation)
- HTTP server uses thread-per-connection instead of actor-per-connection
- Dead code warnings in lexer/parser/MIR lowering
- Map.put typed as (Map, Int, Int) -- string-keyed maps need refinement

---

_For current project status, see .planning/PROJECT.md_
