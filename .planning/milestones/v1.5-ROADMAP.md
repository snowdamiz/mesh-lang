# Milestone v1.5: Compiler Correctness

**Status:** ✅ SHIPPED 2026-02-09
**Phases:** 26-29
**Total Plans:** 6

## Overview

Resolve all three remaining known limitations from v1.4 -- polymorphic List<T>, Ord-requires-Eq compile-time enforcement, and higher-order constraint propagation (qualified types). This milestone made the Snow type and trait systems fully correct with zero known compiler correctness issues remaining.

## Phases

### Phase 26: Polymorphic List Foundation

**Goal**: Users can create and use List<T> with any element type, not just Int
**Depends on**: Phase 25 (v1.4 complete)
**Plans**: 2 plans

Plans:

- [x] 26-01: Parser list literal syntax + polymorphic type signatures
- [x] 26-02: MIR lowering + LLVM codegen + list concatenation

**Details:**
- Added LIST_LITERAL syntax and `[expr, ...]` parser support
- Made all List function schemes polymorphic (TyVar 91000/91001)
- List literal type inference with element unification
- ListLit MIR variant with efficient snow_list_from_array codegen (single allocation, O(n))
- Polymorphic value storage: uniform u64 with type-aware conversion (Bool zext, Float bitcast, Ptr ptrtoint)
- List ++ concatenation operator via snow_list_concat
- 6 new e2e tests covering Int, String, Bool, nested, concat, and append operations

**Completed:** 2026-02-08

### Phase 27: List Trait & Pattern Integration

**Goal**: Trait protocols and pattern matching work correctly with polymorphic List<T>
**Depends on**: Phase 26
**Plans**: 2 plans

Plans:

- [x] 27-01: Display/Debug and Eq/Ord trait dispatch for List<T>
- [x] 27-02: Cons pattern (head :: tail) destructuring for List<T>

**Details:**
- Callback-based element comparison: snow_list_eq and snow_list_compare runtime functions
- Parametric Eq/Ord impls for List<T> via single-letter type param + freshen_type_params
- Synthetic MIR wrapper generation for element comparison/display callbacks
- Collection Debug dispatch reuses wrap_collection_to_string
- Right-associative `head :: tail` cons pattern with full parser-to-LLVM pipeline
- ListDecons decision tree node for runtime length check + head/tail extraction
- AccessPath::ListHead/ListTail for pattern sub-value navigation
- Fixed critical name shadowing bug: local variable bindings take precedence over builtin name mappings
- Conservative exhaustiveness for cons patterns (lists are infinite types)

**Completed:** 2026-02-09

### Phase 28: Trait Deriving Safety

**Goal**: Compiler enforces trait dependency rules at compile time instead of failing at runtime
**Depends on**: Phase 25 (v1.4 complete, independent of Phases 26-27)
**Plans**: 1 plan

Plans:

- [x] 28-01: MissingDerivePrerequisite error variant + validation checks + e2e tests

**Details:**
- MissingDerivePrerequisite error variant (E0029) with trait_name, requires, type_name fields
- Ariadne diagnostic with .with_help() suggesting `deriving(Eq, Ord)`
- Validation in both register_struct_def and register_sum_type_def
- Early-return on error to prevent broken MIR generation
- 3 new e2e tests: struct error, sum type error, Eq+Ord together works

**Completed:** 2026-02-09

### Phase 29: Qualified Types

**Goal**: Trait constraints propagate correctly when constrained functions are passed as higher-order arguments
**Depends on**: Phase 25 (v1.4 complete, independent of Phases 26-28)
**Plans**: 1 plan

Plans:

- [x] 29-01: Argument-level constraint check in infer_call/infer_pipe + e2e tests

**Details:**
- Argument-level trait constraint checking in infer_call and infer_pipe
- After HM unification resolves type variables, check fn_constraints on NameRef arguments
- Soft error collection (extend) for argument constraints vs hard Err for callee constraints
- Filter to concrete types only (skip Ty::Var) to prevent false positives
- Covers direct names, let aliases, and nested higher-order passing
- 5 new e2e tests covering conforming, violation, nested, positive, and let-alias cases

**Completed:** 2026-02-09

---

## Milestone Summary

**Key Decisions:**

- 26-01-D1: ConstraintOrigin::Annotation for list literal element unification (matches map literal pattern)
- 26-01-D2: Desugar list literals to list_new + list_append chain (simplest lowering)
- 26-01-D3: Fix Map.keys/values to return List<K>/List<V> (correct typing)
- 26-02-D1: ListLit MIR variant + snow_list_from_array (single allocation O(n) vs O(n^2))
- 26-02-D2: known_functions return Ptr, actual type from typeck resolve_range
- 26-02-D3: Uniform u64 storage with codegen-level type conversion
- 27-01-D1: Callback-based element comparison for snow_list_eq/snow_list_compare
- 27-01-D2: Parametric Eq/Ord impls for List<T> via single-letter type param
- 27-01-D3: Reuse wrap_collection_to_string for debug/inspect on collections
- 27-02-D1: ListDecons decision tree node for cons patterns
- 27-02-D2: AccessPath::ListHead/ListTail for list sub-value navigation
- 27-02-D3: Local variable bindings take precedence over builtin name mappings
- 27-02-D4: Conservative exhaustiveness for cons patterns (treated as wildcards)
- 28-01-D1: Emit error and early-return instead of silently adding Eq
- 29-01-D1: Soft error collection for argument constraint violations
- 29-01-D2: Only check NameRef arguments for constraints
- 29-01-D3: Filter to concrete types only (skip Ty::Var)

**Issues Resolved:**

- List type was monomorphic (Int only) — now polymorphic with any element type
- Ord deriving without Eq caused runtime error — now compile-time error with suggestion
- Higher-order function argument constraint propagation not supported — now checked at call site
- Name shadowing bug: pattern binding `head` mapped to snow_list_head function — fixed with local scope precedence

**Issues Deferred:**

- TODO: Add proper snow_string_compare in a future phase (lower.rs:5261) — informational, does not block list comparison

**Technical Debt Incurred:**

- snow_string_compare TODO in lower.rs (future string comparison enhancement)

---

_For current project status, see .planning/PROJECT.md_
