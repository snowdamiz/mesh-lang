# Requirements Archive: v1.3 Traits & Protocols

**Archived:** 2026-02-08
**Status:** SHIPPED

This is the archived requirements specification for v1.3.

---

# Requirements: Snow v1.3 Traits & Protocols

**Defined:** 2026-02-07
**Core Value:** Expressive, readable concurrency -- writing concurrent programs should feel as natural as sequential code, with supervision and fault tolerance built in.

## v1.3 Requirements

### Trait Infrastructure (INFRA)

- [x] **INFRA-01**: `type_to_key` replaced with structural type matching that handles generic impls (e.g., `impl Display for List<T>` matches query `List<Int>`) -- structural matching via freshen_type_params + temporary InferCtx
- [x] **INFRA-02**: Duplicate impl detection -- two `impl Display for Int` blocks produce a compiler error (E0026 DuplicateImpl) instead of silent overwrite
- [x] **INFRA-03**: Method name collision between traits resolved deterministically -- AmbiguousMethod error (E0027) on collision via find_method_traits
- [x] **INFRA-04**: Compiler-known trait dispatch and user-defined trait dispatch unified into a single code path -- both resolve through TraitRegistry

### Trait Codegen (CODEGEN)

- [x] **CODEGEN-01**: `impl` blocks lower to executable MIR functions with mangled names (`Trait__Method__Type`)
- [x] **CODEGEN-02**: Trait method calls at call sites resolve to mangled function names via TraitRegistry lookup
- [x] **CODEGEN-03**: `self` parameter handled as first argument with concrete type in impl method bodies
- [x] **CODEGEN-04**: Where clause constraints enforced through typeck (TraitNotSatisfied error) with defense-in-depth warning in lowerer
- [x] **CODEGEN-05**: Monomorphization depth limit (64) prevents infinite trait method instantiation

### Display Protocol (DISP)

- [x] **DISP-01**: `Display` interface defined with `to_string(self) -> String` method signature
- [x] **DISP-02**: String interpolation (`"${value}"`) calls `Display.to_string` for the interpolated value's type
- [x] **DISP-03**: Built-in `Display` impls for all primitive types (Int, Float, Bool, String)

### Debug Protocol (DBG)

- [x] **DBG-01**: `Debug` interface defined with `inspect(self) -> String` method signature
- [x] **DBG-02**: `inspect(value)` produces developer-oriented structural representation (e.g., `Point { x: 1, y: 2 }`)
- [x] **DBG-03**: Built-in `Debug` impls for all primitive types (Int, Float, Bool, String)

### Equality Protocol (EQ)

- [x] **EQ-01**: `Eq` extended to user-defined structs (structural field-by-field equality)
- [x] **EQ-02**: `Eq` extended to sum types (variant tag + payload equality via nested Match)
- [x] **EQ-03**: Built-in `Eq` impls for all primitive types registered through TraitRegistry

### Ordering Protocol (ORD)

- [x] **ORD-01**: `Ordering` semantics implemented via `lt() -> Bool` with negate/swap transformations for all 6 operators (Ordering sum type deferred)
- [x] **ORD-02**: `Ord` extended to user-defined structs (lexicographic field-by-field comparison)
- [x] **ORD-03**: `Ord` extended to sum types (variant ordering + payload comparison via nested Match)
- [x] **ORD-04**: Built-in `Ord` impls for all primitive types registered through TraitRegistry

### Hash Protocol (HASH)

- [x] **HASH-01**: `Hash` interface defined with `hash(self) -> Int` method signature
- [x] **HASH-02**: FNV-1a hash implementation in snow-rt (~35 lines, no new Rust crate dependencies)
- [x] **HASH-03**: Built-in `Hash` impls for all primitive types (Int, Float, Bool, String)
- [x] **HASH-04**: User types with `Hash` impl can be used as `Map` keys via call-site hash interception

### Default Protocol (DFLT)

- [x] **DFLT-01**: `Default` interface defined with `default() -> Self` method signature (static method, no self parameter)
- [x] **DFLT-02**: Built-in `Default` impls for all primitive types (Int -> 0, Float -> 0.0, Bool -> false, String -> "")

### Default Methods (DMETH)

- [x] **DMETH-01**: Interface definitions support default method implementations (optional do...end body with has_default_body flag)
- [x] **DMETH-02**: Impl blocks can omit methods that have defaults; default body re-lowered per concrete type via TextRange lookup

### Auto-Derive -- Stretch (DERIV)

- [x] **DERIV-01**: `deriving(Trait1, Trait2)` syntax on struct/sum type definitions (contextual keyword)
- [x] **DERIV-02**: Compiler generates correct impl bodies from struct field metadata (field-by-field for Eq, lexicographic for Ord, positional for Display)
- [x] **DERIV-03**: Compiler generates correct impl bodies for sum types (variant tag + payload via Constructor patterns)

### Collection Protocols -- Stretch (COLL)

- [x] **COLL-01**: `Display` impl for List -- `[1, 2, 3]` via callback-based snow_list_to_string
- [x] **COLL-02**: `Display` impl for Map -- `%{k => v}` via callback-based snow_map_to_string
- [x] **COLL-03**: `Debug` impl for List, Map, Set via runtime helpers with fn(u64)->*mut u8 callbacks

## Out of Scope

| Feature | Reason |
|---------|--------|
| Iterator/Iterable protocol | Requires associated types or trait type parameters; deferred to v1.4+ |
| From/Into conversion protocol | Requires blanket impl support; deferred to v1.4+ |
| Serialize/Deserialize protocols | Depends on Iterator and broader stdlib maturity; deferred to v1.4+ |
| Supertraits / trait inheritance | Adds significant complexity; not needed for v1.3 protocols |
| Method dot-syntax (`value.method()`) | Syntactic sugar, not capability; deferred to v1.4+ |
| Blanket impls | Implementation complexity too high for v1.3; deferred to v1.4+ |
| Dynamic dispatch / vtables / trait objects | Use sum types instead; never planned |
| Higher-kinded types (Functor/Monad) | Out of language philosophy |
| Specialization (overlapping impls) | Unsound without careful design; not planned |

## Traceability

| Requirement | Phase | Status |
|-------------|-------|--------|
| INFRA-01 | Phase 18 | Complete |
| INFRA-02 | Phase 18 | Complete |
| INFRA-03 | Phase 18 | Complete |
| INFRA-04 | Phase 18 | Complete |
| CODEGEN-01 | Phase 19 | Complete |
| CODEGEN-02 | Phase 19 | Complete |
| CODEGEN-03 | Phase 19 | Complete |
| CODEGEN-04 | Phase 19 | Complete |
| CODEGEN-05 | Phase 19 | Complete |
| DISP-01 | Phase 20 | Complete |
| DISP-02 | Phase 20 | Complete |
| DISP-03 | Phase 20 | Complete |
| DBG-01 | Phase 20 | Complete |
| DBG-02 | Phase 20 | Complete |
| DBG-03 | Phase 20 | Complete |
| EQ-01 | Phase 20 | Complete |
| EQ-02 | Phase 20 | Complete |
| EQ-03 | Phase 20 | Complete |
| ORD-01 | Phase 20 | Complete |
| ORD-02 | Phase 20 | Complete |
| ORD-03 | Phase 20 | Complete |
| ORD-04 | Phase 20 | Complete |
| HASH-01 | Phase 21 | Complete |
| HASH-02 | Phase 21 | Complete |
| HASH-03 | Phase 21 | Complete |
| HASH-04 | Phase 21 | Complete |
| DFLT-01 | Phase 21 | Complete |
| DFLT-02 | Phase 21 | Complete |
| DMETH-01 | Phase 21 | Complete |
| DMETH-02 | Phase 21 | Complete |
| DERIV-01 | Phase 22 | Complete |
| DERIV-02 | Phase 22 | Complete |
| DERIV-03 | Phase 22 | Complete |
| COLL-01 | Phase 21 | Complete |
| COLL-02 | Phase 21 | Complete |
| COLL-03 | Phase 21 | Complete |

**Coverage:**
- v1.3 must-have requirements: 30/30 complete
- v1.3 stretch requirements: 6/6 complete
- Total: 36/36 complete

---

## Milestone Summary

**Shipped:** 36 of 36 requirements
**Adjusted:**
- ORD-01: Ordering sum type replaced with lt() -> Bool + negate/swap transformations (functionally equivalent, all 6 operators work)
- CODEGEN-04: Where clause enforcement confirmed as typeck responsibility, MIR adds warning-only defense-in-depth
**Dropped:** None

---
*Archived: 2026-02-08 as part of v1.3 milestone completion*
