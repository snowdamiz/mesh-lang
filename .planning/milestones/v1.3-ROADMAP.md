# Milestone v1.3: Traits & Protocols

**Status:** SHIPPED 2026-02-08
**Phases:** 18-22
**Total Plans:** 18

## Overview

Complete the trait/protocol system so that user-defined `interface` and `impl` blocks compile to native code via monomorphization, then ship stdlib protocols (Display, Debug, Eq, Ord, Hash, Default) that give Snow users the building blocks for server-oriented abstractions. The trait infrastructure already existed in the type checker (TraitRegistry, where-clause validation) but produced no executable code -- codegen explicitly skipped InterfaceDef/ImplDef. v1.3 bridged that gap by wiring trait method dispatch through MIR lowering, fixing foundational type resolution bugs, and delivering the protocol suite that makes traits useful.

## Phases

### Phase 18: Trait Infrastructure

**Goal**: Trait resolution produces correct, deterministic results for all type shapes including parameterized types
**Depends on**: v1.2 complete
**Plans**: 3 plans

Plans:
- [x] 18-01-PLAN.md -- Structural type matching via temporary unification in TraitRegistry
- [x] 18-02-PLAN.md -- Duplicate impl detection + method name collision handling
- [x] 18-03-PLAN.md -- Dispatch unification (TraitRegistry threading through TypeckResult to Lowerer)

**Details:**
- Replaced string-based `type_to_key` with structural matching via `freshen_type_params` + temporary `InferCtx` unification
- Storage refactored from `FxHashMap<(String,String), ImplDef>` to `FxHashMap<String, Vec<ImplDef>>` keyed by trait name
- DuplicateImpl (E0026) and AmbiguousMethod (E0027) error variants with ariadne diagnostics
- TraitRegistry re-exported at crate root, owned in TypeckResult, borrowed in Lowerer
- Unified dispatch: built-in and user types share identical TraitRegistry resolution path

### Phase 19: Trait Method Codegen

**Goal**: User-defined trait methods compile to native code and execute correctly end-to-end
**Depends on**: Phase 18
**Plans**: 4 plans

Plans:
- [x] 19-01-PLAN.md -- ImplDef pre-registration + MIR lowering with Trait__Method__Type mangled names and self parameter handling
- [x] 19-02-PLAN.md -- Call-site resolution via TraitRegistry lookup + operator dispatch for user types + mir_type_to_ty helper
- [x] 19-03-PLAN.md -- Where-clause defense-in-depth assertion + monomorphization depth limit (64)
- [x] 19-04-PLAN.md -- End-to-end integration tests for all five success criteria + smoke test

**Details:**
- `extract_impl_names()` as free function reused by pre-registration and lowering
- Self parameter detected via SELF_KW, type from Ty::Fun zip
- mir_type_to_ty as separate function for MirType-to-Ty reverse mapping
- Operator dispatch for all 6 comparison operators through Eq/Ord trait calls
- Mono depth limit of 64, tracked in both lower_fn_def and lower_impl_method

### Phase 20: Essential Stdlib Protocols

**Goal**: Users can convert values to strings, inspect data structures, and compare user-defined types with == and < operators
**Depends on**: Phase 19
**Plans**: 5 plans

Plans:
- [x] 20-01-PLAN.md -- Display protocol + Con/App unification fix enabling all user-defined trait impls
- [x] 20-02-PLAN.md -- String interpolation integration (wrap_to_string dispatches via find_method_traits)
- [x] 20-03-PLAN.md -- Debug protocol (auto-generated inspect for structs and sum types)
- [x] 20-04-PLAN.md -- Eq/Ord for structs (field-by-field equality, lexicographic ordering, all 6 operators)
- [x] 20-05-PLAN.md -- Eq/Ord for sum types (variant-tag-then-payload comparison via nested Match)

**Details:**
- Con(c) unifies with App(Con(c), []) bidirectionally for non-generic struct types (critical fix from 20-01)
- Primitive Display/Debug redirected to runtime functions at MIR lowering (not codegen)
- NotEq/Gt/LtEq/GtEq expressed as negate/swap transformations of eq/lt
- Sum type Eq/Ord uses nested Match with Constructor patterns (O(n^2) variant cross-product for Ord)

### Phase 21: Extended Protocols

**Goal**: User types work as Map keys, support zero-initialization, and traits support default method implementations
**Depends on**: Phase 20
**Plans**: 4 plans

Plans:
- [x] 21-01-PLAN.md -- Hash protocol (FNV-1a runtime + auto-derive for structs + Map key hashing)
- [x] 21-02-PLAN.md -- Default protocol (static method + primitive short-circuits)
- [x] 21-03-PLAN.md -- Default method implementations (parser + typeck + MIR lowering)
- [x] 21-04-PLAN.md -- Collection Display (callback-based runtime helpers + MIR dispatch)

**Details:**
- FNV-1a 64-bit hash (~35 lines in snow-rt/src/hash.rs), zero new Rust dependencies
- Default trait registered with has_self=false (first static trait method in Snow)
- Default method body stored as TextRange for Send+Sync compatibility, re-lowered per concrete type
- Collection Display via fn(u64)->*mut u8 callback signature for uniform element-to-string conversion

### Phase 22: Auto-Derive (Stretch)

**Goal**: Users can auto-generate protocol implementations from struct/sum-type metadata instead of writing boilerplate
**Depends on**: Phase 21
**Plans**: 2 plans

Plans:
- [x] 22-01-PLAN.md -- Derive syntax + compiler infrastructure: parser, AST accessors, conditional gating in typeck/MIR, formatter
- [x] 22-02-PLAN.md -- Derive implementations + e2e tests: Display/Hash-sum generation, validation, comprehensive testing

**Details:**
- `deriving` parsed as contextual keyword (IDENT text check), not added to TokenKind
- No deriving clause = derive all defaults (backward compatible)
- Display never auto-derived, only via explicit deriving(Display)
- UnsupportedDerive (E0028) and GenericDerive (E0029) TypeError variants for derive validation

---

## Milestone Summary

**Key Decisions:**
- Static dispatch via monomorphization (no vtables, no trait objects)
- MIR lowering as the critical integration point (not codegen)
- Name mangling: Trait__Method__Type with double-underscore separators
- Zero new Rust crate dependencies
- FNV-1a for Hash protocol
- Trust typeck for where-clause enforcement (MIR adds warning-only defense-in-depth)

**Issues Resolved:**
- type_to_key string lookup replaced with structural unification (Phase 18)
- Duplicate impl silent overwrite fixed with check-before-insert (Phase 18)
- Codegen InterfaceDef/ImplDef skip replaced with full MIR lowering (Phase 19)
- Con vs App(Con, []) type identity issue fixed (Phase 20-01, unblocked all user-defined trait impls)

**Issues Deferred:**
- LLVM Constructor pattern field binding limitation for sum type non-nullary variants (MIR correct, codegen limitation)
- Ordering sum type (Less | Equal | Greater) not defined; lt() -> Bool with negate/swap used instead
- Nested collection Display (List<List<Int>>) falls back to snow_int_to_string

**Technical Debt Incurred:**
- Sum type e2e tests adapted to nullary variants due to LLVM Constructor pattern limitation
- Generic type auto-derive not supported (requires monomorphization-aware trait impl registration)
- Higher-order constrained functions drop constraints when captured as values (documented limitation)

---

_For current project status, see .planning/ROADMAP.md_
