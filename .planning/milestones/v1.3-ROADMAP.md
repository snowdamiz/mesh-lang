# Milestone v1.3: Traits & Protocols

**Status:** In Progress
**Phases:** 18-22
**Total Plans:** TBD (estimated 15-19)

## Overview

Complete the trait/protocol system so that user-defined `interface` and `impl` blocks compile to native code via monomorphization, then ship stdlib protocols (Display, Debug, Eq, Ord, Hash, Default) that give Snow users the building blocks for server-oriented abstractions. The trait infrastructure already exists in the type checker (TraitRegistry, where-clause validation) but produces no executable code -- codegen explicitly skips InterfaceDef/ImplDef. v1.3 bridges that gap by wiring trait method dispatch through MIR lowering, fixing foundational type resolution bugs, and delivering the protocol suite that makes traits useful.

## Phases

### Phase 18: Trait Infrastructure

**Goal**: Trait resolution produces correct, deterministic results for all type shapes including parameterized types
**Depends on**: v1.2 complete
**Requirements**: INFRA-01, INFRA-02, INFRA-03, INFRA-04
**Success Criteria** (what must be TRUE):
  1. `impl Display for List<T>` correctly resolves when queried with `List<Int>` or `List<String>` (structural type matching replaces string-based `type_to_key`)
  2. Two `impl Display for Int` blocks in the same program produce a compile-time error naming both locations
  3. Two traits defining a method with the same name (e.g., `to_string`) at the same call site produce a compile-time ambiguity error or resolve via qualified syntax
  4. `impl Add for MyStruct` makes `my_a + my_b` work the same way `1 + 2` works -- no special-case dispatch path for built-in types vs. user types
**Plans**: 3 plans (estimated)

Plans:
- [ ] 18-01: Structural type matching -- replace `type_to_key` string keys with structural matching via temporary unification in TraitRegistry
- [ ] 18-02: Duplicate impl detection + method name collision handling -- error on overlapping impls, deterministic resolution for shared method names
- [ ] 18-03: Dispatch unification -- merge compiler-known trait dispatch (hardcoded Int/Float logic) with TraitRegistry-based user trait dispatch into single path

### Phase 19: Trait Method Codegen

**Goal**: User-defined trait methods compile to native code and execute correctly end-to-end
**Depends on**: Phase 18
**Requirements**: CODEGEN-01, CODEGEN-02, CODEGEN-03, CODEGEN-04, CODEGEN-05
**Success Criteria** (what must be TRUE):
  1. A Snow program defining `interface Greetable` with a method, `impl Greetable for MyStruct`, and a call to that method compiles and produces correct output
  2. Trait method calls resolve to mangled names (`Trait__Method__Type`) visible in the generated LLVM IR
  3. The `self` parameter in impl methods receives the concrete struct value, not an opaque pointer or type-erased argument
  4. A function with `where T: Display` constraint rejects calls with types that have no `Display` impl at compile time
  5. Deeply recursive trait method instantiation (if triggered) hits a depth limit and produces a compiler error instead of stack overflow
**Plans**: 4 plans (estimated)

Plans:
- [ ] 19-01: MIR lowering for impl method bodies -- lower ImplDef methods to MirFunctions with `Trait__Method__Type` mangled names, handle self parameter
- [ ] 19-02: Call-site resolution -- resolve trait method calls to mangled names via TraitRegistry lookup in lower_call_expr
- [ ] 19-03: Where clause codegen enforcement -- thread trait bounds from type checker through MIR lowering, reject unmet constraints
- [ ] 19-04: Monomorphization depth limit + end-to-end trait codegen tests

### Phase 20: Essential Stdlib Protocols

**Goal**: Users can convert values to strings, inspect data structures, and compare user-defined types with == and < operators
**Depends on**: Phase 19
**Requirements**: DISP-01, DISP-02, DISP-03, DBG-01, DBG-02, DBG-03, EQ-01, EQ-02, EQ-03, ORD-01, ORD-02, ORD-03, ORD-04
**Success Criteria** (what must be TRUE):
  1. `to_string(42)` returns `"42"`, `to_string(true)` returns `"true"`, and `to_string(my_struct)` calls the user's `Display` impl
  2. String interpolation `"value is ${x}"` calls `Display.to_string` on `x` -- works for primitives and any type with a `Display` impl
  3. `inspect(my_struct)` returns a developer-readable string showing the struct name, field names, and field values (e.g., `Point { x: 1, y: 2 }`)
  4. `==` works on user-defined structs (field-by-field equality) and sum types (variant + payload equality), not just primitives
  5. `<`, `>`, `<=`, `>=` work on user-defined structs (lexicographic field comparison) and sum types, returning results consistent with the `Ordering` sum type (`Less | Equal | Greater`)
**Plans**: 4 plans (estimated)

Plans:
- [ ] 20-01: Display protocol -- interface definition, primitive impls in builtins.rs, runtime `snow_int_to_string`/`snow_float_to_string`/`snow_bool_to_string` functions
- [ ] 20-02: String interpolation integration -- wire `"${expr}"` to call `Display__to_string__Type` for the interpolated expression's type
- [ ] 20-03: Debug protocol -- interface definition, primitive impls, struct/sum-type inspect output format, runtime functions
- [ ] 20-04: Eq/Ord extension -- extend Eq to structs and sum types (structural equality), define `Ordering` sum type, extend Ord to structs and sum types, register primitive impls through TraitRegistry

### Phase 21: Extended Protocols

**Goal**: User types work as Map keys, support zero-initialization, and traits support default method implementations
**Depends on**: Phase 20
**Requirements**: HASH-01, HASH-02, HASH-03, HASH-04, DFLT-01, DFLT-02, DMETH-01, DMETH-02, COLL-01, COLL-02, COLL-03
**Success Criteria** (what must be TRUE):
  1. A user-defined struct with `impl Hash` can be used as a `Map` key -- `Map.put(map, my_struct, value)` and `Map.get(map, my_struct)` work correctly
  2. `default()` returns the zero value for any type with a `Default` impl (0 for Int, "" for String, user-defined for structs)
  3. An interface with a default method body does not require implementors to override that method -- the default body executes when no override is provided
  4. `to_string([1, 2, 3])` returns `"[1, 2, 3]"` and `to_string(%{a => 1})` returns a readable map representation
**Plans**: 4 plans (estimated)

Plans:
- [ ] 21-01: Hash protocol -- interface definition, FNV-1a in snow-rt, primitive impls, integration with Map key lookup
- [ ] 21-02: Default protocol -- interface definition with static method (no self), primitive impls, Self type handling
- [ ] 21-03: Default method implementations -- support method bodies in interface blocks, fallback to default when impl omits override
- [ ] 21-04: Collection Display/Debug -- Display impls for List, Map, Set; Debug impls for List, Map, Set

### Phase 22: Auto-Derive (Stretch)

**Goal**: Users can auto-generate protocol implementations from struct/sum-type metadata instead of writing boilerplate
**Depends on**: Phase 21
**Requirements**: DERIV-01, DERIV-02, DERIV-03
**Success Criteria** (what must be TRUE):
  1. `type Point do x :: Int, y :: Int end deriving(Eq, Display, Debug, Hash)` compiles without any manual `impl` blocks and all four protocols work correctly
  2. Derived `Eq` performs field-by-field comparison, derived `Ord` performs lexicographic comparison, derived `Display` produces `"Point(1, 2)"` style output
  3. Deriving on a sum type generates correct variant-aware implementations (tag comparison for Eq, variant ordering for Ord, variant name for Display)
**Plans**: 2 plans (estimated)

Plans:
- [ ] 22-01: Derive syntax + compiler infrastructure -- parse `deriving(...)`, generate impl AST/MIR from struct/sum-type field metadata
- [ ] 22-02: Derive implementations for Eq, Ord, Display, Debug, Hash + e2e tests for structs and sum types

---

## Dependency Chain

```
Phase 18: Trait Infrastructure
    |
    v
Phase 19: Trait Method Codegen
    |
    v
Phase 20: Essential Stdlib Protocols (Display, Debug, Eq, Ord)
    |
    v
Phase 21: Extended Protocols (Hash, Default, Default Methods, Collection Display/Debug)
    |
    v
Phase 22: Auto-Derive (Stretch)
```

All phases are strictly sequential. Each phase builds on the deliverables of the previous one. Phase 18 fixes the foundation, Phase 19 makes traits produce code, Phases 20-21 use that code to ship protocols, Phase 22 generates protocol impls automatically.

## Key Architectural Decisions

| Decision | Rationale |
|----------|-----------|
| Static dispatch via monomorphization | Fits LLVM codegen naturally, no runtime vtable overhead, actor system provides dynamic routing where needed |
| MIR lowering as integration point | Type checker already resolves concrete types; MIR lowerer just mangles names and emits direct calls |
| Name mangling: `Trait__Method__Type` | Double-underscore separators extend existing `mangle_type_name` infrastructure |
| Zero new Rust crate dependencies | Trait systems are core compiler semantics, not library-shaped problems |
| FNV-1a for Hash protocol | Deterministic, platform-independent, ~30 lines in snow-rt, avoids AES instruction dependency |

## Critical Pitfalls (from research)

| # | Pitfall | Phase | Resolution |
|---|---------|-------|------------|
| 1 | `type_to_key` string lookup can't handle generic impls | 18 | Structural type matching via temporary unification |
| 2 | Duplicate impl silent overwrite via HashMap insert | 18 | Check-before-insert with error diagnostic |
| 3 | Method name collision between traits resolves nondeterministically | 18 | Ambiguity error or qualified dispatch |
| 4 | Compiler-known and user traits use different dispatch paths | 18 | Unified dispatch through TraitRegistry |
| 5 | Codegen skips InterfaceDef/ImplDef entirely (line 431 of lower.rs) | 19 | Lower impl method bodies to MirFunctions |
| 6 | Where clause constraints not threaded to codegen | 19 | Verify bounds at MIR lowering call sites |
| 7 | No monomorphization depth limit | 19 | Configurable depth limit with compiler error |

## Progress

| Phase | Plans Complete | Status | Completed |
|-------|----------------|--------|-----------|
| 18. Trait Infrastructure | 0/3 | Not started | - |
| 19. Trait Method Codegen | 0/4 | Not started | - |
| 20. Essential Stdlib Protocols | 0/4 | Not started | - |
| 21. Extended Protocols | 0/4 | Not started | - |
| 22. Auto-Derive (Stretch) | 0/2 | Not started | - |

---

_For current project status, see .planning/ROADMAP.md_
