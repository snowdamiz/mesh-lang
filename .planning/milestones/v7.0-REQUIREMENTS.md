# Requirements Archive: v7.0 Iterator Protocol & Trait Ecosystem

**Archived:** 2026-02-14
**Status:** SHIPPED

For current requirements, see `.planning/REQUIREMENTS.md`.

---

# Requirements: Mesh v7.0 Iterator Protocol & Trait Ecosystem

## Associated Types

- [x] **ASSOC-01**: User can declare associated types in interface definitions (`type Item`)
- [x] **ASSOC-02**: User can specify associated types in impl blocks (`type Item = T`)
- [x] **ASSOC-03**: User can reference associated types via `Self.Item` in method signatures
- [x] **ASSOC-04**: Compiler normalizes associated type projections during type inference (resolves `<T as Trait>::Item` to concrete types)
- [x] **ASSOC-05**: Compiler reports clear errors for missing or extra associated type bindings in impls

## Iterator Protocol

- [x] **ITER-01**: User can define an `Iterator` interface with `type Item` and `fn next(self) -> Option<Self.Item>`
- [x] **ITER-02**: User can define an `Iterable` interface with `type Iter` and `fn iter(self) -> Self.Iter`
- [x] **ITER-03**: User can iterate over any Iterable type with `for x in expr` syntax
- [x] **ITER-04**: Built-in types (List, Map, Set, Range) implement Iterable with compiler-provided iterator types
- [x] **ITER-05**: Existing for-in loops over List/Map/Set/Range continue to work with no regressions
- [x] **ITER-06**: User can create iterators from collections via `Iter.from()` pipe-friendly entry point

## Lazy Combinators

- [x] **COMB-01**: User can transform iterator elements with `Iter.map(iter, fn)`
- [x] **COMB-02**: User can filter iterator elements with `Iter.filter(iter, fn)`
- [x] **COMB-03**: User can limit iteration with `Iter.take(iter, n)` and `Iter.skip(iter, n)`
- [x] **COMB-04**: User can enumerate iterator elements with `Iter.enumerate(iter)` producing `(index, element)` tuples
- [x] **COMB-05**: User can zip two iterators with `Iter.zip(iter1, iter2)` producing tuples
- [x] **COMB-06**: All combinators are lazy -- no intermediate collections allocated

## Terminal Operations

- [x] **TERM-01**: User can count elements with `Iter.count(iter)`
- [x] **TERM-02**: User can sum numeric elements with `Iter.sum(iter)`
- [x] **TERM-03**: User can test predicates with `Iter.any(iter, fn)` and `Iter.all(iter, fn)`
- [x] **TERM-04**: User can find first matching element with `Iter.find(iter, fn)`
- [x] **TERM-05**: User can reduce iterator with `Iter.reduce(iter, fn)`

## From/Into Conversion

- [x] **CONV-01**: User can define `From<T>` trait impls for type conversions (`fn from(value :: T) -> Self`)
- [x] **CONV-02**: Compiler automatically generates `Into<B> for A` when `From<A> for B` exists
- [x] **CONV-03**: Built-in From impls exist for common primitive conversions (Int->Float, Int->String, Float->String, Bool->String)
- [x] **CONV-04**: The `?` operator auto-converts error types via From when function return type differs from expression error type

## Numeric Traits

- [x] **NUM-01**: User can implement Add/Sub/Mul/Div for custom types with `type Output` associated type
- [x] **NUM-02**: Binary operators (+, -, *, /) use the Output associated type for result type inference
- [x] **NUM-03**: User can implement `Neg` trait for unary minus (`-value`) on custom types

## Collect

- [x] **COLL-01**: User can materialize an iterator into a List via `Iter.collect()` with type annotation or `List.collect(iter)`
- [x] **COLL-02**: User can materialize an iterator into a Map via `Map.collect(iter)` from iterator of tuples
- [x] **COLL-03**: User can materialize an iterator into a Set via `Set.collect(iter)`
- [x] **COLL-04**: User can materialize a string iterator into a String via `String.collect(iter)`

## Future Requirements (Deferred)

- Terminal operations beyond basic (flat_map, chain, skip_while, take_while)
- Bounded associated types (`type Iter: Iterator`)
- Zero/One numeric identity traits
- Infinite iterators (repeat, count, cycle)
- TryFrom/TryInto fallible conversions
- Iterator fusion optimization
- Additional Collect targets

## Out of Scope

- Higher-kinded types (HKTs) -- fundamental type system redesign not warranted
- Generic associated types (GATs) -- complexity too high for this milestone
- Trait inheritance / supertraits -- where clauses provide equivalent power
- User-defined blanket impls -- coherence problems; compiler special-cases Into generation
- Dynamic dispatch / trait objects -- Mesh uses monomorphization only
- Async iterators / streams -- Mesh uses actors for concurrency
- Mixed-type arithmetic (Int + Float -> Float) -- use explicit From conversion
- Mutable iterators -- Mesh has no mutable references

## Traceability

| Requirement | Phase | Status |
|-------------|-------|--------|
| ASSOC-01 | Phase 74 | Complete |
| ASSOC-02 | Phase 74 | Complete |
| ASSOC-03 | Phase 74 | Complete |
| ASSOC-04 | Phase 74 | Complete |
| ASSOC-05 | Phase 74 | Complete |
| NUM-01 | Phase 75 | Complete |
| NUM-02 | Phase 75 | Complete |
| NUM-03 | Phase 75 | Complete |
| ITER-01 | Phase 76 | Complete |
| ITER-02 | Phase 76 | Complete |
| ITER-03 | Phase 76 | Complete |
| ITER-04 | Phase 76 | Complete |
| ITER-05 | Phase 76 | Complete |
| ITER-06 | Phase 76 | Complete |
| CONV-01 | Phase 77 | Complete |
| CONV-02 | Phase 77 | Complete |
| CONV-03 | Phase 77 | Complete |
| CONV-04 | Phase 77 | Complete |
| COMB-01 | Phase 78 | Complete |
| COMB-02 | Phase 78 | Complete |
| COMB-03 | Phase 78 | Complete |
| COMB-04 | Phase 78 | Complete |
| COMB-05 | Phase 78 | Complete |
| COMB-06 | Phase 78 | Complete |
| TERM-01 | Phase 78 | Complete |
| TERM-02 | Phase 78 | Complete |
| TERM-03 | Phase 78 | Complete |
| TERM-04 | Phase 78 | Complete |
| TERM-05 | Phase 78 | Complete |
| COLL-01 | Phase 79 | Complete |
| COLL-02 | Phase 79 | Complete |
| COLL-03 | Phase 79 | Complete |
| COLL-04 | Phase 79 | Complete |
