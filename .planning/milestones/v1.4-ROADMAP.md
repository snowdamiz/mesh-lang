# Milestone v1.4: Compiler Polish

**Status:** SHIPPED 2026-02-08
**Phases:** 23-25
**Total Plans:** 5

## Overview

Fix all five known limitations carried from v1.3 -- making the compiler fully correct across pattern matching codegen, trait system generics, and type system soundness.

## Phases

### Phase 23: Pattern Matching Codegen

**Goal**: Sum type pattern matching fully works in LLVM codegen -- users can destructure non-nullary variant fields and use the Ordering type directly in Snow programs
**Depends on**: Phase 22 (v1.3 complete)
**Requirements**: PATM-01, PATM-02
**Plans:** 2 plans

Plans:
- [x] 23-01-PLAN.md -- Fix pattern compiler tag assignment and field type resolution
- [x] 23-02-PLAN.md -- Register Ordering type, add compare(), end-to-end tests

**Details:**
- Constructor tags in decision trees now match sum type definition order (not pattern appearance order)
- Variant field bindings get correct types from MirSumTypeDef instead of MirType::Unit placeholders
- sum_type_defs threaded as &FxHashMap<String, MirSumTypeDef> through compile_match pipeline
- Ordering registered as built-in sum type: Less (tag 0), Equal (tag 1), Greater (tag 2)
- compare(T, T) -> Ordering as polymorphic built-in function
- Ord__compare__Type generated for Int, Float, String, user structs, user sum types
- Primitive compare uses BinOp directly; struct/sum compare delegates to Ord__lt__ and Eq__eq__

### Phase 24: Trait System Generics

**Goal**: Display and auto-derive work correctly with generic and nested types -- users see proper string representations and can derive traits on parameterized structs
**Depends on**: Phase 23
**Requirements**: TGEN-01, TGEN-02
**Plans:** 2 plans

Plans:
- [x] 24-01-PLAN.md -- Recursive nested collection Display (TGEN-01)
- [x] 24-02-PLAN.md -- Generic type deriving with monomorphized trait functions (TGEN-02)

**Details:**
- Recursive resolve_to_string_callback for nested List, Set, Map, and sum types
- Synthetic MIR wrapper functions (__display_{kind}_{type}_to_str) bridge fn(u64)->ptr callback signature
- codegen_var fixed to resolve runtime intrinsic functions via module.get_function() fallback
- GenericDerive error (E0029) removed from entire codebase
- Parametric Ty::App impl registration in trait registry
- Lazy monomorphized trait function generation at struct literal lowering sites
- known_functions fallback for Display/Eq/Ord dispatch on mangled monomorphized types
- display_name separation: "Box(42)" not "Box_Int(42)" for human-readable output

### Phase 25: Type System Soundness

**Goal**: Higher-order constrained functions preserve their trait constraints when captured as values -- the type system prevents unsound calls at compile time
**Depends on**: Phase 23 (independent of Phase 24; numbered last because it is self-contained)
**Requirements**: TSND-01
**Plans:** 1 plan

Plans:
- [x] 25-01-PLAN.md -- Propagate fn_constraints through let bindings + e2e tests

**Details:**
- fn_constraints entries cloned to let-binding aliases in infer_let_binding
- Clone-locally strategy in infer_block avoids &mut cascade to 10+ callers
- Only NameRef initializers get constraint propagation (closures already work via inner call)
- Chain aliases supported: let f = show; let g = f; g(x) checks constraints

---

## Milestone Summary

**Decimal Phases:** None

**Key Decisions:**
- Thread sum_type_defs as parameter, not in PatMatrix (frequent cloning concern)
- Fallback to appearance-order tags when type not in map (backward compatibility)
- Ordering as non-generic built-in sum type (simpler than Option/Result)
- Primitive compare uses BinOp directly (no Ord__lt__Int function exists)
- Synthetic wrapper functions for nested collection Display callbacks
- codegen_var module.get_function() fallback for intrinsic fn ptrs
- Parametric Ty::App registration for generic struct deriving
- Lazy monomorphization at struct literal sites
- known_functions fallback for monomorphized type dispatch
- display_name separation for monomorphized Display/Debug
- Clone-locally strategy for fn_constraints in infer_block
- Propagate constraints only for NameRef initializers

**Issues Resolved:**
- Sum type constructor pattern field binding (MIR correct, codegen limitation fixed)
- Ordering type now user-visible as first-class sum type
- Collection Display via string interpolation works end-to-end (codegen_var fix)
- Generic structs can derive all traits (GenericDerive error removed)
- Where-clause constraints preserved through let-binding aliases

**Issues Deferred:**
- Higher-order function argument constraint propagation (e.g., apply(show, value)) -- requires qualified types
- Nested collection Display e2e blocked by monomorphic List type (infrastructure complete)
- Ord -> Eq dependency not enforced (runtime error instead of compile-time; workaround: derive both)

**Technical Debt Incurred:**
- Ord deriving should auto-derive or require Eq (runtime error if missing)
- List<List<Int>> cannot be created yet (List.append typed as (List, Int) -> List)
- Misleading test name: nested_collection_display.snow only tests flat List<Int>

---

_For current project status, see .planning/ROADMAP.md_
