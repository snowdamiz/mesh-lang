# Roadmap: Mesh

## Milestones

- [x] **v1.0 MVP** - Phases 1-10 (shipped 2026-02-07)
- [x] **v1.1 Language Polish** - Phases 11-15 (shipped 2026-02-08)
- [x] **v1.2 Runtime & Type Fixes** - Phases 16-17 (shipped 2026-02-08)
- [x] **v1.3 Traits & Protocols** - Phases 18-22 (shipped 2026-02-08)
- [x] **v1.4 Compiler Polish** - Phases 23-25 (shipped 2026-02-08)
- [x] **v1.5 Compiler Correctness** - Phases 26-29 (shipped 2026-02-09)
- [x] **v1.6 Method Dot-Syntax** - Phases 30-32 (shipped 2026-02-09)
- [x] **v1.7 Loops & Iteration** - Phases 33-36 (shipped 2026-02-09)
- [x] **v1.8 Module System** - Phases 37-42 (shipped 2026-02-09)
- [x] **v1.9 Stdlib & Ergonomics** - Phases 43-48 (shipped 2026-02-10)
- [x] **v2.0 Database & Serialization** - Phases 49-54 (shipped 2026-02-12)
- [x] **v3.0 Production Backend** - Phases 55-58 (shipped 2026-02-12)
- [x] **v4.0 WebSocket Support** - Phases 59-62 (shipped 2026-02-12)
- [x] **v5.0 Distributed Actors** - Phases 63-69 (shipped 2026-02-13)
- [x] **v6.0 Website & Documentation** - Phases 70-73 (shipped 2026-02-13)
- [x] **v7.0 Iterator Protocol & Trait Ecosystem** - Phases 74-80 (shipped 2026-02-14)
- [x] **v8.0 Developer Tooling** - Phases 81-86 (shipped 2026-02-14)
- [x] **v9.0 Mesher** - Phases 87-95 (shipped 2026-02-15)
- [ ] **v10.0 ORM** - Phases 96-102 (in progress)

## Phases

<details>
<summary>v1.0 MVP (Phases 1-10) - SHIPPED 2026-02-07</summary>

See milestones/v1.0-ROADMAP.md for full phase details.
55 plans across 10 phases. 52,611 lines of Rust. 213 commits.

</details>

<details>
<summary>v1.1 Language Polish (Phases 11-15) - SHIPPED 2026-02-08</summary>

See milestones/v1.1-ROADMAP.md for full phase details.
10 plans across 5 phases. 56,539 lines of Rust (+3,928). 45 commits.

</details>

<details>
<summary>v1.2 Runtime & Type Fixes (Phases 16-17) - SHIPPED 2026-02-08</summary>

See milestones/v1.2-ROADMAP.md for full phase details.
6 plans across 2 phases. 57,657 lines of Rust (+1,118). 22 commits.

</details>

<details>
<summary>v1.3 Traits & Protocols (Phases 18-22) - SHIPPED 2026-02-08</summary>

See milestones/v1.3-ROADMAP.md for full phase details.
18 plans across 5 phases. 63,189 lines of Rust (+5,532). 65 commits.

</details>

<details>
<summary>v1.4 Compiler Polish (Phases 23-25) - SHIPPED 2026-02-08</summary>

See milestones/v1.4-ROADMAP.md for full phase details.
5 plans across 3 phases. 64,548 lines of Rust (+1,359). 13 commits.

</details>

<details>
<summary>v1.5 Compiler Correctness (Phases 26-29) - SHIPPED 2026-02-09</summary>

See milestones/v1.5-ROADMAP.md for full phase details.
6 plans across 4 phases. 66,521 lines of Rust (+1,973). 29 commits.

</details>

<details>
<summary>v1.6 Method Dot-Syntax (Phases 30-32) - SHIPPED 2026-02-09</summary>

See milestones/v1.6-ROADMAP.md for full phase details.
6 plans across 3 phases. 67,546 lines of Rust (+1,025). 24 commits.

</details>

<details>
<summary>v1.7 Loops & Iteration (Phases 33-36) - SHIPPED 2026-02-09</summary>

See milestones/v1.7-ROADMAP.md for full phase details.
8 plans across 4 phases. 70,501 lines of Rust (+2,955). 34 commits.

</details>

<details>
<summary>v1.8 Module System (Phases 37-42) - SHIPPED 2026-02-09</summary>

See milestones/v1.8-ROADMAP.md for full phase details.
12 plans across 6 phases. 73,384 lines of Rust (+2,883). 52 commits.

</details>

<details>
<summary>v1.9 Stdlib & Ergonomics (Phases 43-48) - SHIPPED 2026-02-10</summary>

See milestones/v1.9-ROADMAP.md for full phase details.
13 plans across 6 phases. 76,100 lines of Rust (+2,716). 56 commits.

</details>

<details>
<summary>v2.0 Database & Serialization (Phases 49-54) - SHIPPED 2026-02-12</summary>

See milestones/v2.0-ROADMAP.md for full phase details.
13 plans across 6 phases. 81,006 lines of Rust (+4,906). 52 commits.

</details>

<details>
<summary>v3.0 Production Backend (Phases 55-58) - SHIPPED 2026-02-12</summary>

See milestones/v3.0-ROADMAP.md for full phase details.
8 plans across 4 phases. 83,451 lines of Rust (+2,445). 33 commits.

</details>

<details>
<summary>v4.0 WebSocket Support (Phases 59-62) - SHIPPED 2026-02-12</summary>

See milestones/v4.0-ROADMAP.md for full phase details.
8 plans across 4 phases. ~84,400 lines of Rust (+~950). 38 commits.

</details>

<details>
<summary>v5.0 Distributed Actors (Phases 63-69) - SHIPPED 2026-02-13</summary>

See milestones/v5.0-ROADMAP.md for full phase details.
20 plans across 7 phases. 93,515 lines of Rust (+9,115). 75 commits.

</details>

<details>
<summary>v6.0 Website & Documentation (Phases 70-73) - SHIPPED 2026-02-13</summary>

See milestones/v6.0-ROADMAP.md for full phase details.
11 plans across 4 phases. 5,134 LOC website (Vue/TS/CSS/MD). 32 commits.

</details>

<details>
<summary>v7.0 Iterator Protocol & Trait Ecosystem (Phases 74-80) - SHIPPED 2026-02-14</summary>

See milestones/v7.0-ROADMAP.md for full phase details.
17 plans across 7 phases. 97,190 lines of Rust (+3,675). 84 commits.

</details>

<details>
<summary>v8.0 Developer Tooling (Phases 81-86) - SHIPPED 2026-02-14</summary>

See milestones/v8.0-ROADMAP.md for full phase details.
11 plans across 6 phases. 98,836 lines of Rust (+1,646). 59 commits.

</details>

<details>
<summary>v9.0 Mesher (Phases 87-95) - SHIPPED 2026-02-15</summary>

See milestones/v9.0-ROADMAP.md for full phase details.
38 plans across 14 phases (including inserted phases). ~4,020 lines of Mesh. 95 phases total.

</details>

### v10.0 ORM (In Progress)

**Milestone Goal:** Build a full ORM library in Mesh targeting PostgreSQL -- schema DSL, pipe-chain query builder, full relationships, changesets, migrations. Validated by rewriting Mesher's entire DB layer (627 lines raw SQL + 82 lines DDL) to use the ORM.

- [x] **Phase 96: Compiler Additions** - Language primitives enabling ergonomic ORM syntax (shipped 2026-02-16)
- [x] **Phase 97: Schema Metadata + SQL Generation** - deriving(Schema) codegen and runtime SQL builder (shipped 2026-02-16)
- [x] **Phase 98: Query Builder + Repo** - Pipe-composable queries and database operations (shipped 2026-02-16)
- [ ] **Phase 99: Changesets** - Validation pipeline and type-safe casting before persistence
- [ ] **Phase 100: Relationships + Preloading** - belongs_to/has_many/has_one with batch preloading
- [ ] **Phase 101: Migration System** - Migration DSL, runner, CLI, and scaffold generation
- [ ] **Phase 102: Mesher Rewrite** - Replace all raw SQL with ORM calls, validate end-to-end

## Phase Details

### Phase 96: Compiler Additions
**Goal**: Mesh language has all primitive features needed for an ergonomic, type-safe ORM -- atoms for field references, keyword arguments for DSL syntax, multi-line pipes for readable query chains, struct update for immutable data transformation, and deriving(Schema) infrastructure for compile-time metadata generation
**Depends on**: Nothing (first phase of v10.0)
**Requirements**: COMP-01, COMP-02, COMP-03, COMP-04, COMP-05, COMP-06, COMP-07, COMP-08
**Success Criteria** (what must be TRUE):
  1. Developer can write atom literals (`:name`, `:email`, `:asc`) and they compile to string constants with a distinct Atom type recognized by the type checker
  2. Developer can write keyword arguments at call sites (`where(name: "Alice", age: 30)`) that desugar to Map parameters without explicit Map literal syntax
  3. Developer can write multi-line pipe chains where `|>` at line start continues the previous expression, making query chains readable across multiple lines
  4. Developer can write struct update expressions (`%{user | name: "Bob"}`) to produce a new struct with specific fields changed and all others copied
  5. A struct with `deriving(Schema)` generates callable `__table__()`, `__fields__()`, and `__primary_key__()` metadata functions, and relationship declarations (`belongs_to`, `has_many`, `has_one`) inside struct bodies produce queryable relationship metadata
**Plans**: 5 plans

Plans:
- [x] 96-01-PLAN.md -- Atom literal syntax (lexer, parser, typeck, codegen)
- [x] 96-02-PLAN.md -- Keyword arguments and multi-line pipe chains (parser, typeck)
- [x] 96-03-PLAN.md -- Struct update syntax (parser, typeck, codegen)
- [x] 96-04-PLAN.md -- deriving(Schema) infrastructure and relationship declarations (typeck, MIR, codegen)
- [x] 96-05-PLAN.md -- Bugfixes: Map.collect string key propagation and cross-module from_row resolution

### Phase 97: Schema Metadata + SQL Generation
**Goal**: Schema structs produce complete compile-time metadata (table name, fields, types, primary key, timestamps, column accessors) and a runtime SQL generation module builds parameterized queries from structured data
**Depends on**: Phase 96
**Requirements**: SCHM-01, SCHM-02, SCHM-03, SCHM-04, SCHM-05
**Success Criteria** (what must be TRUE):
  1. A `struct User do ... end deriving(Schema)` generates the correct pluralized table name (`"users"`), field list with column-to-type mappings, and configurable primary key (default UUID `id`)
  2. Schema structs with `timestamps: true` option automatically include `inserted_at` and `updated_at` fields in their metadata and SQL generation
  3. Column accessor functions are generated per field (`User.name_col()`) enabling type-safe column references in queries instead of arbitrary strings
  4. Runtime Rust functions (`mesh_orm_build_select`, `mesh_orm_build_insert`, `mesh_orm_build_update`, `mesh_orm_build_delete`) produce correctly parameterized SQL with `$1, $2` placeholders and proper identifier quoting
**Plans**: 2 plans

Plans:
- [ ] 97-01-PLAN.md -- deriving(Schema) codegen: schema options parsing, field type metadata, column accessors, timestamps injection, configurable table/PK
- [ ] 97-02-PLAN.md -- Runtime SQL generation module (mesh-rt/db/orm.rs): SELECT, INSERT, UPDATE, DELETE builders with parameterized queries

### Phase 98: Query Builder + Repo
**Goal**: Developers can compose queries using pipe chains and execute them through a stateless Repo module, covering all standard CRUD operations, aggregation, transactions, and raw SQL escape hatches
**Depends on**: Phase 97
**Requirements**: QBLD-01, QBLD-02, QBLD-03, QBLD-04, QBLD-05, QBLD-06, QBLD-07, QBLD-08, QBLD-09, REPO-01, REPO-02, REPO-03, REPO-04, REPO-05, REPO-06, REPO-07, REPO-08, REPO-09, REPO-11
**Success Criteria** (what must be TRUE):
  1. Developer can write `User |> Query.where(:name, "Alice") |> Query.order_by(:name, :asc) |> Query.limit(10) |> Repo.all(pool)` and receive a `List<Map<String, String>>` of matching rows
  2. All query builder functions (where with operators, select, order_by, limit, offset, join, group_by, having, fragment) are pipe-composable and return new immutable Query structs
  3. Repo.all, Repo.one, Repo.get, Repo.get_by correctly execute queries and return typed results; Repo.insert, Repo.update, Repo.delete correctly persist changes with RETURNING clauses
  4. Repo.count and Repo.exists return aggregate results; Repo.transaction wraps operations with automatic commit/rollback
  5. Composable scopes work as pure functions (`pub fn active(q) do q |> Query.where(:status, "active") end`) that can be mixed into any query pipeline
**Plans**: 3 plans

Plans:
- [x] 98-01-PLAN.md -- Query struct as opaque Ptr, pipe-composable builder functions (from, where, where_op, where_in, where_null, where_not_null, select, order_by, limit, offset, join, group_by, having, fragment), pipe schema-to-table transformation
- [x] 98-02-PLAN.md -- Repo read operations (all, one, get, get_by, count, exists) with comprehensive SQL generation from Query struct
- [x] 98-03-PLAN.md -- Repo write operations (insert, update, delete) with RETURNING clauses, Repo.transaction with Pool.checkout + Pg.begin/commit/rollback + Pool.checkin

### Phase 99: Changesets
**Goal**: Developers can validate and cast external data before persistence using a pipe-chain validation pipeline, with type coercion from raw params, built-in validators, and PostgreSQL constraint error mapping
**Depends on**: Phase 98
**Requirements**: CHST-01, CHST-02, CHST-03, CHST-04, CHST-05, CHST-06, CHST-07, CHST-08, CHST-09
**Success Criteria** (what must be TRUE):
  1. Developer can create a Changeset from a struct and params map via `Changeset.cast(user, params, [:name, :email])` that filters allowed fields and coerces string values to schema field types
  2. Developer can chain validations (`|> validate_required([:name]) |> validate_length(:name, min: 2) |> validate_format(:email, "@")`) and the changeset accumulates all errors without short-circuiting
  3. Repo.insert and Repo.update accept Changeset structs, check `changeset.valid` before executing SQL, and return `Result<T, Changeset>` with errors attached on failure
  4. PostgreSQL constraint violations (unique index, foreign key) are caught and mapped to human-readable changeset errors on the appropriate field instead of raw database error strings
**Plans**: 2 plans

Plans:
- [ ] 99-01-PLAN.md -- Changeset struct (opaque 8-slot Ptr), Changeset.cast/cast_with_types, five validators (validate_required, validate_length, validate_format, validate_inclusion, validate_number), field accessors, pipe-chain composition
- [ ] 99-02-PLAN.md -- Enhanced PG error parsing (SQLSTATE + constraint extraction), constraint-to-changeset error mapping, Repo.insert_changeset/update_changeset with validation-before-SQL

### Phase 100: Relationships + Preloading
**Goal**: Schema structs can declare relationships (belongs_to, has_many, has_one) and the ORM provides batch preloading that loads associated records in separate queries, eliminating N+1 patterns
**Depends on**: Phase 98
**Requirements**: COMP-06, REPO-10
**Success Criteria** (what must be TRUE):
  1. Developer can declare `has_many :posts, Post`, `belongs_to :user, User`, and `has_one :profile, Profile` in struct bodies and the compiler generates queryable relationship metadata (target table, foreign key, cardinality)
  2. `Repo.preload(pool, users, [:posts])` loads all posts for a list of users in a single `WHERE user_id IN (...)` query instead of N separate queries, correctly grouping results by foreign key
  3. Nested preloading works (`Repo.preload(pool, users, [:posts, "posts.comments"])`) issuing one query per association level regardless of parent record count
  4. Preloaded data is accessible through a predictable structure (Map with association keys) and unloaded associations produce clear error messages directing the developer to use Repo.preload
**Plans**: TBD

Plans:
- [ ] 100-01: Relationship metadata generation and preload query builder
- [ ] 100-02: Repo.preload implementation with batch loading, nested preloading, and result stitching

### Phase 101: Migration System
**Goal**: Developers can define database schema changes as versioned migration files with up/down functions, run them via CLI, and track applied state -- following a forward-only philosophy with expand-migrate-contract pattern
**Depends on**: Phase 97
**Requirements**: MIGR-01, MIGR-02, MIGR-03, MIGR-04, MIGR-05, MIGR-06, MIGR-07, MIGR-08
**Success Criteria** (what must be TRUE):
  1. Developer can write migration files as Mesh functions with `up(pool)` and `down(pool)` definitions using DSL helpers (`Migration.create_table`, `Migration.alter_table`, `Migration.drop_table`, `Migration.create_index`, `Migration.drop_index`)
  2. Running `meshc migrate` discovers pending migrations, applies them in timestamp order within transactions, and records each in a `_mesh_migrations` tracking table
  3. Running `meshc migrate down` rolls back the last applied migration; `meshc migrate status` shows applied vs pending
  4. Running `meshc migrate generate <name>` creates a timestamped scaffold file with empty up/down function stubs
  5. Migration documentation follows expand-migrate-contract philosophy: additive changes first, destructive changes only after code deployment
**Plans**: TBD

Plans:
- [ ] 101-01: Migration DSL (create_table, alter_table, drop_table, create_index, drop_index) and file format
- [ ] 101-02: Migration runner (discover, sort, apply, rollback, tracking table) and meshc CLI integration
- [ ] 101-03: Migration scaffold generation (meshc migrate generate) and expand-migrate-contract documentation

### Phase 102: Mesher Rewrite
**Goal**: Mesher's entire database layer is rewritten using the ORM, validating that every ORM feature works correctly in a real application with 11 schema types, complex filtered queries, and multi-table relationships
**Depends on**: Phase 96, Phase 97, Phase 98, Phase 99, Phase 100, Phase 101
**Requirements**: MSHR-01, MSHR-02, MSHR-03, MSHR-04, MSHR-05
**Success Criteria** (what must be TRUE):
  1. All 11 Mesher type structs (Organization, User, OrgMembership, Session, Project, ApiKey, Event, Issue, AlertRule, Alert, RetentionSettings) use `deriving(Schema)` and their metadata functions return correct table/field/PK information
  2. storage/queries.mpl (627 lines of raw SQL) is replaced with ORM Repo calls, reducing to approximately 100-150 lines of ORM query code
  3. storage/schema.mpl (82 lines of imperative DDL) is replaced with versioned migration files using the Migration DSL
  4. All service modules (OrgService, ProjectService, UserService, EventProcessor, etc.) use Repo operations instead of raw Pool.query/Pool.execute calls
  5. All existing Mesher functionality (ingestion, error grouping, REST API, streaming, alerting, retention, clustering) works identically after the rewrite -- verified by running the full application
**Plans**: TBD

Plans:
- [ ] 102-01: Convert all 11 type structs to deriving(Schema) and create migration files
- [ ] 102-02: Rewrite storage/queries.mpl with ORM Repo calls and update service modules
- [ ] 102-03: End-to-end verification -- all Mesher features working identically

## Progress

**Execution Order:**
Phases execute in numeric order: 96 -> 97 -> 98 -> 99 -> 100 -> 101 -> 102
Note: Phase 100 and 101 both depend on earlier phases but are independent of each other. Phase 101 could start after Phase 97 if desired. Phase 102 requires all other v10.0 phases complete.

| Phase | Milestone | Plans Complete | Status | Completed |
|-------|-----------|----------------|--------|-----------|
| 1-10 | v1.0 | 55/55 | Complete | 2026-02-07 |
| 11-15 | v1.1 | 10/10 | Complete | 2026-02-08 |
| 16-17 | v1.2 | 6/6 | Complete | 2026-02-08 |
| 18-22 | v1.3 | 18/18 | Complete | 2026-02-08 |
| 23-25 | v1.4 | 5/5 | Complete | 2026-02-08 |
| 26-29 | v1.5 | 6/6 | Complete | 2026-02-09 |
| 30-32 | v1.6 | 6/6 | Complete | 2026-02-09 |
| 33-36 | v1.7 | 8/8 | Complete | 2026-02-09 |
| 37-42 | v1.8 | 12/12 | Complete | 2026-02-09 |
| 43-48 | v1.9 | 13/13 | Complete | 2026-02-10 |
| 49-54 | v2.0 | 13/13 | Complete | 2026-02-12 |
| 55-58 | v3.0 | 8/8 | Complete | 2026-02-12 |
| 59-62 | v4.0 | 8/8 | Complete | 2026-02-12 |
| 63-69 | v5.0 | 20/20 | Complete | 2026-02-13 |
| 70-73 | v6.0 | 11/11 | Complete | 2026-02-13 |
| 74-80 | v7.0 | 17/17 | Complete | 2026-02-14 |
| 81-86 | v8.0 | 11/11 | Complete | 2026-02-14 |
| 87-95 | v9.0 | 38/38 | Complete | 2026-02-15 |
| 96 | v10.0 | 5/5 | Complete | 2026-02-16 |
| 97 | v10.0 | 2/2 | Complete | 2026-02-16 |
| 98 | v10.0 | 3/3 | Complete | 2026-02-16 |
| 99 | v10.0 | 0/2 | Not started | - |
| 100 | v10.0 | 0/2 | Not started | - |
| 101 | v10.0 | 0/3 | Not started | - |
| 102 | v10.0 | 0/3 | Not started | - |

**Total: 102 phases shipped across 18 milestones. 290 plans completed. v10.0: 3/7 phases complete, 10/20 plans done.**
