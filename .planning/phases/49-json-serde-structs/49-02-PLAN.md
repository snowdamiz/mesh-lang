---
phase: 49-json-serde-structs
plan: 02
type: execute
wave: 2
depends_on: ["49-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "User writes deriving(Json) on a struct and typeck accepts it without error"
    - "ToJson and FromJson trait impls are registered in the trait registry for deriving(Json) structs"
    - "MIR lowering generates ToJson__to_json__StructName that builds a JSON object field-by-field"
    - "MIR lowering generates FromJson__from_json__StructName that extracts fields with nested Result propagation"
    - "Json.encode(struct_value) chains to_json + snow_json_encode to produce a JSON string"
    - "Type.from_json(json_string) parses JSON then calls from_json to produce Result<T, String>"
    - "Nested deriving(Json) structs, Option<T>, List<T>, and Map<String, V> fields all encode/decode correctly"
    - "Compiler emits clear error when deriving(Json) on struct with non-serializable field"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Json in valid_derives, ToJson/FromJson trait impl registration"
      contains: "ToJson"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "NonSerializableField error variant"
      contains: "NonSerializableField"
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Error message for non-serializable field"
      contains: "does not derive Json"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "generate_to_json_struct, generate_from_json_struct, emit_to_json_for_type, emit_from_json_for_type, Json.encode struct dispatch, Type.from_json wiring"
      contains: "generate_to_json_struct"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Trait registry ToJson/FromJson impls read during MIR lowering"
      pattern: "ToJson|FromJson"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/json.rs"
      via: "Generated MIR calls snow_json_object_new/put/get, snow_json_as_*/snow_json_from_*"
      pattern: "snow_json_object_new|snow_json_from_int|snow_json_as_int"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Json.encode call site detects struct type and inserts ToJson__to_json__ call before snow_json_encode"
      pattern: "ToJson__to_json__"
---

<objective>
Implement the full deriving(Json) compiler pipeline: typeck validation, MIR generation for to_json/from_json, Json.encode struct dispatch, Type.from_json wiring, collection/Option support, and non-serializable field detection.

Purpose: This is the core compiler work that makes `deriving(Json)` functional. After this plan, users can write `deriving(Json)` on structs and get compile-time-generated JSON encode/decode functions that handle all field types including nested structs, Option, List, and Map.

Output: Compiler accepts `deriving(Json)`, generates correct MIR, handles all field types, emits errors for non-serializable fields. Ready for E2E testing in plan 03.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-json-serde-structs/49-RESEARCH.md
@.planning/phases/49-json-serde-structs/49-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-rt/src/json.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Typeck -- Register Json in valid_derives + ToJson/FromJson trait impls + non-serializable field error</name>
  <files>crates/snow-typeck/src/infer.rs, crates/snow-typeck/src/error.rs, crates/snow-typeck/src/diagnostics.rs</files>
  <action>
**A. Add "Json" to valid_derives in `infer.rs`:**

At line 1775, change:
```rust
let valid_derives = ["Eq", "Ord", "Display", "Debug", "Hash"];
```
to:
```rust
let valid_derives = ["Eq", "Ord", "Display", "Debug", "Hash", "Json"];
```

Do the same for the sum type valid_derives check (grep for the same array around line 2073 or similar -- this is the sum type deriving validation). Note: for Phase 49 we only need structs, but adding "Json" to the sum type list prevents false errors. The actual sum type MIR generation is Phase 50.

**B. Register ToJson and FromJson trait impls** (after the Hash impl registration block, around line 1870-1880):

```rust
// Json impl (ToJson + FromJson)
if derive_list.iter().any(|t| t == "Json") {
    // Validate all fields are JSON-serializable BEFORE registering impls.
    // Serializable types: Int, Float, Bool, String, structs with ToJson impl,
    // Option<T> where T is serializable, List<T> where T is serializable,
    // Map<String, V> where V is serializable.
    let mut json_valid = true;
    for (field_name, field_ty) in &fields {
        if !is_json_serializable(field_ty, type_registry, trait_registry) {
            ctx.errors.push(TypeError::NonSerializableField {
                struct_name: name.clone(),
                field_name: field_name.clone(),
                field_type: format!("{}", field_ty),
            });
            json_valid = false;
        }
    }

    if json_valid {
        let mut to_json_methods = FxHashMap::default();
        to_json_methods.insert(
            "to_json".to_string(),
            ImplMethodSig {
                has_self: true,
                param_count: 0,
                return_type: Some(Ty::Con(TyCon::new("Json"))),
            },
        );
        let _ = trait_registry.register_impl(TraitImplDef {
            trait_name: "ToJson".to_string(),
            impl_type: impl_ty.clone(),
            impl_type_name: name.clone(),
            methods: to_json_methods,
        });

        let mut from_json_methods = FxHashMap::default();
        from_json_methods.insert(
            "from_json".to_string(),
            ImplMethodSig {
                has_self: false,
                param_count: 1,
                return_type: Some(Ty::result(
                    Ty::Con(TyCon::new(&name)),
                    Ty::string(),
                )),
            },
        );
        let _ = trait_registry.register_impl(TraitImplDef {
            trait_name: "FromJson".to_string(),
            impl_type: impl_ty.clone(),
            impl_type_name: name.clone(),
            methods: from_json_methods,
        });
    }
}
```

**C. Add `is_json_serializable` helper function** (as a free function near the struct def processing code in infer.rs):

```rust
fn is_json_serializable(ty: &Ty, type_registry: &TypeRegistry, trait_registry: &TraitRegistry) -> bool {
    match ty {
        Ty::Con(con) => match con.name.as_str() {
            "Int" | "Float" | "Bool" | "String" => true,
            name => {
                // Check if this type has a ToJson impl registered
                let ty_for_lookup = Ty::Con(TyCon::new(name));
                trait_registry.has_impl("ToJson", &ty_for_lookup)
            }
        },
        Ty::App(base, args) => {
            if let Ty::Con(con) = base.as_ref() {
                match con.name.as_str() {
                    "Option" => args.first().map_or(false, |t| is_json_serializable(t, type_registry, trait_registry)),
                    "List" => args.first().map_or(false, |t| is_json_serializable(t, type_registry, trait_registry)),
                    "Map" => {
                        // Map key must be String for JSON objects
                        let key_ok = args.first().map_or(false, |t| {
                            matches!(t, Ty::Con(c) if c.name == "String")
                        });
                        let val_ok = args.get(1).map_or(false, |t| is_json_serializable(t, type_registry, trait_registry));
                        key_ok && val_ok
                    }
                    _ => false,
                }
            } else {
                false
            }
        },
        _ => false, // Type variables, functions, etc. are not serializable
    }
}
```

**D. Add NonSerializableField error variant to `error.rs`:**

Add after the existing error variants (around line 260):
```rust
/// A field type in a `deriving(Json)` struct is not JSON-serializable.
NonSerializableField {
    struct_name: String,
    field_name: String,
    field_type: String,
},
```

**E. Add error formatting in `diagnostics.rs`:**

Add the error code mapping (after E0037 or wherever the last error code is):
```rust
TypeError::NonSerializableField { .. } => "E0038",
```

Add the error message formatting (in the main match block):
```rust
TypeError::NonSerializableField {
    struct_name,
    field_name,
    field_type,
} => {
    let msg = format!(
        "field `{}` of type `{}` is not JSON-serializable",
        field_name, field_type
    );
    Report::build(ReportKind::Error, &source_id, 0)
        .with_code("E0038")
        .with_message(msg)
        .with_help(format!(
            "type `{}` does not derive Json; add `deriving(Json)` to its definition, or use a serializable type (Int, Float, Bool, String, Option<T>, List<T>, Map<String, V>)",
            field_type
        ))
        .finish()
}
```

Also update the UnsupportedDerive help text (around line 1365-1375) to include Json:
Change `"only Eq, Ord, Display, Debug, and Hash are derivable"` to `"only Eq, Ord, Display, Debug, Hash, and Json are derivable"`.
  </action>
  <verify>
`cargo build -p snow-typeck` -- compiles cleanly.
`cargo test -p snow-typeck` -- all existing tests pass (Json added to valid_derives doesn't break anything).
  </verify>
  <done>
"Json" is in valid_derives for both structs and sum types. ToJson/FromJson impls are registered when deriving(Json) is present and all fields are serializable. NonSerializableField error is emitted for non-serializable fields with clear E0038 diagnostic. Diagnostics help text updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: MIR -- Generate to_json/from_json + Json.encode struct dispatch + Type.from_json wiring</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
This task adds the core MIR generation for deriving(Json). All changes are in `crates/snow-codegen/src/mir/lower.rs`.

**A. Add Json to the struct deriving dispatch** (around line 1599, after the Display derive check):

```rust
if derive_list.iter().any(|t| t == "Json") {
    self.generate_to_json_struct(&name, &fields);
    self.generate_from_json_struct(&name, &fields);
}
```

Also add Json to `ensure_monomorphized_struct_trait_fns` (around line 1658-1681):
```rust
let has_json = self.trait_registry.has_impl("ToJson", typeck_ty);
// ... in the generation block:
if has_json {
    self.generate_to_json_struct(&mangled, &fields);
    self.generate_from_json_struct(&mangled, &fields);
}
```

**B. Implement `generate_to_json_struct`** (add near the Hash generation section, around line 2713):

```rust
fn generate_to_json_struct(&mut self, name: &str, fields: &[(String, MirType)]) {
    let mangled = format!("ToJson__to_json__{}", name);
    let struct_ty = MirType::Struct(name.to_string());
    let self_var = MirExpr::Var("self".to_string(), struct_ty.clone());

    // Build body: create JSON object, put each field
    let obj_new_ty = MirType::FnPtr(vec![], Box::new(MirType::Ptr));
    let obj_put_ty = MirType::FnPtr(
        vec![MirType::Ptr, MirType::Ptr, MirType::Ptr],
        Box::new(MirType::Ptr),
    );

    let mut body = MirExpr::Call {
        func: Box::new(MirExpr::Var("snow_json_object_new".to_string(), obj_new_ty)),
        args: vec![],
        ty: MirType::Ptr,
    };

    for (field_name, field_ty) in fields {
        let field_access = MirExpr::FieldAccess {
            object: Box::new(self_var.clone()),
            field: field_name.clone(),
            ty: field_ty.clone(),
        };

        // Convert field value to SnowJson
        let json_val = self.emit_to_json_for_type(field_access, field_ty, name);

        // Create key string
        let key = MirExpr::StringLit(field_name.clone(), MirType::String);

        // obj = snow_json_object_put(obj, key, json_val)
        body = MirExpr::Call {
            func: Box::new(MirExpr::Var("snow_json_object_put".to_string(), obj_put_ty.clone())),
            args: vec![body, key, json_val],
            ty: MirType::Ptr,
        };
    }

    let func = MirFunction {
        name: mangled.clone(),
        params: vec![("self".to_string(), struct_ty.clone())],
        return_type: MirType::Ptr,
        body,
        is_closure_fn: false,
        captures: vec![],
        has_tail_calls: false,
    };

    self.functions.push(func);
    self.known_functions.insert(
        mangled,
        MirType::FnPtr(vec![struct_ty], Box::new(MirType::Ptr)),
    );
}
```

**C. Implement `emit_to_json_for_type` helper** (type-directed dispatch, mirrors `emit_hash_for_type`):

```rust
fn emit_to_json_for_type(&mut self, expr: MirExpr, ty: &MirType, context_struct: &str) -> MirExpr {
    match ty {
        MirType::Int => {
            let fn_ty = MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr));
            MirExpr::Call {
                func: Box::new(MirExpr::Var("snow_json_from_int".to_string(), fn_ty)),
                args: vec![expr],
                ty: MirType::Ptr,
            }
        }
        MirType::Float => {
            let fn_ty = MirType::FnPtr(vec![MirType::Float], Box::new(MirType::Ptr));
            MirExpr::Call {
                func: Box::new(MirExpr::Var("snow_json_from_float".to_string(), fn_ty)),
                args: vec![expr],
                ty: MirType::Ptr,
            }
        }
        MirType::Bool => {
            let fn_ty = MirType::FnPtr(vec![MirType::Bool], Box::new(MirType::Ptr));
            MirExpr::Call {
                func: Box::new(MirExpr::Var("snow_json_from_bool".to_string(), fn_ty)),
                args: vec![expr],
                ty: MirType::Ptr,
            }
        }
        MirType::String => {
            let fn_ty = MirType::FnPtr(vec![MirType::String], Box::new(MirType::Ptr));
            MirExpr::Call {
                func: Box::new(MirExpr::Var("snow_json_from_string".to_string(), fn_ty)),
                args: vec![expr],
                ty: MirType::Ptr,
            }
        }
        MirType::Struct(inner_name) => {
            // Recursive: call ToJson__to_json__InnerStruct
            let inner_mangled = format!("ToJson__to_json__{}", inner_name);
            let fn_ty = MirType::FnPtr(vec![ty.clone()], Box::new(MirType::Ptr));
            MirExpr::Call {
                func: Box::new(MirExpr::Var(inner_mangled, fn_ty)),
                args: vec![expr],
                ty: MirType::Ptr,
            }
        }
        MirType::SumType(sum_name) if sum_name.starts_with("Option_") => {
            // Option<T>: Match on Some(v) -> encode inner, None -> json null
            self.emit_option_to_json(expr, sum_name, context_struct)
        }
        MirType::Ptr => {
            // Collection type (List or Map) -- need to look up typeck Ty for element type.
            // For now emit the expr as-is (will be resolved via typeck Ty lookup).
            // This case is handled by the outer generate_to_json_struct which
            // has access to StructDefInfo.fields for typeck Ty recovery.
            // Fallback: treat as opaque JSON value (pass through).
            expr
        }
        _ => {
            // Unsupported type -- should have been caught by typeck.
            // Fallback: pass as opaque pointer.
            expr
        }
    }
}
```

**D. Handle Option<T> encoding in `emit_option_to_json`:**

```rust
fn emit_option_to_json(&mut self, expr: MirExpr, sum_name: &str, context_struct: &str) -> MirExpr {
    // Extract inner type name from "Option_Int" -> "Int"
    let inner_type_str = sum_name.strip_prefix("Option_").unwrap_or("Int");
    let inner_mir_type = self.mir_type_from_name(inner_type_str);

    let null_ty = MirType::FnPtr(vec![], Box::new(MirType::Ptr));
    let null_expr = MirExpr::Call {
        func: Box::new(MirExpr::Var("snow_json_null".to_string(), null_ty)),
        args: vec![],
        ty: MirType::Ptr,
    };

    // Match expr { Some(v) -> emit_to_json(v), None -> null }
    let some_var = MirExpr::Var("__opt_val".to_string(), inner_mir_type.clone());
    let some_body = self.emit_to_json_for_type(some_var, &inner_mir_type, context_struct);

    MirExpr::Match {
        scrutinee: Box::new(expr),
        arms: vec![
            MirMatchArm {
                pattern: MirPattern::Constructor {
                    type_name: sum_name.to_string(),
                    variant: "Some".to_string(),
                    bindings: vec![("__opt_val".to_string(), inner_mir_type.clone())],
                },
                guard: None,
                body: some_body,
            },
            MirMatchArm {
                pattern: MirPattern::Constructor {
                    type_name: sum_name.to_string(),
                    variant: "None".to_string(),
                    bindings: vec![],
                },
                guard: None,
                body: null_expr,
            },
        ],
        ty: MirType::Ptr,
    }
}
```

Add helper `mir_type_from_name`:
```rust
fn mir_type_from_name(&self, name: &str) -> MirType {
    match name {
        "Int" => MirType::Int,
        "Float" => MirType::Float,
        "Bool" => MirType::Bool,
        "String" => MirType::String,
        n => {
            if self.structs.iter().any(|s| s.name == n) || self.registry.struct_defs.contains_key(n) {
                MirType::Struct(n.to_string())
            } else {
                MirType::Ptr // Collection or unknown
            }
        }
    }
}
```

**E. Handle List<T> and Map<String, V> encoding.**

The `emit_to_json_for_type` function needs to handle `MirType::Ptr` for collections. Since `Ptr` erases the element type, the generate_to_json_struct function must look up the typeck `Ty` for each field from the StructDefInfo in the registry. Modify `generate_to_json_struct` to accept the struct name and look up `StructDefInfo.fields` when a field's MirType is Ptr:

In the `generate_to_json_struct` body loop, before calling `emit_to_json_for_type`, check if the field's MirType is Ptr and look up the typeck Ty:

```rust
let json_val = if matches!(field_ty, MirType::Ptr) {
    // Look up typeck Ty from StructDefInfo for collection element type
    if let Some(info) = self.registry.struct_defs.get(name) {
        if let Some((_, typeck_ty)) = info.fields.iter().find(|(n, _)| n == field_name) {
            self.emit_collection_to_json(field_access, typeck_ty, name)
        } else {
            field_access // fallback
        }
    } else {
        field_access // fallback
    }
} else {
    self.emit_to_json_for_type(field_access, field_ty, name)
};
```

Implement `emit_collection_to_json`:
```rust
fn emit_collection_to_json(&mut self, expr: MirExpr, typeck_ty: &Ty, context_struct: &str) -> MirExpr {
    match typeck_ty {
        Ty::App(base, args) => {
            if let Ty::Con(con) = base.as_ref() {
                match con.name.as_str() {
                    "List" => {
                        // Build JSON array by iterating list
                        // Generate a synthetic wrapper function that:
                        // 1. Creates snow_json_array_new()
                        // 2. Iterates list with snow_list_length/snow_list_get
                        // 3. For each element, calls emit_to_json_for_type(elem, elem_mir_type)
                        // 4. Pushes each to array with snow_json_array_push
                        let elem_ty = args.first().cloned().unwrap_or(Ty::int());
                        self.generate_list_to_json_wrapper(expr, &elem_ty, context_struct)
                    }
                    "Map" => {
                        // Build JSON object by iterating map
                        // Key must be String (enforced by typeck)
                        // Value is args[1]
                        let val_ty = args.get(1).cloned().unwrap_or(Ty::string());
                        self.generate_map_to_json_wrapper(expr, &val_ty, context_struct)
                    }
                    _ => expr,
                }
            } else {
                expr
            }
        }
        _ => expr,
    }
}
```

For `generate_list_to_json_wrapper` and `generate_map_to_json_wrapper`: These need to generate synthetic MIR functions (similar to `generate_display_collection_wrapper` at line 5482). Each creates a unique wrapper function name like `__list_to_json_Int` that loops over elements:

```rust
fn generate_list_to_json_wrapper(&mut self, list_expr: MirExpr, elem_ty: &Ty, context_struct: &str) -> MirExpr {
    let elem_mir = resolve_type(elem_ty, self.registry, false);
    let wrapper_name = format!("__list_to_json_{}", mangle_type_name_from_ty(elem_ty, self.registry));

    if !self.known_functions.contains_key(&wrapper_name) {
        // Generate wrapper: fn(list: Ptr) -> Ptr
        // Body: for i in 0..len: arr = push(arr, to_json(get(list, i)))
        // This is a MirExpr::Call to a generated function.
        // Use a ForRange MIR loop or unfold as Let chains.
        //
        // Actually, for simplicity and correctness: generate a runtime helper approach.
        // Call snow_json_array_new(), then for each element, convert and push.
        // But MIR doesn't have loops in expression position.
        //
        // Instead: generate a standalone function that uses the existing
        // snow_list_length + snow_list_get + loop pattern.
        // For the MIR representation, use a Call to a synthetic function
        // that we generate with a ForRange body.
        //
        // Simplest correct approach: generate the function body using
        // a runtime-side helper. Add snow_json_list_to_json(list_ptr, elem_to_json_fn_ptr)
        // that takes a callback for element conversion.
        //
        // This matches the snow_list_to_string(list, callback) pattern used for Display.
        // We need a new runtime function: snow_json_from_list(list_ptr, elem_to_json_fn) -> *mut u8
        // that iterates the list and calls the callback for each element.
        //
        // For now, use direct runtime functions. Will add snow_json_from_list
        // and snow_json_from_map runtime helpers.

        self.known_functions.insert(
            wrapper_name.clone(),
            MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr)),
        );
    }

    // Call the wrapper
    MirExpr::Call {
        func: Box::new(MirExpr::Var(
            wrapper_name,
            MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr)),
        )),
        args: vec![list_expr],
        ty: MirType::Ptr,
    }
}
```

ACTUALLY -- the research is clear: use a callback-based runtime helper (matching the snow_list_to_string pattern). The approach is:

Add 2 additional runtime functions to json.rs (add these in this plan, they are straightforward and needed now):

- `snow_json_from_list(list_ptr: *mut u8, elem_fn: extern fn(u64) -> *mut u8) -> *mut u8` -- Iterates list, calls elem_fn for each element to get SnowJson*, builds JSON array.
- `snow_json_from_map(map_ptr: *mut u8, val_fn: extern fn(u64) -> *mut u8) -> *mut u8` -- Iterates map, keys are SnowString (become JSON keys), calls val_fn for each value, builds JSON object.
- `snow_json_to_list(json_arr: *mut u8, elem_fn: extern fn(*mut u8) -> *mut u8) -> *mut u8` -- For from_json: iterates JSON array, calls elem_fn for each to decode element, returns SnowResult wrapping a SnowList. Each elem_fn call returns a SnowResult; if any fails, propagate error.
- `snow_json_to_map(json_obj: *mut u8, val_fn: extern fn(*mut u8) -> *mut u8) -> *mut u8` -- For from_json: iterates JSON object, calls val_fn for each value, returns SnowResult wrapping a SnowMap.

Register these 4 new functions in intrinsics.rs and known_functions (three-point registration, all take ptr args and return ptr).

Then in MIR, for a `List<Int>` field, generate:
```
snow_json_from_list(self.field, snow_json_from_int)
```
Where `snow_json_from_int` is passed as a function pointer. For `List<User>` (nested struct):
```
snow_json_from_list(self.field, ToJson__to_json__User)
```

For `Map<String, Int>` field:
```
snow_json_from_map(self.field, snow_json_from_int)
```

The `emit_to_json_for_type` for Ptr case becomes:
- Look up typeck Ty, determine if List<T> or Map<String, V>
- Resolve the element-to-json callback function name
- Call `snow_json_from_list(expr, callback)` or `snow_json_from_map(expr, callback)`

Implement `resolve_to_json_callback` (mirrors `resolve_to_string_callback`):
```rust
fn resolve_to_json_callback(&self, elem_ty: &Ty) -> String {
    match elem_ty {
        Ty::Con(con) => match con.name.as_str() {
            "Int" => "snow_json_from_int".to_string(),
            "Float" => "snow_json_from_float".to_string(),
            "Bool" => "snow_json_from_bool".to_string(),
            "String" => "snow_json_from_string".to_string(),
            name => format!("ToJson__to_json__{}", name),
        },
        _ => "snow_json_from_int".to_string(), // fallback
    }
}
```

Similarly `resolve_from_json_callback` for decoding:
```rust
fn resolve_from_json_callback(&self, elem_ty: &Ty) -> String {
    match elem_ty {
        Ty::Con(con) => match con.name.as_str() {
            "Int" => "snow_json_as_int".to_string(),
            "Float" => "snow_json_as_float".to_string(),
            "Bool" => "snow_json_as_bool".to_string(),
            "String" => "snow_json_as_string".to_string(),
            name => format!("FromJson__from_json__{}", name),
        },
        _ => "snow_json_as_int".to_string(), // fallback
    }
}
```

**F. Implement `generate_from_json_struct`:**

This generates `FromJson__from_json__StructName(json: Ptr) -> SumType(Result_StructName_String)`.

The body is a nested chain of Match expressions. For each field:
1. Call `snow_json_object_get(json, "field_name")` -> Result
2. Match on Result: Err(e) -> propagate Err, Ok(json_val) -> extract typed value
3. Call the appropriate `snow_json_as_*` function -> Result
4. Match on Result: Err(e) -> propagate Err, Ok(val) -> continue to next field
5. After all fields extracted: `ConstructVariant("Result", "Ok", [StructLit(name, fields)])`

Build this inside-out: start with the innermost Ok case (struct construction), then wrap each field extraction around it.

```rust
fn generate_from_json_struct(&mut self, name: &str, fields: &[(String, MirType)]) {
    let mangled = format!("FromJson__from_json__{}", name);
    let struct_ty = MirType::Struct(name.to_string());
    let result_ty = MirType::Ptr; // Result is represented as Ptr in MIR

    let json_var = MirExpr::Var("json".to_string(), MirType::Ptr);

    // Build the innermost expression: Ok(StructLit(...))
    let field_bindings: Vec<(String, MirExpr)> = fields.iter().enumerate().map(|(i, (fname, fty))| {
        (fname.clone(), MirExpr::Var(format!("__field_{}", i), fty.clone()))
    }).collect();

    let struct_lit = MirExpr::StructLit {
        name: name.to_string(),
        fields: field_bindings,
        ty: struct_ty.clone(),
    };

    let ok_variant = MirExpr::ConstructVariant {
        type_name: format!("Result_{}_String", name),
        variant: "Ok".to_string(),
        fields: vec![struct_lit],
        ty: result_ty.clone(),
    };

    // Wrap each field extraction around the inner expression, from last to first
    let mut body = ok_variant;

    for (i, (field_name, field_ty)) in fields.iter().enumerate().rev() {
        let obj_get_ty = MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr));
        let key_lit = MirExpr::StringLit(field_name.clone(), MirType::String);

        // snow_json_object_get(json, "field_name") -> Result
        let get_call = MirExpr::Call {
            func: Box::new(MirExpr::Var("snow_json_object_get".to_string(), obj_get_ty)),
            args: vec![json_var.clone(), key_lit],
            ty: MirType::Ptr,
        };

        // For the type extraction: call the appropriate snow_json_as_* or FromJson__from_json__*
        let field_var = format!("__json_field_{}", i);
        let val_var = format!("__field_{}", i);

        let extract_call = self.emit_from_json_for_type(
            MirExpr::Var(field_var.clone(), MirType::Ptr),
            field_ty,
            name,
        );

        // Inner match: extract typed value from JSON
        let inner_match = MirExpr::Match {
            scrutinee: Box::new(extract_call),
            arms: vec![
                MirMatchArm {
                    pattern: MirPattern::Constructor {
                        type_name: "Result".to_string(),
                        variant: "Ok".to_string(),
                        bindings: vec![(val_var.clone(), field_ty.clone())],
                    },
                    guard: None,
                    body,
                },
                MirMatchArm {
                    pattern: MirPattern::Constructor {
                        type_name: "Result".to_string(),
                        variant: "Err".to_string(),
                        bindings: vec![("__err".to_string(), MirType::String)],
                    },
                    guard: None,
                    body: MirExpr::ConstructVariant {
                        type_name: format!("Result_{}_String", name),
                        variant: "Err".to_string(),
                        fields: vec![MirExpr::Var("__err".to_string(), MirType::String)],
                        ty: result_ty.clone(),
                    },
                },
            ],
            ty: result_ty.clone(),
        };

        // Outer match: get field from object
        body = MirExpr::Match {
            scrutinee: Box::new(get_call),
            arms: vec![
                MirMatchArm {
                    pattern: MirPattern::Constructor {
                        type_name: "Result".to_string(),
                        variant: "Ok".to_string(),
                        bindings: vec![(field_var, MirType::Ptr)],
                    },
                    guard: None,
                    body: inner_match,
                },
                MirMatchArm {
                    pattern: MirPattern::Constructor {
                        type_name: "Result".to_string(),
                        variant: "Err".to_string(),
                        bindings: vec![("__err".to_string(), MirType::String)],
                    },
                    guard: None,
                    body: MirExpr::ConstructVariant {
                        type_name: format!("Result_{}_String", name),
                        variant: "Err".to_string(),
                        fields: vec![MirExpr::Var("__err".to_string(), MirType::String)],
                        ty: result_ty.clone(),
                    },
                },
            ],
            ty: result_ty.clone(),
        };
    }

    let func = MirFunction {
        name: mangled.clone(),
        params: vec![("json".to_string(), MirType::Ptr)],
        return_type: result_ty.clone(),
        body,
        is_closure_fn: false,
        captures: vec![],
        has_tail_calls: false,
    };

    self.functions.push(func);
    self.known_functions.insert(
        mangled,
        MirType::FnPtr(vec![MirType::Ptr], Box::new(result_ty)),
    );
}
```

Implement `emit_from_json_for_type` (mirrors emit_to_json_for_type but for decoding):
```rust
fn emit_from_json_for_type(&self, json_expr: MirExpr, target_ty: &MirType, context_struct: &str) -> MirExpr {
    let fn_name = match target_ty {
        MirType::Int => "snow_json_as_int",
        MirType::Float => "snow_json_as_float",
        MirType::Bool => "snow_json_as_bool",
        MirType::String => "snow_json_as_string",
        MirType::Struct(inner) => {
            // Call FromJson__from_json__InnerStruct
            let name = format!("FromJson__from_json__{}", inner);
            let fn_ty = MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr));
            return MirExpr::Call {
                func: Box::new(MirExpr::Var(name, fn_ty)),
                args: vec![json_expr],
                ty: MirType::Ptr,
            };
        }
        // Option<T> and collection types handled via typeck Ty lookup (same as encoding)
        _ => "snow_json_as_int", // fallback
    };

    let fn_ty = MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr));
    MirExpr::Call {
        func: Box::new(MirExpr::Var(fn_name.to_string(), fn_ty)),
        args: vec![json_expr],
        ty: MirType::Ptr,
    }
}
```

For Option and collection fields in from_json: use the same typeck Ty lookup pattern from StructDefInfo.fields. For `Option<T>`: check if JSON is null -> None, else decode inner -> wrap in Some. For `List<T>`: call `snow_json_to_list(json, elem_from_json_fn)`. For `Map<String, V>`: call `snow_json_to_map(json, val_from_json_fn)`.

**G. Wire `Json.encode(struct_value)` to chain to_json + encode.**

In the call expression lowering (around line 3980-4050 in `lower_call_expr`), after the existing collection Display dispatch and before the trait method rewriting, add handling for `snow_json_encode`:

When the callee resolves to `snow_json_encode` and the first argument has a `MirType::Struct(name)`:
- Check if `ToJson__to_json__<name>` exists in known_functions
- If yes: wrap the arg with the to_json call first, then pass to snow_json_encode

```rust
// Json.encode struct dispatch: if encoding a struct with ToJson, chain to_json + encode
if let MirExpr::Var(ref name, _) = callee {
    if name == "snow_json_encode" && args.len() == 1 {
        if let MirType::Struct(struct_name) = args[0].ty() {
            let to_json_fn = format!("ToJson__to_json__{}", struct_name);
            if self.known_functions.contains_key(&to_json_fn) {
                let fn_ty = MirType::FnPtr(vec![args[0].ty().clone()], Box::new(MirType::Ptr));
                let json_ptr = MirExpr::Call {
                    func: Box::new(MirExpr::Var(to_json_fn, fn_ty)),
                    args: args.clone(),
                    ty: MirType::Ptr,
                };
                return MirExpr::Call {
                    func: Box::new(callee),
                    args: vec![json_ptr],
                    ty: MirType::String,
                };
            }
        }
    }
}
```

**H. Wire `Type.from_json(json_string)` call resolution.**

When the user writes `User.from_json(str)`, this resolves through the trait method dispatch. The `from_json` method is registered on `FromJson` trait. When `resolve_trait_callee` sees `from_json` called on a type `User`, it should find the `FromJson` impl and rewrite to `FromJson__from_json__User`.

However, `from_json` is a static method (no self parameter), so it won't go through normal trait dispatch (which checks the first arg's type). Instead, handle it in the module-qualified field access path. When lowering `User.from_json(...)`:

The call `User.from_json(str)` resolves as field access on identifier `User` with field `from_json`. Since `User` is a struct name (not a stdlib module or service), this currently falls through to struct field access. Add handling: if the base is a struct name and the field is `from_json`, check trait registry for FromJson impl and rewrite to `FromJson__from_json__User`.

In the field access lowering section (around line 4130-4190), after the sum type variant check and before the struct field access fallthrough:

```rust
// Check if this is StructName.from_json (static trait method)
if let Some(info) = self.registry.struct_defs.get(&base_name) {
    let field = fa.field().map(|t| t.text().to_string()).unwrap_or_default();
    if field == "from_json" {
        let from_json_fn = format!("FromJson__from_json__{}", base_name);
        if self.known_functions.contains_key(&from_json_fn) {
            let ty = self.known_functions.get(&from_json_fn).unwrap().clone();
            return MirExpr::Var(from_json_fn, ty);
        }
    }
}
```

But `User.from_json(str)` should parse the JSON string THEN call from_json. So the generated function `FromJson__from_json__User` takes a `Ptr` (SnowJson*), not a String. The user API should be:
- `Json.encode(user)` -> calls `ToJson__to_json__User(user)` then `snow_json_encode(json_ptr)` -> String
- `User.from_json(json_string)` -> calls `snow_json_parse(str)` then on Ok: `FromJson__from_json__User(json_ptr)` -> Result<User, String>

So `User.from_json` needs to be a wrapper that chains parse + decode. Generate this wrapper during MIR lowering when `deriving(Json)` is processed:

```rust
fn generate_from_json_string_wrapper(&mut self, name: &str) {
    let wrapper_name = format!("__json_decode__{}", name);
    let parse_ty = MirType::FnPtr(vec![MirType::String], Box::new(MirType::Ptr));
    let from_json_ty = MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr));
    let result_ty = MirType::Ptr;

    let str_var = MirExpr::Var("__input".to_string(), MirType::String);

    // snow_json_parse(input) -> Result<SnowJson, String>
    let parse_call = MirExpr::Call {
        func: Box::new(MirExpr::Var("snow_json_parse".to_string(), parse_ty)),
        args: vec![str_var],
        ty: MirType::Ptr,
    };

    // Match parse result
    let from_json_call = MirExpr::Call {
        func: Box::new(MirExpr::Var(format!("FromJson__from_json__{}", name), from_json_ty)),
        args: vec![MirExpr::Var("__parsed_json".to_string(), MirType::Ptr)],
        ty: result_ty.clone(),
    };

    let body = MirExpr::Match {
        scrutinee: Box::new(parse_call),
        arms: vec![
            MirMatchArm {
                pattern: MirPattern::Constructor {
                    type_name: "Result".to_string(),
                    variant: "Ok".to_string(),
                    bindings: vec![("__parsed_json".to_string(), MirType::Ptr)],
                },
                guard: None,
                body: from_json_call,
            },
            MirMatchArm {
                pattern: MirPattern::Constructor {
                    type_name: "Result".to_string(),
                    variant: "Err".to_string(),
                    bindings: vec![("__err".to_string(), MirType::String)],
                },
                guard: None,
                body: MirExpr::ConstructVariant {
                    type_name: format!("Result_{}_String", name),
                    variant: "Err".to_string(),
                    fields: vec![MirExpr::Var("__err".to_string(), MirType::String)],
                    ty: result_ty.clone(),
                },
            },
        ],
        ty: result_ty.clone(),
    };

    let func = MirFunction {
        name: wrapper_name.clone(),
        params: vec![("__input".to_string(), MirType::String)],
        return_type: result_ty.clone(),
        body,
        is_closure_fn: false,
        captures: vec![],
        has_tail_calls: false,
    };

    self.functions.push(func);
    self.known_functions.insert(
        wrapper_name,
        MirType::FnPtr(vec![MirType::String], Box::new(result_ty)),
    );
}
```

Call this from `generate_from_json_struct` at the end. Then in the field access lowering for `User.from_json`, resolve to `__json_decode__User` instead.

**IMPORTANT implementation notes:**
- The pseudo-code above is a guide -- adapt to match the exact MirExpr/MirPattern/MirMatchArm types in the codebase. Read the enum definitions in `mir/mod.rs` to use correct variant names.
- Test incrementally: first get basic struct to_json working (Int/String/Bool/Float fields only), then add from_json, then nested structs, then Option, then List/Map.
- If the ConstructVariant or StructLit MIR nodes have different field names, adapt accordingly.
- The `Result` type in MIR may be represented as `SumType("Result_User_String")` or similar -- check how existing Result handling works in the codebase.
- When adding the 4 collection runtime helpers (snow_json_from_list, snow_json_from_map, snow_json_to_list, snow_json_to_map), add them to json.rs with full three-point registration (runtime + intrinsics + known_functions). These take callback function pointers similar to snow_list_to_string.
  </action>
  <verify>
`cargo build` -- full project compiles without errors.
`cargo test` -- all existing tests pass (no regressions from new MIR generation code).
Write a minimal test Snow file to verify basic compilation:
```snow
struct Point do
  x :: Int
  y :: Int
end deriving(Json)

fn main() do
  let p = Point { x: 1, y: 2 }
  let json = Json.encode(p)
  println(json)
end
```
Compile and run: should print `{"x":1,"y":2}` (or `{"y":2,"x":1}` -- field order depends on map iteration).
  </verify>
  <done>
MIR lowering generates ToJson__to_json__StructName and FromJson__from_json__StructName for all deriving(Json) structs. Json.encode(struct_value) chains to_json + encode. User.from_json(str) chains parse + from_json. Option, List, and Map fields are handled via typeck Ty recovery and callback-based runtime helpers. Nested structs recurse. Non-serializable fields caught by typeck. Basic struct round-trip compiles and runs.
  </done>
</task>

</tasks>

<verification>
- `cargo build` compiles successfully
- `cargo test` passes with zero regressions
- A simple Snow program with `deriving(Json)` compiles:
  - `struct Point do x :: Int y :: Int end deriving(Json)` + `Json.encode(Point { x: 1, y: 2 })` produces a JSON string
  - `Point.from_json("{\"x\":1,\"y\":2}")` produces `Ok(Point { x: 1, y: 2 })`
- A struct with a non-Json field produces compile error E0038
</verification>

<success_criteria>
- deriving(Json) accepted in typeck with ToJson/FromJson impl registration
- MIR generates correct to_json (object construction) and from_json (nested Match extraction) functions
- Json.encode works on structs, Type.from_json works on JSON strings
- Option<T>, List<T>, Map<String, V> fields handled
- Non-serializable field check produces E0038 error
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/49-json-serde-structs/49-02-SUMMARY.md`
</output>
