---
phase: 49-json-serde-structs
plan: 03
type: execute
wave: 3
depends_on: ["49-02"]
files_modified:
  - tests/e2e/deriving_json_basic.snow
  - tests/e2e/deriving_json_nested.snow
  - tests/e2e/deriving_json_option.snow
  - tests/e2e/deriving_json_collections.snow
  - tests/e2e/deriving_json_roundtrip.snow
  - tests/e2e/deriving_json_number_types.snow
  - tests/e2e/deriving_json_error.snow
  - tests/compile_fail/deriving_json_non_serializable.snow
autonomous: true

must_haves:
  truths:
    - "User writes deriving(Json) on a struct and can call Json.encode(value) to get a JSON string"
    - "User calls Type.from_json(json_string) and gets back Result<T, String> with the original struct values"
    - "Structs with nested deriving(Json) structs, Option<T>, List<T>, and Map<String, V> fields all round-trip correctly"
    - "Compiler emits clear error when deriving(Json) on struct with non-serializable field type"
    - "Int and Float values survive JSON round-trip without type confusion"
  artifacts:
    - path: "tests/e2e/deriving_json_basic.snow"
      provides: "Basic encode/decode test for struct with primitive fields"
    - path: "tests/e2e/deriving_json_nested.snow"
      provides: "Nested struct encode/decode test"
    - path: "tests/e2e/deriving_json_option.snow"
      provides: "Option<T> field handling (Some -> value, None -> null)"
    - path: "tests/e2e/deriving_json_collections.snow"
      provides: "List<T> and Map<String, V> field handling"
    - path: "tests/e2e/deriving_json_roundtrip.snow"
      provides: "Full round-trip verification: encode then decode matches original"
    - path: "tests/e2e/deriving_json_number_types.snow"
      provides: "Int stays Int, Float stays Float through JSON round-trip"
    - path: "tests/e2e/deriving_json_error.snow"
      provides: "Decode error handling: missing fields, wrong types"
    - path: "tests/compile_fail/deriving_json_non_serializable.snow"
      provides: "Compile-time error E0038 for non-serializable field"
  key_links:
    - from: "tests/e2e/deriving_json_roundtrip.snow"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Exercises full encode->decode pipeline through generated MIR"
      pattern: "deriving.*Json"
    - from: "tests/compile_fail/deriving_json_non_serializable.snow"
      to: "crates/snow-typeck/src/infer.rs"
      via: "Triggers NonSerializableField error in typeck"
      pattern: "E0038"
---

<objective>
Comprehensive E2E test suite covering all 9 JSON serde requirements (JSON-01 through JSON-07, JSON-10, JSON-11).

Purpose: Validate that the entire deriving(Json) pipeline works end-to-end from Snow source to correct runtime behavior. Each test maps directly to one or more requirements. Without these tests, we cannot verify the success criteria of Phase 49.

Output: 7 E2E test files + 1 compile_fail test, all passing. Phase 49 success criteria fully verified.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-json-serde-structs/49-RESEARCH.md
@.planning/phases/49-json-serde-structs/49-01-SUMMARY.md
@.planning/phases/49-json-serde-structs/49-02-SUMMARY.md
@tests/e2e/deriving_struct.snow
@tests/e2e/stdlib_json_parse_roundtrip.snow
</context>

<tasks>

<task type="auto">
  <name>Task 1: E2E tests for basic encode/decode, nested structs, Option, and number types</name>
  <files>tests/e2e/deriving_json_basic.snow, tests/e2e/deriving_json_nested.snow, tests/e2e/deriving_json_option.snow, tests/e2e/deriving_json_number_types.snow</files>
  <action>
Create 4 E2E test files. Follow the existing pattern from `tests/e2e/deriving_struct.snow` for structure (pure Snow source, main function, println for output verification).

**File 1: `tests/e2e/deriving_json_basic.snow`** (covers JSON-01, JSON-02, JSON-03)
```snow
-- Tests basic JSON encode/decode for a struct with primitive fields.
struct User do
  name :: String
  age :: Int
  score :: Float
  active :: Bool
end deriving(Json)

fn main() do
  let u = User { name: "Alice", age: 30, score: 95.5, active: true }
  let json = Json.encode(u)
  println(json)

  let result = User.from_json(json)
  case result do
    Ok(u2) ->
      println(u2.name)
      println(u2.age)
      println(u2.active)
    Err(e) -> println("Error: ${e}")
  end
end
```
Expected output (verify with `cargo test`):
```
{"name":"Alice","age":30,"score":95.5,"active":true}
Alice
30
true
```
Note: JSON field order may vary -- check the actual output and adjust expected output to match. The key is all fields are present with correct values.

**File 2: `tests/e2e/deriving_json_nested.snow`** (covers JSON-04)
```snow
-- Tests nested struct JSON encode/decode.
struct Address do
  city :: String
  zip :: Int
end deriving(Json)

struct Person do
  name :: String
  addr :: Address
end deriving(Json)

fn main() do
  let p = Person { name: "Bob", addr: Address { city: "NYC", zip: 10001 } }
  let json = Json.encode(p)
  println(json)

  let result = Person.from_json(json)
  case result do
    Ok(p2) ->
      println(p2.name)
      println(p2.addr.city)
      println(p2.addr.zip)
    Err(e) -> println("Error: ${e}")
  end
end
```
Expected output:
```
{"name":"Bob","addr":{"city":"NYC","zip":10001}}
Bob
NYC
10001
```

**File 3: `tests/e2e/deriving_json_option.snow`** (covers JSON-05)
```snow
-- Tests Option<T> field handling: Some -> value, None -> null.
struct Profile do
  name :: String
  bio :: Option<String>
end deriving(Json)

fn main() do
  let with_bio = Profile { name: "Alice", bio: Some("Hello!") }
  let without_bio = Profile { name: "Bob", bio: None }

  let json1 = Json.encode(with_bio)
  let json2 = Json.encode(without_bio)
  println(json1)
  println(json2)

  let r1 = Profile.from_json(json1)
  case r1 do
    Ok(p) ->
      case p.bio do
        Some(b) -> println(b)
        None -> println("no bio")
      end
    Err(e) -> println("Error: ${e}")
  end

  let r2 = Profile.from_json(json2)
  case r2 do
    Ok(p) ->
      case p.bio do
        Some(b) -> println(b)
        None -> println("no bio")
      end
    Err(e) -> println("Error: ${e}")
  end
end
```
Expected output:
```
{"name":"Alice","bio":"Hello!"}
{"name":"Bob","bio":null}
Hello!
no bio
```

**File 4: `tests/e2e/deriving_json_number_types.snow`** (covers JSON-11)
```snow
-- Tests that Int and Float survive JSON round-trip without type confusion.
struct Numbers do
  i :: Int
  f :: Float
end deriving(Json)

fn main() do
  let n = Numbers { i: 42, f: 3.14 }
  let json = Json.encode(n)
  println(json)

  let result = Numbers.from_json(json)
  case result do
    Ok(n2) ->
      println(n2.i)
      println(n2.f)
      -- Verify types: Int arithmetic should work on i, Float on f
      println(n2.i + 1)
      println(n2.f + 0.01)
    Err(e) -> println("Error: ${e}")
  end
end
```
Expected output:
```
{"i":42,"f":3.14}
42
3.14
43
3.15
```

Run all 4 tests with `cargo test` and verify output matches expectations. Fix any issues in the compiler/runtime code (plan 02 artifacts) before proceeding.
  </action>
  <verify>
`cargo test deriving_json_basic` -- passes with correct output
`cargo test deriving_json_nested` -- passes with correct output
`cargo test deriving_json_option` -- passes with correct output
`cargo test deriving_json_number_types` -- passes with correct output
  </verify>
  <done>4 E2E tests pass covering JSON-01, JSON-02, JSON-03, JSON-04, JSON-05, JSON-11. Basic encode/decode, nested structs, Option fields, and Int/Float round-trip fidelity all verified.</done>
</task>

<task type="auto">
  <name>Task 2: E2E tests for collections, round-trip verification, error handling, and compile-fail</name>
  <files>tests/e2e/deriving_json_collections.snow, tests/e2e/deriving_json_roundtrip.snow, tests/e2e/deriving_json_error.snow, tests/compile_fail/deriving_json_non_serializable.snow</files>
  <action>
Create 4 more test files covering the remaining requirements.

**File 5: `tests/e2e/deriving_json_collections.snow`** (covers JSON-06, JSON-07)
```snow
-- Tests List<T> and Map<String, V> field handling.
struct Config do
  tags :: List<String>
  settings :: Map<String, Int>
end deriving(Json)

fn main() do
  let c = Config {
    tags: ["web", "api", "prod"],
    settings: %{ "port" => 8080, "workers" => 4 }
  }
  let json = Json.encode(c)
  println(json)

  let result = Config.from_json(json)
  case result do
    Ok(c2) ->
      println(List.length(c2.tags))
      println(Map.size(c2.settings))
    Err(e) -> println("Error: ${e}")
  end
end
```
Expected output (field order may vary in JSON string):
```
{"tags":["web","api","prod"],"settings":{"port":8080,"workers":4}}
3
2
```

**File 6: `tests/e2e/deriving_json_roundtrip.snow`** (covers JSON-01 through JSON-07 integration)
```snow
-- Full round-trip test: encode a complex struct, decode it, verify equality.
struct Inner do
  value :: Int
end deriving(Eq, Json)

struct Complex do
  name :: String
  count :: Int
  inner :: Inner
  maybe :: Option<Int>
end deriving(Eq, Json)

fn main() do
  let orig = Complex {
    name: "test",
    count: 42,
    inner: Inner { value: 99 },
    maybe: Some(7)
  }
  let json = Json.encode(orig)
  let result = Complex.from_json(json)
  case result do
    Ok(decoded) ->
      if decoded == orig do
        println("round-trip OK")
      else
        println("round-trip MISMATCH")
      end
    Err(e) -> println("Error: ${e}")
  end

  -- Also test None round-trip
  let orig2 = Complex {
    name: "empty",
    count: 0,
    inner: Inner { value: 0 },
    maybe: None
  }
  let json2 = Json.encode(orig2)
  let result2 = Complex.from_json(json2)
  case result2 do
    Ok(decoded2) ->
      if decoded2 == orig2 do
        println("none round-trip OK")
      else
        println("none round-trip MISMATCH")
      end
    Err(e) -> println("Error: ${e}")
  end
end
```
Expected output:
```
round-trip OK
none round-trip OK
```

**File 7: `tests/e2e/deriving_json_error.snow`** (covers JSON-03 error path)
```snow
-- Tests error handling for invalid JSON and missing/wrong-type fields.
struct Point do
  x :: Int
  y :: Int
end deriving(Json)

fn main() do
  -- Invalid JSON string
  let r1 = Point.from_json("not json")
  case r1 do
    Ok(_) -> println("unexpected success")
    Err(e) -> println("parse error: ok")
  end

  -- Missing field
  let r2 = Point.from_json("{\"x\":1}")
  case r2 do
    Ok(_) -> println("unexpected success")
    Err(e) -> println("missing field: ok")
  end

  -- Wrong type
  let r3 = Point.from_json("{\"x\":\"hello\",\"y\":2}")
  case r3 do
    Ok(_) -> println("unexpected success")
    Err(e) -> println("wrong type: ok")
  end
end
```
Expected output:
```
parse error: ok
missing field: ok
wrong type: ok
```

**File 8: `tests/compile_fail/deriving_json_non_serializable.snow`** (covers JSON-10)

Check if a `tests/compile_fail/` directory exists. If not, create it. Check how compile-fail tests work in this project -- look at existing error test patterns. If there's a compile_fail test runner, follow its convention. Otherwise, create the test file and verify manually that `snowc` produces error E0038.

```snow
-- Should produce compile error E0038: Pid is not JSON-serializable
struct BadStruct do
  name :: String
  worker :: Pid
end deriving(Json)

fn main() do
  println("should not compile")
end
```

Verify: `snowc compile tests/compile_fail/deriving_json_non_serializable.snow` should exit non-zero with error containing "E0038" or "not JSON-serializable".

If the compile_fail test directory/runner doesn't exist, instead add this as a unit test in the typeck test suite or verify manually and document the expected behavior.

Run the full test suite: `cargo test` to confirm all new tests pass and no regressions.
  </action>
  <verify>
`cargo test deriving_json_collections` -- passes with correct output
`cargo test deriving_json_roundtrip` -- passes with correct output
`cargo test deriving_json_error` -- passes with correct output
`cargo test` -- full suite passes, including all new E2E tests
Compile-fail test: `snowc` rejects the non-serializable struct with error E0038
  </verify>
  <done>All 7 E2E tests + 1 compile-fail test pass. All 9 requirements (JSON-01 through JSON-07, JSON-10, JSON-11) verified through end-to-end tests. Full test suite passes with zero regressions. Phase 49 success criteria met.</done>
</task>

</tasks>

<verification>
- `cargo test` -- full suite passes including all 7+ new E2E tests
- Each requirement has at least one test:
  - JSON-01: deriving_json_basic (deriving(Json) on struct)
  - JSON-02: deriving_json_basic (Json.encode produces JSON string)
  - JSON-03: deriving_json_basic + deriving_json_error (Type.from_json returns Result)
  - JSON-04: deriving_json_nested (nested struct round-trip)
  - JSON-05: deriving_json_option (Option Some/None handling)
  - JSON-06: deriving_json_collections (List field)
  - JSON-07: deriving_json_collections (Map field)
  - JSON-10: compile_fail/deriving_json_non_serializable (E0038 error)
  - JSON-11: deriving_json_number_types (Int/Float fidelity)
- The round-trip test (deriving_json_roundtrip) exercises the full pipeline integration
</verification>

<success_criteria>
- 7 E2E tests pass covering basic, nested, option, collections, roundtrip, number types, and error handling
- 1 compile-fail test verifies E0038 error for non-serializable fields
- All 9 phase requirements (JSON-01 through JSON-07, JSON-10, JSON-11) have test coverage
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/49-json-serde-structs/49-03-SUMMARY.md`
</output>
