---
phase: 49-json-serde-structs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/json.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "JSON_INT and JSON_FLOAT are separate tags -- Int values survive round-trip as Int, Float values survive round-trip as Float"
    - "Runtime provides structured JSON object construction (new/put/get) and typed value extraction (as_int/as_float/as_string/as_bool)"
    - "Generated MIR can call structured JSON object/array functions and collection encode/decode helpers for field-by-field encode/decode"
  artifacts:
    - path: "crates/snow-rt/src/json.rs"
      provides: "14 new runtime functions (9 structured + snow_json_null + 4 collection helpers) + INT/FLOAT tag split"
      contains: "JSON_INT"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for all 14 new functions"
      contains: "snow_json_object_new"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "known_functions entries for all 14 new functions"
      contains: "snow_json_object_new"
  key_links:
    - from: "crates/snow-rt/src/json.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "Matching extern C function names and signatures"
      pattern: "snow_json_object_new|snow_json_object_put|snow_json_object_get|snow_json_array_new|snow_json_array_push|snow_json_as_int|snow_json_as_float|snow_json_as_string|snow_json_as_bool|snow_json_from_list|snow_json_from_map|snow_json_to_list|snow_json_to_map"
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "known_functions entries matching intrinsics declarations"
      pattern: "snow_json_object_new|snow_json_as_int|snow_json_from_list|snow_json_to_list"
---

<objective>
Add JSON Int/Float tag split and 14 new structured JSON runtime functions with full three-point registration.

Purpose: Establish the complete runtime foundation needed for struct-aware JSON encode/decode. Without separate INT/FLOAT tags, Float values produce garbage when round-tripped. Without the structured JSON object/array construction, typed extraction, and collection helper functions, the compiler-generated to_json/from_json MIR cannot build or parse JSON objects field-by-field.

Output: Updated json.rs with 14 new runtime functions (9 structured + snow_json_null + 4 collection helpers), updated intrinsics.rs with LLVM declarations, updated lower.rs with known_functions entries. All existing JSON tests continue to pass.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-json-serde-structs/49-RESEARCH.md
@crates/snow-rt/src/json.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Split JSON_NUMBER into JSON_INT and JSON_FLOAT tags + update converters</name>
  <files>crates/snow-rt/src/json.rs</files>
  <action>
Split the single JSON_NUMBER tag into two:
- `JSON_INT: u8 = 2` (stores i64 value directly in the u64 value field)
- `JSON_FLOAT: u8 = 6` (stores f64::to_bits() in the u64 value field)

Remove the `JSON_NUMBER` constant entirely.

Update `serde_value_to_snow_json` (line 77-118):
- In the `Number` arm: use `n.as_i64()` -> `alloc_json(JSON_INT, i as u64)`, else `n.as_f64()` -> `alloc_json(JSON_FLOAT, f.to_bits())`. The fallback should use `JSON_INT` with value 0.

Update `snow_json_to_serde_value` (line 123-170):
- Replace the single `JSON_NUMBER` match arm with two:
  - `JSON_INT => { let ival = (*json).value as i64; serde_json::Value::Number(serde_json::Number::from(ival)) }`
  - `JSON_FLOAT => { let bits = (*json).value; let f = f64::from_bits(bits); serde_json::Number::from_f64(f).map(serde_json::Value::Number).unwrap_or(serde_json::Value::Null) }`

Update `snow_json_from_int` (line 281-283):
- Change `alloc_json(JSON_NUMBER, val as u64)` to `alloc_json(JSON_INT, val as u64)`

Update `snow_json_from_float` (line 287-289):
- Change `alloc_json(JSON_NUMBER, val.to_bits())` to `alloc_json(JSON_FLOAT, val.to_bits())`

Update module doc comment (line 15) to reflect new tags:
- "Tags: 0=Null, 1=Bool, 2=Int(i64), 3=Str(*SnowString), 4=Array(*SnowList), 5=Object(*SnowMap), 6=Float(f64)"

Update test `test_json_parse_primitives`: change `JSON_NUMBER` to `JSON_INT` for the integer parse test.

Run `cargo test -p snow-rt` to confirm all existing json tests pass with new tags.
  </action>
  <verify>
`cargo test -p snow-rt -- json` -- all JSON tests pass, including the roundtrip test.
Confirm test_json_parse_primitives checks for `JSON_INT` tag.
  </verify>
  <done>JSON_NUMBER is fully replaced by JSON_INT (tag 2) and JSON_FLOAT (tag 6). All converters handle both tags. All existing runtime tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add 14 new runtime functions with three-point registration</name>
  <files>crates/snow-rt/src/json.rs, crates/snow-codegen/src/codegen/intrinsics.rs, crates/snow-codegen/src/mir/lower.rs</files>
  <action>
**A. Add 10 new structured runtime functions to `crates/snow-rt/src/json.rs`** (after the existing `snow_json_from_string` function, around line 301):

1. `snow_json_object_new() -> *mut u8` -- Creates empty JSON object. Calls `map::snow_map_new()`, wraps in `alloc_json(JSON_OBJECT, map as u64)`.

2. `snow_json_object_put(obj: *mut u8, key: *mut u8, val: *mut u8) -> *mut u8` -- Adds key-value to JSON object. Cast obj to `*mut SnowJson`, extract map from value field, call `map::snow_map_put(map, key as u64, val as u64)`, return `alloc_json(JSON_OBJECT, new_map as u64)`.

3. `snow_json_object_get(obj: *mut u8, key: *mut u8) -> *mut u8` -- Gets value from JSON object by key. Returns `*mut SnowResult` (cast to `*mut u8` for uniform ABI). Check tag is JSON_OBJECT, extract map, check `map::snow_map_has_key(map, key as u64)`. If found: `alloc_result(0, val as *mut u8)`. If missing: `err_result(&format!("missing field: {}", key_str.as_str()))`. Key is a `*const SnowString`.

4. `snow_json_array_new() -> *mut u8` -- Creates empty JSON array. Calls `list::snow_list_new()`, wraps in `alloc_json(JSON_ARRAY, list as u64)`.

5. `snow_json_array_push(arr: *mut u8, val: *mut u8) -> *mut u8` -- Appends to JSON array. Cast arr to `*mut SnowJson`, extract list, call `list::snow_list_append(list, val as u64)`, return `alloc_json(JSON_ARRAY, new_list as u64)`.

6. `snow_json_as_int(json: *mut u8) -> *mut u8` -- Extract Int from SnowJson. Returns `*mut SnowResult` cast to `*mut u8`. Match on tag: `JSON_INT` -> `alloc_result(0, (*j).value as i64 as *mut u8)`. `JSON_FLOAT` -> coerce: `let f = f64::from_bits((*j).value); alloc_result(0, f as i64 as *mut u8)`. Otherwise `err_result("expected Int")`.

7. `snow_json_as_float(json: *mut u8) -> *mut u8` -- Extract Float from SnowJson. Returns `*mut SnowResult`. `JSON_FLOAT` -> `alloc_result(0, (*j).value as *mut u8)` (bits preserved). `JSON_INT` -> promote: `let i = (*j).value as i64; let f = (i as f64).to_bits(); alloc_result(0, f as *mut u8)`. Otherwise `err_result("expected Float")`.

8. `snow_json_as_string(json: *mut u8) -> *mut u8` -- Extract String from SnowJson. Returns `*mut SnowResult`. `JSON_STR` -> `alloc_result(0, (*j).value as *mut u8)`. Otherwise `err_result("expected String")`.

9. `snow_json_as_bool(json: *mut u8) -> *mut u8` -- Extract Bool from SnowJson. Returns `*mut SnowResult`. `JSON_BOOL` -> `alloc_result(0, (*j).value as *mut u8)`. Otherwise `err_result("expected Bool")`.

10. `snow_json_null() -> *mut u8` -- Returns a SnowJson null value. `alloc_json(JSON_NULL, 0) as *mut u8`. (Needed for Option::None encoding.)

**B. Add 4 collection helper runtime functions to `crates/snow-rt/src/json.rs`** (after the 10 structured functions above):

These use the callback-based pattern matching `snow_list_to_string`:

11. `snow_json_from_list(list_ptr: *mut u8, elem_fn: extern "C" fn(u64) -> *mut u8) -> *mut u8` -- Iterates list using `snow_list_length` + `snow_list_get`, calls `elem_fn` for each element to get a `*mut SnowJson`, builds a JSON array via `snow_json_array_new` + `snow_json_array_push`. Returns the final JSON array pointer.

12. `snow_json_from_map(map_ptr: *mut u8, val_fn: extern "C" fn(u64) -> *mut u8) -> *mut u8` -- Iterates map entries. Keys are `*const SnowString` (become JSON string keys via `snow_json_from_string`), calls `val_fn` for each value to get SnowJson*. Builds a JSON object via `snow_json_object_new` + `snow_json_object_put`. Returns the final JSON object pointer.

13. `snow_json_to_list(json_arr: *mut u8, elem_fn: extern "C" fn(*mut u8) -> *mut u8) -> *mut u8` -- For from_json decoding: checks tag is JSON_ARRAY, extracts the SnowList, iterates elements calling `elem_fn` for each (which returns a `*mut SnowResult`). If any element decode fails, propagates the Err. On success, builds a new SnowList of decoded values and returns `alloc_result(0, list as *mut u8)`.

14. `snow_json_to_map(json_obj: *mut u8, val_fn: extern "C" fn(*mut u8) -> *mut u8) -> *mut u8` -- For from_json decoding: checks tag is JSON_OBJECT, extracts the SnowMap, iterates entries. Keys remain as SnowStrings. Calls `val_fn` for each JSON value (returns `*mut SnowResult`). If any fails, propagates Err. Returns `alloc_result(0, map as *mut u8)`.

All 14 functions are `#[no_mangle] pub extern "C"`.

Add unit tests for at minimum: `snow_json_object_new` + `snow_json_object_put` + `snow_json_object_get` roundtrip, `snow_json_as_int` with both INT and FLOAT inputs, `snow_json_as_float` with both INT and FLOAT inputs, `snow_json_as_string` happy path + error, `snow_json_null` returns NULL tag, `snow_json_from_list` with a simple int list, `snow_json_to_list` roundtrip.

**C. Register LLVM declarations in `crates/snow-codegen/src/codegen/intrinsics.rs`** (after the existing `snow_json_from_string` declaration, around line 373):

All 14 functions take and return ptr types. The collection helpers take a function pointer as their second argument, which in LLVM is also a ptr:
```
// snow_json_object_new() -> ptr
module.add_function("snow_json_object_new", ptr_type.fn_type(&[], false), Some(inkwell::module::Linkage::External));
// snow_json_object_put(obj: ptr, key: ptr, val: ptr) -> ptr
module.add_function("snow_json_object_put", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_object_get(obj: ptr, key: ptr) -> ptr (SnowResult)
module.add_function("snow_json_object_get", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_array_new() -> ptr
module.add_function("snow_json_array_new", ptr_type.fn_type(&[], false), Some(inkwell::module::Linkage::External));
// snow_json_array_push(arr: ptr, val: ptr) -> ptr
module.add_function("snow_json_array_push", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_as_int(json: ptr) -> ptr (SnowResult)
module.add_function("snow_json_as_int", ptr_type.fn_type(&[ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_as_float(json: ptr) -> ptr (SnowResult)
module.add_function("snow_json_as_float", ptr_type.fn_type(&[ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_as_string(json: ptr) -> ptr (SnowResult)
module.add_function("snow_json_as_string", ptr_type.fn_type(&[ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_as_bool(json: ptr) -> ptr (SnowResult)
module.add_function("snow_json_as_bool", ptr_type.fn_type(&[ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_null() -> ptr
module.add_function("snow_json_null", ptr_type.fn_type(&[], false), Some(inkwell::module::Linkage::External));
// snow_json_from_list(list: ptr, elem_fn: ptr) -> ptr
module.add_function("snow_json_from_list", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_from_map(map: ptr, val_fn: ptr) -> ptr
module.add_function("snow_json_from_map", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_to_list(json_arr: ptr, elem_fn: ptr) -> ptr (SnowResult)
module.add_function("snow_json_to_list", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
// snow_json_to_map(json_obj: ptr, val_fn: ptr) -> ptr (SnowResult)
module.add_function("snow_json_to_map", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
```

**D. Register in known_functions in `crates/snow-codegen/src/mir/lower.rs`** (after line 633, after existing JSON known_functions):

```rust
// JSON structured object/array functions (Phase 49)
self.known_functions.insert("snow_json_object_new".to_string(), MirType::FnPtr(vec![], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_object_put".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_object_get".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_array_new".to_string(), MirType::FnPtr(vec![], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_array_push".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_as_int".to_string(), MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_as_float".to_string(), MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_as_string".to_string(), MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_as_bool".to_string(), MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_null".to_string(), MirType::FnPtr(vec![], Box::new(MirType::Ptr)));
// JSON collection helpers (callback-based, for List<T> and Map<String, V> fields)
self.known_functions.insert("snow_json_from_list".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_from_map".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_to_list".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_json_to_map".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
```

No map_builtin_name entries needed for these functions -- they are called directly from generated MIR code, not from user-written Snow source via module-qualified access.
  </action>
  <verify>
`cargo test -p snow-rt -- json` -- all JSON tests pass including new unit tests.
`cargo build -p snow-codegen` -- compiles without errors (intrinsics + known_functions type-check).
`cargo test` -- full test suite passes (no regressions).
  </verify>
  <done>14 new runtime functions exist in json.rs with unit tests (10 structured + 4 collection helpers), LLVM declarations in intrinsics.rs, and known_functions entries in lower.rs. The three-point registration is complete for all functions. All existing tests continue to pass.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-rt -- json` passes with all new and existing JSON tests
- `cargo build -p snow-codegen` compiles cleanly
- `cargo test` full suite passes with zero regressions
- JSON_NUMBER constant no longer exists anywhere in the codebase
- JSON_INT (tag 2) and JSON_FLOAT (tag 6) are used in all conversion paths
</verification>

<success_criteria>
- JSON Int/Float tag split is complete and all converters handle both tags
- All 14 new runtime functions (10 structured + 4 collection helpers) exist with unit tests
- Three-point registration (runtime, intrinsics, known_functions) is complete for all new functions
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/49-json-serde-structs/49-01-SUMMARY.md`
</output>
