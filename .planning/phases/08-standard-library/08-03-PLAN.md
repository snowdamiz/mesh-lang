---
phase: 08-standard-library
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - crates/snow-rt/src/file.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "File.read(path) reads an entire file and returns Result<String, String>"
    - "File.write(path, content) writes content to a file and returns Result<(), String>"
    - "File.append(path, content) appends content to a file and returns Result<(), String>"
    - "File.exists(path) returns Bool"
    - "File.delete(path) returns Result<(), String>"
    - "A Snow program can read a file, process its contents, and write output to another file"
  artifacts:
    - path: "crates/snow-rt/src/file.rs"
      provides: "File I/O runtime functions"
      contains: "snow_file_read"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "File function type registrations"
      contains: "file_read"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for file functions"
      contains: "snow_file_read"
  key_links:
    - from: "crates/snow-rt/src/file.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "Runtime function signatures match LLVM declarations"
      pattern: "snow_file_read"
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Snow names map to runtime names for file functions"
      pattern: "file_read.*snow_file_read"
---

<objective>
Implement file I/O operations returning Result types, enabling Snow programs to read, write, and manage files on the filesystem.

Purpose: File I/O is essential for CLI tools and data processing. Combined with string operations from Plan 01, this enables the first success criterion: "A Snow program can read a file, process its contents with string and list operations, and write output to another file."

Output: Complete File module with read, write, append, exists, delete, and read_lines operations.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-RESEARCH.md
@.planning/phases/08-standard-library/08-01-SUMMARY.md

Key files:
@crates/snow-rt/src/string.rs -- SnowString pattern
@crates/snow-rt/src/io.rs -- SnowResult struct from Plan 01
@crates/snow-codegen/src/codegen/expr.rs -- how Result/Option variants are constructed in codegen
</context>

<tasks>

<task type="auto">
  <name>Task 1: File I/O runtime functions</name>
  <files>
    crates/snow-rt/src/file.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
Create `crates/snow-rt/src/file.rs`. Add `pub mod file;` to `lib.rs`.

All functions return SnowResult (the `#[repr(C)]` struct from `io.rs` in Plan 01 -- use it directly or import it). The return value encoding must match how Snow's Result sum type is laid out in codegen:
- Tag 0 = Ok variant, value = pointer to payload
- Tag 1 = Err variant, value = pointer to SnowString error message

Implement these `extern "C"` functions:

**`snow_file_read(path: *const SnowString) -> *mut u8`**
- Read the file at `path` as a UTF-8 string
- On success: return SnowResult { tag: 0, value: ptr to SnowString containing file contents }
- On failure: return SnowResult { tag: 1, value: ptr to SnowString containing error message (e.g., "File not found: /path") }
- Use `std::fs::read_to_string()` internally
- Allocate the result struct and payload via `snow_gc_alloc`

**`snow_file_write(path: *const SnowString, content: *const SnowString) -> *mut u8`**
- Write content to file (creates or overwrites)
- On success: return SnowResult { tag: 0, value: null (Unit payload) }
- On failure: return SnowResult { tag: 1, value: ptr to SnowString error }
- Use `std::fs::write()` internally

**`snow_file_append(path: *const SnowString, content: *const SnowString) -> *mut u8`**
- Append content to file (creates if doesn't exist)
- Use `OpenOptions::new().append(true).create(true).open(path)` then write

**`snow_file_exists(path: *const SnowString) -> i8`**
- Returns 1 if file exists, 0 otherwise
- Use `std::path::Path::new(path).exists()`

**`snow_file_delete(path: *const SnowString) -> *mut u8`**
- Delete file at path
- Returns SnowResult (Ok on success, Err with message on failure)
- Use `std::fs::remove_file()`

**`snow_file_read_lines(path: *const SnowString) -> *mut u8`**
- Read file and split into lines
- Returns SnowResult where Ok payload is a List<String> (opaque pointer from Plan 02's SnowList)
- If Plan 02 is not yet complete when this executes, return the lines as a packed array format (same temporary format used in Plan 01's string_split) and note that proper List integration will come when Plan 02 lands
- Use `std::fs::read_to_string()` then `.lines()` to split

CRITICAL: The SnowResult memory layout must match what the codegen expects for Result variants. Check how the codegen constructs Result values in `expr.rs`. The typical pattern is:
1. Allocate struct: { u8 tag, [padding], ptr payload }
2. Store tag at offset 0
3. Store payload pointer at offset 8 (after alignment)

Make sure the GC-allocated SnowResult follows this exact layout. Use `snow_gc_alloc` for all allocations.

Add unit tests: create temp files, test read/write/append/exists/delete cycle. Use `tempfile` or just create files in /tmp with unique names.
  </action>
  <verify>
`cargo test -p snow-rt` -- all file I/O unit tests pass. Tests verify: write then read returns same content, append adds content, exists returns correct bool, delete removes file.
  </verify>
  <done>
All file I/O runtime functions implemented and unit tested. SnowResult return values correctly encode Ok/Err variants matching the codegen layout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline integration and E2E tests for File I/O</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
**Type checker -- builtins.rs**: Register file functions (extend stdlib_modules "File" entry from Plan 01):
- `file_read` : `(String) -> Result<String, String>`
- `file_write` : `(String, String) -> Result<(), String>` -- for Result<(), String>, use `Ty::result(Ty::Tuple(vec![]), Ty::string())`
- `file_append` : `(String, String) -> Result<(), String>`
- `file_exists` : `(String) -> Bool`
- `file_delete` : `(String) -> Result<(), String>`

Also update the "File" entry in `stdlib_modules` so `File.read`, `File.write`, etc. work via qualified access.

**Intrinsics -- intrinsics.rs**: Declare LLVM signatures:
- `snow_file_read(ptr) -> ptr`
- `snow_file_write(ptr, ptr) -> ptr`
- `snow_file_append(ptr, ptr) -> ptr`
- `snow_file_exists(ptr) -> i8`
- `snow_file_delete(ptr) -> ptr`

**MIR lowering -- lower.rs**: Extend map_builtin_name and known_functions:
- `"file_read" => "snow_file_read"`, etc.
- Register in known_functions with appropriate MirType signatures.

**E2E tests**: Add to `e2e_stdlib.rs`:

1. **File write and read** -- Snow program that writes "Hello, Snow!" to a temp file, then reads it back and prints the contents. Use pattern matching on the Result:
```snow
fn main() do
  let write_result = file_write("/tmp/snow_test_e2e.txt", "Hello, Snow!")
  case write_result do
    Ok(_) ->
      let read_result = file_read("/tmp/snow_test_e2e.txt")
      case read_result do
        Ok(contents) -> println(contents)
        Err(msg) -> println("Read error: ${msg}")
      end
    Err(msg) -> println("Write error: ${msg}")
  end
end
```
Expected output: "Hello, Snow!"

2. **File.exists** -- Check that a written file exists. Print "true" or "false".

3. **File write + process + write** -- Read a file, apply string operations (e.g., to_upper), write to another file, read back and verify. This tests the first success criterion end-to-end.

4. **Error handling** -- Try to read a non-existent file, match on Err variant, print error message. Verify the program doesn't crash and produces an error message.

IMPORTANT: E2E tests need to clean up temp files. Use unique file paths based on test name or PID.
  </action>
  <verify>
`cargo test --workspace` -- all tests pass including new E2E file I/O tests. The file write-read roundtrip produces correct output. Error handling (reading non-existent file) produces an Err result without crashing.
  </verify>
  <done>
File I/O fully integrated into compiler pipeline. E2E tests verify: file read/write roundtrip, file exists check, error handling for missing files. First success criterion achievable: "A Snow program can read a file, process its contents with string and list operations, and write output to another file."
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. Snow program writes "Hello" to /tmp/test.txt, reads it back, prints "Hello" -- correct output
3. Snow program reads non-existent file, matches Err variant, prints error -- no crash
4. File.exists returns correct boolean for existing and non-existing files
5. File.append adds to file without overwriting
</verification>

<success_criteria>
- File.read returns Result<String, String> with file contents or error message
- File.write creates/overwrites a file, returns Result<(), String>
- File.append adds to a file, returns Result<(), String>
- File.exists returns Bool
- File.delete removes a file, returns Result<(), String>
- Result pattern matching works naturally with file operations
- E2E test: write file -> read file -> process -> write result (success criterion 1)
- Full workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-03-SUMMARY.md`
</output>
