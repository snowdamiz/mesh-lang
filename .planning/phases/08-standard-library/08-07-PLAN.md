---
phase: 08-standard-library
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snowc/tests/e2e_stdlib.rs
  - tests/e2e/stdlib_http_server_runtime.snow
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "A Snow HTTP server compiles, starts, accepts a request, and returns a JSON response body"
    - "The HTTP server handler receives a request and returns a response with correct status and body"
  artifacts:
    - path: "tests/e2e/stdlib_http_server_runtime.snow"
      provides: "HTTP server fixture with handler that returns JSON body"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "E2E test that starts server, makes HTTP request, verifies response"
  key_links:
    - from: "tests/e2e/stdlib_http_server_runtime.snow"
      to: "crates/snow-rt/src/http/server.rs"
      via: "HTTP.serve blocks listening, handler called via fn pointer, response returned"
      pattern: "snow_http_serve|snow_http_response_new|snow_http_route"
    - from: "crates/snowc/tests/e2e_stdlib.rs"
      to: "tests/e2e/stdlib_http_server_runtime.snow"
      via: "compile_and_start_server helper compiles fixture, spawns binary, makes HTTP request"
      pattern: "e2e_http_server_runtime"
---

<objective>
Close the critical HTTP server verification gap: prove that a Snow HTTP server actually starts, accepts requests, and returns correct responses at runtime. Currently all HTTP tests only verify compilation (compile_only), but none verify the server actually works.

Purpose: Phase 8 Success Criterion 2 states "A Snow program can start an HTTP server that accepts requests and returns JSON responses." The verification report found this FAILED because no test starts the server and makes a request.

Output: One new Snow HTTP server fixture and one new Rust E2E test that performs a real HTTP request against a running Snow server.

**NOTE on thread-per-connection:** STATE.md decision [08-05] explicitly records "Thread-per-connection instead of actor-per-connection for HTTP server (tiny_http + std::thread::spawn)" as a deliberate implementation choice. This plan does NOT attempt to change the concurrency model. The gap is verification, not architecture.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-05-SUMMARY.md
@crates/snowc/tests/e2e_stdlib.rs
@crates/snow-rt/src/http/server.rs
@tests/e2e/stdlib_http_response.snow
</context>

<tasks>

<task type="auto">
  <name>Task 1: HTTP server runtime E2E test</name>
  <files>
    tests/e2e/stdlib_http_server_runtime.snow
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Create a Snow fixture and Rust E2E test that proves the HTTP server actually works at runtime.

**Step 1: Snow fixture** (`tests/e2e/stdlib_http_server_runtime.snow`)

Write a Snow program that:
1. Defines a handler function that returns a JSON-style response body
2. Creates a router, adds a route, and serves on port 0 (let OS assign port)

**IMPORTANT on port 0:** The `snow_http_serve` function calls `tiny_http::Server::http("0.0.0.0:{port}")`. When port is 0, the OS assigns a random available port. However, the Snow program has no way to communicate the actual port back. Two solutions:

**Option A (preferred):** Use a fixed high port (e.g., 18080) in the test. Since tests run sequentially in the same test binary, port conflicts are unlikely. The fixture uses a specific port:
```snow
fn handler(request) do
  HTTP.response(200, "{\"status\":\"ok\"}")
end

fn main() do
  let r = HTTP.router()
  let r = HTTP.route(r, "/health", handler)
  HTTP.serve(r, 18080)
end
```

**Option B (alternative):** Use a port passed via environment variable. The Snow program reads `Env.get("TEST_PORT")` and serves on that port. The Rust test sets the env var before starting the binary.

Choose Option A for simplicity unless port conflicts are observed.

**Step 2: Rust E2E test helper** (add to `crates/snowc/tests/e2e_stdlib.rs`)

Create a helper function `compile_and_start_server`:
```rust
fn compile_and_start_server(source: &str) -> (std::process::Child, PathBuf) {
    // 1. Create temp dir, write source as main.snow
    // 2. Compile with snowc build (assert success)
    // 3. Spawn the binary as a background process (Child)
    // 4. Return (child, binary_path) so caller can kill it
}
```

**Step 3: Rust E2E test** `e2e_http_server_runtime`

The test should:
1. Read the fixture with `read_fixture("stdlib_http_server_runtime.snow")`
2. Compile the Snow source using the `compile_only` path to get the binary, then spawn it
3. Wait a short time (500ms-1s) for the server to start using `std::thread::sleep`
4. Make an HTTP GET request to `http://127.0.0.1:18080/health` using `ureq` (already a dependency of snow-rt) or a simple TCP connection
5. Assert the response body contains `{"status":"ok"}`
6. Kill the server child process
7. Clean up

**IMPORTANT on ureq availability:** The test binary (snowc tests) may not have ureq as a dependency. Options:
- Add ureq as a dev-dependency of snowc (in crates/snowc/Cargo.toml)
- Use `std::net::TcpStream` to make a raw HTTP request (no external dependency needed):
  ```rust
  use std::io::{Read, Write};
  use std::net::TcpStream;

  let mut stream = TcpStream::connect("127.0.0.1:18080").expect("connect failed");
  stream.write_all(b"GET /health HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n").unwrap();
  let mut response = String::new();
  stream.read_to_string(&mut response).unwrap();
  assert!(response.contains("{\"status\":\"ok\"}"));
  ```

**Prefer TcpStream** to avoid adding dependencies. Use a retry loop (up to 5 attempts with 200ms sleep between) for robustness -- the server may need time to start.

**Step 4: Cleanup**

The test MUST kill the child process in all paths (success and failure). Use a Drop guard or ensure child.kill() is called before test returns. Consider wrapping in a struct with Drop impl:
```rust
struct ServerGuard(std::process::Child);
impl Drop for ServerGuard {
    fn drop(&mut self) {
        let _ = self.0.kill();
        let _ = self.0.wait();
    }
}
```

**Step 5: Test isolation**

Mark the test with `#[ignore]` if it proves flaky in CI, but try without first. Add a comment explaining the test starts a real HTTP server.
  </action>
  <verify>
Run `cargo test -p snowc --test e2e_stdlib e2e_http_server_runtime` — test passes, confirming the Snow HTTP server starts and responds to requests.
  </verify>
  <done>
A Snow HTTP server compiles to a native binary, starts and listens on a port, accepts an HTTP request, dispatches to the handler function, and returns the correct response body. This closes the "HTTP server runtime behavior unverified" gap.
  </done>
</task>

<task type="auto">
  <name>Task 2: Document thread-per-connection deviation acceptance</name>
  <files>
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Add a comment block near the HTTP E2E tests section in `e2e_stdlib.rs` documenting the thread-per-connection decision:

```rust
// ── HTTP E2E Tests (Phase 8 Plan 05) ──────────────────────────────────
//
// Note: The HTTP server uses thread-per-connection (std::thread::spawn)
// rather than actor-per-connection (snow_actor_spawn). This was a deliberate
// implementation decision [STATE.md 08-05] because the actor runtime uses
// corosensei coroutines with cooperative scheduling, and integrating
// tiny-http's blocking I/O model with it introduces unnecessary complexity.
// Thread-per-connection is simple and correct for Phase 8.
```

This documents the deviation directly in the test file where future developers will see it.
  </action>
  <verify>
The comment exists in e2e_stdlib.rs near the HTTP test section.
  </verify>
  <done>
Thread-per-connection decision documented in test file for maintainability.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snowc --test e2e_stdlib e2e_http_server_runtime` passes
2. All existing 25+ E2E stdlib tests still pass: `cargo test -p snowc --test e2e_stdlib`
3. Full workspace builds: `cargo build --workspace`
4. No port conflicts or flaky behavior observed (server starts and stops cleanly)
</verification>

<success_criteria>
- HTTP server E2E test makes a real HTTP request to a running Snow server and gets correct response
- Server process is properly cleaned up after test
- Thread-per-connection deviation documented
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-07-SUMMARY.md`
</output>
