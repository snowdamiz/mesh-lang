---
phase: 08-standard-library
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - crates/snow-rt/src/collections/mod.rs
  - crates/snow-rt/src/collections/list.rs
  - crates/snow-rt/src/collections/map.rs
  - crates/snow-rt/src/collections/set.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/ty.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/types.rs
autonomous: true

must_haves:
  truths:
    - "List.new() creates an empty list, List operations (map, filter, reduce, head, tail, length, append, concat) work correctly"
    - "Map.new() creates an empty map, Map.put/get/delete/keys/values/has_key work correctly"
    - "Set.new() creates an empty set, Set operations (add, remove, contains, size, union, intersection) work correctly"
    - "Pipe operator chains with collection-first argument convention: list |> map(fn) |> filter(fn)"
    - "Higher-order functions (map, filter, reduce) accept Snow closures and invoke them correctly"
    - "Collection types use opaque pointer representation at LLVM level"
    - "Common collection functions (map, filter, reduce, head, tail) are in prelude (auto-imported)"
  artifacts:
    - path: "crates/snow-rt/src/collections/list.rs"
      provides: "SnowList implementation with all list operations"
      contains: "snow_list_map"
    - path: "crates/snow-rt/src/collections/map.rs"
      provides: "SnowMap implementation with hash map operations"
      contains: "snow_map_put"
    - path: "crates/snow-rt/src/collections/set.rs"
      provides: "SnowSet implementation with set operations"
      contains: "snow_set_add"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Polymorphic type registrations for collection functions"
      contains: "list_map"
    - path: "crates/snow-codegen/src/mir/types.rs"
      provides: "List/Map/Set type resolution to MirType::Ptr"
      contains: "List"
  key_links:
    - from: "crates/snow-rt/src/collections/list.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "Runtime function signatures match LLVM declarations"
      pattern: "snow_list_map"
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Snow names map to runtime names for collections"
      pattern: "list_map.*snow_list_map"
---

<objective>
Implement List, Map, and Set collection types with all operations, including higher-order functions (map, filter, reduce) that accept Snow closures.

Purpose: Collections are the backbone of data processing in any language. This plan delivers the full collection suite with pipe-friendly APIs, enabling `list |> map(fn) |> filter(fn) |> reduce(init, fn)` chains. Higher-order function support (passing Snow closures to runtime functions) is the key technical challenge.

Output: Working List, Map, and Set types with all operations, registered through the full compiler pipeline.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-RESEARCH.md
@.planning/phases/08-standard-library/08-01-SUMMARY.md

Key files:
@crates/snow-rt/src/string.rs -- SnowString pattern to follow
@crates/snow-rt/src/gc.rs -- snow_gc_alloc for allocating collection memory
@crates/snow-typeck/src/builtins.rs -- where to register collection types
@crates/snow-codegen/src/mir/lower.rs -- map_builtin_name and known_functions
@crates/snow-codegen/src/mir/types.rs -- resolve_type, needs List/Map/Set -> Ptr mapping
@crates/snow-codegen/src/codegen/expr.rs -- how closures are called (fn_ptr + env_ptr pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Collection runtime implementations -- List, Map, Set</name>
  <files>
    crates/snow-rt/src/collections/mod.rs
    crates/snow-rt/src/collections/list.rs
    crates/snow-rt/src/collections/map.rs
    crates/snow-rt/src/collections/set.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
Create `crates/snow-rt/src/collections/` directory with `mod.rs`, `list.rs`, `map.rs`, `set.rs`. Add `pub mod collections;` to `lib.rs`.

**List (list.rs):**

Define `SnowList` as an opaque struct wrapping a `Vec<u64>` (all elements stored as 8-byte values -- i64 for Int, f64 bits for Float, i8 widened to u64 for Bool, pointer as u64 for String/collections). Use `#[repr(C)]` for the struct that is allocated on the GC arena.

Design choice: Store list data as a GC-allocated block: `{ u64 len, u64 capacity, u64 element_size, [u8; capacity * 8] data }`. All elements are 8 bytes (uniform representation). The element_size is always 8.

Implement these `extern "C"` functions:

- `snow_list_new() -> *mut u8` -- create empty list
- `snow_list_length(list: *mut u8) -> i64` -- return element count
- `snow_list_append(list: *mut u8, element: u64) -> *mut u8` -- return NEW list with element appended (immutable)
- `snow_list_head(list: *mut u8) -> u64` -- return first element (panics if empty)
- `snow_list_tail(list: *mut u8) -> *mut u8` -- return NEW list without first element (panics if empty)
- `snow_list_get(list: *mut u8, index: i64) -> u64` -- get element at index
- `snow_list_concat(a: *mut u8, b: *mut u8) -> *mut u8` -- concatenate two lists
- `snow_list_reverse(list: *mut u8) -> *mut u8` -- return reversed list
- `snow_list_map(list: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> *mut u8` -- apply closure to each element, return new list. The closure calling convention: if env_ptr is null, call fn_ptr(element); if env_ptr is non-null, call fn_ptr(env_ptr, element). This matches Snow's lifted closure convention (05-02 decision: closures have __env as first param).
- `snow_list_filter(list: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> *mut u8` -- keep elements where closure returns non-zero (true)
- `snow_list_reduce(list: *mut u8, init: u64, fn_ptr: *mut u8, env_ptr: *mut u8) -> u64` -- fold left with accumulator. Closure signature: fn(env_ptr, acc, element) -> acc

CRITICAL: Higher-order functions (map, filter, reduce) must call the Snow closure correctly. The closure is a `{ fn_ptr, env_ptr }` pair. The codegen will pass these as two separate pointer arguments. The runtime must call `fn_ptr(env_ptr, element)` when env_ptr is non-null, or `fn_ptr(element)` when env_ptr is null (bare function, not a closure). Use transmute to cast fn_ptr to the appropriate function pointer type before calling.

For the closure call, use something like:
```rust
type ClosureFn = unsafe extern "C" fn(*mut u8, u64) -> u64;
type BareFn = unsafe extern "C" fn(u64) -> u64;
if env_ptr.is_null() {
    let f: BareFn = std::mem::transmute(fn_ptr);
    f(element)
} else {
    let f: ClosureFn = std::mem::transmute(fn_ptr);
    f(env_ptr, element)
}
```

Also implement `snow_list_from_elements(count: i64, ...) -> *mut u8` as a variadic-style constructor. Since C variadics are complex, instead use `snow_list_from_array(data: *const u64, count: i64) -> *mut u8` which takes a pointer to an array of u64 elements and the count.

**Map (map.rs):**

Define `SnowMap` backed by a Rust `HashMap<u64, u64>` (keys and values are both 8-byte uniform). Use FxHashMap for performance. The map is allocated on the GC arena as an opaque box.

IMPORTANT: For string keys (which are pointers), hashing must dereference and hash the string content, not the pointer value. Add a wrapper type or custom hash logic that detects string pointers. For Phase 8 simplicity, use a different approach: store keys as `(u64, u64)` pairs where the first u64 is a type tag and the second is the value. OR simpler: just use pointer identity for now and document the limitation. The cleanest approach: use a Vec<(u64, u64)> with linear scan for small maps, since Snow maps in Phase 8 won't be huge.

Actually, the simplest correct approach: wrap Rust's HashMap<String, u64> for string-keyed maps (the common case for JSON/HTTP), and HashMap<i64, u64> for integer-keyed maps. Since the type checker erases types at the LLVM level, we need a way to dispatch. Use two separate implementations:
- `snow_map_new() -> *mut u8` -- creates a map (internally uses a BTreeMap<Vec<u8>, u64> where keys are stored as raw bytes for uniformity)
- `snow_map_put(map: *mut u8, key: u64, value: u64) -> *mut u8` -- returns NEW map with key-value added
- `snow_map_get(map: *mut u8, key: u64) -> u64` -- get value for key (returns 0/null if not found)
- `snow_map_has_key(map: *mut u8, key: u64) -> i8` -- 1 if key exists, 0 otherwise
- `snow_map_delete(map: *mut u8, key: u64) -> *mut u8` -- returns NEW map without key
- `snow_map_size(map: *mut u8) -> i64` -- number of entries
- `snow_map_keys(map: *mut u8) -> *mut u8` -- returns List of keys
- `snow_map_values(map: *mut u8) -> *mut u8` -- returns List of values

For key hashing: Store keys as their raw u64 value. For string keys, the u64 IS the pointer to SnowString. Hash by dereferencing the pointer and hashing the string bytes. Use a custom hasher wrapper. For integer keys, hash the i64 value directly.

The map needs a "key type" tag so it knows how to hash/compare. Store this as a field: `key_type: u8` (0=Int, 1=String). Set it on first `put`.

**Set (set.rs):**

Similar to Map but values-only. Back with a HashSet equivalent using same key hashing strategy.

- `snow_set_new() -> *mut u8`
- `snow_set_add(set: *mut u8, element: u64) -> *mut u8` -- returns NEW set
- `snow_set_remove(set: *mut u8, element: u64) -> *mut u8` -- returns NEW set
- `snow_set_contains(set: *mut u8, element: u64) -> i8`
- `snow_set_size(set: *mut u8) -> i64`
- `snow_set_union(a: *mut u8, b: *mut u8) -> *mut u8`
- `snow_set_intersection(a: *mut u8, b: *mut u8) -> *mut u8`

Add comprehensive unit tests for all collection operations. Test List.map with a simple function pointer, test Map put/get cycles, test Set add/contains.
  </action>
  <verify>
`cargo test -p snow-rt` -- all collection unit tests pass. `cargo build -p snow-rt` -- staticlib builds.
  </verify>
  <done>
List, Map, and Set runtime implementations complete with all operations. Higher-order functions (map, filter, reduce) correctly invoke function pointers with the closure calling convention. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline -- collection types, type registrations, intrinsics, and E2E tests</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/ty.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/mir/types.rs
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
**Type system -- ty.rs**: Add a `Ty::list(inner: Ty) -> Ty` constructor following the Option/Result pattern:
```rust
pub fn list(inner: Ty) -> Ty {
    Ty::App(Box::new(Ty::Con(TyCon::new("List"))), vec![inner])
}
pub fn map(key: Ty, value: Ty) -> Ty {
    Ty::App(Box::new(Ty::Con(TyCon::new("Map"))), vec![key, value])
}
pub fn set(inner: Ty) -> Ty {
    Ty::App(Box::new(Ty::Con(TyCon::new("Set"))), vec![inner])
}
```

**Type checker -- builtins.rs**: Register all collection functions. The critical ones use polymorphic types:

For List operations, use `Scheme::poly` (generalized schemes) with fresh type variables. Check how the existing type system handles polymorphic builtins -- if Scheme::mono is all that's used, we may need to use Scheme with quantified variables. Look at how Option::Some is typed (it's a polymorphic constructor). Follow the same pattern.

Prelude functions (bare names, auto-imported):
- `map` : `forall A B. (List<A>, (A) -> B) -> List<B>`
- `filter` : `forall A. (List<A>, (A) -> Bool) -> List<A>`
- `reduce` : `forall A B. (List<A>, B, (B, A) -> B) -> B`
- `head` : `forall A. (List<A>) -> A`
- `tail` : `forall A. (List<A>) -> List<A>`

Module-qualified functions (registered in stdlib_modules from Plan 01):
- "List" -> { "new" -> () -> List<A>, "length" -> List<A> -> Int, "append" -> (List<A>, A) -> List<A>, "concat" -> (List<A>, List<A>) -> List<A>, "reverse" -> List<A> -> List<A>, "get" -> (List<A>, Int) -> A, "map" -> ..., "filter" -> ..., "reduce" -> ..., "head" -> ..., "tail" -> ... }
- "Map" -> { "new" -> () -> Map<K,V>, "put" -> (Map<K,V>, K, V) -> Map<K,V>, "get" -> (Map<K,V>, K) -> V, "has_key" -> (Map<K,V>, K) -> Bool, "delete" -> (Map<K,V>, K) -> Map<K,V>, "size" -> Map<K,V> -> Int, "keys" -> Map<K,V> -> List<K>, "values" -> Map<K,V> -> List<V> }
- "Set" -> { "new" -> () -> Set<A>, "add" -> (Set<A>, A) -> Set<A>, "remove" -> (Set<A>, A) -> Set<A>, "contains" -> (Set<A>, A) -> Bool, "size" -> Set<A> -> Int }

IMPORTANT: If the type system doesn't support registering polymorphic builtins easily, use a simpler approach: register collection functions as monomorphic for common types (Int, String) and handle the generics at the MIR level through type erasure. Since all collections are opaque pointers at LLVM level, the type parameter only matters for type checking, not codegen.

**MIR types -- types.rs**: In `resolve_con` and `resolve_app`, add cases for "List", "Map", "Set" -> all resolve to `MirType::Ptr` (opaque pointer). Collections are just pointers at the LLVM level.

```rust
// In resolve_con:
"List" | "Map" | "Set" => MirType::Ptr,

// In resolve_app: if base_name is "List", "Map", or "Set", return MirType::Ptr
```

**Intrinsics -- intrinsics.rs**: Declare all collection runtime functions. All take/return `ptr` (opaque pointers) and `i64` (for counts/indices/elements). For higher-order functions, closures are passed as `(ptr, ptr)` (fn_ptr, env_ptr).

**MIR lowering -- lower.rs**:
1. Extend `map_builtin_name` with all collection function name mappings.
2. Register all collection functions in `known_functions`.
3. Ensure the module-qualified access from Plan 01 works for List, Map, Set modules.

For higher-order functions (map, filter, reduce): When lowering a call like `map(list, closure)`, the closure argument is a `MirExpr::MakeClosure { fn_name, captures }`. The codegen needs to extract the fn_ptr and env_ptr from the closure and pass them as separate arguments to the runtime function. Check how the current codegen handles closure arguments passed to function calls. The lowerer may need to emit the closure as-is (a two-pointer struct) and let the codegen split it into fn_ptr + env_ptr when calling the runtime function.

**E2E tests**: Create/extend `e2e_stdlib.rs`:

1. **List operations** -- Create a list with List.new + append, get its length, print result
2. **List.map** -- `List.new() |> List.append(1) |> List.append(2) |> list_map(fn(x) -> x * 2 end)` -- verify doubled values
3. **Prelude map** -- Using bare `map` name: `map(list, fn(x) -> x + 1 end)`
4. **List.filter** -- Filter a list to keep only values > 2
5. **List.reduce** -- Sum all elements: `reduce(list, 0, fn(acc, x) -> acc + x end)`
6. **Pipe chain** -- `list |> map(double) |> filter(positive) |> reduce(0, sum)` -- full pipe chain test
7. **Map.put/get** -- Create map, put a key-value, get it back
8. **Set.add/contains** -- Create set, add element, check contains
  </action>
  <verify>
`cargo test --workspace` -- all tests pass. E2E tests for List.map, filter, reduce, pipe chains, Map.put/get, and Set operations all produce correct output.
  </verify>
  <done>
List, Map, and Set types fully integrated into the compiler pipeline. Polymorphic type inference works for collection operations. Higher-order functions (map, filter, reduce) correctly accept and invoke Snow closures. Pipe operator chains work with collection-first argument convention. All E2E tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. A Snow program with `list |> map(fn(x) -> x * 2 end) |> filter(fn(x) -> x > 2 end)` compiles and produces correct output
3. `Map.put(Map.new(), "key", "value") |> Map.get("key")` returns "value"
4. `reduce(list, 0, fn(acc, x) -> acc + x end)` correctly sums a list
5. Bare prelude names (map, filter, reduce, head, tail) work without imports
6. Module-qualified names (List.map, Map.put, Set.add) work
</verification>

<success_criteria>
- List with map/filter/reduce/head/tail/append/concat/reverse/length/get operations
- Map with new/put/get/has_key/delete/size/keys/values operations
- Set with new/add/remove/contains/size/union/intersection operations
- Higher-order functions accept Snow closures (fn_ptr + env_ptr) and invoke them correctly
- Pipe chains work: `list |> map(fn) |> filter(fn) |> reduce(init, fn)`
- Prelude names auto-imported, module-qualified access works
- All collections are immutable (operations return new collections)
- Full workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-02-SUMMARY.md`
</output>
