---
phase: 08-standard-library
plan: 04
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - crates/snow-rt/src/json.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-rt/Cargo.toml
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "JSON.parse(string) parses a JSON string and returns Result<Json, String>"
    - "JSON.encode(value) converts a Snow value to a JSON string"
    - "The Json type is a sum type with variants: Null, Bool, Number, Str, Array, Object"
    - "Parsed JSON can be pattern matched: case JSON.parse(s) do Ok(Json.Object(map)) -> ... end"
    - "JSON.encode works on maps, lists, strings, numbers, and booleans"
  artifacts:
    - path: "crates/snow-rt/src/json.rs"
      provides: "JSON parsing and encoding runtime functions"
      contains: "snow_json_parse"
    - path: "crates/snow-rt/Cargo.toml"
      provides: "serde_json dependency"
      contains: "serde_json"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Json sum type and JSON function registrations"
      contains: "json_parse"
  key_links:
    - from: "crates/snow-rt/src/json.rs"
      to: "crates/snow-rt/src/collections/map.rs"
      via: "JSON objects use SnowMap for Object variant"
      pattern: "SnowMap"
    - from: "crates/snow-rt/src/json.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "JSON arrays use SnowList for Array variant"
      pattern: "SnowList"
---

<objective>
Implement JSON encoding and decoding using serde_json, with a dynamic Json sum type for pattern-matchable parsed data.

Purpose: JSON is essential for web APIs. This plan enables Snow programs to parse JSON strings into a matchable data structure and encode Snow values back to JSON strings. Combined with HTTP (Plan 05), this enables the second success criterion: "A Snow program can start an HTTP server that accepts requests and returns JSON responses."

Output: JSON module with parse/encode functions, Json sum type (Null/Bool/Number/Str/Array/Object).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-RESEARCH.md
@.planning/phases/08-standard-library/08-01-SUMMARY.md
@.planning/phases/08-standard-library/08-02-SUMMARY.md

Key files:
@crates/snow-rt/src/string.rs -- SnowString for string values
@crates/snow-rt/src/collections/list.rs -- SnowList for JSON arrays
@crates/snow-rt/src/collections/map.rs -- SnowMap for JSON objects
@crates/snow-codegen/src/codegen/expr.rs -- how sum type variants are constructed
</context>

<tasks>

<task type="auto">
  <name>Task 1: JSON runtime with serde_json and Json type representation</name>
  <files>
    crates/snow-rt/src/json.rs
    crates/snow-rt/src/lib.rs
    crates/snow-rt/Cargo.toml
  </files>
  <action>
Add `serde_json = "1"` to `crates/snow-rt/Cargo.toml` dependencies. Create `crates/snow-rt/src/json.rs`. Add `pub mod json;` to `lib.rs`.

**Json type representation:**

The Json type in Snow is a sum type: `type Json do Null | Bool(Bool) | Number(Float) | Str(String) | Array(List<Json>) | Object(Map<String, Json>) end`

At the runtime level, represent this as a tagged union allocated on the GC arena:
```rust
#[repr(C)]
pub struct SnowJson {
    pub tag: u8,       // 0=Null, 1=Bool, 2=Number, 3=Str, 4=Array, 5=Object
    pub value: u64,    // payload: 0 for Null, i8 for Bool, f64 bits for Number,
                       // ptr for Str (SnowString), ptr for Array (SnowList), ptr for Object (SnowMap)
}
```

This matches the standard sum type representation used by the codegen (tag byte + payload).

**Parse function:**

`snow_json_parse(input: *const SnowString) -> *mut u8`
- Uses `serde_json::from_str()` to parse the input string
- Returns SnowResult: Ok(SnowJson*) on success, Err(SnowString error msg) on failure
- Recursively converts `serde_json::Value` to `SnowJson`:
  - `Value::Null` -> SnowJson { tag: 0, value: 0 }
  - `Value::Bool(b)` -> SnowJson { tag: 1, value: b as u64 }
  - `Value::Number(n)` -> SnowJson { tag: 2, value: n.as_f64().to_bits() }
  - `Value::String(s)` -> SnowJson { tag: 3, value: snow_string_new(s) as u64 }
  - `Value::Array(arr)` -> SnowJson { tag: 4, value: convert_to_snow_list(arr) as u64 }
  - `Value::Object(map)` -> SnowJson { tag: 5, value: convert_to_snow_map(map) as u64 }

For Array: create a SnowList and append each converted SnowJson pointer as a u64 element.
For Object: create a SnowMap and put each key (as SnowString pointer) -> value (as SnowJson pointer).

**Encode function:**

`snow_json_encode(json: *mut u8) -> *mut SnowString`
- Takes a SnowJson pointer, recursively converts back to a JSON string
- For Null: "null"
- For Bool: "true" / "false"
- For Number: format f64
- For Str: quote and escape the string
- For Array: "[" + comma-separated encoded elements + "]"
- For Object: "{" + comma-separated "key":value pairs + "}"
- Returns a new SnowString with the JSON text

**Convenience encode functions:**

`snow_json_encode_string(s: *const SnowString) -> *mut SnowString` -- wraps a string in JSON quotes
`snow_json_encode_int(val: i64) -> *mut SnowString` -- converts int to JSON number string
`snow_json_encode_map(map: *mut u8) -> *mut SnowString` -- converts a SnowMap to JSON object string. Traverses the map, encoding each key-value pair. Values are encoded based on their runtime type (this is a best-effort encoding -- for Phase 8, assume values are either strings, ints, floats, or nested maps/lists).

Add unit tests:
1. Parse `{"name":"Snow","version":1}` -> extract tag=5 (Object), verify map contents
2. Parse `[1,2,3]` -> extract tag=4 (Array), verify list length
3. Parse `null` -> tag=0
4. Parse invalid JSON -> Err result
5. Encode round-trip: parse then encode, verify output matches (modulo whitespace)
  </action>
  <verify>
`cargo test -p snow-rt` -- all JSON unit tests pass. Parse/encode round-trip works correctly.
  </verify>
  <done>
JSON parse and encode functions work correctly using serde_json. SnowJson tagged union correctly represents all JSON types. Array/Object variants use SnowList/SnowMap from Plan 02.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline and E2E tests for JSON</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
**Type checker -- builtins.rs**:

Register the Json sum type in the TypeRegistry (same mechanism used for Option/Result):
```
Json sum type with variants:
  - Null (no payload)
  - Bool(Bool)
  - Number(Float)
  - Str(String)
  - Array(List<Json>)
  - Object(Map<String, Json>)
```

Register Json variant constructors (Json.Null, Json.Bool, etc.) following the pattern used for Option.Some/Option.None/Result.Ok/Result.Err in Phase 4's `register_variant_constructors`.

Register JSON module functions:
- `json_parse` : `(String) -> Result<Json, String>`
- `json_encode` : `(Json) -> String`
- `json_encode_string` : `(String) -> String`
- `json_encode_int` : `(Int) -> String`
- `json_encode_map` : `(Map<String, String>) -> String` (simplified for common case)

Add "JSON" to stdlib_modules with "parse", "encode", "encode_string", "encode_int", "encode_map" entries.

**Intrinsics**: Declare LLVM signatures:
- `snow_json_parse(ptr) -> ptr` (returns SnowResult pointer)
- `snow_json_encode(ptr) -> ptr` (returns SnowString pointer)
- `snow_json_encode_string(ptr) -> ptr`
- `snow_json_encode_int(i64) -> ptr`
- `snow_json_encode_map(ptr) -> ptr`

**MIR lowering**: Add name mappings and known_functions entries.

**E2E tests**:

1. **Parse and match** -- Parse a JSON object, pattern match on result:
```snow
fn main() do
  let result = json_parse("{\"name\":\"Snow\"}")
  case result do
    Ok(value) -> println("parsed ok")
    Err(msg) -> println("error: ${msg}")
  end
end
```

2. **Encode map** -- Create a map with string values, encode to JSON, print:
```snow
fn main() do
  let data = Map.new() |> Map.put("name", "Snow") |> Map.put("version", "0.1")
  let json_str = json_encode_map(data)
  println(json_str)
end
```
Expected output should contain `"name":"Snow"` (exact format may vary).

3. **Parse error** -- Parse invalid JSON, match Err variant, verify no crash.

4. **Encode primitives** -- Encode a string and an integer to JSON strings, verify output.

NOTE: Full Json sum type pattern matching (matching on Json.Object, Json.Array, etc.) requires the Json type to be registered as a proper sum type in the TypeRegistry. This is the most complex part. If full sum type registration proves too complex in this plan, a simpler approach is to expose accessor functions: `json_is_object(json) -> Bool`, `json_as_object(json) -> Map`, etc. Use whichever approach is more tractable given the existing sum type infrastructure.
  </action>
  <verify>
`cargo test --workspace` -- all tests pass. JSON parse returns correct Result, encode produces valid JSON strings.
  </verify>
  <done>
JSON module fully integrated into compiler pipeline. JSON.parse/encode work from Snow source code. Json sum type registered for pattern matching. E2E tests verify parse/encode roundtrip and error handling.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. JSON.parse of a valid object returns Ok with parseable structure
3. JSON.parse of invalid input returns Err without crash
4. JSON.encode_map produces valid JSON string output
5. The Json type is usable in pattern matching contexts
</verification>

<success_criteria>
- JSON.parse parses JSON strings using serde_json and returns Result<Json, String>
- JSON.encode converts Json/Map/String/Int values back to JSON strings
- Json sum type (Null/Bool/Number/Str/Array/Object) works with pattern matching
- Parse/encode roundtrip produces correct results
- serde_json dependency added to snow-rt
- E2E tests verify JSON operations from compiled Snow programs
- Full workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-04-SUMMARY.md`
</output>
