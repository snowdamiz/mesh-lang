---
phase: 08-standard-library
plan: 04
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - crates/snow-rt/src/json.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-rt/Cargo.toml
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "JSON.parse(string) parses a JSON string and returns Result<Json, String>"
    - "JSON.encode(value) converts a Snow value to a JSON string for any T: ToJSON"
    - "JSON.decode<T>(string) parses JSON into a typed value for any T: FromJSON, returns Result<T, String>"
    - "The Json type is a sum type with variants: Null, Bool, Number, Str, Array, Object"
    - "Parsed JSON can be pattern matched: case JSON.parse(s) do Ok(Json.Object(map)) -> ... end"
    - "JSON.encode works on maps, lists, strings, numbers, and booleans via built-in ToJSON implementations"
    - "ToJSON trait: interface ToJSON do fn to_json(self) -> Json end -- types can convert themselves to Json"
    - "FromJSON trait: interface FromJSON do fn from_json(json: Json) -> Result<Self, String> end -- types can parse from Json"
    - "Built-in ToJSON/FromJSON implementations exist for Int, Float, Bool, String, List<T: ToJSON>, Map<String, V: ToJSON>"
    - "User-defined structs can implement ToJSON/FromJSON for typed encoding/decoding"
  artifacts:
    - path: "crates/snow-rt/src/json.rs"
      provides: "JSON parsing, encoding, and trait dispatch runtime functions"
      contains: "snow_json_parse"
    - path: "crates/snow-rt/Cargo.toml"
      provides: "serde_json dependency"
      contains: "serde_json"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Json sum type, ToJSON/FromJSON trait registrations, and JSON function registrations"
      contains: "json_parse"
  key_links:
    - from: "crates/snow-rt/src/json.rs"
      to: "crates/snow-rt/src/collections/map.rs"
      via: "JSON objects use SnowMap for Object variant"
      pattern: "SnowMap"
    - from: "crates/snow-rt/src/json.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "JSON arrays use SnowList for Array variant"
      pattern: "SnowList"
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "crates/snow-rt/src/json.rs"
      via: "ToJSON/FromJSON trait dispatch maps to runtime encode/decode functions"
      pattern: "to_json.*from_json"
---

<objective>
Implement JSON encoding and decoding using serde_json, with BOTH a dynamic Json sum type for pattern-matchable parsed data AND trait-based ToJSON/FromJSON for typed encoding/decoding of known structs.

Purpose: JSON is essential for web APIs. This plan enables Snow programs to parse JSON strings into a matchable data structure and encode Snow values back to JSON strings. The dual approach (dynamic Json type + ToJSON/FromJSON traits) gives developers flexibility: dynamic for unknown schemas, traits for typed API contracts. Combined with HTTP (Plan 05), this enables the second success criterion: "A Snow program can start an HTTP server that accepts requests and returns JSON responses."

Output: JSON module with parse/encode functions, Json sum type (Null/Bool/Number/Str/Array/Object), ToJSON/FromJSON traits with built-in implementations for primitives and collections.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-RESEARCH.md
@.planning/phases/08-standard-library/08-01-SUMMARY.md
@.planning/phases/08-standard-library/08-02-SUMMARY.md

Key files:
@crates/snow-rt/src/string.rs -- SnowString for string values
@crates/snow-rt/src/collections/list.rs -- SnowList for JSON arrays
@crates/snow-rt/src/collections/map.rs -- SnowMap for JSON objects
@crates/snow-codegen/src/codegen/expr.rs -- how sum type variants are constructed
</context>

<tasks>

<task type="auto">
  <name>Task 1: JSON runtime with serde_json and Json type representation</name>
  <files>
    crates/snow-rt/src/json.rs
    crates/snow-rt/src/lib.rs
    crates/snow-rt/Cargo.toml
  </files>
  <action>
Add `serde_json = "1"` to `crates/snow-rt/Cargo.toml` dependencies. Create `crates/snow-rt/src/json.rs`. Add `pub mod json;` to `lib.rs`.

**Json type representation:**

The Json type in Snow is a sum type: `type Json do Null | Bool(Bool) | Number(Float) | Str(String) | Array(List<Json>) | Object(Map<String, Json>) end`

At the runtime level, represent this as a tagged union allocated on the GC arena:
```rust
#[repr(C)]
pub struct SnowJson {
    pub tag: u8,       // 0=Null, 1=Bool, 2=Number, 3=Str, 4=Array, 5=Object
    pub value: u64,    // payload: 0 for Null, i8 for Bool, f64 bits for Number,
                       // ptr for Str (SnowString), ptr for Array (SnowList), ptr for Object (SnowMap)
}
```

This matches the standard sum type representation used by the codegen (tag byte + payload).

**Parse function:**

`snow_json_parse(input: *const SnowString) -> *mut u8`
- Uses `serde_json::from_str()` to parse the input string
- Returns SnowResult: Ok(SnowJson*) on success, Err(SnowString error msg) on failure
- Recursively converts `serde_json::Value` to `SnowJson`:
  - `Value::Null` -> SnowJson { tag: 0, value: 0 }
  - `Value::Bool(b)` -> SnowJson { tag: 1, value: b as u64 }
  - `Value::Number(n)` -> SnowJson { tag: 2, value: n.as_f64().to_bits() }
  - `Value::String(s)` -> SnowJson { tag: 3, value: snow_string_new(s) as u64 }
  - `Value::Array(arr)` -> SnowJson { tag: 4, value: convert_to_snow_list(arr) as u64 }
  - `Value::Object(map)` -> SnowJson { tag: 5, value: convert_to_snow_map(map) as u64 }

For Array: create a SnowList and append each converted SnowJson pointer as a u64 element.
For Object: create a SnowMap and put each key (as SnowString pointer) -> value (as SnowJson pointer).

**Encode function:**

`snow_json_encode(json: *mut u8) -> *mut SnowString`
- Takes a SnowJson pointer, recursively converts back to a JSON string
- For Null: "null"
- For Bool: "true" / "false"
- For Number: format f64
- For Str: quote and escape the string
- For Array: "[" + comma-separated encoded elements + "]"
- For Object: "{" + comma-separated "key":value pairs + "}"
- Returns a new SnowString with the JSON text

**Convenience encode functions:**

`snow_json_encode_string(s: *const SnowString) -> *mut SnowString` -- wraps a string in JSON quotes
`snow_json_encode_int(val: i64) -> *mut SnowString` -- converts int to JSON number string
`snow_json_encode_map(map: *mut u8) -> *mut SnowString` -- converts a SnowMap to JSON object string. Traverses the map, encoding each key-value pair. Values are encoded based on their runtime type (this is a best-effort encoding -- for Phase 8, assume values are either strings, ints, floats, or nested maps/lists).

**ToJSON/FromJSON runtime support:**

The ToJSON and FromJSON traits are Snow-level interfaces. At the runtime level, we need functions that convert primitive types to/from SnowJson:

`snow_json_from_int(val: i64) -> *mut u8` -- returns SnowJson { tag: 2, value: (val as f64).to_bits() }
`snow_json_from_float(val: f64) -> *mut u8` -- returns SnowJson { tag: 2, value: val.to_bits() }
`snow_json_from_bool(val: i8) -> *mut u8` -- returns SnowJson { tag: 1, value: val as u64 }
`snow_json_from_string(s: *const SnowString) -> *mut u8` -- returns SnowJson { tag: 3, value: s as u64 }
`snow_json_from_list(list: *mut u8, elem_to_json_fn: *mut u8, elem_to_json_env: *mut u8) -> *mut u8` -- converts a SnowList to SnowJson Array. Calls elem_to_json_fn on each element to get its SnowJson representation, collects into a SnowList of SnowJson pointers, wraps as Array variant.
`snow_json_from_map(map: *mut u8, val_to_json_fn: *mut u8, val_to_json_env: *mut u8) -> *mut u8` -- converts a SnowMap (with string keys) to SnowJson Object. Calls val_to_json_fn on each value.

`snow_json_to_int(json: *mut u8) -> *mut u8` -- returns SnowResult: Ok(i64) if json is Number, Err(String) otherwise
`snow_json_to_float(json: *mut u8) -> *mut u8` -- returns SnowResult: Ok(f64) if json is Number, Err(String) otherwise
`snow_json_to_bool(json: *mut u8) -> *mut u8` -- returns SnowResult: Ok(Bool) if json is Bool, Err(String) otherwise
`snow_json_to_string(json: *mut u8) -> *mut u8` -- returns SnowResult: Ok(String) if json is Str, Err(String) otherwise

`snow_json_decode(input: *const SnowString, from_json_fn: *mut u8, from_json_env: *mut u8) -> *mut u8`
- Parses the JSON string into SnowJson (same as snow_json_parse)
- Then calls from_json_fn(from_json_env, json_ptr) to convert the SnowJson into the target type
- Returns the Result from from_json_fn
- This is the generic `JSON.decode<T>(string)` entry point -- the compiler passes the FromJSON impl's from_json function pointer

`snow_json_encode_value(value: *mut u8, to_json_fn: *mut u8, to_json_env: *mut u8) -> *mut SnowString`
- Calls to_json_fn(to_json_env, value) to get a SnowJson representation
- Then calls snow_json_encode on the result to get the JSON string
- This is the generic `JSON.encode(value)` entry point -- the compiler passes the ToJSON impl's to_json function pointer

Add unit tests:
1. Parse `{"name":"Snow","version":1}` -> extract tag=5 (Object), verify map contents
2. Parse `[1,2,3]` -> extract tag=4 (Array), verify list length
3. Parse `null` -> tag=0
4. Parse invalid JSON -> Err result
5. Encode round-trip: parse then encode, verify output matches (modulo whitespace)
6. snow_json_from_int(42) produces SnowJson with tag=2, extractable as 42.0
7. snow_json_from_string("hello") produces SnowJson with tag=3
8. snow_json_to_int on a Number json succeeds, on a String json returns Err
  </action>
  <verify>
`cargo test -p snow-rt` -- all JSON unit tests pass. Parse/encode round-trip works correctly.
  </verify>
  <done>
JSON parse and encode functions work correctly using serde_json. SnowJson tagged union correctly represents all JSON types. Array/Object variants use SnowList/SnowMap from Plan 02.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline and E2E tests for JSON</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
**Type checker -- builtins.rs**:

Register the Json sum type in the TypeRegistry (same mechanism used for Option/Result):
```
Json sum type with variants:
  - Null (no payload)
  - Bool(Bool)
  - Number(Float)
  - Str(String)
  - Array(List<Json>)
  - Object(Map<String, Json>)
```

Register Json variant constructors (Json.Null, Json.Bool, etc.) following the pattern used for Option.Some/Option.None/Result.Ok/Result.Err in Phase 4's `register_variant_constructors`.

**Register ToJSON and FromJSON traits:**

```snow
interface ToJSON do
  fn to_json(self) -> Json
end

interface FromJSON do
  fn from_json(json: Json) -> Result<Self, String>
end
```

Register these as trait/interface types in the type system, following the existing trait registration pattern (if traits are implemented) or as phantom marker types that the compiler uses to dispatch to the correct runtime functions.

**Built-in trait implementations** (register in the type registry):
- `impl ToJSON for Int` -- calls snow_json_from_int
- `impl ToJSON for Float` -- calls snow_json_from_float
- `impl ToJSON for Bool` -- calls snow_json_from_bool
- `impl ToJSON for String` -- calls snow_json_from_string
- `impl ToJSON for List<T: ToJSON>` -- calls snow_json_from_list with element's to_json as callback
- `impl ToJSON for Map<String, V: ToJSON>` -- calls snow_json_from_map with value's to_json as callback
- `impl FromJSON for Int` -- calls snow_json_to_int
- `impl FromJSON for Float` -- calls snow_json_to_float
- `impl FromJSON for Bool` -- calls snow_json_to_bool
- `impl FromJSON for String` -- calls snow_json_to_string

If the trait system is not yet fully operational (traits may be Phase 9), implement this as compiler-recognized special functions: `JSON.encode(value)` dispatches based on the compile-time type of `value` to the appropriate `snow_json_from_*` + `snow_json_encode` chain. `JSON.decode<T>(string)` dispatches based on `T` to the appropriate `snow_json_to_*` chain. This is monomorphization -- the compiler generates the right call sequence at compile time based on the known type.

Register JSON module functions:
- `json_parse` : `(String) -> Result<Json, String>`
- `json_encode` : `forall T: ToJSON. (T) -> String` -- generic encode, dispatches via trait/monomorphization
- `json_decode` : `forall T: FromJSON. (String) -> Result<T, String>` -- generic decode
- `json_encode_string` : `(String) -> String`
- `json_encode_int` : `(Int) -> String`
- `json_encode_map` : `(Map<String, String>) -> String` (simplified for common case)

Add "JSON" to stdlib_modules with "parse", "encode", "decode", "encode_string", "encode_int", "encode_map" entries.

**Intrinsics**: Declare LLVM signatures:
- `snow_json_parse(ptr) -> ptr` (returns SnowResult pointer)
- `snow_json_encode(ptr) -> ptr` (returns SnowString pointer)
- `snow_json_encode_string(ptr) -> ptr`
- `snow_json_encode_int(i64) -> ptr`
- `snow_json_encode_map(ptr) -> ptr`
- `snow_json_from_int(i64) -> ptr` (returns SnowJson pointer)
- `snow_json_from_float(f64) -> ptr`
- `snow_json_from_bool(i8) -> ptr`
- `snow_json_from_string(ptr) -> ptr`
- `snow_json_from_list(ptr, ptr, ptr) -> ptr` (list, to_json_fn, env)
- `snow_json_from_map(ptr, ptr, ptr) -> ptr` (map, to_json_fn, env)
- `snow_json_to_int(ptr) -> ptr` (returns SnowResult)
- `snow_json_to_float(ptr) -> ptr`
- `snow_json_to_bool(ptr) -> ptr`
- `snow_json_to_string(ptr) -> ptr`
- `snow_json_decode(ptr, ptr, ptr) -> ptr` (input_string, from_json_fn, env -> Result)
- `snow_json_encode_value(ptr, ptr, ptr) -> ptr` (value, to_json_fn, env -> String)

**MIR lowering**: Add name mappings and known_functions entries for all JSON functions including the trait dispatch functions.

**E2E tests**:

1. **Parse and match** -- Parse a JSON object, pattern match on result:
```snow
fn main() do
  let result = json_parse("{\"name\":\"Snow\"}")
  case result do
    Ok(value) -> println("parsed ok")
    Err(msg) -> println("error: ${msg}")
  end
end
```

2. **Encode map** -- Create a map with string values, encode to JSON, print:
```snow
fn main() do
  let data = Map.new() |> Map.put("name", "Snow") |> Map.put("version", "0.1")
  let json_str = json_encode_map(data)
  println(json_str)
end
```
Expected output should contain `"name":"Snow"` (exact format may vary).

3. **Parse error** -- Parse invalid JSON, match Err variant, verify no crash.

4. **Encode primitives** -- Encode a string and an integer to JSON strings, verify output.

5. **ToJSON encode** -- Encode an Int and a String to JSON via the generic encode path:
```snow
fn main() do
  let json_str = JSON.encode(42)
  println(json_str)
  let json_str2 = JSON.encode("hello")
  println(json_str2)
end
```
Expected output: `42` and `"hello"` (with JSON quoting).

6. **FromJSON decode** -- Decode a JSON string into a typed Int:
```snow
fn main() do
  let result = JSON.decode<Int>("42")
  case result do
    Ok(n) -> println(int_to_string(n))
    Err(msg) -> println("error: ${msg}")
  end
end
```
Expected output: `42`.

7. **ToJSON with List** -- Encode a list of integers to JSON:
```snow
fn main() do
  let list = List.new() |> List.append(1) |> List.append(2) |> List.append(3)
  let json_str = JSON.encode(list)
  println(json_str)
end
```
Expected output: `[1,2,3]` (or `[1, 2, 3]`).

NOTE: Full Json sum type pattern matching (matching on Json.Object, Json.Array, etc.) requires the Json type to be registered as a proper sum type in the TypeRegistry. This is the most complex part. If full sum type registration proves too complex in this plan, a simpler approach is to expose accessor functions: `json_is_object(json) -> Bool`, `json_as_object(json) -> Map`, etc. Use whichever approach is more tractable given the existing sum type infrastructure.

NOTE on ToJSON/FromJSON: If the trait system is not yet available, implement the generic JSON.encode/JSON.decode as compiler-driven monomorphization -- the compiler sees the argument type at call site and emits the appropriate specialized runtime call. This achieves the same user-facing API without requiring runtime trait dispatch.
  </action>
  <verify>
`cargo test --workspace` -- all tests pass. JSON parse returns correct Result, encode produces valid JSON strings.
  </verify>
  <done>
JSON module fully integrated into compiler pipeline. JSON.parse/encode work from Snow source code. Json sum type registered for pattern matching. E2E tests verify parse/encode roundtrip and error handling.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. JSON.parse of a valid object returns Ok with parseable structure
3. JSON.parse of invalid input returns Err without crash
4. JSON.encode_map produces valid JSON string output
5. The Json type is usable in pattern matching contexts
6. JSON.encode(42) produces "42", JSON.encode("hello") produces "\"hello\""
7. JSON.decode<Int>("42") returns Ok(42)
8. JSON.encode on a List<Int> produces a JSON array string
9. ToJSON/FromJSON dispatch works for all primitive types (Int, Float, Bool, String)
</verification>

<success_criteria>
- JSON.parse parses JSON strings using serde_json and returns Result<Json, String>
- JSON.encode converts any T: ToJSON value to a JSON string (generic encode)
- JSON.decode<T> parses JSON strings into typed values for T: FromJSON (generic decode)
- Json sum type (Null/Bool/Number/Str/Array/Object) works with pattern matching
- ToJSON trait with built-in implementations for Int, Float, Bool, String, List<T: ToJSON>, Map<String, V: ToJSON>
- FromJSON trait with built-in implementations for Int, Float, Bool, String
- User-defined structs can implement ToJSON/FromJSON for typed encoding/decoding
- Parse/encode roundtrip produces correct results
- serde_json dependency added to snow-rt
- E2E tests verify both dynamic JSON and trait-based encoding/decoding
- Full workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-04-SUMMARY.md`
</output>
