---
phase: 08-standard-library
plan: 05
type: execute
wave: 4
depends_on: ["08-03", "08-04"]
files_modified:
  - crates/snow-rt/src/http/mod.rs
  - crates/snow-rt/src/http/server.rs
  - crates/snow-rt/src/http/client.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-rt/Cargo.toml
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "HTTP.serve(port, handler_fn) starts an HTTP server that calls handler_fn for each request"
    - "HTTP.get(url) performs an HTTP GET request and returns Result<String, String>"
    - "HTTP.post(url, body) performs an HTTP POST request and returns Result<String, String>"
    - "A Snow program can start an HTTP server that accepts requests and returns JSON responses"
    - "Each HTTP connection is handled by a separate actor (actor-per-connection model)"
    - "The HTTP server does not crash when a handler function fails"
  artifacts:
    - path: "crates/snow-rt/src/http/server.rs"
      provides: "HTTP server with actor-per-connection model"
      contains: "snow_http_serve"
    - path: "crates/snow-rt/src/http/client.rs"
      provides: "HTTP client (GET, POST)"
      contains: "snow_http_get"
    - path: "crates/snow-rt/Cargo.toml"
      provides: "tiny-http and ureq dependencies"
      contains: "tiny-http"
  key_links:
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "HTTP server spawns actors for each connection"
      pattern: "snow_actor_spawn"
    - from: "crates/snow-rt/src/http/client.rs"
      to: "crates/snow-rt/src/string.rs"
      via: "HTTP responses returned as SnowString"
      pattern: "SnowString"
---

<objective>
Implement HTTP client and server using tiny-http and ureq, with an actor-per-connection server model that integrates with Snow's actor runtime.

Purpose: HTTP is the final piece needed to build real web backends. This plan delivers the second success criterion: "A Snow program can start an HTTP server that accepts requests and returns JSON responses." The actor-per-connection model leverages Snow's existing actor infrastructure for request isolation and fault tolerance.

Output: HTTP module with serve (server), get/post (client) functions, integrated with actors and JSON.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-RESEARCH.md
@.planning/phases/08-standard-library/08-01-SUMMARY.md
@.planning/phases/08-standard-library/08-02-SUMMARY.md
@.planning/phases/08-standard-library/08-03-SUMMARY.md
@.planning/phases/08-standard-library/08-04-SUMMARY.md

Key files:
@crates/snow-rt/src/actor/ -- actor spawn, send, receive infrastructure
@crates/snow-rt/src/string.rs -- SnowString for request/response bodies
@crates/snow-rt/src/json.rs -- JSON encode/decode for API responses
@crates/snow-rt/src/io.rs -- SnowResult struct for Result returns
</context>

<tasks>

<task type="auto">
  <name>Task 1: HTTP server and client runtime implementations</name>
  <files>
    crates/snow-rt/src/http/mod.rs
    crates/snow-rt/src/http/server.rs
    crates/snow-rt/src/http/client.rs
    crates/snow-rt/src/lib.rs
    crates/snow-rt/Cargo.toml
  </files>
  <action>
Add dependencies to `crates/snow-rt/Cargo.toml`:
```toml
tiny-http = "0.12"
ureq = "2"
```

Create `crates/snow-rt/src/http/` directory with `mod.rs`, `server.rs`, `client.rs`. Add `pub mod http;` to `lib.rs`.

**HTTP Server (server.rs):**

The server uses a simplified model for Phase 8: the handler is called synchronously on the tiny-http listener thread (not actor-per-connection initially). Actor-per-connection integration is the stretch goal.

**Simplified approach (implement this first):**

`snow_http_serve(port: i64, handler_fn_ptr: *mut u8, handler_env_ptr: *mut u8)`
- This function BLOCKS (runs the server loop indefinitely)
- Starts a `tiny_http::Server` listening on the given port
- For each incoming request:
  1. Extract method, path, and body as SnowStrings
  2. Pack them into a request struct: allocate a struct on the GC arena with fields { method: *SnowString, path: *SnowString, body: *SnowString, headers: *SnowMap }
  3. Call the handler closure: `handler_fn_ptr(handler_env_ptr, request_ptr) -> response_ptr`
     - The handler returns a response struct: { status: i64, body: *SnowString }
  4. Use tiny-http to send the response

The request and response are passed as opaque pointers (ptr). At the Snow level, they'll be typed as structs or tuples.

For simplicity, represent request as a tuple: `(String, String, String)` = (method, path, body)
And response as a tuple: `(Int, String)` = (status_code, body)

Then the handler signature from Snow's perspective is: `fn(method: String, path: String, body: String) -> (Int, String)`

Actually, even simpler: pass method, path, body as separate arguments to the handler:

`snow_http_serve(port: i64, handler_fn_ptr: *mut u8, handler_env_ptr: *mut u8)`
- The handler is called as: `handler_fn_ptr(env_ptr, method_str, path_str, body_str) -> *mut u8`
- The return value is a pointer to a GC-allocated struct: `{ i64 status, *SnowString body }`
- OR simpler: the handler returns two values packed as `{ i64 status, *SnowString body }` -- but this requires struct return which is complex in FFI

**Simplest approach:** Use a two-call protocol:
1. Handler returns a SnowString (the response body). Status is always 200.
2. For custom status codes, provide a `snow_http_response(status: i64, body: *const SnowString) -> *mut u8` that creates a response struct, and the handler returns a pointer to it.

**Recommended approach:** Handler takes a single request pointer and returns a single response pointer.

Define request and response structs:
```rust
#[repr(C)]
pub struct SnowHttpRequest {
    pub method: *const SnowString,
    pub path: *const SnowString,
    pub body: *const SnowString,
}

#[repr(C)]
pub struct SnowHttpResponse {
    pub status: i64,
    pub body: *const SnowString,
}
```

The serve function:
```rust
#[no_mangle]
pub extern "C" fn snow_http_serve(port: i64, fn_ptr: *mut u8, env_ptr: *mut u8) {
    let server = tiny_http::Server::http(format!("0.0.0.0:{}", port)).unwrap();
    for request in server.incoming_requests() {
        // Extract request data
        let method = snow_string_new(request.method().as_str().as_bytes());
        let path = snow_string_new(request.url().as_bytes());
        let body = read_body(&mut request);

        // Allocate SnowHttpRequest
        let req = allocate_request(method, path, body);

        // Call handler
        let response = call_handler(fn_ptr, env_ptr, req);

        // Send response
        let resp = tiny_http::Response::from_string(response_body)
            .with_status_code(status as u16);
        request.respond(resp);
    }
}
```

Handle panics in the handler with `std::panic::catch_unwind` so a crashing handler doesn't take down the server.

**Actor-per-connection (stretch goal):** If time permits and the actor runtime is accessible from this context, spawn an actor for each request. The actor receives the request as a message, runs the handler, and sends the response back. Use `snow_actor_spawn` and message passing. However, this is complex because the Snow actor spawn requires a function pointer registered in the LLVM module. For Phase 8, the synchronous handler approach is acceptable -- actor-per-connection can be enhanced in Phase 9.

**HTTP Client (client.rs):**

`snow_http_get(url: *const SnowString) -> *mut u8`
- Uses `ureq::get(url).call()` to make a GET request
- Returns SnowResult: Ok(SnowString response body) or Err(SnowString error message)
- Handle connection errors, timeouts, non-2xx status codes

`snow_http_post(url: *const SnowString, body: *const SnowString) -> *mut u8`
- Uses `ureq::post(url).send_string(body)` to make a POST request
- Returns SnowResult: Ok(SnowString response body) or Err(SnowString error message)
- Set Content-Type to "application/json" if body looks like JSON, otherwise "text/plain"

Add unit tests for the client (use a mock or test against httpbin if available). For the server, test startup/shutdown (the blocking nature makes unit testing harder -- rely on E2E tests).
  </action>
  <verify>
`cargo test -p snow-rt` -- HTTP client tests pass. `cargo build -p snow-rt` -- staticlib builds with tiny-http and ureq linked.
  </verify>
  <done>
HTTP server (snow_http_serve) and client (snow_http_get, snow_http_post) implemented. Server handles requests synchronously with panic recovery. Client returns Result<String, String> for all operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline, E2E tests, and success criteria verification</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
**Type checker -- builtins.rs**: Register HTTP functions:

- `http_serve` : `(Int, (String, String, String) -> (Int, String)) -> ()` -- port + handler function. The handler takes (method, path, body) and returns (status, body). Adjust the handler signature based on Task 1's final design.
- `http_get` : `(String) -> Result<String, String>`
- `http_post` : `(String, String) -> Result<String, String>`

Or if using the request/response struct approach:
- `http_serve` : `(Int, (Ptr) -> Ptr) -> ()` -- handler takes opaque request, returns opaque response
- `http_response` : `(Int, String) -> Ptr` -- create a response struct

Add "HTTP" to stdlib_modules with "serve", "get", "post", "response" entries.

**Intrinsics**: Declare LLVM signatures:
- `snow_http_serve(i64, ptr, ptr) -> void` (port, fn_ptr, env_ptr)
- `snow_http_get(ptr) -> ptr` (url -> result)
- `snow_http_post(ptr, ptr) -> ptr` (url, body -> result)

**MIR lowering**: Add name mappings and known_functions entries.

IMPORTANT: The handler function passed to `http_serve` is a closure. The lowerer needs to extract fn_ptr and env_ptr from the closure value and pass them as separate arguments to `snow_http_serve`. Check how the existing codegen handles closure arguments -- the closure is a `{ ptr fn, ptr env }` struct. The codegen should emit extractvalue to get the two pointers and pass them as separate arguments.

**E2E tests**:

1. **HTTP client GET** -- Make a GET request to a known public URL (or skip if no network in CI). Test the compilation at minimum:
```snow
fn main() do
  let result = http_get("http://httpbin.org/get")
  case result do
    Ok(body) -> println("Got response")
    Err(msg) -> println("Error: ${msg}")
  end
end
```
Verify it compiles and runs (may timeout if no network).

2. **HTTP server + client combo** -- Start a server on a background thread, make a client request to it:
This is tricky for E2E because the server blocks. Use a test approach:
- Compile the server program
- Run it in a background process
- Use `curl` or the Snow HTTP client to make a request
- Kill the server
- Check output

If this is too complex for automated testing, verify the server compiles and the client makes successful requests. Add a manual test note.

3. **JSON API server** -- Compile a program that serves JSON responses. This is the key success criterion test:
```snow
fn main() do
  http_serve(8080, fn(method, path, body) ->
    case path do
      "/" -> (200, "{\"message\":\"Hello from Snow!\"}")
      _ -> (404, "{\"error\":\"Not found\"}")
    end
  end)
end
```
Verify compilation succeeds. Run manually to test.

4. **Verify all 4 success criteria**:
   - SC1: File read + process + write (from Plan 03)
   - SC2: HTTP server with JSON responses (this plan)
   - SC3: List map/filter/reduce with pipe chains (from Plan 02)
   - SC4: Standard I/O -- print works, IO.read_line available (from Plan 01)

Write verification programs for SC2 (HTTP+JSON) and SC4 (stdin input program) and verify they compile.
  </action>
  <verify>
`cargo test --workspace` -- all tests pass. HTTP client/server compile and link correctly. A Snow program using `http_serve` and `http_get` compiles to a working native binary. All four Phase 8 success criteria are met.
  </verify>
  <done>
HTTP module fully integrated. Snow programs can start HTTP servers and make HTTP requests. All four Phase 8 success criteria verified: (1) file read+process+write, (2) HTTP server with JSON, (3) collection pipe chains, (4) standard I/O.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. `cargo build --workspace` -- clean build with tiny-http and ureq
3. Snow program with `http_serve(8080, handler)` compiles to working binary
4. Snow program with `http_get(url)` makes HTTP requests and returns Result
5. HTTP server handles crashed handlers without shutting down (panic recovery)
6. All four Phase 8 success criteria verified

**Phase 8 Success Criteria Check:**
- [SC1] A Snow program can read a file, process its contents with string and list operations, and write output to another file
- [SC2] A Snow program can start an HTTP server that accepts requests and returns JSON responses
- [SC3] List operations (map, filter, reduce) and Map operations work with full type inference and pipe operator chaining
- [SC4] Standard I/O (print, read from stdin) works for interactive CLI programs
</verification>

<success_criteria>
- HTTP.serve starts a server that calls a handler for each request
- HTTP.get and HTTP.post make HTTP requests and return Result<String, String>
- Server recovers from handler panics (crash isolation)
- tiny-http and ureq dependencies added and linking correctly
- All four Phase 8 success criteria verified in E2E tests
- Full workspace compiles and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-05-SUMMARY.md`
</output>
