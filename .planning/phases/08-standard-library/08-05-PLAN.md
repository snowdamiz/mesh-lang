---
phase: 08-standard-library
plan: 05
type: execute
wave: 4
depends_on: ["08-03", "08-04"]
files_modified:
  - crates/snow-rt/src/http/mod.rs
  - crates/snow-rt/src/http/server.rs
  - crates/snow-rt/src/http/router.rs
  - crates/snow-rt/src/http/middleware.rs
  - crates/snow-rt/src/http/static_files.rs
  - crates/snow-rt/src/http/request.rs
  - crates/snow-rt/src/http/client.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-rt/Cargo.toml
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "Each HTTP connection spawns an actor via snow_actor_spawn -- actor-per-connection model (Erlang-style)"
    - "HTTP.router() creates a Router, HTTP.route(router, path, handler) adds routes, HTTP.serve(router, port) starts the server"
    - "Router supports exact match and wildcard patterns: HTTP.route(router, '/api/*', handler)"
    - "HTTP.middleware(router, middleware_fn) adds composable request/response processors to the chain"
    - "HTTP.static(router, '/public', './static') serves static files from a directory"
    - "Request parsing: query params, headers, and content-type-based body parsing are available on the request object"
    - "HTTP.get(url) performs an HTTP GET request and returns Result<String, String>"
    - "HTTP.post(url, body) performs an HTTP POST request and returns Result<String, String>"
    - "A Snow program can start an HTTP server that accepts requests and returns JSON responses"
    - "The HTTP server does not crash when a handler actor fails (actor isolation)"
  artifacts:
    - path: "crates/snow-rt/src/http/server.rs"
      provides: "HTTP server with actor-per-connection model using snow_actor_spawn"
      contains: "snow_actor_spawn"
    - path: "crates/snow-rt/src/http/router.rs"
      provides: "Router type with path matching and route registration"
      contains: "snow_http_router"
    - path: "crates/snow-rt/src/http/middleware.rs"
      provides: "Middleware chain for request/response processing"
      contains: "snow_http_middleware"
    - path: "crates/snow-rt/src/http/static_files.rs"
      provides: "Static file serving from directory"
      contains: "snow_http_static"
    - path: "crates/snow-rt/src/http/request.rs"
      provides: "Request parsing with query params, headers, body"
      contains: "snow_http_request_query"
    - path: "crates/snow-rt/src/http/client.rs"
      provides: "HTTP client (GET, POST)"
      contains: "snow_http_get"
    - path: "crates/snow-rt/Cargo.toml"
      provides: "tiny-http and ureq dependencies"
      contains: "tiny-http"
  key_links:
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "HTTP server spawns actors for each connection using snow_actor_spawn"
      pattern: "snow_actor_spawn"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/http/router.rs"
      via: "Server uses Router to dispatch requests to handlers"
      pattern: "SnowRouter"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/http/middleware.rs"
      via: "Server runs middleware chain before handler dispatch"
      pattern: "middleware"
    - from: "crates/snow-rt/src/http/client.rs"
      to: "crates/snow-rt/src/string.rs"
      via: "HTTP responses returned as SnowString"
      pattern: "SnowString"
---

<objective>
Implement a batteries-included HTTP server with actor-per-connection model, built-in routing, middleware chain, static file serving, and request parsing, plus an HTTP client using ureq.

Purpose: HTTP is the final piece needed to build real web backends. This plan delivers the second success criterion: "A Snow program can start an HTTP server that accepts requests and returns JSON responses." The actor-per-connection model (Erlang-style) leverages Snow's existing actor infrastructure from Phase 6-7 -- each incoming HTTP request spawns an actor via `snow_actor_spawn`, giving request isolation and fault tolerance. The batteries-included approach means routing, middleware, and static files work out of the box.

Output: HTTP module with Router (routing + middleware + static files), actor-per-connection serve, request parsing (query params, headers, body), and HTTP client (get/post).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-RESEARCH.md
@.planning/phases/08-standard-library/08-01-SUMMARY.md
@.planning/phases/08-standard-library/08-02-SUMMARY.md
@.planning/phases/08-standard-library/08-03-SUMMARY.md
@.planning/phases/08-standard-library/08-04-SUMMARY.md

Key files:
@crates/snow-rt/src/actor/ -- actor spawn, send, receive infrastructure
@crates/snow-rt/src/string.rs -- SnowString for request/response bodies
@crates/snow-rt/src/json.rs -- JSON encode/decode for API responses
@crates/snow-rt/src/io.rs -- SnowResult struct for Result returns
</context>

<tasks>

<task type="auto">
  <name>Task 1: HTTP server with actor-per-connection, routing, middleware, static files, request parsing, and client</name>
  <files>
    crates/snow-rt/src/http/mod.rs
    crates/snow-rt/src/http/server.rs
    crates/snow-rt/src/http/router.rs
    crates/snow-rt/src/http/middleware.rs
    crates/snow-rt/src/http/static_files.rs
    crates/snow-rt/src/http/request.rs
    crates/snow-rt/src/http/client.rs
    crates/snow-rt/src/lib.rs
    crates/snow-rt/Cargo.toml
  </files>
  <action>
Add dependencies to `crates/snow-rt/Cargo.toml`:
```toml
tiny-http = "0.12"
ureq = "2"
```

Create `crates/snow-rt/src/http/` directory with `mod.rs`, `server.rs`, `router.rs`, `middleware.rs`, `static_files.rs`, `request.rs`, `client.rs`. Add `pub mod http;` to `lib.rs`.

---

**Request type (request.rs):**

Define the full request struct with parsed fields:

```rust
#[repr(C)]
pub struct SnowHttpRequest {
    pub method: *const SnowString,    // "GET", "POST", etc.
    pub path: *const SnowString,      // "/api/users" (path only, no query)
    pub body: *const SnowString,      // raw body string
    pub headers: *mut u8,             // SnowMap<String, String> of headers
    pub query_params: *mut u8,        // SnowMap<String, String> of query params
}

#[repr(C)]
pub struct SnowHttpResponse {
    pub status: i64,
    pub body: *const SnowString,
    pub headers: *mut u8,             // SnowMap<String, String> of response headers
}
```

Implement request parsing functions:

- `snow_http_request_method(req: *mut u8) -> *const SnowString` -- extract method
- `snow_http_request_path(req: *mut u8) -> *const SnowString` -- extract path (without query string)
- `snow_http_request_body(req: *mut u8) -> *const SnowString` -- extract body
- `snow_http_request_header(req: *mut u8, name: *const SnowString) -> *mut u8` -- get header by name, returns Option (Some/None)
- `snow_http_request_query(req: *mut u8, name: *const SnowString) -> *mut u8` -- get query param by name, returns Option
- `snow_http_request_query_params(req: *mut u8) -> *mut u8` -- get all query params as SnowMap
- `snow_http_request_headers(req: *mut u8) -> *mut u8` -- get all headers as SnowMap

**Request parsing logic:** When building SnowHttpRequest from a tiny_http::Request:
1. Split URL at `?` to separate path from query string
2. Parse query string into key=value pairs, URL-decode, store in query_params SnowMap
3. Extract all headers into headers SnowMap (header name -> value, both as SnowString)
4. Read body. If Content-Type is `application/json`, body is the raw JSON string. If `application/x-www-form-urlencoded`, parse key=value pairs (store as body string, Snow code can parse further).

`snow_http_response_new(status: i64, body: *const SnowString) -> *mut u8` -- create a response struct

---

**Router (router.rs):**

Define `SnowRouter` as a GC-allocated struct containing:
- A list of route entries: `Vec<RouteEntry>` where each entry is `{ pattern: String, handler_fn: *mut u8, handler_env: *mut u8 }`
- A list of middleware entries: `Vec<MiddlewareEntry>` where each entry is `{ fn_ptr: *mut u8, env_ptr: *mut u8 }`
- An optional static file config: `Option<StaticConfig>` where StaticConfig is `{ url_prefix: String, dir_path: String }`

Route pattern matching:
- **Exact match:** `"/api/health"` matches only `"/api/health"`
- **Wildcard match:** `"/api/*"` matches `"/api/users"`, `"/api/users/123"`, etc. The `*` matches any suffix after the prefix.
- **Root match:** `"/"` matches only `"/"`
- Routes are checked in registration order, first match wins.

Implement these `extern "C"` functions:

- `snow_http_router() -> *mut u8` -- create empty router
- `snow_http_route(router: *mut u8, pattern: *const SnowString, handler_fn: *mut u8, handler_env: *mut u8) -> *mut u8` -- return NEW router with route added (immutable). Handler signature: `fn(request: *mut u8) -> *mut u8` (takes SnowHttpRequest, returns SnowHttpResponse).
- `snow_http_route_match(router: *mut u8, path: *const SnowString) -> *mut u8` -- internal: find matching route entry for a path. Returns pointer to RouteEntry or null if no match.

The Snow-level API looks like:
```snow
HTTP.router()
  |> HTTP.route("/", home_handler)
  |> HTTP.route("/api/*", api_handler)
  |> HTTP.serve(8080)
```

---

**Middleware (middleware.rs):**

Middleware is a composable request/response processor. A middleware function receives the request and a `next` callback, and returns a response. It can modify the request before calling next, modify the response after, or short-circuit by returning a response without calling next.

At the runtime level, middleware is stored as a closure (fn_ptr + env_ptr). The middleware signature is:
`fn(request: *mut u8, next_fn: *mut u8, next_env: *mut u8) -> *mut u8`

The middleware receives the request, and a `next` closure that represents the rest of the middleware chain + the route handler. Calling `next(request)` passes the request down the chain.

Implement:

- `snow_http_middleware(router: *mut u8, mw_fn: *mut u8, mw_env: *mut u8) -> *mut u8` -- return NEW router with middleware added to the chain. Middleware runs in registration order (first registered = outermost).

When the server dispatches a request:
1. Build the handler chain: start with the matched route handler as the innermost function
2. Wrap it with each middleware (in reverse registration order) so the first-registered middleware runs first
3. Call the outermost middleware with the request

For building the chain at runtime: create a chain of closures. Each middleware wraps the next handler. The final handler is the route handler. This can be done with a simple loop:

```rust
fn build_chain(middlewares: &[MiddlewareEntry], handler_fn: *mut u8, handler_env: *mut u8) -> (*mut u8, *mut u8) {
    let mut current_fn = handler_fn;
    let mut current_env = handler_env;
    for mw in middlewares.iter().rev() {
        // Create a closure that captures (mw.fn_ptr, mw.env_ptr, current_fn, current_env)
        // and calls mw.fn_ptr(mw.env_ptr, request, current_fn, current_env)
        let chain_env = allocate_chain_env(mw.fn_ptr, mw.env_ptr, current_fn, current_env);
        current_fn = chain_dispatch_fn as *mut u8;  // a trampoline function
        current_env = chain_env;
    }
    (current_fn, current_env)
}
```

The Snow-level API:
```snow
HTTP.router()
  |> HTTP.middleware(logger_middleware)
  |> HTTP.middleware(cors_middleware)
  |> HTTP.route("/", handler)
  |> HTTP.serve(8080)
```

Example middleware in Snow:
```snow
fn logger(request, next) do
  println("${Request.method(request)} ${Request.path(request)}")
  next(request)
end
```

---

**Static file serving (static_files.rs):**

- `snow_http_static(router: *mut u8, url_prefix: *const SnowString, dir_path: *const SnowString) -> *mut u8` -- return NEW router configured to serve static files from `dir_path` for URLs matching `url_prefix/*`.

When a request comes in and matches the static file URL prefix:
1. Strip the URL prefix from the path
2. Sanitize the remaining path (prevent directory traversal: reject `..`, resolve to absolute path within dir_path)
3. Check if the file exists at `dir_path + "/" + remaining_path`
4. If exists: read the file, guess Content-Type from extension (`.html` -> `text/html`, `.css` -> `text/css`, `.js` -> `application/javascript`, `.json` -> `application/json`, `.png` -> `image/png`, default `application/octet-stream`), return 200 with file contents
5. If not exists: fall through to next route (or return 404 if no other route matches)

The Snow-level API:
```snow
HTTP.router()
  |> HTTP.static("/public", "./static")
  |> HTTP.route("/api/*", api_handler)
  |> HTTP.serve(8080)
```

Static file routes are checked BEFORE regular routes (they act as a prefix match).

---

**HTTP Server with Actor-Per-Connection (server.rs):**

CRITICAL: This is NOT optional. The user decided on actor-per-connection. The actor runtime is fully functional (Phase 6-7).

`snow_http_serve(router: *mut u8, port: i64)`
- This function BLOCKS (runs the server loop indefinitely)
- Starts a `tiny_http::Server` listening on the given port
- For each incoming request:
  1. Parse the tiny_http::Request into a SnowHttpRequest (using request.rs functions)
  2. **Spawn an actor** via `snow_actor_spawn` to handle this request
  3. The actor's entry function receives the request data and the router as arguments
  4. Inside the actor:
     a. Check static file routes first
     b. If not a static file, match the request path against routes in the router
     c. Build the middleware chain for the matched route
     d. Call the middleware chain with the request
     e. Get the SnowHttpResponse back
     f. Send the HTTP response via tiny-http
  5. If no route matches, return 404

**Actor spawning approach:**

The actor runtime's `snow_actor_spawn(fn_ptr, args, args_size, priority)` takes a function pointer and opaque args. For HTTP handling:

1. Create a Rust-level wrapper function `http_handler_actor_entry` that is the actor's entry point
2. Pack the request data, router pointer, and the tiny_http `Request` handle into args
3. Spawn with `snow_actor_spawn(http_handler_actor_entry as *const u8, args_ptr, args_size, 1)` (Normal priority)

The challenge: tiny_http's `Request` must be responded to from the same thread (it owns the TCP stream). Two approaches:

**Approach A (channel-based):** The main server thread keeps the tiny_http Request. It creates a one-shot channel (std::sync::mpsc), packs the channel sender into the actor args. The actor processes the request, computes the response, and sends the SnowHttpResponse back through the channel. The main thread receives the response and calls `request.respond()`.

**Approach B (thread-based):** Use `std::thread::spawn` instead of `snow_actor_spawn` for the initial dispatch, then use actors within the thread. This doesn't satisfy the requirement.

**Approach C (actor with response sync):** Use a shared AtomicPtr or Mutex. The actor writes the response to a shared location. The main thread polls/waits for it.

**Recommended: Approach A.** It cleanly separates concerns:
```rust
fn snow_http_serve(router: *mut u8, port: i64) {
    let server = tiny_http::Server::http(format!("0.0.0.0:{}", port)).unwrap();
    for request in server.incoming_requests() {
        let snow_req = parse_request(&request);
        let (tx, rx) = std::sync::mpsc::sync_channel::<(*mut u8)>(1);

        // Pack args: router_ptr, snow_req_ptr, tx_ptr
        let args = pack_handler_args(router, snow_req, tx);

        // Spawn actor
        snow_actor_spawn(
            http_handler_actor_entry as *const u8,
            args.as_ptr(),
            args.len() as u64,
            1, // Normal priority
        );

        // Wait for actor to produce response
        let response_ptr = rx.recv().unwrap_or_else(|_| {
            // Actor crashed -- return 500
            create_500_response()
        });

        // Send HTTP response
        let response = unsafe { &*(response_ptr as *const SnowHttpResponse) };
        let body_str = unsafe { snow_string_to_rust(response.body) };
        let resp = tiny_http::Response::from_string(body_str)
            .with_status_code(response.status as u16);
        let _ = request.respond(resp);
    }
}

// Actor entry point -- runs inside an actor
extern "C" fn http_handler_actor_entry(args: *const u8, args_size: u64) {
    let (router, snow_req, tx) = unpack_handler_args(args, args_size);

    // Route matching + middleware chain + handler invocation
    let response = dispatch_request(router, snow_req);

    // Send response back to main thread
    tx.send(response).ok();
}
```

This gives true actor-per-connection: each request is processed inside an actor with its own stack, heap, and reduction budget. If the handler crashes (panic), the actor dies, the channel drops, and the main thread sends a 500 response. This is the Erlang model.

---

**HTTP Client (client.rs):**

`snow_http_get(url: *const SnowString) -> *mut u8`
- Uses `ureq::get(url).call()` to make a GET request
- Returns SnowResult: Ok(SnowString response body) or Err(SnowString error message)
- Handle connection errors, timeouts, non-2xx status codes

`snow_http_post(url: *const SnowString, body: *const SnowString) -> *mut u8`
- Uses `ureq::post(url).send_string(body)` to make a POST request
- Returns SnowResult: Ok(SnowString response body) or Err(SnowString error message)
- Set Content-Type to "application/json" if body looks like JSON (starts with `{` or `[`), otherwise "text/plain"

---

**mod.rs:** Re-export all submodules. `pub mod server; pub mod router; pub mod middleware; pub mod static_files; pub mod request; pub mod client;`

Add unit tests:
- Router: test exact match, wildcard match, no-match returns null
- Middleware chain: test that middleware wraps correctly (outer runs first)
- Static files: test path sanitization (reject `../` traversal)
- Request parsing: test query string parsing `?foo=bar&baz=qux`
- Client: test against a mock or verify compilation
  </action>
  <verify>
`cargo test -p snow-rt` -- HTTP router, middleware, static file, request parsing, and client tests pass. `cargo build -p snow-rt` -- staticlib builds with tiny-http and ureq linked.
  </verify>
  <done>
HTTP server with actor-per-connection (using snow_actor_spawn), Router with exact/wildcard matching, middleware chain, static file serving, request parsing (query params, headers, body), and HTTP client (GET, POST) all implemented. Actor isolation means crashed handlers return 500 without taking down the server.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline, E2E tests, and success criteria verification</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
**Type checker -- builtins.rs**: Register HTTP types and functions:

Register opaque types for the HTTP module:
- `Router` -- opaque pointer type (resolves to MirType::Ptr)
- `Request` -- opaque pointer type
- `Response` -- opaque pointer type

Register HTTP module functions in the "HTTP" stdlib module:
- `http_router` : `() -> Router` -- create empty router
- `http_route` : `(Router, String, (Request) -> Response) -> Router` -- add a route with handler
- `http_middleware` : `(Router, (Request, (Request) -> Response) -> Response) -> Router` -- add middleware
- `http_static` : `(Router, String, String) -> Router` -- static file serving (url_prefix, dir_path)
- `http_serve` : `(Router, Int) -> ()` -- start server on port (blocks)
- `http_get` : `(String) -> Result<String, String>` -- HTTP GET client
- `http_post` : `(String, String) -> Result<String, String>` -- HTTP POST client
- `http_response` : `(Int, String) -> Response` -- create response with status + body

Register Request accessor functions in the "Request" stdlib module (or as methods):
- `request_method` : `(Request) -> String`
- `request_path` : `(Request) -> String`
- `request_body` : `(Request) -> String`
- `request_header` : `(Request, String) -> Option<String>`
- `request_query` : `(Request, String) -> Option<String>`
- `request_query_params` : `(Request) -> Map<String, String>`
- `request_headers` : `(Request) -> Map<String, String>`

Add "HTTP" to stdlib_modules with "router", "route", "middleware", "static", "serve", "get", "post", "response" entries.
Add "Request" to stdlib_modules with "method", "path", "body", "header", "query", "query_params", "headers" entries.

**Intrinsics**: Declare LLVM signatures:
- `snow_http_router() -> ptr`
- `snow_http_route(ptr, ptr, ptr, ptr) -> ptr` (router, pattern, handler_fn, handler_env)
- `snow_http_middleware(ptr, ptr, ptr) -> ptr` (router, mw_fn, mw_env)
- `snow_http_static(ptr, ptr, ptr) -> ptr` (router, url_prefix, dir_path)
- `snow_http_serve(ptr, i64) -> void` (router, port)
- `snow_http_get(ptr) -> ptr` (url -> result)
- `snow_http_post(ptr, ptr) -> ptr` (url, body -> result)
- `snow_http_response_new(i64, ptr) -> ptr` (status, body -> response)
- `snow_http_request_method(ptr) -> ptr`
- `snow_http_request_path(ptr) -> ptr`
- `snow_http_request_body(ptr) -> ptr`
- `snow_http_request_header(ptr, ptr) -> ptr` (request, header_name -> Option)
- `snow_http_request_query(ptr, ptr) -> ptr` (request, param_name -> Option)
- `snow_http_request_query_params(ptr) -> ptr`
- `snow_http_request_headers(ptr) -> ptr`

**MIR lowering**: Add name mappings and known_functions entries for all HTTP and Request functions.

IMPORTANT: Handler and middleware closures passed to `http_route` and `http_middleware` must have their fn_ptr and env_ptr extracted. The lowerer needs to extract fn_ptr and env_ptr from the closure value and pass them as separate arguments. The closure is a `{ ptr fn, ptr env }` struct. The codegen should emit extractvalue to get the two pointers.

**E2E tests**:

1. **HTTP client GET** -- Make a GET request to a known public URL (or skip if no network in CI). Test the compilation at minimum:
```snow
fn main() do
  let result = HTTP.get("http://httpbin.org/get")
  case result do
    Ok(body) -> println("Got response")
    Err(msg) -> println("Error: ${msg}")
  end
end
```
Verify it compiles and runs (may timeout if no network).

2. **Router-based server with routing** -- Compile a program that uses the Router API with multiple routes:
```snow
fn home(request) do
  HTTP.response(200, "{\"message\":\"Hello from Snow!\"}")
end

fn api_handler(request) do
  let path = Request.path(request)
  HTTP.response(200, "{\"endpoint\":\"${path}\"}")
end

fn main() do
  HTTP.router()
    |> HTTP.route("/", home)
    |> HTTP.route("/api/*", api_handler)
    |> HTTP.serve(8080)
end
```
Verify compilation succeeds. For runtime test: start server in background, curl `/` and `/api/test`, kill server, check output.

3. **Middleware test** -- Compile a program that uses middleware:
```snow
fn logger(request, next) do
  println("${Request.method(request)} ${Request.path(request)}")
  next(request)
end

fn handler(request) do
  HTTP.response(200, "OK")
end

fn main() do
  HTTP.router()
    |> HTTP.middleware(logger)
    |> HTTP.route("/", handler)
    |> HTTP.serve(8080)
end
```
Verify compilation. Middleware should print the request log before the handler runs.

4. **Static file serving** -- Compile a program that serves static files:
```snow
fn main() do
  HTTP.router()
    |> HTTP.static("/public", "./static")
    |> HTTP.route("/api/health", fn(req) -> HTTP.response(200, "ok") end)
    |> HTTP.serve(8080)
end
```
Verify compilation. Create a test `./static/index.html`, start server, curl `/public/index.html`.

5. **Request parsing** -- Compile a program that reads query params and headers:
```snow
fn handler(request) do
  let name = Request.query(request, "name")
  case name do
    Some(n) -> HTTP.response(200, "Hello ${n}")
    None -> HTTP.response(400, "Missing name param")
  end
end

fn main() do
  HTTP.router()
    |> HTTP.route("/greet", handler)
    |> HTTP.serve(8080)
end
```
Verify compilation. Test with `curl "http://localhost:8080/greet?name=Snow"`.

6. **JSON API server (key success criterion)** -- Full integration test:
```snow
fn main() do
  HTTP.router()
    |> HTTP.route("/", fn(req) -> HTTP.response(200, "{\"message\":\"Hello from Snow!\"}") end)
    |> HTTP.route("/api/*", fn(req) -> HTTP.response(200, JSON.encode_map(Map.new() |> Map.put("status", "ok"))) end)
    |> HTTP.serve(8080)
end
```
This verifies the HTTP+JSON success criterion.

7. **Verify all 4 success criteria**:
   - SC1: File read + process + write (from Plan 03)
   - SC2: HTTP server with JSON responses (this plan)
   - SC3: List map/filter/reduce with pipe chains (from Plan 02)
   - SC4: Standard I/O -- print works, IO.read_line available (from Plan 01)

Write verification programs for SC2 (HTTP+JSON) and SC4 (stdin input program) and verify they compile.
  </action>
  <verify>
`cargo test --workspace` -- all tests pass. HTTP client/server compile and link correctly. A Snow program using `http_serve` and `http_get` compiles to a working native binary. All four Phase 8 success criteria are met.
  </verify>
  <done>
HTTP module fully integrated with actor-per-connection, routing, middleware, static files, and request parsing. Snow programs can build HTTP servers using `HTTP.router() |> HTTP.route(...) |> HTTP.middleware(...) |> HTTP.static(...) |> HTTP.serve(port)`. Each request spawns an actor. All four Phase 8 success criteria verified: (1) file read+process+write, (2) HTTP server with JSON, (3) collection pipe chains, (4) standard I/O.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. `cargo build --workspace` -- clean build with tiny-http and ureq
3. Snow program with `HTTP.router() |> HTTP.route("/", handler) |> HTTP.serve(8080)` compiles to working binary
4. Snow program with `HTTP.get(url)` makes HTTP requests and returns Result
5. Each HTTP request spawns an actor via snow_actor_spawn (actor-per-connection)
6. Crashed handler actors return 500 without taking down the server (actor isolation)
7. Router matches exact paths and wildcard patterns correctly
8. Middleware chain runs in registration order, can modify request/response
9. Static file serving reads files from disk and returns with correct Content-Type
10. Request.query(req, "name") extracts query parameters correctly
11. All four Phase 8 success criteria verified

**Phase 8 Success Criteria Check:**
- [SC1] A Snow program can read a file, process its contents with string and list operations, and write output to another file
- [SC2] A Snow program can start an HTTP server that accepts requests and returns JSON responses
- [SC3] List operations (map, filter, reduce) and Map operations work with full type inference and pipe operator chaining
- [SC4] Standard I/O (print, read from stdin) works for interactive CLI programs
</verification>

<success_criteria>
- Actor-per-connection: each HTTP request spawns an actor via snow_actor_spawn (NOT synchronous handler)
- Router: HTTP.router() |> HTTP.route(path, handler) with exact and wildcard matching
- Middleware: HTTP.middleware(router, mw_fn) composable chain runs before handler
- Static files: HTTP.static(router, url_prefix, dir_path) serves files from disk
- Request parsing: query params, headers, and body accessible via Request module functions
- HTTP.serve(router, port) starts the server using the router (blocks)
- HTTP.get and HTTP.post make HTTP requests and return Result<String, String>
- Actor isolation: crashed handler actors produce 500 response, server continues
- tiny-http and ureq dependencies added and linking correctly
- All four Phase 8 success criteria verified in E2E tests
- Full workspace compiles and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-05-SUMMARY.md`
</output>
