---
phase: 08-standard-library
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snowc/tests/e2e_stdlib.rs
  - tests/e2e/stdlib_list_pipe_chain.snow
  - tests/e2e/stdlib_io_read_line.snow
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "A Snow program using list |> map(fn) |> filter(fn) |> reduce(init, fn) compiles and produces correct output"
    - "A Snow program using IO.read_line() compiles and runs through the full compiler pipeline"
  artifacts:
    - path: "tests/e2e/stdlib_list_pipe_chain.snow"
      provides: "Pipe chain E2E fixture with closures"
    - path: "tests/e2e/stdlib_io_read_line.snow"
      provides: "IO.read_line E2E fixture"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "Two new E2E test functions"
  key_links:
    - from: "tests/e2e/stdlib_list_pipe_chain.snow"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "Pipe operator desugaring -> map/filter/reduce intrinsics -> runtime HOF calls"
      pattern: "snow_list_map|snow_list_filter|snow_list_reduce"
    - from: "tests/e2e/stdlib_io_read_line.snow"
      to: "crates/snow-rt/src/io.rs"
      via: "IO.read_line module-qualified access -> snow_io_read_line intrinsic"
      pattern: "snow_io_read_line"
---

<objective>
Close two verification gaps from Phase 8: (1) missing E2E test for pipe operator chaining with collection higher-order functions and closures, (2) missing E2E test for IO.read_line through the full compiler pipeline.

Purpose: Phase 8 Success Criterion 3 requires "pipe operator chaining" with map/filter/reduce, and Success Criterion 4 requires stdin I/O. Runtime implementations exist and unit tests pass, but no E2E test proves these work through the full compile-and-run cycle with Snow closures.

Output: Two new Snow test fixtures and two new Rust E2E test functions in e2e_stdlib.rs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-02-SUMMARY.md
@.planning/phases/08-standard-library/08-01-SUMMARY.md
@crates/snowc/tests/e2e_stdlib.rs
@tests/e2e/stdlib_list_basic.snow
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pipe chain E2E test with closures</name>
  <files>
    tests/e2e/stdlib_list_pipe_chain.snow
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Create a Snow test fixture `tests/e2e/stdlib_list_pipe_chain.snow` that demonstrates pipe operator chaining with closures through the full compiler pipeline.

**IMPORTANT — Multiline pipe limitation:** The Snow parser does NOT support multiline pipe chains (pipe operator `|>` at start of continuation line fails to parse). All pipe expressions MUST be on a single line, or use intermediate `let` bindings.

The fixture should:
1. Create a list with `List.new()` and `List.append()` calls to build a list of integers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
2. Use pipe chains with closures to transform: `list |> map(fn(x) -> x * 2 end) |> filter(fn(x) -> x > 10 end) |> reduce(0, fn(acc, x) -> acc + x end)`
   - Since multiline pipes don't work, use intermediate let bindings:
     ```
     let doubled = map(list, fn(x) -> x * 2 end)
     let filtered = filter(doubled, fn(x) -> x > 10 end)
     let sum = reduce(filtered, 0, fn(acc, x) -> acc + x end)
     ```
   - OR use single-line pipe: `let result = list |> map(fn(x) -> x * 2 end)`
3. Print the final result

**Expected computation:**
- Input: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
- After map(x * 2): [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
- After filter(x > 10): [12, 14, 16, 18, 20]
- After reduce(0, acc + x): 80

Use prelude names (map, filter, reduce) which are auto-imported and resolve to List operations per 08-02 decisions.

**NOTE on reduce argument order:** Check the type registration in builtins.rs. The Snow `reduce` function takes `(list, initial_value, fn)` — collection-first convention. The runtime `snow_list_reduce` takes `(list_ptr, init_val, fn_ptr, env_ptr)`.

Add a Rust E2E test function `e2e_list_pipe_chain` in `crates/snowc/tests/e2e_stdlib.rs` that:
- Reads the fixture with `read_fixture("stdlib_list_pipe_chain.snow")`
- Calls `compile_and_run()`
- Asserts output is `"80\n"`
  </action>
  <verify>
Run `cargo test -p snowc --test e2e_stdlib e2e_list_pipe_chain` — test passes with output "80\n".
  </verify>
  <done>
A Snow program with list pipe chains using closures (map, filter, reduce) compiles and runs correctly through the full compiler pipeline, producing the expected computed result.
  </done>
</task>

<task type="auto">
  <name>Task 2: IO.read_line E2E compilation test</name>
  <files>
    tests/e2e/stdlib_io_read_line.snow
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Create a Snow test fixture `tests/e2e/stdlib_io_read_line.snow` that uses `IO.read_line()` and compiles through the full pipeline.

**Testing approach:** Since IO.read_line blocks waiting for stdin input, we cannot use the standard `compile_and_run` helper (it would hang). Instead:

Option A (preferred): Use `compile_and_run_with_stdin` — create a new helper function in e2e_stdlib.rs that pipes stdin to the binary:
```rust
fn compile_and_run_with_stdin(source: &str, stdin_input: &str) -> String {
    // Same as compile_and_run but uses .stdin(Stdio::piped()) and writes stdin_input
    // before waiting for output
}
```

The helper should:
1. Compile the Snow source using `snowc build`
2. Start the binary with `Command::new(&binary).stdin(Stdio::piped()).stdout(Stdio::piped()).spawn()`
3. Write `stdin_input` to the child's stdin, then drop stdin to signal EOF
4. Wait for child to complete and capture stdout
5. Assert the child exited successfully

Option B (fallback if runtime issues): Use `compile_only` to just verify compilation succeeds, similar to HTTP tests. This is less ideal but still closes the "never tested through compiler" gap.

The Snow fixture should:
```snow
fn main() do
  let result = IO.read_line()
  case result do
    Ok(line) -> println(line)
    Err(msg) -> println("error")
  end
end
```

Add a Rust E2E test `e2e_io_read_line` that:
- With Option A: Passes "hello world\n" as stdin, asserts output is "hello world\n"
- With Option B: Uses compile_only(), asserts compilation succeeds

**Prefer Option A.** Only fall back to Option B if the binary crashes or hangs.
  </action>
  <verify>
Run `cargo test -p snowc --test e2e_stdlib e2e_io_read_line` — test passes (either with stdin piping or compile-only verification).
  </verify>
  <done>
A Snow program using IO.read_line() compiles (and ideally runs with piped stdin) through the full compiler pipeline, verifying the IO module's stdin function works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snowc --test e2e_stdlib e2e_list_pipe_chain` passes
2. `cargo test -p snowc --test e2e_stdlib e2e_io_read_line` passes
3. All existing 25+ E2E stdlib tests still pass: `cargo test -p snowc --test e2e_stdlib`
4. Full workspace builds: `cargo build --workspace`
</verification>

<success_criteria>
- Pipe chain E2E test produces "80\n" (map * 2, filter > 10, reduce sum)
- IO.read_line E2E test compiles and runs (or at minimum compiles) through full pipeline
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-06-SUMMARY.md`
</output>
