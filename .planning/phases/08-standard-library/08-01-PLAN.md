---
phase: 08-standard-library
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/string.rs
  - crates/snow-rt/src/io.rs
  - crates/snow-rt/src/env.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "String operations (length, split, trim, contains, replace, slice, starts_with, ends_with, to_upper, to_lower) work from Snow source code"
    - "IO.read_line() reads a line from stdin and returns Result<String, String>"
    - "IO.eprintln() prints to stderr"
    - "Env.get(key) returns Option<String> for environment variable access"
    - "Env.args() returns a List<String> of CLI arguments"
    - "Module-qualified access (String.length, IO.read_line, Env.get) resolves correctly in type checker and codegen"
    - "from Module import func syntax injects stdlib names into local scope"
  artifacts:
    - path: "crates/snow-rt/src/string.rs"
      provides: "String operation runtime functions"
      contains: "snow_string_length"
    - path: "crates/snow-rt/src/io.rs"
      provides: "Console I/O runtime functions (stdin, stderr)"
      contains: "snow_io_read_line"
    - path: "crates/snow-rt/src/env.rs"
      provides: "Environment variable and CLI args access"
      contains: "snow_env_get"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Type registrations for all stdlib functions"
      contains: "string_length"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Module namespace resolution for from/import"
      contains: "stdlib_modules"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for all new runtime functions"
      contains: "snow_string_length"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Name mapping and module-qualified access resolution"
      contains: "string_length"
  key_links:
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "crates/snow-rt/src/string.rs"
      via: "Type signatures match runtime function signatures"
      pattern: "string_length.*Ty::fun"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "map_builtin_name output matches intrinsic declaration name"
      pattern: "snow_string_length"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "stdlib_modules references same names registered as builtins"
      pattern: "stdlib_modules"
---

<objective>
Implement string operations, console I/O, environment access, and the module/import namespace resolution that all subsequent stdlib plans depend on.

Purpose: This is the foundation plan for Phase 8. It establishes the stdlib module infrastructure (how `String.length`, `from IO import read_line`, etc. resolve through the compiler pipeline) and delivers the first batch of stdlib functions. Every subsequent plan depends on this module resolution mechanism.

Output: String operations, IO module (stdin/stderr), Env module, and working module-qualified + from/import resolution for stdlib names.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-standard-library/08-RESEARCH.md

Key existing files to understand:
@crates/snow-rt/src/string.rs -- existing SnowString and string functions (extend this)
@crates/snow-typeck/src/builtins.rs -- existing builtin registration (extend this)
@crates/snow-typeck/src/infer.rs -- line 452: ImportDecl/FromImportDecl currently return None (implement module resolution here)
@crates/snow-codegen/src/codegen/intrinsics.rs -- existing intrinsic declarations (extend this)
@crates/snow-codegen/src/mir/lower.rs -- map_builtin_name function (extend this), known_functions (extend this)
@crates/snow-codegen/src/mir/types.rs -- MirType enum and resolve_type (may need List type mapping)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Runtime functions -- String operations, IO, and Env</name>
  <files>
    crates/snow-rt/src/string.rs
    crates/snow-rt/src/io.rs
    crates/snow-rt/src/env.rs
    crates/snow-rt/src/lib.rs
    crates/snow-rt/Cargo.toml
  </files>
  <action>
**String operations** -- Extend `crates/snow-rt/src/string.rs` with these `#[no_mangle] pub extern "C"` functions following the existing SnowString pattern:

- `snow_string_length(s: *const SnowString) -> i64` -- returns codepoint count (iterate UTF-8, count chars, NOT byte length)
- `snow_string_slice(s: *const SnowString, start: i64, end: i64) -> *mut SnowString` -- codepoint-based slice (0-indexed, exclusive end). Clamp to bounds.
- `snow_string_contains(haystack: *const SnowString, needle: *const SnowString) -> i8` -- 1 if contains, 0 otherwise
- `snow_string_starts_with(s: *const SnowString, prefix: *const SnowString) -> i8` -- boolean
- `snow_string_ends_with(s: *const SnowString, suffix: *const SnowString) -> i8` -- boolean
- `snow_string_trim(s: *const SnowString) -> *mut SnowString` -- trim whitespace both sides
- `snow_string_to_upper(s: *const SnowString) -> *mut SnowString` -- uppercase
- `snow_string_to_lower(s: *const SnowString) -> *mut SnowString` -- lowercase
- `snow_string_replace(s: *const SnowString, from: *const SnowString, to: *const SnowString) -> *mut SnowString` -- replace all occurrences
- `snow_string_split(s: *const SnowString, delimiter: *const SnowString) -> *mut SnowList` -- split into List of strings. NOTE: This depends on SnowList from Plan 02. For now, return a `*mut u8` (raw pointer) that represents an opaque list. Define a minimal `SnowList` struct in string.rs or a shared location so this compiles. The full List integration comes in Plan 02; here just allocate the split results into a contiguous memory layout that Plan 02's SnowList can consume.

IMPORTANT: For `snow_string_split`, since List doesn't exist yet, implement it as returning a pointer to a packed array: `[u64 count, ptr elem0, ptr elem1, ...]` where each elem is a `*mut SnowString`. This is a temporary representation that Plan 02 will wire into the proper List type. Alternatively, if this creates too much complexity, SKIP `snow_string_split` in this plan and defer it to Plan 02 when List exists.

All string functions use Rust's `str` methods via `as_str()` for correctness. Allocate new strings via `snow_string_new`.

**Console I/O** -- Create `crates/snow-rt/src/io.rs`:

- `snow_io_read_line() -> *mut SnowResult` -- reads a line from stdin. Returns SnowResult where tag=0 (Ok) with SnowString value on success, tag=1 (Err) with error message string on failure. Define `#[repr(C)] pub struct SnowResult { pub tag: u8, pub value: *mut u8 }` in this file (or in a shared types module).
- `snow_io_eprintln(s: *const SnowString)` -- print to stderr with newline

For SnowResult: Use the same tagged union representation as Snow's Result sum type. Tag 0 = Ok (variant index 0), Tag 1 = Err (variant index 1). The value pointer points to the payload. This must match how the codegen lays out Result variants (check `crates/snow-codegen/src/codegen/expr.rs` for how Result/Option are constructed -- they use tag + payload in an alloca).

**Environment access** -- Create `crates/snow-rt/src/env.rs`:

- `snow_env_get(key: *const SnowString) -> *mut u8` -- returns SnowResult-style tagged value. Tag 0 = Some(string), Tag 1 = None. Uses `std::env::var()`.
- `snow_env_args() -> *mut u8` -- returns a packed array of strings (same temp format as split). This will be properly wired to List<String> in Plan 02.

**Wire up modules** -- In `crates/snow-rt/src/lib.rs`, add `pub mod io;` and `pub mod env;`. No changes to Cargo.toml needed (all implementations use only Rust stdlib).

Add unit tests for all new runtime functions (follow the existing test pattern in string.rs -- call `snow_rt_init()` first, then test each function).
  </action>
  <verify>
Run `cargo test -p snow-rt` -- all new tests pass. Run `cargo build -p snow-rt` -- library compiles as staticlib.
  </verify>
  <done>
All string operation functions, IO functions (read_line, eprintln), and Env functions (get, args) compile and pass unit tests. SnowResult struct defined for Result-returning functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline -- type registration, intrinsics, name mapping, and module resolution</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**Type checker -- builtins.rs**: Extend `register_builtins()` to register all new stdlib functions. Follow the existing pattern (Scheme::mono with Ty::fun). Register these with their Snow-facing names:

String operations (prelude -- bare names):
- `string_length` : `(String) -> Int`
- `string_slice` : `(String, Int, Int) -> String`
- `string_contains` : `(String, String) -> Bool`
- `string_starts_with` : `(String, String) -> Bool`
- `string_ends_with` : `(String, String) -> Bool`
- `string_trim` : `(String) -> String`
- `string_to_upper` : `(String) -> String`
- `string_to_lower` : `(String) -> String`
- `string_replace` : `(String, String, String) -> String`

IO functions:
- `io_read_line` : `() -> Result<String, String>`
- `io_eprintln` : `(String) -> ()`

Env functions:
- `env_get` : `(String) -> Option<String>`

For `Result<String, String>` and `Option<String>` return types, use `Ty::result(Ty::string(), Ty::string())` and `Ty::option(Ty::string())` respectively.

**Type checker -- infer.rs**: Implement minimal module namespace resolution. Add a `stdlib_modules` registry (a `HashMap<String, HashMap<String, Scheme>>`) that maps module names to their exported function names and types. Populate it with:
- "String" -> { "length" -> (String) -> Int, "slice" -> ..., "contains" -> ..., etc. }
- "IO" -> { "read_line" -> () -> Result<String, String>, "eprintln" -> (String) -> () }
- "Env" -> { "get" -> (String) -> Option<String>, "args" -> () -> List<String> }

In the match arm for `Item::FromImportDecl(decl)`:
1. Extract the module name and imported names from the CST
2. Look up the module in `stdlib_modules`
3. For each imported name, insert the corresponding Scheme into the current TypeEnv
4. Return None (imports don't produce a value)

For `Item::ImportDecl(decl)`: Record the module name as "available for qualified access" in a set on the inference context or environment. When encountering a FieldAccess expression where the object is a known module name (e.g., `String.length`), resolve it as a direct function reference rather than a field access on a value. This may require changes in the expression inference code path where FieldAccess is handled.

IMPORTANT: Check how FieldAccess is currently inferred in infer.rs. If it tries to look up a field on a struct, module names will fail. Add a check: if the object of FieldAccess resolves to a known module name (from stdlib_modules or import set), treat the entire expression as a function reference with the qualified name (e.g., "string_length" for String.length).

**Intrinsics -- intrinsics.rs**: Add LLVM function declarations for all new runtime functions. Follow the existing pattern:
- String ops: all take `ptr` args and return `ptr` or `i64` or `i8`
- IO: `snow_io_read_line() -> ptr`, `snow_io_eprintln(ptr) -> void`
- Env: `snow_env_get(ptr) -> ptr`

**MIR lowering -- lower.rs**:
1. Extend `map_builtin_name` to map all new Snow names to runtime names:
   - `"string_length" => "snow_string_length"`, etc.
   - `"io_read_line" => "snow_io_read_line"`, etc.
   - `"env_get" => "snow_env_get"`, etc.

2. Register all new functions in `known_functions` (in the Lowerer::new or init section where println/print are registered).

3. Handle module-qualified access in the lowering: When lowering a FieldAccess where the object is a module name (String, IO, Env), convert it to a Var with the concatenated name (e.g., `String.length` -> `string_length` which then maps to `snow_string_length` via map_builtin_name).

Add a set of known module names in the lowerer: `["String", "IO", "Env", "File", "List", "Map", "Set", "HTTP", "JSON"]`. When the lowerer encounters FieldAccess and the object is a Var whose name is in this set, emit `MirExpr::Var("{module_lower}_{field}", ...)` instead of the normal struct field access.

Run `cargo test -p snow-typeck` and `cargo test -p snow-codegen` after changes.
  </action>
  <verify>
`cargo test -p snow-typeck` passes (builtins test, module resolution). `cargo test -p snow-codegen` passes (intrinsics test updated to check new functions). `cargo build --workspace` succeeds with no errors.
  </verify>
  <done>
All string/IO/Env functions registered in type checker, declared in intrinsics, mapped in MIR lowerer. Module-qualified access (String.length, IO.read_line, Env.get) resolves through the full pipeline. from/import injects names into scope.
  </done>
</task>

<task type="auto">
  <name>Task 3: E2E integration tests for string ops, IO, and module resolution</name>
  <files>
    crates/snowc/tests/e2e.rs
  </files>
  <action>
Add end-to-end tests to `crates/snowc/tests/e2e.rs` (or a new `e2e_stdlib.rs` if the file is getting large). Use the existing `compile_and_run` test helper.

Test cases:

1. **String.length** -- Snow program that calls `string_length("hello")` and prints the result. Expected output: "5".

2. **String.contains** -- `string_contains("hello world", "world")` returning true. Print the boolean result.

3. **String.trim** -- `string_trim("  hello  ")` returns "hello".

4. **String.to_upper / to_lower** -- Verify case conversion.

5. **String.replace** -- `string_replace("hello world", "world", "snow")` returns "hello snow".

6. **Module-qualified access** -- Snow program using `String.length("test")` syntax (FieldAccess on module name). This is the critical test for module resolution.

7. **from import syntax** -- Snow program with `from String import length` then calling `length("test")`. This verifies FromImportDecl resolution.

8. **IO.eprintln** -- Snow program calling `io_eprintln("error message")`. Verify it compiles and runs (stderr output won't show in compile_and_run, but the program should not crash).

If module-qualified access (Test 6) requires parser changes for the FieldAccess lowering path, note this and adjust. The parser already handles `X.y` as FieldAccess, so it should work if the type checker and lowerer handle the module name correctly.

NOTE: IO.read_line and Env.args are hard to test in E2E (they need stdin/env setup). Test them via unit tests in snow-rt only for now.
  </action>
  <verify>
`cargo test -p snowc --test e2e_stdlib` (or the appropriate test target) -- all string and module resolution E2E tests pass. `cargo test --workspace` -- full suite green.
  </verify>
  <done>
E2E tests verify: string operations produce correct output from compiled Snow programs, module-qualified access (String.length) works, from/import syntax resolves correctly. Full workspace test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (existing + new)
2. `cargo build --workspace` -- clean build
3. A Snow program using `String.length("hello")` compiles and prints "5"
4. A Snow program using `from String import length` then `length("test")` compiles correctly
5. A Snow program using `string_trim("  hi  ")` prints "hi"
6. Runtime unit tests for IO.read_line and Env.get pass
</verification>

<success_criteria>
- All string operations (length, trim, contains, replace, starts_with, ends_with, to_upper, to_lower, slice) available as both bare names and module-qualified (String.length)
- IO.read_line returns Result<String, String>, IO.eprintln writes to stderr
- Env.get returns Option<String>
- Module-qualified access (Module.function) works through type checker and codegen
- from Module import function syntax injects names into scope
- Full workspace compiles and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-standard-library/08-01-SUMMARY.md`
</output>
