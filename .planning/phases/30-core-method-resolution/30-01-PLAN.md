---
phase: 30-core-method-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/src/infer.rs
autonomous: true

must_haves:
  truths:
    - "Method resolution searches all trait impl blocks for the receiver's concrete type"
    - "infer_field_access returns the method's full function type when a trait method matches"
    - "Calling a nonexistent method produces a NoSuchMethod error, not NoSuchField"
    - "Ambiguous methods (multiple traits) produce AmbiguousMethod error"
    - "Struct field access, module-qualified access, service methods, and variant construction all continue to work unchanged"
  artifacts:
    - path: "crates/snow-typeck/src/error.rs"
      provides: "NoSuchMethod error variant"
      contains: "NoSuchMethod"
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "NoSuchMethod diagnostic rendering with E0030 code"
      contains: "NoSuchMethod"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Method resolution fallback in infer_field_access after struct field lookup fails"
      contains: "resolve_trait_method"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/traits.rs"
      via: "trait_registry.resolve_trait_method in infer_field_access"
      pattern: "trait_registry\\.resolve_trait_method"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "NoSuchMethod error emission"
      pattern: "TypeError::NoSuchMethod"
---

<objective>
Add method resolution to the Snow type checker so that `value.method(args)` resolves to trait impl methods, with the receiver's function type returned for arity/type checking by `infer_call`.

Purpose: This is the type-checking half of method dot-syntax (METH-01, METH-02, METH-03, DIAG-01). Without it, `point.to_string()` either produces a NoSuchField error (if `point` is a struct) or returns a fresh type variable (if the base type has no struct def). The type checker must recognize method calls and resolve them through the TraitRegistry.

Output: Type checker correctly infers method call types, emits NoSuchMethod for invalid methods, and emits AmbiguousMethod for multi-trait conflicts.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-core-method-resolution/30-RESEARCH.md

@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-typeck/src/traits.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NoSuchMethod error variant and diagnostic rendering</name>
  <files>crates/snow-typeck/src/error.rs, crates/snow-typeck/src/diagnostics.rs</files>
  <action>
Add a new `TypeError::NoSuchMethod` variant to error.rs, positioned after `NoSuchField` (line ~119):

```rust
NoSuchMethod {
    ty: Ty,
    method_name: String,
    span: TextRange,
},
```

Add its `Display` impl in the match block (after the NoSuchField arm):
```rust
TypeError::NoSuchMethod { ty, method_name, .. } => {
    write!(f, "no method `{}` on type `{}`", method_name, ty)
}
```

In diagnostics.rs:

1. Add error code mapping in `error_code()`: `TypeError::NoSuchMethod { .. } => "E0030"` (next available code after E0029).

2. Add span extraction in the large match that extracts spans (~line 465): add `TypeError::NoSuchMethod { span, .. }` to the existing group that includes `NoSuchField { span, .. }`.

3. Add diagnostic rendering in the report-building match (after the NoSuchField rendering at ~line 875):
```rust
TypeError::NoSuchMethod { ty, method_name, span } => {
    let msg = format!("no method `{}` on type `{}`", method_name, ty);
    let range = clamp(text_range_to_range(*span));
    Report::build(ReportKind::Error, range.clone())
        .with_code(code)
        .with_message(&msg)
        .with_config(config)
        .with_label(
            Label::new(range)
                .with_message(format!("method `{}` not found", method_name))
                .with_color(Color::Red),
        )
        .with_help(format!(
            "type `{}` has no trait impl providing `{}`",
            ty, method_name
        ))
        .finish()
}
```

This directly addresses requirement DIAG-01: "no method `x` on type `Y`" instead of "no field".
  </action>
  <verify>Run `cargo check -p snow-typeck` -- compiles with no errors. The new variant is exhaustively handled in all match blocks.</verify>
  <done>NoSuchMethod variant exists in TypeError, has Display impl, has E0030 error code, has diagnostic rendering with help text. Compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Add method resolution fallback in infer_field_access and method-call detection in infer_call</name>
  <files>crates/snow-typeck/src/infer.rs</files>
  <action>
Two changes in infer.rs:

**Change 1: Add `is_method_call: bool` parameter to `infer_field_access`.**

Update the signature of `infer_field_access` (line ~3879) to add `is_method_call: bool` as the last parameter. This flag indicates whether the FieldAccess is the callee of a CallExpr (meaning the user wrote `expr.name(...)`, not just `expr.name`).

Find all call sites of `infer_field_access` in the file. There should be one in the main `infer_expr` dispatch and possibly one in `infer_call`. For all existing call sites, pass `false` as the `is_method_call` argument (preserving existing behavior).

**Change 2: Add method resolution fallback in `infer_field_access`.**

After the struct field lookup fails (line ~3981, the block that currently creates `TypeError::NoSuchField`), add method resolution before emitting the error:

```rust
// After struct field lookup loop ends without returning (field not found):
// Try method resolution via trait registry (step 5 in resolution priority)
if is_method_call {
    // Check for ambiguous methods first
    let matching_traits = trait_registry.find_method_traits(&field_name, &resolved_base);
    if matching_traits.len() > 1 {
        let err = TypeError::AmbiguousMethod {
            method_name: field_name.clone(),
            candidate_traits: matching_traits,
            ty: resolved_base.clone(),
        };
        ctx.errors.push(err.clone());
        return Err(err);
    }
    // Try to resolve the method's return type and build the full function type
    if let Some(ret_ty) = trait_registry.resolve_trait_method(&field_name, &resolved_base) {
        // Build the method's full function type: Fun([self_type, ...other_params], ret_type)
        // Look up the method signature to get parameter types
        let method_fn_ty = build_method_fn_type(trait_registry, &field_name, &resolved_base, &ret_ty, ctx);
        return Ok(method_fn_ty);
    }
    // Method not found -- emit NoSuchMethod (not NoSuchField)
    let err = TypeError::NoSuchMethod {
        ty: resolved_base,
        method_name: field_name,
        span: fa.syntax().text_range(),
    };
    ctx.errors.push(err.clone());
    return Err(err);
}
// Existing NoSuchField error (only when NOT a method call context)
```

Also handle the case where `struct_name` is None but `is_method_call` is true (base type is not a struct, e.g., a primitive or type variable). Add this check before the final `Ok(ctx.fresh_var())` fallback at line ~3992:

```rust
if is_method_call {
    // Check trait methods for non-struct types too (primitives handled in Phase 31)
    let matching_traits = trait_registry.find_method_traits(&field_name, &resolved_base);
    if matching_traits.len() > 1 {
        let err = TypeError::AmbiguousMethod {
            method_name: field_name.clone(),
            candidate_traits: matching_traits,
            ty: resolved_base.clone(),
        };
        ctx.errors.push(err.clone());
        return Err(err);
    }
    if let Some(ret_ty) = trait_registry.resolve_trait_method(&field_name, &resolved_base) {
        let method_fn_ty = build_method_fn_type(trait_registry, &field_name, &resolved_base, &ret_ty, ctx);
        return Ok(method_fn_ty);
    }
    // For Ty::Var (unresolved type), emit specific error
    if matches!(resolved_base, Ty::Var(_)) {
        let err = TypeError::NoSuchMethod {
            ty: resolved_base,
            method_name: field_name,
            span: fa.syntax().text_range(),
        };
        ctx.errors.push(err.clone());
        return Err(err);
    }
    let err = TypeError::NoSuchMethod {
        ty: resolved_base,
        method_name: field_name,
        span: fa.syntax().text_range(),
    };
    ctx.errors.push(err.clone());
    return Err(err);
}
```

**Change 3: Add `build_method_fn_type` helper function.**

Add a helper near `infer_field_access` that constructs the full `Ty::Fun(...)` type for a resolved method:

```rust
/// Build the full function type for a trait method, including the self parameter.
/// Returns Ty::Fun([self_type, ...param_types], return_type).
fn build_method_fn_type(
    trait_registry: &TraitRegistry,
    method_name: &str,
    self_ty: &Ty,
    ret_ty: &Ty,
    ctx: &mut InferCtx,
) -> Ty {
    // Look up the method signature to determine parameter count and types.
    // The trait registry stores method signatures with their full parameter lists.
    // For now, search through impls to find the matching method signature.
    for impl_list in trait_registry.impls.values() {
        for impl_def in impl_list {
            if let Some(method_sig) = impl_def.methods.get(method_name) {
                let mut temp_ctx = InferCtx::new();
                let freshened = crate::traits::freshen_type_params(&impl_def.impl_type, &mut temp_ctx);
                if temp_ctx.unify(freshened, self_ty.clone(), ConstraintOrigin::Builtin).is_ok() {
                    // Found the matching impl. Build function type from signature.
                    let mut param_types = vec![self_ty.clone()]; // self parameter
                    // Add remaining params from the signature (skip first, which is self)
                    for (i, param_ty) in method_sig.param_types.iter().enumerate() {
                        if i == 0 { continue; } // skip self param
                        let resolved = temp_ctx.resolve(param_ty.clone());
                        param_types.push(resolved);
                    }
                    return Ty::Fun(param_types, Box::new(ret_ty.clone()));
                }
            }
        }
    }
    // Fallback: if we can't find the full signature, construct a unary function
    // (self -> return_type). infer_call's unification will catch arity mismatches.
    Ty::Fun(vec![self_ty.clone()], Box::new(ret_ty.clone()))
}
```

NOTE: The `impls` field on TraitRegistry and the `methods` HashMap on ImplDef may need to be checked for accessibility (pub vs pub(crate)). Read `traits.rs` to verify the field visibility. If `impls` is not public, either make it `pub(crate)` or add a method to TraitRegistry that returns the method signature info.

**Change 4: Detect method call context in `infer_call`.**

In `infer_call` (line ~2671), after getting `callee_expr` but before calling `infer_expr` on it, detect whether the callee is a FieldAccess. If so, handle method call inference specially:

```rust
// In infer_call, after extracting callee_expr (around line 2688):

// Check if this is a method call (callee is FieldAccess: expr.method(...))
if let Expr::FieldAccess(ref fa) = callee_expr {
    // Infer the field access in method-call context
    let callee_ty = infer_field_access(ctx, env, fa, types, type_registry, trait_registry, fn_constraints, true)?;

    // The callee_ty is Ty::Fun([self_type, ...params], ret_type).
    // Build expected function type from arguments: the first "argument" is the
    // receiver (already included in callee_ty), followed by explicit args.
    let mut arg_types = Vec::new();
    // Infer the receiver type (the base expression of the FieldAccess)
    if let Some(base) = fa.base() {
        let receiver_ty = infer_expr(ctx, env, &base, types, type_registry, trait_registry, fn_constraints)?;
        arg_types.push(receiver_ty);
    }
    // Infer explicit argument types
    if let Some(arg_list) = call.arg_list() {
        for arg in arg_list.args() {
            let arg_ty = infer_expr(ctx, env, &arg, types, type_registry, trait_registry, fn_constraints)?;
            arg_types.push(arg_ty);
        }
    }

    let ret_var = ctx.fresh_var();
    let expected_fn_ty = Ty::Fun(arg_types, Box::new(ret_var.clone()));

    let origin = ConstraintOrigin::FnArg {
        call_site: call.syntax().text_range(),
        param_idx: 0,
    };
    ctx.unify(callee_ty, expected_fn_ty, origin)?;

    let result = ctx.resolve(ret_var);
    types.insert(call.syntax().text_range(), result.clone());
    return Ok(result);
}

// ... existing infer_call code for non-method calls follows ...
```

IMPORTANT: The receiver's base expression will be inferred twice -- once inside `infer_field_access` (to resolve the base type for field/method lookup) and once in `infer_call` (to get the argument type). This is the same pattern used by the existing struct field access code. The second inference returns the already-cached type from `types`.

**Resolution priority preservation (critical invariant):**
Method resolution MUST remain step 5. The code in `infer_field_access` tries module (line 3903), service (line 3917), variant (line 3934), struct field (line 3962) BEFORE reaching the new method resolution code. This order MUST NOT change.
  </action>
  <verify>
Run `cargo check -p snow-typeck` -- compiles cleanly.
Run `cargo test -p snow-typeck` -- all existing tests pass (0 regressions).
Run `cargo test -p snow-codegen` -- all existing tests pass (this verifies no breakage from the new parameter on infer_field_access, though codegen doesn't call it directly).
  </verify>
  <done>
1. `infer_field_access` accepts `is_method_call: bool` and uses TraitRegistry to resolve methods as step 5 in the resolution priority chain.
2. `infer_call` detects FieldAccess callee and passes `is_method_call: true`, prepending the receiver type to the argument list for unification.
3. NoSuchMethod emitted for failed method lookups (not NoSuchField).
4. AmbiguousMethod emitted when multiple traits match.
5. All existing typeck and codegen tests pass with 0 regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p snow-typeck` compiles with no errors
2. `cargo test -p snow-typeck` -- all existing tests pass
3. `cargo test -p snow-codegen` -- all existing tests pass (no regressions from infer.rs signature change)
4. Grep for "NoSuchMethod" in error.rs, diagnostics.rs, and infer.rs confirms the variant exists and is used
5. Resolution priority chain in infer_field_access: module (3903) > service (3917) > variant (3934) > struct field (3962) > method (new) > error (new)
</verification>

<success_criteria>
- NoSuchMethod error variant exists with E0030 code and diagnostic rendering
- infer_field_access resolves trait methods as step 5 (after struct field, before error)
- infer_call detects FieldAccess callee and handles method call inference with receiver prepending
- AmbiguousMethod error wired for multi-trait conflicts
- All 1,232+ existing tests pass with 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/30-core-method-resolution/30-01-SUMMARY.md`
</output>
