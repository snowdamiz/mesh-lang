---
phase: 30-core-method-resolution
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "User can write `point.to_string()` and it compiles and runs, producing the same result as `to_string(point)`"
    - "The receiver is automatically passed as the first argument to the resolved impl method"
    - "`point.to_string()` and `to_string(point)` produce identical MIR (same mangled function name, same args)"
    - "Struct field access (`point.x`), module-qualified calls (`String.length(s)`), and variant construction (`Shape.Circle`) are unaffected"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Method call interception in lower_call_expr and shared trait dispatch helper"
      contains: "FieldAccess"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-typeck/src/traits.rs"
      via: "trait_registry.find_method_traits for method dispatch"
      pattern: "find_method_traits"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "shared dispatch helper used by both bare-name and dot-syntax calls"
      pattern: "resolve_trait_callee"
---

<objective>
Add method call desugaring to MIR lowering so that `value.method(args)` produces identical MIR to `method(value, args)`, with end-to-end tests proving the feature works.

Purpose: This is the MIR lowering half of method dot-syntax. Plan 01 made the type checker resolve method calls. This plan makes MIR lowering emit the correct `MirExpr::Call` by intercepting `CallExpr(FieldAccess(...))` before the callee reaches `lower_field_access` (which would produce a struct GEP, crashing codegen). The existing trait dispatch logic (lines 3527-3600) is extracted into a shared helper so both bare-name and dot-syntax calls use identical dispatch paths.

Output: Method dot-syntax compiles end-to-end. E2e tests confirm `point.to_string()` works and produces the same output as `to_string(point)`.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-core-method-resolution/30-RESEARCH.md
@.planning/phases/30-core-method-resolution/30-01-SUMMARY.md

@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/mod.rs
@crates/snow-codegen/src/mir/types.rs
@crates/snow-parser/src/ast/expr.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Intercept method calls in lower_call_expr and extract shared trait dispatch helper</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Two changes in lower.rs:

**Change 1: Extract trait dispatch into a shared helper method.**

Extract the existing trait dispatch logic (lines ~3527-3600 in `lower_call_expr`) into a helper method on the MirLowerer:

```rust
/// Resolve a trait method callee: given a method name and the first argument's type,
/// check if it's a trait method and rewrite to the mangled name (Trait__Method__Type).
/// Returns the resolved callee (either mangled or original).
fn resolve_trait_callee(
    &self,
    name: &str,
    var_ty: &MirType,
    first_arg_ty: &MirType,
) -> MirExpr {
    if !self.known_functions.contains_key(name) {
        let ty_for_lookup = mir_type_to_ty(first_arg_ty);
        let matching_traits = self.trait_registry.find_method_traits(name, &ty_for_lookup);
        if !matching_traits.is_empty() {
            let trait_name = &matching_traits[0];
            let type_name = mir_type_to_impl_name(first_arg_ty);
            let mangled = format!("{}__{}__{}", trait_name, name, type_name);

            // Primitive Display/Debug/Hash builtin redirects
            let resolved = match mangled.as_str() {
                "Display__to_string__Int" | "Debug__inspect__Int" => "snow_int_to_string".to_string(),
                "Display__to_string__Float" | "Debug__inspect__Float" => "snow_float_to_string".to_string(),
                "Display__to_string__Bool" | "Debug__inspect__Bool" => "snow_bool_to_string".to_string(),
                "Hash__hash__Int" => "snow_hash_int".to_string(),
                "Hash__hash__Float" => "snow_hash_float".to_string(),
                "Hash__hash__Bool" => "snow_hash_bool".to_string(),
                "Hash__hash__String" => "snow_hash_string".to_string(),
                _ => mangled,
            };
            return MirExpr::Var(resolved, var_ty.clone());
        }

        // Fallback for monomorphized generic types
        let type_name = mir_type_to_impl_name(first_arg_ty);
        let known_traits = ["Display", "Debug", "Eq", "Ord", "Hash"];
        for trait_name in &known_traits {
            let candidate = format!("{}__{}__{}", trait_name, name, type_name);
            if self.known_functions.contains_key(&candidate) {
                return MirExpr::Var(candidate, var_ty.clone());
            }
        }

        // Defense-in-depth warning
        if self.lookup_var(name).is_none() {
            let type_name = mir_type_to_impl_name(first_arg_ty);
            eprintln!(
                "[snow-codegen] warning: call to '{}' could not be resolved \
                 as a trait method for type '{}'. This may indicate a type checker bug.",
                name, type_name
            );
        }
    }
    MirExpr::Var(name.to_string(), var_ty.clone())
}
```

Then replace the inline trait dispatch block (lines ~3527-3600) with a call to this helper:

```rust
let callee = if let MirExpr::Var(ref name, ref var_ty) = callee {
    if !args.is_empty() {
        let first_arg_ty = args[0].ty().clone();
        self.resolve_trait_callee(name, var_ty, &first_arg_ty)
    } else {
        callee
    }
} else {
    callee
};
```

**Change 2: Intercept method call pattern at the TOP of `lower_call_expr`.**

At the beginning of `lower_call_expr` (line ~3362), BEFORE the existing `call.callee().map(|e| self.lower_expr(&e))` line, add method call detection:

```rust
fn lower_call_expr(&mut self, call: &CallExpr) -> MirExpr {
    // Method call interception: if callee is a FieldAccess (expr.method(...)),
    // extract receiver + method name, prepend receiver to args, and route
    // through trait dispatch. This MUST happen BEFORE lower_expr on the callee,
    // because lower_expr would route to lower_field_access which produces a
    // struct GEP (MirExpr::FieldAccess), not a callable.
    if let Some(callee_expr) = call.callee() {
        if let Expr::FieldAccess(ref fa) = callee_expr {
            // Check if this is a module/service/variant access (NOT a method call).
            // Module-qualified calls (String.length), service methods (Counter.start),
            // and variant constructors (Shape.Circle) are handled by lower_field_access.
            let is_module_or_special = if let Some(base) = fa.base() {
                if let Expr::NameRef(ref name_ref) = base {
                    if let Some(base_name) = name_ref.text() {
                        STDLIB_MODULES.contains(&base_name.as_str())
                            || self.service_modules.contains_key(&base_name)
                            || self.is_sum_type_name(&base_name)
                    } else {
                        false
                    }
                } else {
                    false
                }
            } else {
                false
            };

            if !is_module_or_special {
                let method_name = fa.field().map(|t| t.text().to_string()).unwrap_or_default();

                // Lower the receiver expression
                let receiver = fa.base().map(|e| self.lower_expr(&e)).unwrap_or(MirExpr::Unit);

                // Lower explicit arguments
                let mut args = vec![receiver];
                if let Some(arg_list) = call.arg_list() {
                    for arg in arg_list.args() {
                        args.push(self.lower_expr(&arg));
                    }
                }

                let ty = self.resolve_range(call.syntax().text_range());

                // Route through the shared trait dispatch helper
                let first_arg_ty = args[0].ty().clone();
                let callee_var_ty = MirType::FnPtr(
                    args.iter().map(|a| a.ty().clone()).collect(),
                    Box::new(ty.clone()),
                );
                let callee = self.resolve_trait_callee(&method_name, &callee_var_ty, &first_arg_ty);

                // Apply the same post-dispatch optimizations as bare-name calls:
                // Display__to_string__String identity short-circuit
                if let MirExpr::Var(ref name, _) = callee {
                    if name == "Display__to_string__String" && !args.is_empty() {
                        return args.into_iter().next().unwrap();
                    }
                    if name == "Debug__inspect__String" && !args.is_empty() {
                        let val = args.into_iter().next().unwrap();
                        let quote = MirExpr::StringLit("\"".to_string(), MirType::String);
                        let concat_ty = MirType::FnPtr(
                            vec![MirType::String, MirType::String],
                            Box::new(MirType::String),
                        );
                        let left = MirExpr::Call {
                            func: Box::new(MirExpr::Var("snow_string_concat".to_string(), concat_ty.clone())),
                            args: vec![quote.clone(), val],
                            ty: MirType::String,
                        };
                        return MirExpr::Call {
                            func: Box::new(MirExpr::Var("snow_string_concat".to_string(), concat_ty)),
                            args: vec![left, quote],
                            ty: MirType::String,
                        };
                    }
                }

                // Collection Display dispatch for method calls
                if let MirExpr::Var(ref name, _) = callee {
                    if (name == "to_string" || name == "debug" || name == "inspect")
                        && args.len() == 1
                        && matches!(args[0].ty(), MirType::Ptr)
                    {
                        if let Some(base_expr) = fa.base() {
                            if let Some(typeck_ty) = self.get_ty(base_expr.syntax().text_range()).cloned() {
                                if let Some(collection_call) = self.wrap_collection_to_string(&args[0], &typeck_ty) {
                                    return collection_call;
                                }
                            }
                        }
                    }
                }

                return MirExpr::Call {
                    func: Box::new(callee),
                    args,
                    ty,
                };
            }
        }
    }

    // ... existing lower_call_expr code (unchanged) ...
```

NOTE on `is_sum_type_name`: You may need a helper to check if a name is a sum type. Check if the MirLowerer has access to sum type definitions. The `self.registry.sum_type_defs` HashMap maps names to definitions. Add a simple check:

```rust
fn is_sum_type_name(&self, name: &str) -> bool {
    self.registry.sum_type_defs.contains_key(name)
}
```

Or inline the check. The key is that `Shape.Circle(5.0)` must NOT be intercepted as a method call -- it must fall through to the existing lower_field_access + variant construction path.

Also check if struct type names could collide: if a user defines `struct Point` and writes `Point.something()`, that should also NOT be intercepted (it's a module-style qualified call or an error). Check `type_registry` or `self.registry.struct_defs` for struct name lookup.

CRITICAL: The existing code at lines 3362-3367 (lowering callee and args) must remain for non-method-call paths. The new method call interception returns early, so the existing code runs only for normal function calls.
  </action>
  <verify>
Run `cargo check -p snow-codegen` -- compiles cleanly.
Run `cargo test -p snow-codegen` -- all existing tests pass (0 regressions).
Run `cargo test` (full suite) -- all 1,232+ tests pass.
  </verify>
  <done>
1. Trait dispatch helper extracted -- `resolve_trait_callee` method shared by both bare-name and method calls.
2. Method call interception at top of `lower_call_expr` detects `FieldAccess` callee, extracts receiver + method name, prepends receiver to args, feeds through shared dispatch.
3. Module-qualified, service, and variant accesses are NOT intercepted (fall through to existing paths).
4. All existing tests pass with 0 regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end tests for method dot-syntax</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Add e2e tests at the end of lower.rs (after the last existing e2e test function). The tests follow the established pattern: write a Snow program string, compile it, run it, assert output.

Test 1: `e2e_method_dot_syntax_basic` -- METH-01 + METH-02
```snow
struct Point do
  x :: Int
  y :: Int
end

interface Display do
  fn to_string(self) -> String
end

impl Display for Point do
  fn to_string(p) do
    "Point(" <> Int.to_string(p.x) <> ", " <> Int.to_string(p.y) <> ")"
  end
end

fn main() do
  let p = Point { x: 10, y: 20 }
  # Method dot-syntax: should produce same result as to_string(p)
  IO.println(p.to_string())
end
```
Expected output: `Point(10, 20)`

Test 2: `e2e_method_dot_syntax_with_args` -- METH-02 (receiver + additional args)
```snow
interface Greeter do
  fn greet(self, greeting :: String) -> String
end

struct Person do
  name :: String
end

impl Greeter for Person do
  fn greet(p, greeting) do
    greeting <> ", " <> p.name <> "!"
  end
end

fn main() do
  let bob = Person { name: "Bob" }
  IO.println(bob.greet("Hello"))
end
```
Expected output: `Hello, Bob!`

Test 3: `e2e_method_dot_syntax_equivalence` -- METH-02 (identical to bare-name)
```snow
struct Point do
  x :: Int
  y :: Int
end

interface Display do
  fn to_string(self) -> String
end

impl Display for Point do
  fn to_string(p) do
    "Point(" <> Int.to_string(p.x) <> ", " <> Int.to_string(p.y) <> ")"
  end
end

fn main() do
  let p = Point { x: 1, y: 2 }
  let a = to_string(p)
  let b = p.to_string()
  IO.println(a)
  IO.println(b)
end
```
Expected output:
```
Point(1, 2)
Point(1, 2)
```

Test 4: `e2e_method_dot_syntax_field_access_preserved` -- Regression test (INTG-01)
```snow
struct Point do
  x :: Int
  y :: Int
end

fn main() do
  let p = Point { x: 42, y: 99 }
  IO.println(Int.to_string(p.x))
  IO.println(Int.to_string(p.y))
end
```
Expected output:
```
42
99
```

Test 5: `e2e_method_dot_syntax_module_qualified_preserved` -- Regression test (INTG-02)
```snow
fn main() do
  let s = "hello world"
  IO.println(Int.to_string(String.length(s)))
end
```
Expected output: `11`

Follow the exact test structure used by existing e2e tests in the file (look at the last few tests for the pattern -- typically `#[test] fn e2e_xxx() { let src = r#"..."#; let output = compile_and_run(src); assert_eq!(output.trim(), "expected"); }`). Match the exact helper function names and assertion patterns.
  </action>
  <verify>
Run `cargo test -p snow-codegen e2e_method_dot_syntax` -- all 5 new tests pass.
Run `cargo test` (full suite) -- all tests pass including new ones.
  </verify>
  <done>
1. 5 e2e tests covering: basic method call, method with additional args, bare-name equivalence, field access preservation, module-qualified preservation.
2. All tests pass.
3. All 1,232+ existing tests continue passing (0 regressions).
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- full suite passes (1,232+ existing + 5 new)
2. `point.to_string()` compiles and produces identical output to `to_string(point)`
3. `bob.greet("Hello")` compiles with receiver + additional arg
4. `point.x` field access still works (regression test)
5. `String.length(s)` module-qualified call still works (regression test)
6. Trait dispatch helper is shared -- no duplicated dispatch logic
</verification>

<success_criteria>
- Method dot-syntax compiles end-to-end: `point.to_string()` works
- Receiver automatically prepended as first argument
- Method calls and bare-name calls produce identical results
- Struct field access, module-qualified calls, variant construction unaffected
- Shared trait dispatch helper eliminates code duplication
- 5 new e2e tests pass, 0 regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/30-core-method-resolution/30-02-SUMMARY.md`
</output>
