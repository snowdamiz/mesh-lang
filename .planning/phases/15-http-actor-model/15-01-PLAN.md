---
phase: 15-http-actor-model
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/http/server.rs
  - crates/snow-rt/src/http/mod.rs
  - tests/e2e/stdlib_http_crash_isolation.snow
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "HTTP server spawns a lightweight actor (not OS thread) for each incoming connection"
    - "A crash in one connection handler does not affect other active connections"
    - "A Snow HTTP server program that worked under v1.0 thread model continues to work with the actor model"
  artifacts:
    - path: "crates/snow-rt/src/http/server.rs"
      provides: "Actor-per-connection HTTP server with catch_unwind crash isolation"
      contains: "connection_handler_entry"
    - path: "crates/snow-rt/src/http/mod.rs"
      provides: "Updated architecture documentation reflecting actor model"
      contains: "actor"
    - path: "tests/e2e/stdlib_http_crash_isolation.snow"
      provides: "E2E test demonstrating crash isolation"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "Rust e2e test harness for crash isolation"
      contains: "e2e_http_crash_isolation"
  key_links:
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "global_scheduler().spawn() for actor creation"
      pattern: "global_scheduler.*spawn"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/gc.rs"
      via: "snow_gc_alloc_actor for per-actor heap allocation"
      pattern: "snow_gc_alloc_actor"
---

<objective>
Replace the thread-per-connection HTTP server model with actor-per-connection using the existing lightweight actor system (corosensei coroutines on M:N scheduler). Add crash isolation via `catch_unwind` so a panic in one connection handler does not affect other connections.

Purpose: This is the final v1.1 phase. It unifies the runtime model so that HTTP connections are actors, benefiting from the same lightweight scheduling (64 KiB stack vs ~8 MiB for OS threads) and crash isolation that regular actors enjoy.

Output: Modified `server.rs` with actor spawning, `connection_handler_entry` with `catch_unwind`, updated `mod.rs` docs, and e2e tests verifying backward compatibility and crash isolation.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-http-actor-model/15-RESEARCH.md

@crates/snow-rt/src/http/server.rs
@crates/snow-rt/src/http/mod.rs
@crates/snow-rt/src/actor/mod.rs
@crates/snow-rt/src/gc.rs
@tests/e2e/stdlib_http_server_runtime.snow
@crates/snowc/tests/e2e_stdlib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace thread-per-connection with actor-per-connection</name>
  <files>
    crates/snow-rt/src/http/server.rs
    crates/snow-rt/src/http/mod.rs
  </files>
  <action>
Modify `crates/snow-rt/src/http/server.rs`:

1. **Add imports** at the top:
   - `use crate::actor::{self, GLOBAL_SCHEDULER};`
   - `use crate::gc::snow_gc_alloc_actor;` (will replace `snow_gc_alloc` usage in `handle_request`)

2. **Add `ConnectionArgs` struct** (before `snow_http_serve`):
   ```rust
   /// Arguments passed to the connection handler actor via raw pointer.
   #[repr(C)]
   struct ConnectionArgs {
       /// Router address as usize (for Send safety across thread boundaries).
       router_addr: usize,
       /// Raw pointer to a boxed tiny_http::Request, transferred as usize.
       request_ptr: usize,
   }
   ```

3. **Add `connection_handler_entry` function** (before `snow_http_serve`):
   ```rust
   /// Actor entry function for handling a single HTTP connection.
   ///
   /// Receives a raw pointer to `ConnectionArgs` containing the router
   /// address and a boxed `tiny_http::Request`. Wraps the handler call
   /// in `catch_unwind` for crash isolation -- a panic in one handler
   /// does not affect other connections.
   extern "C" fn connection_handler_entry(args: *const u8) {
       if args.is_null() {
           return;
       }

       let args = unsafe { Box::from_raw(args as *mut ConnectionArgs) };
       let router_ptr = args.router_addr as *mut u8;
       let request = unsafe { *Box::from_raw(args.request_ptr as *mut tiny_http::Request) };

       let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
           handle_request(router_ptr, request);
       }));

       if let Err(panic_info) = result {
           eprintln!("[snow-rt] HTTP handler panicked: {:?}", panic_info);
       }
   }
   ```

4. **Modify `snow_http_serve`** to use actor spawning instead of `std::thread::spawn`:
   - Remove the `let addr = router_addr;` line and the `std::thread::spawn(move || { ... })` block.
   - Replace the inner loop body with:
     ```rust
     for request in server.incoming_requests() {
         let request_ptr = Box::into_raw(Box::new(request)) as usize;
         let args = ConnectionArgs {
             router_addr,
             request_ptr,
         };
         let args_ptr = Box::into_raw(Box::new(args)) as *const u8;
         let args_size = std::mem::size_of::<ConnectionArgs>() as u64;

         let sched = actor::global_scheduler();
         sched.spawn(
             connection_handler_entry as *const u8,
             args_ptr,
             args_size,
             1, // Normal priority
         );
     }
     ```
   - **Important**: The `actor::global_scheduler()` function is `pub(crate)` (defined in `crates/snow-rt/src/actor/mod.rs`), which is accessible since `server.rs` is in the same crate (`snow-rt`). Use `crate::actor::global_scheduler()` or import it.
   - Update the function doc comment to reflect actor-per-connection model.
   - Remove outdated comments about thread safety and `router_addr` casting for `Send`.

5. **Update `handle_request`** to use `snow_gc_alloc_actor` instead of `snow_gc_alloc`:
   - Replace ALL calls to `snow_gc_alloc(...)` inside `handle_request` with `snow_gc_alloc_actor(...)`.
   - This includes the `SnowHttpRequest` allocation (line ~232 in current code).
   - Do NOT change `snow_gc_alloc` calls in `snow_http_response_new` or `alloc_option` -- those are called from compiled Snow code (not from within the actor handler), and they use the global arena correctly. Actually, `snow_http_response_new` IS called from Snow handler code which runs inside the actor. So it will naturally use the actor heap if we switch it. However, `snow_http_response_new` is an ABI function called from various contexts, so keep it using `snow_gc_alloc` for safety. The Snow handler function pointer calls `snow_http_response_new` from inside the actor, but the alloc will use the global arena -- this is acceptable since the arena does not collect (Phase 5 no-collect).
   - Focus ONLY on the allocations inside `handle_request` itself for the `SnowHttpRequest` struct.

6. **Update the module doc comment** in `server.rs`:
   - Replace "Uses `tiny_http` for the HTTP server and `std::thread::spawn` for per-connection handling" with "Uses `tiny_http` for the HTTP server and the Snow actor system for per-connection handling."
   - Update the "Deviation from plan" section to note that actor-per-connection is now implemented.

7. **Update `crates/snow-rt/src/http/mod.rs`**:
   - Replace the architecture comment: change "std::thread::spawn for per-connection handling" to "the Snow actor system (corosensei coroutines on M:N scheduler) for per-connection handling"
   - Update the "pragmatic choice" comment to reflect that actor-per-connection is now the model, with a note about blocking I/O limitation being accepted (same as BEAM NIFs).

8. **Make `global_scheduler` accessible**: Check if `actor::global_scheduler()` is accessible from `http::server`. It is `fn global_scheduler()` (no `pub`) in `actor/mod.rs`. It needs to be `pub(crate)` to be callable from `http::server.rs`. Update the visibility in `crates/snow-rt/src/actor/mod.rs` if needed: change `fn global_scheduler()` to `pub(crate) fn global_scheduler()`.
  </action>
  <verify>
Run the full test suite:
```bash
cd /Users/sn0w/Documents/dev/snow && cargo test --workspace 2>&1 | tail -20
```
The existing `e2e_http_server_runtime` test must pass (backward compatibility).
Also run just the HTTP server test to confirm:
```bash
cargo test -p snowc e2e_http_server_runtime -- --nocapture 2>&1 | tail -30
```
  </verify>
  <done>
- `snow_http_serve` uses `sched.spawn()` instead of `std::thread::spawn` for each connection
- `connection_handler_entry` wraps `handle_request` in `catch_unwind`
- `ConnectionArgs` struct transfers router+request via raw pointers
- `handle_request` uses `snow_gc_alloc_actor` for SnowHttpRequest allocation
- Module docs updated to reflect actor-per-connection architecture
- `global_scheduler` is accessible from http module
- Existing e2e HTTP test passes unchanged (backward compatible API)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add crash isolation e2e test</name>
  <files>
    tests/e2e/stdlib_http_crash_isolation.snow
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
1. **Create `tests/e2e/stdlib_http_crash_isolation.snow`**:
   This Snow program starts an HTTP server where one route intentionally triggers a crash (division by zero or match failure), while another route works normally. The test verifies that after the crashing route is hit, the normal route still works.

   ```snow
   fn crash_handler(request) do
     # Intentionally cause a panic via division by zero
     let x = 1 / 0
     HTTP.response(200, "unreachable")
   end

   fn health_handler(request) do
     HTTP.response(200, "{\"status\":\"ok\"}")
   end

   fn main() do
     let r = HTTP.router()
     let r = HTTP.route(r, "/crash", crash_handler)
     let r = HTTP.route(r, "/health", health_handler)
     HTTP.serve(r, 18081)
   end
   ```

   **Note**: Use port 18081 to avoid conflict with the existing test on 18080. The division by zero should trigger a panic in the Snow runtime (the codegen emits a panic on division by zero), which will be caught by `catch_unwind` in `connection_handler_entry`.

   **Alternative if division by zero doesn't panic**: Use a case expression with no matching clause (exhaustiveness failure at runtime produces a panic). Example:
   ```snow
   fn crash_handler(request) do
     case 42 do
       0 -> HTTP.response(200, "unreachable")
     end
   end
   ```
   This is guaranteed to trigger a runtime panic on the unmatched case.

   Use whichever approach reliably causes a panic -- check how the compiler handles division by zero (it may emit LLVM sdiv which produces undefined behavior, not a Rust panic). The case-expression approach is safer because the Snow compiler emits an explicit `snow_panic` call for non-exhaustive case matches.

2. **Add the e2e test in `crates/snowc/tests/e2e_stdlib.rs`**:
   Add a new test function `e2e_http_crash_isolation` following the same pattern as `e2e_http_server_runtime`:

   ```rust
   #[test]
   fn e2e_http_crash_isolation() {
       // This test verifies that a crash in one HTTP handler does not
       // affect other connections (actor crash isolation).
       let source = read_fixture("stdlib_http_crash_isolation.snow");
       let mut guard = compile_and_start_server(&source);

       // Wait for server to be ready.
       let stderr = guard.0.stderr.take().expect("no stderr pipe");
       let stderr_reader = BufReader::new(stderr);
       let (tx, rx) = std::sync::mpsc::channel();
       std::thread::spawn(move || {
           for line in stderr_reader.lines() {
               if let Ok(line) = line {
                   if line.contains("HTTP server listening on") {
                       let _ = tx.send(true);
                       return;
                   }
               }
           }
           let _ = tx.send(false);
       });
       let ready = rx
           .recv_timeout(std::time::Duration::from_secs(10))
           .unwrap_or(false);
       assert!(ready, "Server did not start within 10 seconds");

       // Step 1: Hit the /crash endpoint. This should trigger a panic
       // in the handler actor. The connection may reset or return an error.
       // We don't care about the response -- just that the server survives.
       let _ = std::net::TcpStream::connect("127.0.0.1:18081").map(|mut stream| {
           stream.set_read_timeout(Some(std::time::Duration::from_secs(2))).ok();
           stream.write_all(b"GET /crash HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n").ok();
           let mut buf = String::new();
           let _ = stream.read_to_string(&mut buf);
       });

       // Brief pause to let the crash propagate.
       std::thread::sleep(std::time::Duration::from_millis(500));

       // Step 2: Hit the /health endpoint. This MUST still work after the crash.
       let mut response = String::new();
       let mut connected = false;
       for attempt in 0..5 {
           if attempt > 0 {
               std::thread::sleep(std::time::Duration::from_millis(200));
           }
           match std::net::TcpStream::connect("127.0.0.1:18081") {
               Ok(mut stream) => {
                   stream.set_read_timeout(Some(std::time::Duration::from_secs(5))).unwrap();
                   stream.write_all(b"GET /health HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
                       .expect("failed to write HTTP request");
                   stream.read_to_string(&mut response)
                       .expect("failed to read HTTP response");
                   connected = true;
                   break;
               }
               Err(_) => continue,
           }
       }

       assert!(connected, "Failed to connect to server after crash");
       assert!(
           response.contains("200"),
           "Expected HTTP 200 after crash isolation, got: {}",
           response
       );
       assert!(
           response.contains(r#"{\"status\":\"ok\"}"#),
           "Expected JSON body after crash isolation, got: {}",
           response
       );
   }
   ```

   **Important**: The `compile_and_start_server` helper and `read_fixture` function should already exist in e2e_stdlib.rs from Phase 8. Reuse them. Use `BufReader` and `std::io::prelude::*` imports that are already at the top of the file.

   **Port conflict note**: The existing test uses port 18080. This test uses 18081. If tests run in parallel, there is no conflict. If they share a binary, ports are different. This is safe.
  </action>
  <verify>
Run the crash isolation test:
```bash
cd /Users/sn0w/Documents/dev/snow && cargo test -p snowc e2e_http_crash_isolation -- --nocapture 2>&1 | tail -30
```
Also run the full test suite to confirm no regressions:
```bash
cd /Users/sn0w/Documents/dev/snow && cargo test --workspace 2>&1 | tail -20
```
  </verify>
  <done>
- `tests/e2e/stdlib_http_crash_isolation.snow` exists with a crash-triggering route and a health route
- `e2e_http_crash_isolation` test passes: server survives a handler panic and serves subsequent requests
- Full test suite passes with zero regressions
- Both HTTP-01 (actor-per-connection) and HTTP-02 (crash isolation) requirements are verified
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- full test suite passes with zero regressions
2. `cargo test -p snowc e2e_http_server_runtime` -- existing HTTP test passes (backward compatibility)
3. `cargo test -p snowc e2e_http_crash_isolation` -- new crash isolation test passes
4. Confirm `server.rs` contains `sched.spawn(` and NOT `std::thread::spawn` in the accept loop
5. Confirm `server.rs` contains `catch_unwind` in `connection_handler_entry`
6. Confirm `server.rs` uses `snow_gc_alloc_actor` in `handle_request`
</verification>

<success_criteria>
- HTTP server spawns lightweight actors (not OS threads) for each connection
- A panicking handler does not crash the server (catch_unwind isolation)
- Existing Snow HTTP programs work without any code changes (backward-compatible API)
- All existing e2e tests pass (31+ tests, zero regressions)
- New crash isolation e2e test demonstrates the isolation property
</success_criteria>

<output>
After completion, create `.planning/phases/15-http-actor-model/15-01-SUMMARY.md`
</output>
