---
phase: 24-trait-system-generics
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/fixtures/generic_deriving.snow
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "A generic struct `type Box<T> do value :: T end` with `deriving(Display, Eq)` compiles without errors"
    - "`Box<Int>` and `Box<String>` get independent Display/Eq implementations"
    - "`to_string(Box { value: 42 })` produces `Box(42)` at runtime"
    - "`to_string(Box { value: \"hello\" })` produces `Box(hello)` at runtime"
    - "The GenericDerive error (E0029) no longer exists in the compiler"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Generic type deriving support -- parametric trait impl registration"
      contains: "Ty::App"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "GenericDerive variant removed"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Monomorphized trait function generation for generic structs"
      contains: "monomorphized_trait_fns"
    - path: "crates/snowc/tests/fixtures/generic_deriving.snow"
      provides: "E2E test fixture for generic type deriving"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E test for generic type deriving"
      contains: "e2e_generic_deriving"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "TraitRegistry"
      via: "register_impl with Ty::App for parametric types"
      pattern: "register_impl.*Ty::App"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "generate_display_struct"
      via: "monomorphized trait function generation at struct literal sites"
      pattern: "monomorphized_trait_fns"
---

<objective>
Enable `deriving(Eq, Ord, Display, Debug, Hash)` on generic types by removing the GenericDerive error, registering parametric trait impls in the trait registry, and generating monomorphized trait functions at MIR lowering time.

Purpose: TGEN-02 -- Generic structs like `type Box<T> do value :: T end` with `deriving(Display, Eq)` should work for any concrete instantiation. `Box<Int>` and `Box<String>` each need independent Display/Eq implementations generated with correct field type dispatch.

Output: Removed GenericDerive error, parametric trait impl registration, monomorphized trait function generation, and e2e tests proving `Box<Int>` and `Box<String>` Display/Eq work correctly.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-trait-system-generics/24-RESEARCH.md
@.planning/phases/24-trait-system-generics/24-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-typeck/src/traits.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove GenericDerive error and register parametric trait impls for generic types</name>
  <files>crates/snow-typeck/src/infer.rs, crates/snow-typeck/src/error.rs, crates/snow-typeck/src/diagnostics.rs</files>
  <action>
Three files need coordinated changes:

**1. Remove GenericDerive from `crates/snow-typeck/src/error.rs`:**
- Delete the `GenericDerive { type_name: String }` variant from the `TypeError` enum (line 241-243)
- Delete the `GenericDerive` arm from the `fmt::Display` impl (line 502-508)

**2. Remove GenericDerive from `crates/snow-typeck/src/diagnostics.rs`:**
- Delete the `TypeError::GenericDerive { .. } => "E0029"` line from the error code function (line 122)
- Delete the `TypeError::GenericDerive { type_name }` match arm from the diagnostic generation function (line 1336 onwards, the full arm body)

**3. Modify `crates/snow-typeck/src/infer.rs` -- struct registration (around line 1510-1615):**

Remove the GenericDerive error emission (lines 1510-1515):
```rust
// DELETE this block:
if has_deriving && !generic_params.is_empty() {
    ctx.errors.push(TypeError::GenericDerive {
        type_name: name.clone(),
    });
}
```

Change the `if generic_params.is_empty()` guard (line 1518) to handle BOTH generic and non-generic types:

For non-generic types (`generic_params.is_empty()`): Keep existing behavior exactly as-is. `impl_ty = Ty::Con(TyCon::new(&name))`.

For generic types (`!generic_params.is_empty()`): Register a **parametric** trait impl using `Ty::App`:
```rust
// Build the parametric type: e.g., Box<T> -> Ty::App(Box<Con("Box")>, [Con("T")])
let base_ty = Ty::Con(TyCon::new(&name));
let param_tys: Vec<Ty> = generic_params.iter().map(|p| Ty::Con(TyCon::new(p))).collect();
let impl_ty = Ty::App(Box::new(base_ty), param_tys);
```

Then register the same trait impls (Debug, Eq, Ord, Hash, Display) using this `impl_ty`, exactly following the existing pattern. The `impl_type_name` should still be `name.clone()` (the base name like `"Box"`). The `TraitRegistry`'s structural matching via `freshen_type_params` will automatically match `Box<T>` against queries for `Box<Int>`, `Box<String>`, etc.

**4. Modify `crates/snow-typeck/src/infer.rs` -- sum type registration (around line 1794-1900):**

Apply the same changes as for structs:
- Remove the GenericDerive error emission (lines 1794-1799)
- Change the `if generic_params.is_empty()` guard to handle both cases
- For generic sum types, build `Ty::App` from the generic params and register parametric impls

After these changes, `type Box<T> do value :: T end deriving(Display, Eq)` will compile without errors, and the trait registry will contain a parametric `Display` impl for `Box<T>` that matches any concrete instantiation.
  </action>
  <verify>
Run `cargo build -p snow-typeck` -- must compile (no references to GenericDerive left).
Run `cargo test -p snow-typeck` -- all type checker tests pass.
Verify with a quick grep: `grep -r "GenericDerive" crates/snow-typeck/src/` returns no matches.
  </verify>
  <done>
GenericDerive error removed. Generic types with deriving clauses register parametric trait impls. `type Box<T> do value :: T end deriving(Display, Eq)` passes type checking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate monomorphized trait functions for generic structs at MIR lowering time</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
The type checker now registers parametric impls (e.g., `Display for Box<T>`), but the MIR lowerer still needs to generate concrete trait functions like `Display__to_string__Box_Int` and `Eq__eq__Box_Int` for each monomorphized instantiation.

**Key insight:** The `lower_struct_def` function (line ~1275) processes struct definitions. For generic structs, the type registry's `struct_defs` stores the definition with generic param types (`Ty::Con("T")`). The MIR lowerer needs to detect when a generic struct has deriving traits and, at each concrete instantiation site, generate the monomorphized trait functions.

**Approach:** Add a `HashSet<String>` field `monomorphized_trait_fns` to the MIR lowerer struct. When processing struct literal expressions for generic structs (in `lower_struct_literal` or similar), check the typeck type to get concrete type arguments. If a monomorphized trait function hasn't been generated yet:

1. Look up the struct definition from the type registry
2. Substitute generic param types with concrete types in the field list
3. Call the existing `generate_display_struct`, `generate_eq_struct`, etc. with the monomorphized name (`Box_Int`) and substituted field types
4. Add the monomorphized name to `self.monomorphized_trait_fns` to prevent duplicates

**Detailed steps:**

**Step A: Add tracking field to MIR lowerer struct.**

Find the struct definition of the MIR lowerer (search for `struct MirLowerer` or equivalent). Add:
```rust
monomorphized_trait_fns: HashSet<String>,
```
Initialize it as `HashSet::new()` in the constructor.

**Step B: Add a method `ensure_monomorphized_trait_fns(&mut self, base_name: &str, type_args: &[Ty])`.**

This method:
1. Computes the mangled name (e.g., `Box_Int`) using `mangle_type_name(base_name, type_args, self.registry)`
2. Checks `self.monomorphized_trait_fns.contains(&mangled_name)` -- if yes, return early
3. Looks up the struct definition from `self.registry.struct_defs.get(base_name)`
4. Checks the AST (or stored derive info) for which traits were derived -- since the derive info may not be stored in the type registry, check if the trait registry has impls registered for this type using `self.trait_registry.find_method_traits("to_string", &concrete_ty)`, `find_method_traits("eq", ...)`, etc.
5. For each derived trait, build the substituted field list:
   - For each field `(name, ty)` in the struct def, substitute generic params with concrete type args
   - Map generic `Ty::Con("T")` -> concrete type arg (e.g., `Ty::int()`)
   - Resolve to `MirType` using `resolve_type`
6. Call `self.generate_display_struct(&mangled_name, &substituted_fields)` (for Display)
7. Call `self.generate_eq_struct(&mangled_name, &substituted_fields)` (for Eq)
8. Similarly for Debug, Hash, Ord
9. Also push `MirStructDef { name: mangled_name, fields: substituted_fields }` to `self.structs` if not already present
10. Insert `mangled_name` into `self.monomorphized_trait_fns`

**Step C: Call `ensure_monomorphized_trait_fns` at struct literal lowering sites.**

In the struct literal lowering code (search for `lower_struct_literal` or where `StructLit` / `StructExpr` is lowered), after determining the struct name and type arguments:
- If the struct has generic params (check `self.registry.struct_defs.get(&name)` and its `generic_params`), extract the concrete type args from the typeck type
- Call `self.ensure_monomorphized_trait_fns(&base_name, &type_args)`

The typeck type for a struct literal like `Box { value: 42 }` will be `Ty::App(Con("Box"), [Con("Int")])`. Extract the type args from the `Ty::App`.

**Step D: Handle `lower_struct_def` for generic structs.**

In `lower_struct_def` (line ~1275), when the struct has generic params, skip generating trait functions directly (since the concrete types aren't known). The trait functions will be generated lazily via `ensure_monomorphized_trait_fns` at instantiation sites. Add a guard:

```rust
let has_generic_params = self.registry.struct_defs.get(&name)
    .map_or(false, |info| !info.generic_params.is_empty());

if !has_generic_params {
    // Existing trait function generation (unchanged)
    if derive_all || derive_list.iter().any(|t| t == "Debug") { ... }
    // ...
}
// For generic structs: trait functions generated lazily at instantiation
```

**Important:** The `wrap_to_string` calls inside the generated Display function need to correctly dispatch for the concrete field types. Since `generate_display_struct` already calls `self.wrap_to_string(field_access, None)`, and the field types will be the concrete MirTypes (e.g., `MirType::Int` for `Box<Int>.value`), the existing dispatch logic should work correctly.

**For generic sum types:** Apply the same pattern. Add `ensure_monomorphized_sum_trait_fns` that works similarly. Sum type monomorphized instantiations are typically seen when constructing variants (e.g., `Some(42)`) -- the typeck type will be `Ty::App(Con("Option"), [Con("Int")])`. Hook into the variant constructor lowering to trigger monomorphized function generation.

Note: Option and Result are built-in sum types that are already registered without deriving clauses. They get `Debug` by default (derive_all = true when no deriving clause). So `Debug__inspect__Option_Int` should be generated when `Some(42)` is lowered. This enables Plan 01's `to_string([Some(1), None])` fallback to Debug.
  </action>
  <verify>
Run `cargo build -p snow-codegen` -- must compile.
Run `cargo test -p snow-codegen` -- all codegen tests pass.
Run `cargo test -p snowc` -- all e2e tests pass (no regressions).
  </verify>
  <done>
Monomorphized trait functions are generated lazily at struct literal / variant constructor sites. `Display__to_string__Box_Int`, `Eq__eq__Box_Int`, etc. are emitted for each concrete instantiation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add e2e tests for generic type deriving</name>
  <files>crates/snowc/tests/fixtures/generic_deriving.snow, crates/snowc/tests/e2e.rs</files>
  <action>
Create a Snow fixture and e2e test exercising generic type deriving.

**Fixture `crates/snowc/tests/fixtures/generic_deriving.snow`:**

```snow
type Box<T> do
  value :: T
end deriving(Display, Eq)

fn main() do
  let b1 = Box { value: 42 }
  let b2 = Box { value: 42 }
  let b3 = Box { value: 99 }

  println(to_string(b1))

  let bs = Box { value: "hello" }
  println(to_string(bs))

  println(to_string(b1 == b2))
  println(to_string(b1 == b3))
end
```

**E2E test in `crates/snowc/tests/e2e.rs`:**

Add after the nested collection Display test from Plan 01:

```rust
/// Generic type deriving: Box<T> with deriving(Display, Eq) works for Box<Int> and Box<String>.
#[test]
fn e2e_generic_deriving() {
    let source = read_fixture("generic_deriving.snow");
    let output = compile_and_run(&source);
    assert_eq!(output, "Box(42)\nBox(hello)\ntrue\nfalse\n");
}
```

Expected output breakdown:
- `Box(42)` -- Display for Box<Int>
- `Box(hello)` -- Display for Box<String>
- `true` -- Eq: Box{42} == Box{42}
- `false` -- Eq: Box{42} == Box{99}

Additionally, if Plan 01's Option Display test was deferred, update the nested collection Display fixture and test to include `[Some(1), None, Some(3)]` now that generic sum type Debug functions are generated for monomorphized types (Option_Int gets Debug__inspect via the lazy generation). Update the expected output accordingly.
  </action>
  <verify>
Run `cargo test -p snowc e2e_generic_deriving -- --nocapture` -- test must pass.
Run `cargo test -p snowc e2e_nested_collection_display -- --nocapture` -- test must pass (including Option Display if re-enabled).
Run `cargo test -p snowc` -- all e2e tests pass.
Run `cargo test` -- full test suite passes (1,200+ tests).
  </verify>
  <done>
`Box<Int>` Display produces `Box(42)`, `Box<String>` Display produces `Box(hello)`, `Box<Int>` Eq works correctly. All existing tests pass. Phase 24 success criteria met.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` -- type checker tests pass, GenericDerive error fully removed
2. `cargo test -p snow-codegen` -- codegen tests pass
3. `cargo test -p snowc e2e_generic_deriving` -- generic struct deriving works at runtime
4. `cargo test -p snowc e2e_nested_collection_display` -- nested Display works at runtime
5. `cargo test` -- full test suite passes (1,200+ tests, no regressions)
6. `grep -r "GenericDerive" crates/` returns no matches
</verification>

<success_criteria>
- `type Box<T> do value :: T end deriving(Display, Eq)` compiles without errors
- `to_string(Box { value: 42 })` produces `Box(42)` at runtime
- `to_string(Box { value: "hello" })` produces `Box(hello)` at runtime
- `Box { value: 42 } == Box { value: 42 }` evaluates to `true`
- `Box { value: 42 } == Box { value: 99 }` evaluates to `false`
- GenericDerive error (E0029) completely removed from codebase
- All 1,200+ existing tests pass without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/24-trait-system-generics/24-02-SUMMARY.md`
</output>
