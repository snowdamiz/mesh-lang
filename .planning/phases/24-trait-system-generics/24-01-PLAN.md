---
phase: 24-trait-system-generics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "`to_string([[1, 2], [3, 4]])` produces `[[1, 2], [3, 4]]` at runtime"
    - "`to_string([Some(1), None])` produces `[Some(1), None]` at runtime"
    - "Existing flat collection Display still works: `to_string([1, 2, 3])` produces `[1, 2, 3]`"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Recursive resolve_to_string_callback with synthetic wrapper function generation"
      contains: "__display_"
    - path: "crates/snowc/tests/fixtures/nested_collection_display.snow"
      provides: "E2E test fixture for nested collection Display"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E test for nested collection Display"
      contains: "e2e_nested_collection_display"
  key_links:
    - from: "resolve_to_string_callback"
      to: "self.functions"
      via: "generates synthetic __display_ wrapper MIR functions"
      pattern: "__display_.*to_str"
    - from: "wrap_collection_to_string"
      to: "resolve_to_string_callback"
      via: "callback resolution for element types"
      pattern: "resolve_to_string_callback"
---

<objective>
Make `resolve_to_string_callback` recursive so nested collection Display renders correctly. When a collection element is itself a collection (e.g., `List<List<Int>>`) or a sum type with Display (e.g., `List<Option<Int>>`), generate a synthetic MIR wrapper function that bridges the `fn(u64) -> *mut u8` callback signature expected by the runtime.

Purpose: TGEN-01 -- `to_string([[1, 2], [3, 4]])` currently produces garbage because the inner list callback falls back to `snow_int_to_string`. After this plan, nested Display recurses correctly through any depth of collection nesting and through sum type elements.

Output: Modified `resolve_to_string_callback` that handles `Ty::App` for nested collections and sum types, synthetic wrapper function generation, and e2e tests proving correctness.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-trait-system-generics/24-RESEARCH.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/types.rs
@crates/snow-rt/src/collections/list.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make resolve_to_string_callback recursive with synthetic wrapper generation</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Modify the MIR lowerer to support recursive Display callback resolution for nested collections and sum type elements. Three changes required:

**1. Change `resolve_to_string_callback` and `wrap_collection_to_string` signatures from `&self` to `&mut self`.**

This is needed because the recursive callback resolution must generate synthetic wrapper functions and register them in `self.functions` and `self.known_functions`. Propagate the `&mut self` change up through any callers. The main caller chain is:
- `wrap_to_string` (already takes `&self` -- change to `&mut self`)
- `wrap_collection_to_string` (already takes `&self` -- change to `&mut self`)
- `resolve_to_string_callback` (already takes `&self` -- change to `&mut self`)

Trace all call sites of `wrap_to_string`, `wrap_collection_to_string`, and `resolve_to_string_callback` and update them. These functions are called from `generate_display_struct`, `generate_display_sum_type`, `generate_debug_inspect_struct`, `generate_debug_inspect_sum_type`, and the main expression lowering in `lower_call_expr` / `lower_interpolation`. All of these already have `&mut self`.

**2. Make `resolve_to_string_callback` handle nested collection types recursively.**

Current code at line 4509 (`Ty::App(con_ty, _)` arm) falls back to `"snow_int_to_string"`. Replace with:

For `Ty::App(Con("List"), [inner_ty])`:
- Recursively call `self.resolve_to_string_callback(inner_ty)` to get the inner callback name
- Generate a synthetic MIR wrapper function named `__display_list_{mangled_inner}_to_str` where `{mangled_inner}` is derived from the inner type (e.g., `Int`, `List_Int`, `Option_Int`)
- The wrapper function takes one `Ptr` parameter, and calls `snow_list_to_string(param, inner_callback_fn_ptr)`, returning the result
- Push this wrapper to `self.functions` and register in `self.known_functions`
- Use a dedup check: if `self.known_functions` already contains the wrapper name, skip generation (handles multiple uses of the same nested type)
- Return the wrapper function name

For `Ty::App(Con("Map"), [key_ty, val_ty])`:
- Similarly generate `__display_map_{key_mangled}_{val_mangled}_to_str` that calls `snow_map_to_string(param, key_callback, val_callback)`

For `Ty::App(Con("Set"), [inner_ty])`:
- Same pattern as List: `__display_set_{mangled_inner}_to_str`

For `Ty::App(Con(sum_type_name), type_args)` where the sum type name is a known sum type (e.g., `Option`, `Result`, or user-defined):
- Check if `Display__to_string__{mangled_name}` exists in `self.known_functions` -- if so, return it
- Check if `Debug__inspect__{mangled_name}` exists in `self.known_functions` -- if so, return it as fallback
- Otherwise fall back to `snow_int_to_string`
- The mangled name uses the same convention as `mangle_type_name`: `Option_Int`, `Result_Int_String`

Also fix the `Ty::Con` arm for bare `"List" | "Map" | "Set"` (line 4493) to handle them the same way as `Ty::App` with empty args (default to Int callback), keeping backward compat.

**3. Handle the `Ty::Con` arm for user-defined sum types (like `Option` without type args).**

The existing code at line 4494-4506 checks `find_method_traits("to_string", ...)` for user types. Extend this to also try `Debug__inspect__{name}` as a fallback when no Display impl is found.

**Synthetic wrapper function MIR structure:**

```
MirFunction {
    name: "__display_list_Int_to_str",
    params: [("__elem", MirType::Ptr)],
    return_type: MirType::String,
    body: MirExpr::Call {
        func: "snow_list_to_string",
        args: [Var("__elem", Ptr), Var("snow_int_to_string", FnPtr)],
        ty: String,
    },
    is_closure_fn: false,
    captures: vec![],
}
```

For naming consistency, use this scheme:
- `__display_list_{elem}_to_str` for List wrappers
- `__display_map_{key}_{val}_to_str` for Map wrappers
- `__display_set_{elem}_to_str` for Set wrappers

Where `{elem}`, `{key}`, `{val}` are the recursively mangled type names (e.g., `Int`, `String`, `list_Int` for `List<Int>`).
  </action>
  <verify>
Run `cargo build -p snow-codegen` -- must compile without errors.
Run `cargo test -p snow-codegen` -- all existing tests must pass.
Run `cargo test -p snowc` -- all existing e2e tests must pass (no regressions from signature changes).
  </verify>
  <done>
`resolve_to_string_callback` recursively resolves nested collection types and generates synthetic MIR wrapper functions. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for nested collection and sum type Display</name>
  <files>crates/snowc/tests/fixtures/nested_collection_display.snow, crates/snowc/tests/e2e.rs</files>
  <action>
Create a Snow fixture file and e2e test that exercises nested collection Display.

**Fixture `crates/snowc/tests/fixtures/nested_collection_display.snow`:**

```snow
fn main() do
  let nested = [[1, 2], [3, 4]]
  println(to_string(nested))

  let opts = [Some(1), None, Some(3)]
  println(to_string(opts))

  let flat = [10, 20, 30]
  println(to_string(flat))
end
```

Note: The `[Some(1), None, Some(3)]` test depends on Option having a Display or Debug function reachable as a callback. If Option doesn't have Display impl registered (it's a built-in sum type without an explicit `deriving` clause), the sum type callback lookup in `resolve_to_string_callback` should fall back to `Debug__inspect__Option_Int`. Verify that the Debug inspect function for monomorphized Option_Int is generated. If it is not (because Option is registered as a generic type and the MIR lowerer only generates `Debug__inspect__Option` without monomorphized variants), then the `[Some(1), None]` test may need to be deferred to Plan 02 when generic type deriving is implemented. In that case, comment out the Option lines and add a `TODO: enable after Plan 02 (generic deriving)` comment, and only test `[[1, 2], [3, 4]]`.

**E2E test in `crates/snowc/tests/e2e.rs`:**

Add a new test after the Phase 23 tests:

```rust
// -- Phase 24: Trait System Generics ------------------------------------

/// Nested collection Display: List<List<Int>> renders recursively.
#[test]
fn e2e_nested_collection_display() {
    let source = read_fixture("nested_collection_display.snow");
    let output = compile_and_run(&source);
    // If Option Display works:
    assert_eq!(output, "[[1, 2], [3, 4]]\n[Some(1), None, Some(3)]\n[10, 20, 30]\n");
    // If Option Display deferred:
    // assert_eq!(output, "[[1, 2], [3, 4]]\n[10, 20, 30]\n");
}
```

The key assertion: `[[1, 2], [3, 4]]` instead of `[<garbage>, <garbage>]`. The flat `[10, 20, 30]` test verifies no regression.
  </action>
  <verify>
Run `cargo test -p snowc e2e_nested_collection_display -- --nocapture` -- test must pass.
Run `cargo test -p snowc` -- all e2e tests must pass (no regressions).
  </verify>
  <done>
E2E test confirms `to_string([[1, 2], [3, 4]])` produces `[[1, 2], [3, 4]]` at runtime. Flat collection Display is not regressed.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-codegen` -- all codegen tests pass
2. `cargo test -p snowc` -- all e2e tests pass including new nested Display test
3. `cargo test` -- full test suite passes (1,200+ tests, no regressions)
</verification>

<success_criteria>
- `to_string([[1, 2], [3, 4]])` produces `[[1, 2], [3, 4]]` (recursive nesting)
- `to_string([10, 20, 30])` still produces `[10, 20, 30]` (no regression)
- All 1,200+ existing tests pass
- Synthetic wrapper functions are generated with dedup (no duplicate definitions)
</success_criteria>

<output>
After completion, create `.planning/phases/24-trait-system-generics/24-01-SUMMARY.md`
</output>
