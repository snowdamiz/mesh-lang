---
phase: 99-changesets
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-rt/src/db/changeset.rs
  - crates/mesh-rt/src/db/mod.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-repl/src/jit.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Changeset.cast(data, params, allowed_fields) creates a Changeset that filters params to only allowed fields"
    - "Changeset.cast(data, params, allowed_fields, field_types) additionally coerces string values to schema field types"
    - "Changeset.validate_required(changeset, fields_list) adds errors for missing or empty fields without short-circuiting"
    - "Changeset.validate_length(changeset, field, min, max) adds error when string length is outside bounds"
    - "Changeset.validate_format(changeset, field, pattern) adds error when field does not contain pattern string"
    - "Changeset.validate_inclusion(changeset, field, allowed_values) adds error when field value not in list"
    - "Changeset.validate_number(changeset, field, gt, lt, gte, lte) adds error when numeric value outside bounds"
    - "Changeset.valid(changeset) returns Bool reflecting whether errors map is empty"
    - "Pipe-chain validation works: Changeset.cast(...) |> Changeset.validate_required(...) |> Changeset.validate_length(...)"
    - "Multiple validators accumulate errors on different fields without overwriting each other"
  artifacts:
    - path: "crates/mesh-rt/src/db/changeset.rs"
      provides: "Changeset runtime: 8-slot opaque Ptr, cast, 5 validators, field accessors"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Changeset module type signatures in build_stdlib_modules"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Changeset functions in known_functions, map_builtin_name, STDLIB_MODULES"
  key_links:
    - from: "crates/mesh-rt/src/db/changeset.rs"
      to: "crates/mesh-rt/src/gc.rs"
      via: "mesh_gc_alloc_actor for 64-byte changeset allocation"
      pattern: "mesh_gc_alloc_actor"
    - from: "crates/mesh-rt/src/db/changeset.rs"
      to: "crates/mesh-rt/src/collections/map.rs"
      via: "mesh_map_new_typed, mesh_map_put, mesh_map_get, mesh_map_has_key for errors/changes maps"
      pattern: "mesh_map_new_typed.*mesh_map_put.*mesh_map_get"
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "Changeset module in STDLIB_MODULE_NAMES matches STDLIB_MODULES for MIR lowering"
      pattern: "Changeset"
---

<objective>
Implement the Changeset struct as an opaque 8-slot runtime object with Changeset.cast for field filtering and type coercion, five validation functions (validate_required, validate_length, validate_format, validate_inclusion, validate_number), and field accessors (valid, errors, changes, get_change, get_error). Each validator takes Changeset as first argument and returns a new Changeset, enabling pipe-chain composition.

Purpose: Provides a data validation pipeline that accumulates all errors without short-circuiting, enabling developers to validate external input before persistence.
Output: Changeset module registered in full compiler pipeline (typeck, MIR, intrinsics, runtime, JIT) with e2e tests confirming pipe-chain validation, error accumulation, and type coercion.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/099-changesets/99-RESEARCH.md
@.planning/phases/098-query-builder-repo/98-01-SUMMARY.md
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/codegen/intrinsics.rs
@crates/mesh-rt/src/db/query.rs
@crates/mesh-rt/src/db/repo.rs
@crates/mesh-rt/src/collections/map.rs
@crates/mesh-rt/src/gc.rs
@crates/mesh-rt/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Changeset module in compiler pipeline and implement runtime changeset functions</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-rt/src/db/changeset.rs
    crates/mesh-rt/src/db/mod.rs
    crates/mesh-rt/src/lib.rs
    crates/mesh-repl/src/jit.rs
  </files>
  <action>
    **1. Type checker (infer.rs) -- Register Changeset module in `build_stdlib_modules()`:**

    Add `"Changeset"` to the `STDLIB_MODULE_NAMES` array (search for the existing array containing "Query", "Repo").

    Then register the Changeset module with these function signatures:

    ```
    // Cast functions (3-arg and 4-arg variants)
    Changeset.cast(Ptr, Ptr, Ptr) -> Ptr
        // (data: Map, params: Map, allowed: List<Atom>) -> Changeset
    Changeset.cast_with_types(Ptr, Ptr, Ptr, Ptr) -> Ptr
        // (data: Map, params: Map, allowed: List<Atom>, field_types: List<String>) -> Changeset

    // Validators -- all take Changeset as first arg, return Changeset
    Changeset.validate_required(Ptr, Ptr) -> Ptr
        // (changeset, fields: List<Atom>) -> Changeset
    Changeset.validate_length(Ptr, Atom, Int, Int) -> Ptr
        // (changeset, field, min, max) -- use -1 for "not set"
    Changeset.validate_format(Ptr, Atom, String) -> Ptr
        // (changeset, field, pattern_substring) -> Changeset
    Changeset.validate_inclusion(Ptr, Atom, Ptr) -> Ptr
        // (changeset, field, allowed_values: List<String>) -> Changeset
    Changeset.validate_number(Ptr, Atom, Int, Int, Int, Int) -> Ptr
        // (changeset, field, gt, lt, gte, lte) -- use -1 for "not set"

    // Field accessors
    Changeset.valid(Ptr) -> Bool
        // (changeset) -> whether errors map is empty
    Changeset.errors(Ptr) -> Ptr
        // (changeset) -> Map<String, String>
    Changeset.changes(Ptr) -> Ptr
        // (changeset) -> Map<String, String>
    Changeset.get_change(Ptr, Atom) -> Ptr
        // (changeset, field) -> String value
    Changeset.get_error(Ptr, Atom) -> Ptr
        // (changeset, field) -> String error message
    ```

    Follow the exact pattern used for the Query and Repo modules. The `Ptr` type is `Ty::Con(TyCon::new("Ptr"))`, `Atom` type is `Ty::Con(TyCon::new("Atom"))`, `Int` is `Ty::int()`, `Bool` is `Ty::bool()`, `String` is `Ty::string()`.

    **IMPORTANT:** The `cast` (3-arg) and `cast_with_types` (4-arg) must have different names because Mesh does not support same-name different-arity overloading. Use `cast` for the common 3-arg version (no type coercion) and `cast_with_types` for the 4-arg version (with coercion).

    **2. MIR lowerer (lower.rs):**

    Add `"Changeset"` to the `STDLIB_MODULES` array (search for the existing array containing "Query", "Repo").

    Add to known_functions (search for existing `mesh_repo_*` entries and add after them):
    ```
    "mesh_changeset_cast"              -> FnPtr([Ptr, Ptr, Ptr], Ptr)
    "mesh_changeset_cast_with_types"   -> FnPtr([Ptr, Ptr, Ptr, Ptr], Ptr)
    "mesh_changeset_validate_required" -> FnPtr([Ptr, Ptr], Ptr)
    "mesh_changeset_validate_length"   -> FnPtr([Ptr, Ptr, Ptr, Ptr], Ptr)
    "mesh_changeset_validate_format"   -> FnPtr([Ptr, Ptr, Ptr], Ptr)
    "mesh_changeset_validate_inclusion"-> FnPtr([Ptr, Ptr, Ptr], Ptr)
    "mesh_changeset_validate_number"   -> FnPtr([Ptr, Ptr, Ptr, Ptr, Ptr, Ptr], Ptr)
    "mesh_changeset_valid"             -> FnPtr([Ptr], Ptr)
    "mesh_changeset_errors"            -> FnPtr([Ptr], Ptr)
    "mesh_changeset_changes"           -> FnPtr([Ptr], Ptr)
    "mesh_changeset_get_change"        -> FnPtr([Ptr, Ptr], Ptr)
    "mesh_changeset_get_error"         -> FnPtr([Ptr, Ptr], Ptr)
    ```

    **IMPORTANT for known_functions:** Int parameters at the MIR level are `MirType::Int` but at the LLVM level they are `i64` which is pointer-sized, so they appear as `Ptr` in the FnPtr signatures. Check how existing functions with Int params are handled (e.g., `mesh_query_limit` or `mesh_query_offset`). The known_functions entries should use `Ptr` for ALL parameters since at the LLVM extern C level, everything is passed as `*mut u8` or `i64` (both 8 bytes). Verify by checking how Query.limit(Ptr, Int) is declared in known_functions.

    Add map_builtin_name entries (search for `repo_` prefix entries):
    ```
    "changeset_cast" => "mesh_changeset_cast"
    "changeset_cast_with_types" => "mesh_changeset_cast_with_types"
    "changeset_validate_required" => "mesh_changeset_validate_required"
    "changeset_validate_length" => "mesh_changeset_validate_length"
    "changeset_validate_format" => "mesh_changeset_validate_format"
    "changeset_validate_inclusion" => "mesh_changeset_validate_inclusion"
    "changeset_validate_number" => "mesh_changeset_validate_number"
    "changeset_valid" => "mesh_changeset_valid"
    "changeset_errors" => "mesh_changeset_errors"
    "changeset_changes" => "mesh_changeset_changes"
    "changeset_get_change" => "mesh_changeset_get_change"
    "changeset_get_error" => "mesh_changeset_get_error"
    ```

    **3. LLVM intrinsics (intrinsics.rs):**

    Declare 12 new Changeset functions. Follow the exact pattern used for Query and Repo functions. Each function takes the parameter count from known_functions and returns `ptr_ty` (i8*). For `valid`, the return type is still `ptr_ty` at the LLVM level (Bool is i64, treated as pointer-sized).

    **4. Runtime implementation -- Create `crates/mesh-rt/src/db/changeset.rs`:**

    **Changeset slot layout (8 slots, 64 bytes):**
    ```rust
    pub(crate) const CS_SLOTS: usize = 8;
    pub(crate) const CS_SIZE: usize = CS_SLOTS * 8;

    pub(crate) const SLOT_DATA: usize = 0;        // *mut u8 -> Map<String,String>
    pub(crate) const SLOT_CHANGES: usize = 1;      // *mut u8 -> Map<String,String>
    pub(crate) const SLOT_ERRORS: usize = 2;       // *mut u8 -> Map<String,String>
    pub(crate) const SLOT_VALID: usize = 3;         // i64: 1 = valid, 0 = invalid
    pub(crate) const SLOT_FIELD_TYPES: usize = 4;  // *mut u8 -> List<String>
    pub(crate) const SLOT_TABLE: usize = 5;         // *mut u8 -> MeshString (or null)
    pub(crate) const SLOT_PK: usize = 6;            // *mut u8 -> MeshString (or null)
    pub(crate) const SLOT_ACTION: usize = 7;        // i64: 0 = insert, 1 = update
    ```

    **Helper functions:**
    ```rust
    unsafe fn cs_get(cs: *mut u8, slot: usize) -> *mut u8 {
        *(cs.add(slot * 8) as *const *mut u8)
    }
    unsafe fn cs_set(cs: *mut u8, slot: usize, val: *mut u8) {
        *(cs.add(slot * 8) as *mut *mut u8) = val;
    }
    unsafe fn cs_get_int(cs: *mut u8, slot: usize) -> i64 {
        *(cs.add(slot * 8) as *const i64)
    }
    unsafe fn cs_set_int(cs: *mut u8, slot: usize, val: i64) {
        *(cs.add(slot * 8) as *mut i64) = val;
    }
    ```

    Follow the exact same pattern from `query.rs` for slot access helpers. Check how query.rs defines `q_get`, `q_set`, `q_get_int`, `q_set_int`.

    **Allocation and cloning:**
    ```rust
    unsafe fn alloc_changeset() -> *mut u8 {
        let cs = mesh_gc_alloc_actor(CS_SIZE as u64, 8);
        std::ptr::write_bytes(cs, 0, CS_SIZE);
        cs_set(cs, SLOT_DATA, mesh_map_new_typed(1));       // string-keyed
        cs_set(cs, SLOT_CHANGES, mesh_map_new_typed(1));
        cs_set(cs, SLOT_ERRORS, mesh_map_new_typed(1));
        cs_set_int(cs, SLOT_VALID, 1);                      // valid until proven otherwise
        cs_set(cs, SLOT_FIELD_TYPES, mesh_list_new());
        cs_set_int(cs, SLOT_ACTION, 0);                     // insert by default
        cs
    }

    unsafe fn clone_changeset(src: *mut u8) -> *mut u8 {
        let dst = mesh_gc_alloc_actor(CS_SIZE as u64, 8);
        std::ptr::copy_nonoverlapping(src, dst, CS_SIZE);
        dst
    }
    ```

    **`mesh_changeset_cast(data, params, allowed)` -- 3-arg version (no type coercion):**
    1. Allocate new changeset via `alloc_changeset()`
    2. Set `SLOT_DATA` to `data` (the existing record Map, or empty Map for inserts)
    3. Iterate `allowed` list to get allowed field names as Rust strings. Use the same list iteration pattern from query.rs or repo.rs (check how they iterate List pointers -- likely via `mesh_list_length` + `mesh_list_get`).
    4. For each allowed field name, check if `params` map has that key (use `mesh_map_has_key`). If yes, get the value and put it into a new changes Map.
    5. No type coercion -- string values pass through as-is.
    6. Set `SLOT_CHANGES` to the built changes map.
    7. `SLOT_ERRORS` stays empty, `SLOT_VALID` stays 1.
    8. Return the changeset pointer.

    **`mesh_changeset_cast_with_types(data, params, allowed, field_types)` -- 4-arg version (with type coercion):**
    Same as 3-arg version but additionally:
    1. Parse `field_types` list (format: "field_name:SQL_TYPE" strings from `__field_types__()`).
    2. Build a lookup map from field name to SQL type.
    3. For each allowed field value from params, attempt type coercion:
       - `TEXT` -> pass through
       - `BIGINT` -> parse as i64, error on failure
       - `DOUBLE PRECISION` -> parse as f64, error on failure
       - `BOOLEAN` -> accept "true"/"false"/"1"/"0"/"t"/"f", error on others
    4. If coercion fails, add error "is invalid" to errors map for that field. Do NOT add the field to changes.
    5. If coercion succeeds, add the coerced string value to changes.
    6. After processing all fields, update `SLOT_VALID` based on whether errors map is empty.

    For string helper functions (converting between Mesh strings and Rust strings), look at how `repo.rs` or `query.rs` handles this. They likely use patterns like:
    - `mesh_string_to_rust(ptr)` or `std::slice::from_raw_parts` to read a Mesh string
    - `mesh_string_new(bytes, len)` to create a Mesh string

    Search for how `mesh_str_ref` or similar functions are used in the existing runtime code to convert `*mut u8` Mesh strings to `&str`.

    **Validator implementations (all follow the same pattern: clone, check, add error if needed, update valid):**

    **`mesh_changeset_validate_required(cs, fields_list)`:**
    1. Clone the changeset
    2. For each field in fields_list:
       - Check if field exists and is non-empty in `changes` map. If not, also check `data` map (for update changesets where unchanged fields are in data).
       - If field is missing or empty string in both maps, and no error exists yet for this field: add error `"can't be blank"`.
    3. Update SLOT_VALID.
    4. Return new changeset.

    **`mesh_changeset_validate_length(cs, field, min, max)`:**
    1. Clone the changeset
    2. Get field value from `changes` map. If field not in changes, skip (don't validate absent fields).
    3. Get string length.
    4. If min != -1 and length < min: add error `"should be at least {min} character(s)"`.
    5. If max != -1 and length > max: add error `"should be at most {max} character(s)"`.
    6. Only add first error per field (check mesh_map_has_key on errors before adding).
    7. Update SLOT_VALID. Return new changeset.

    **`mesh_changeset_validate_format(cs, field, pattern)`:**
    1. Clone the changeset
    2. Get field value from `changes` map. If absent, skip.
    3. Check if the field value string contains the pattern substring (Rust `str::contains`).
    4. If not, and no error exists for field: add error `"has invalid format"`.
    5. Update SLOT_VALID. Return new changeset.

    **`mesh_changeset_validate_inclusion(cs, field, allowed_values_list)`:**
    1. Clone the changeset
    2. Get field value from `changes`. If absent, skip.
    3. Iterate allowed_values_list and check if field value matches any.
    4. If no match, and no error exists for field: add error `"is invalid"`.
    5. Update SLOT_VALID. Return new changeset.

    **`mesh_changeset_validate_number(cs, field, gt, lt, gte, lte)`:**
    1. Clone the changeset
    2. Get field value from `changes`. If absent, skip.
    3. Parse value as i64 (all numeric values stored as strings in Map<String,String>).
    4. If parse fails: add error `"is not a number"`.
    5. If gt != -1 and value <= gt: add error `"must be greater than {gt}"`.
    6. If lt != -1 and value >= lt: add error `"must be less than {lt}"`.
    7. If gte != -1 and value < gte: add error `"must be greater than or equal to {gte}"`.
    8. If lte != -1 and value > lte: add error `"must be less than or equal to {lte}"`.
    9. Only add first error per field. Update SLOT_VALID. Return new changeset.

    **Field accessors:**

    **`mesh_changeset_valid(cs)`:** Return `cs_get_int(cs, SLOT_VALID)` as `*mut u8` (i64 -> pointer cast, matching Bool convention where 1 = true, 0 = false).

    **`mesh_changeset_errors(cs)`:** Return `cs_get(cs, SLOT_ERRORS)`.

    **`mesh_changeset_changes(cs)`:** Return `cs_get(cs, SLOT_CHANGES)`.

    **`mesh_changeset_get_change(cs, field)`:** Look up field (as string key) in changes map. Return the value or empty string if not found.

    **`mesh_changeset_get_error(cs, field)`:** Look up field in errors map. Return the value or empty string if not found.

    **5. Module registration (db/mod.rs):**
    Add `pub mod changeset;` to the db module.

    **6. Re-exports (lib.rs):**
    Re-export all 12 `mesh_changeset_*` functions from `lib.rs`, following the existing pattern for `mesh_query_*` and `mesh_repo_*`.

    **7. JIT registration (jit.rs):**
    Add JIT symbol mappings for all 12 Changeset functions.

    **Commit:** `feat(99-01): implement Changeset struct with cast and validation pipeline`
  </action>
  <verify>
    Run `cargo build --workspace` -- zero errors.
    Run `cargo test -p mesh-rt` -- all tests pass (zero regressions).
    Verify 12 Changeset functions present in intrinsics, known_functions, map_builtin_name, JIT, and lib.rs re-exports.
  </verify>
  <done>
    Changeset module registered across full compiler pipeline. Runtime implements 8-slot opaque changeset with cast (3-arg and 4-arg), five validators, and five field accessors. All validators follow clone-check-error-return pattern without short-circuiting. Type coercion in cast_with_types handles TEXT, BIGINT, DOUBLE PRECISION, BOOLEAN with error on failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for Changeset cast, validation pipeline, and pipe-chain composition</name>
  <files>
    crates/meshc/tests/e2e.rs
  </files>
  <action>
    Add e2e tests verifying Changeset functions compile and work correctly. These tests verify compilation, type checking, and (where possible) runtime behavior through compile-and-run tests.

    **Test 1: changeset_cast_basic** -- Verify Changeset.cast creates changeset from params:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => "Alice", "email" => "alice@example.com", "role" => "admin"}
      let cs = Changeset.cast(data, params, [:name, :email])
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `valid\n` (cast filters to allowed fields, no validation errors)

    **Test 2: changeset_validate_required** -- Verify validate_required catches missing fields:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => "Alice"}
      let cs = Changeset.cast(data, params, [:name, :email])
        |> Changeset.validate_required([:name, :email])
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `invalid\n` (email is missing from params, so not in changes)

    **Test 3: changeset_validate_length** -- Verify validate_length catches short strings:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => "Al", "email" => "a@b.com"}
      let cs = Changeset.cast(data, params, [:name, :email])
        |> Changeset.validate_length(:name, 3, -1)
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `invalid\n` ("Al" has length 2, min is 3)

    **Test 4: changeset_validate_format** -- Verify validate_format checks substring:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"email" => "not-an-email"}
      let cs = Changeset.cast(data, params, [:email])
        |> Changeset.validate_format(:email, "@")
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `invalid\n` ("not-an-email" does not contain "@")

    **Test 5: changeset_validate_inclusion** -- Verify validate_inclusion checks allowed values:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"role" => "superadmin"}
      let cs = Changeset.cast(data, params, [:role])
        |> Changeset.validate_inclusion(:role, ["admin", "user"])
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `invalid\n` ("superadmin" not in ["admin", "user"])

    **Test 6: changeset_validate_number** -- Verify validate_number checks bounds:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"age" => "0"}
      let cs = Changeset.cast(data, params, [:age])
        |> Changeset.validate_number(:age, 0, -1, -1, -1)
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `invalid\n` (age 0 is not greater than 0; gt=0 means value must be > 0)

    **Test 7: changeset_pipe_chain_accumulates_errors** -- Multiple validators on different fields accumulate errors:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => "A", "email" => "bad"}
      let cs = Changeset.cast(data, params, [:name, :email])
        |> Changeset.validate_required([:name, :email])
        |> Changeset.validate_length(:name, 2, -1)
        |> Changeset.validate_format(:email, "@")
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `invalid\n` (name too short AND email missing @; errors accumulate)

    **Test 8: changeset_valid_passes** -- Changeset with all validations passing:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => "Alice", "email" => "alice@example.com"}
      let cs = Changeset.cast(data, params, [:name, :email])
        |> Changeset.validate_required([:name, :email])
        |> Changeset.validate_length(:name, 2, 50)
        |> Changeset.validate_format(:email, "@")
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `valid\n` (all validations pass)

    **Test 9: changeset_cast_with_types_compiles** -- Verify 4-arg cast with field_types compiles:
    ```mesh
    import Changeset

    struct User do
      id: String
      name: String
      email: String
    end deriving(Schema, Row)

    fn main() do
      let data = %{}
      let params = %{"name" => "Alice", "email" => "alice@example.com"}
      let cs = Changeset.cast_with_types(data, params, [:name, :email], User.__field_types__())
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `valid\n` (cast with field type metadata compiles and runs)

    **Test 10: changeset_accessors** -- Verify changes and get_change work:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => "Alice", "email" => "alice@example.com"}
      let cs = Changeset.cast(data, params, [:name, :email])
      let name = Changeset.get_change(cs, :name)
      println(name)
    end
    ```
    Expected: `Alice\n`

    **Commit:** `test(99-01): add e2e tests for Changeset cast and validation pipeline`
  </action>
  <verify>
    Run `cargo test -p meshc --test e2e` -- ALL tests pass including all new Changeset tests.
    Verify zero regressions in pre-existing tests (~197 tests from Phase 98).
    Run `cargo build --workspace` -- clean build.
  </verify>
  <done>
    10 e2e tests verify Changeset cast (basic and with types), all five validators (required, length, format, inclusion, number), pipe-chain error accumulation, valid changeset, and field accessors. All tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` -- zero errors, zero new warnings
2. `cargo test -p meshc --test e2e` -- all tests pass (~197 baseline + 10 new)
3. `cargo test -p mesh-rt` -- all runtime tests pass
4. All 12 Changeset functions declared across intrinsics, known_functions, map_builtin_name, JIT
5. Changeset module in both STDLIB_MODULE_NAMES (typeck) and STDLIB_MODULES (MIR)
6. Pipe-chain validation demonstrated in e2e tests: cast |> validate_required |> validate_length |> validate_format
7. Error accumulation verified: multiple validators add errors to different fields
8. Changeset.valid returns correct Bool based on errors map state
</verification>

<success_criteria>
- Changeset.cast filters params to allowed fields and creates valid changeset
- Changeset.cast_with_types additionally coerces string values by SQL type
- All 5 validators work correctly: validate_required, validate_length, validate_format, validate_inclusion, validate_number
- Validators accumulate errors without short-circuiting
- First error per field wins (no overwriting)
- Pipe-chain composition works: Changeset.cast(...) |> Changeset.validate_required(...)
- Field accessors return correct data: valid, errors, changes, get_change, get_error
- At least 10 e2e tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/099-changesets/99-01-SUMMARY.md`
</output>
