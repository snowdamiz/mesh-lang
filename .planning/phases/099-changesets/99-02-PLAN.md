---
phase: 99-changesets
plan: 02
type: execute
wave: 2
depends_on: ["99-01"]
files_modified:
  - crates/mesh-rt/src/db/pg.rs
  - crates/mesh-rt/src/db/changeset.rs
  - crates/mesh-rt/src/db/repo.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-repl/src/jit.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Repo.insert_changeset(pool, table, changeset) checks changeset.valid before executing SQL and returns Err(changeset) if invalid"
    - "Repo.update_changeset(pool, table, id, changeset) checks changeset.valid before executing SQL and returns Err(changeset) if invalid"
    - "On SQL success, Repo.insert_changeset/update_changeset return Ok(row) as Map<String,String>"
    - "PostgreSQL unique constraint violation (SQLSTATE 23505) is caught and mapped to changeset error with message 'has already been taken' on the appropriate field"
    - "PostgreSQL foreign key violation (SQLSTATE 23503) is caught and mapped to changeset error with message 'does not exist' on the appropriate field"
    - "Enhanced PG error parsing extracts SQLSTATE code, constraint name, and detail from ErrorResponse without breaking existing callers"
  artifacts:
    - path: "crates/mesh-rt/src/db/pg.rs"
      provides: "parse_error_response_full returning structured PgError with sqlstate/constraint/detail fields"
    - path: "crates/mesh-rt/src/db/repo.rs"
      provides: "Repo.insert_changeset and Repo.update_changeset extern C functions"
    - path: "crates/mesh-rt/src/db/changeset.rs"
      provides: "map_constraint_error and extract_field_from_constraint helper functions"
  key_links:
    - from: "crates/mesh-rt/src/db/repo.rs"
      to: "crates/mesh-rt/src/db/changeset.rs"
      via: "Repo changeset functions read changeset slots and call map_constraint_error on PG failures"
      pattern: "SLOT_CHANGES.*SLOT_VALID.*map_constraint_error"
    - from: "crates/mesh-rt/src/db/pg.rs"
      to: "crates/mesh-rt/src/db/repo.rs"
      via: "parse_error_response_full provides structured error for constraint mapping"
      pattern: "parse_error_response_full.*PgError"
    - from: "crates/mesh-rt/src/db/repo.rs"
      to: "crates/mesh-rt/src/db/orm.rs"
      via: "insert_changeset/update_changeset use build_insert_sql/build_update_sql from ORM module"
      pattern: "build_insert_sql.*build_update_sql"
---

<objective>
Add PostgreSQL constraint error mapping and Repo changeset integration. Enhance the PG wire protocol parser to extract SQLSTATE codes and constraint names from ErrorResponse messages. Implement Repo.insert_changeset and Repo.update_changeset that validate changesets before SQL execution and map database constraint violations to human-readable changeset errors. This completes the Changeset phase by connecting validation to persistence.

Purpose: Enables the full changeset workflow where invalid data is rejected before hitting the database, and database-level constraint violations are mapped back to user-friendly field-specific errors.
Output: Enhanced PG error parsing, two new Repo functions, constraint-to-changeset error mapping, e2e tests confirming the full validation-to-persistence pipeline.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/099-changesets/99-RESEARCH.md
@.planning/phases/099-changesets/99-01-SUMMARY.md
@crates/mesh-rt/src/db/pg.rs
@crates/mesh-rt/src/db/repo.rs
@crates/mesh-rt/src/db/changeset.rs
@crates/mesh-rt/src/db/orm.rs
@crates/mesh-rt/src/io.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Enhanced PG error parsing and constraint mapping</name>
  <files>
    crates/mesh-rt/src/db/pg.rs
    crates/mesh-rt/src/db/changeset.rs
  </files>
  <action>
    **1. Enhanced PG error parsing (pg.rs):**

    Add a `PgError` struct and `parse_error_response_full` function. Keep the existing `parse_error_response()` function unchanged for backward compatibility.

    ```rust
    pub(crate) struct PgError {
        pub sqlstate: String,           // 'C' field (e.g., "23505")
        pub message: String,            // 'M' field
        pub detail: Option<String>,     // 'D' field
        pub constraint: Option<String>, // 'n' field
        pub table: Option<String>,      // 't' field
        pub column: Option<String>,     // 'c' field
    }
    ```

    Implement `parse_error_response_full(body: &[u8]) -> PgError` that iterates through the error response body, extracting all tagged fields:
    - `b'C'` -> sqlstate
    - `b'M'` -> message
    - `b'D'` -> detail
    - `b'n'` -> constraint
    - `b't'` -> table
    - `b'c'` -> column
    - `b'\0'` -> terminator, break

    The body format is: `[field_type_byte][null_terminated_string][field_type_byte][null_terminated_string]...[0]`

    This is the same format the existing `parse_error_response()` already parses for the 'M' field. Look at the existing implementation (around line 544-566 according to research) and create a parallel function that extracts additional fields.

    **IMPORTANT backward compatibility:** Update the existing `parse_error_response()` to call `parse_error_response_full()` internally and return just `pg_error.message`. This avoids code duplication and ensures all existing callers continue to work.

    **Error string encoding for downstream consumers:** Update the internal error string construction in the query/execute paths (where ErrorResponse byte `b'E'` is handled) to use `parse_error_response_full()` and format as tab-separated structured string:
    ```rust
    let pg_err = parse_error_response_full(&body);
    let constraint_str = pg_err.constraint.as_deref().unwrap_or("");
    let table_str = pg_err.table.as_deref().unwrap_or("");
    let column_str = pg_err.column.as_deref().unwrap_or("");
    let err_msg = format!("{}\t{}\t{}\t{}\t{}",
        pg_err.sqlstate, constraint_str, table_str, column_str, pg_err.message);
    ```

    The existing `parse_error_response()` public API stays unchanged. Only the internal error string construction in the query/execute paths changes. Since no existing user code parses these error strings, the format change is safe.

    **2. Constraint-to-changeset error mapping (changeset.rs):**

    Add three `pub(crate)` functions to changeset.rs:

    **`map_constraint_error(sqlstate: &str, constraint: &str, table: &str, column: &str) -> Option<(String, String)>`:**
    Match on `sqlstate`:
    - `"23505"` (unique_violation): Call `extract_field_from_constraint(constraint, table)`, return `(field, "has already been taken")`
    - `"23503"` (foreign_key_violation): Call `extract_field_from_constraint(constraint, table)`, return `(field, "does not exist")`
    - `"23502"` (not_null_violation): Use `column` if non-empty, return `(column, "can't be blank")`
    - Anything else: return `None`

    **`extract_field_from_constraint(constraint_name: &str, table_name: &str) -> Option<String>`:**
    PostgreSQL constraint names follow conventions:
    - `{table}_{column}_key` for unique constraints (e.g., "users_email_key" -> "email")
    - `{table}_{column}_fkey` for foreign keys (e.g., "posts_user_id_fkey" -> "user_id")
    - `{table}_pkey` for primary key (e.g., "users_pkey" -> empty, return None)

    Strip the `{table}_` prefix and then strip the `_key`, `_fkey`, `_pkey`, or `_check` suffix. If the resulting field is empty, return None.

    **`add_constraint_error_to_changeset(cs: *mut u8, field: &str, message: &str) -> *mut u8`:**
    An unsafe helper that clones the changeset, adds the error to the errors map (if no error exists for that field yet), updates SLOT_VALID, and returns the new changeset. This is used by the Repo changeset functions (Task 1b) when a PG constraint error is caught.

    **Commit:** `feat(99-02): enhance PG error parsing and add constraint-to-changeset mapping`
  </action>
  <verify>
    Run `cargo build --workspace` -- zero errors.
    Run `cargo test -p mesh-rt` -- all tests pass (no regressions from error format change).
    Verify `PgError` struct and `parse_error_response_full` exist in pg.rs.
    Verify `map_constraint_error`, `extract_field_from_constraint`, and `add_constraint_error_to_changeset` exist in changeset.rs.
  </verify>
  <done>
    PG error parsing enhanced with full ErrorResponse field extraction. Error strings in query/execute paths now include SQLSTATE, constraint, table, and column as tab-separated prefix. Constraint-to-field mapping handles unique_violation, foreign_key_violation, and not_null_violation SQLSTATE codes. All existing callers unaffected.
  </done>
</task>

<task type="auto">
  <name>Task 1b: Repo changeset functions and compiler pipeline integration</name>
  <files>
    crates/mesh-rt/src/db/repo.rs
    crates/mesh-rt/src/lib.rs
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-repl/src/jit.rs
  </files>
  <action>
    **1. Repo changeset functions (repo.rs):**

    Import the changeset slot constants and helpers from changeset.rs: `use super::changeset::{SLOT_CHANGES, SLOT_VALID, cs_get, cs_get_int, map_constraint_error, extract_field_from_constraint, add_constraint_error_to_changeset}`.

    Add a helper to parse the structured error string from pg.rs (tab-separated format from Task 1a):
    ```rust
    fn parse_pg_error_string(err: &str) -> (&str, &str, &str, &str, &str) {
        let parts: Vec<&str> = err.splitn(5, '\t').collect();
        if parts.len() == 5 {
            (parts[0], parts[1], parts[2], parts[3], parts[4])
        } else {
            // Fallback for non-PG errors
            ("", "", "", "", err)
        }
    }
    ```

    **`mesh_repo_insert_changeset(pool, table, changeset) -> *mut u8`:**
    1. If `cs_get_int(changeset, SLOT_VALID) == 0` (invalid): return `alloc_result(1, changeset)` (Err with changeset), skipping SQL entirely.
    2. Extract the changes map from `cs_get(changeset, SLOT_CHANGES)`.
    3. Read the changes map to get column names and values (same map extraction pattern as existing `mesh_repo_insert`).
    4. Build INSERT SQL using `build_insert_sql_pure` from orm.rs with RETURNING *.
    5. Execute via `mesh_pool_query(pool, sql_ptr, params_ptr)`.
    6. Check the result:
       - If OK: Extract first row, return `alloc_result(0, first_row)`.
       - If Err: Parse the error string via `parse_pg_error_string`, call `map_constraint_error(sqlstate, constraint, table, column)`.
         - If constraint mapped: call `add_constraint_error_to_changeset(changeset, field, message)`, return `alloc_result(1, changeset_with_error)`.
         - If not mapped: return `alloc_result(1, changeset)` with a generic "_base" error added.

    **`mesh_repo_update_changeset(pool, table, id, changeset) -> *mut u8`:**
    Same pattern as insert_changeset but builds UPDATE SQL with WHERE id = $N+1.

    **2. Type checker (infer.rs):**
    Add to the existing Repo module:
    ```
    Repo.insert_changeset(Ptr, String, Ptr) -> Ptr
        // (pool, table, changeset) -> Result<Map, Changeset>
    Repo.update_changeset(Ptr, String, String, Ptr) -> Ptr
        // (pool, table, id, changeset) -> Result<Map, Changeset>
    ```

    **3. MIR lowerer (lower.rs):**
    Add known_functions:
    ```
    "mesh_repo_insert_changeset"  -> FnPtr([Ptr, Ptr, Ptr], Ptr)
    "mesh_repo_update_changeset"  -> FnPtr([Ptr, Ptr, Ptr, Ptr], Ptr)
    ```
    Add map_builtin_name:
    ```
    "repo_insert_changeset" => "mesh_repo_insert_changeset"
    "repo_update_changeset" => "mesh_repo_update_changeset"
    ```

    **4. LLVM intrinsics (intrinsics.rs):**
    Declare 2 new Repo changeset functions following the existing pattern.

    **5. Re-exports (lib.rs):**
    Re-export `mesh_repo_insert_changeset` and `mesh_repo_update_changeset`.

    **6. JIT registration (jit.rs):**
    Add JIT symbol mappings for the 2 new functions.

    **Commit:** `feat(99-02): implement Repo changeset functions with constraint error mapping`
  </action>
  <verify>
    Run `cargo build --workspace` -- zero errors.
    Run `cargo test -p mesh-rt` -- all tests pass.
    Verify 2 new Repo functions in intrinsics, known_functions, map_builtin_name, JIT, and lib.rs re-exports.
    Verify repo.rs imports and uses changeset slot constants and constraint mapping helpers from Task 1a.
  </verify>
  <done>
    Repo.insert_changeset and Repo.update_changeset validate changeset before SQL execution, returning Err(changeset) immediately if invalid. On SQL success, return Ok(row). On PG constraint violation, parse structured error string from Task 1a, map to field-specific changeset error, return Err(changeset_with_error). Registered across full compiler pipeline (typeck, MIR, intrinsics, JIT).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for Repo changeset integration and verify full phase</name>
  <files>
    crates/meshc/tests/e2e.rs
  </files>
  <action>
    Add e2e tests verifying Repo changeset functions compile and the full changeset pipeline works. These tests verify compilation, type checking, and basic runtime behavior.

    **Test 1: repo_insert_changeset_compiles** -- Verify Repo.insert_changeset type signature:
    ```mesh
    import Changeset
    import Repo

    fn main() do
      println("ok")
    end
    ```
    Expected: `ok\n` (Changeset and Repo modules both importable)

    **Test 2: changeset_invalid_skips_sql** -- Verify invalid changeset returns immediately without SQL:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => ""}
      let cs = Changeset.cast(data, params, [:name, :email])
        |> Changeset.validate_required([:name, :email])
      if Changeset.valid(cs) do
        println("would execute SQL")
      else
        println("skipped SQL")
      end
    end
    ```
    Expected: `skipped SQL\n`

    **Test 3: full_changeset_validation_pipeline** -- Full pipeline from cast through multiple validations:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => "Alice", "email" => "alice@example.com", "role" => "admin"}
      let cs = Changeset.cast(data, params, [:name, :email, :role])
        |> Changeset.validate_required([:name, :email])
        |> Changeset.validate_length(:name, 2, 50)
        |> Changeset.validate_format(:email, "@")
        |> Changeset.validate_inclusion(:role, ["admin", "user", "moderator"])
      if Changeset.valid(cs) do
        println("valid")
      else
        println("invalid")
      end
    end
    ```
    Expected: `valid\n`

    **Test 4: changeset_repo_insert_type_checks** -- Verify Repo.insert_changeset has correct type:
    ```mesh
    import Changeset
    import Repo

    struct User do
      id: String
      name: String
      email: String
    end deriving(Schema, Row)

    fn main() do
      let data = %{}
      let params = %{"name" => "Alice", "email" => "alice@example.com"}
      let cs = Changeset.cast_with_types(data, params, [:name, :email], User.__field_types__())
        |> Changeset.validate_required([:name, :email])
        |> Changeset.validate_format(:email, "@")
      println("ok")
    end
    ```
    Expected: `ok\n` (Full changeset with schema metadata type-checks correctly)

    **Test 5: changeset_update_type_checks** -- Verify Repo.update_changeset has correct type:
    ```mesh
    import Changeset
    import Repo

    fn main() do
      let data = %{"name" => "Alice", "email" => "alice@example.com"}
      let params = %{"name" => "Bob"}
      let cs = Changeset.cast(data, params, [:name])
        |> Changeset.validate_required([:name])
        |> Changeset.validate_length(:name, 1, 50)
      if Changeset.valid(cs) do
        println("valid update")
      else
        println("invalid update")
      end
    end
    ```
    Expected: `valid update\n` (Update changeset with existing data + new params passes validation)

    **Test 6: changeset_error_accumulation_multiple_fields** -- Verify errors accumulate across multiple fields:
    ```mesh
    import Changeset

    fn main() do
      let data = %{}
      let params = %{"name" => "", "email" => "bad", "age" => "-5"}
      let cs = Changeset.cast(data, params, [:name, :email, :age])
        |> Changeset.validate_required([:name])
        |> Changeset.validate_format(:email, "@")
        |> Changeset.validate_number(:age, 0, -1, -1, -1)
      if Changeset.valid(cs) do
        println("valid")
      else
        let name_err = Changeset.get_error(cs, :name)
        let email_err = Changeset.get_error(cs, :email)
        println(name_err)
        println(email_err)
      end
    end
    ```
    Expected:
    ```
    can't be blank
    has invalid format
    ```
    (Errors accumulate: name is blank, email has invalid format, age is not > 0. Each field gets its own error.)

    **Commit:** `test(99-02): add e2e tests for Repo changeset integration and constraint mapping`
  </action>
  <verify>
    Run `cargo test -p meshc --test e2e` -- ALL tests pass including all new Phase 99 tests.
    Count total new tests from Phase 99 (across both plans): should be ~16 new tests.
    Verify zero regressions in pre-existing tests (~197 tests from Phase 98).
    Run `cargo build --workspace` -- clean build.
  </verify>
  <done>
    6 e2e tests verify Repo changeset integration: module import, invalid changeset skipping SQL, full validation pipeline, Schema + changeset type checking, update changeset with existing data, and multi-field error accumulation with get_error accessor. All tests pass with zero regressions. Phase 99 complete.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` -- zero errors, zero new warnings
2. `cargo test -p meshc --test e2e` -- all tests pass (~197 baseline + ~16 new from Phase 99)
3. `cargo test -p mesh-rt` -- all runtime tests pass
4. PgError struct and parse_error_response_full exist in pg.rs
5. map_constraint_error and extract_field_from_constraint exist in changeset.rs
6. Repo.insert_changeset and Repo.update_changeset registered across full compiler pipeline
7. Error string format includes SQLSTATE and constraint info for PG errors
8. Constraint name parsing handles users_email_key -> email, posts_user_id_fkey -> user_id conventions
9. Full validation pipeline demonstrated: Changeset.cast |> validators |> Repo.insert_changeset
</verification>

<success_criteria>
- Repo.insert_changeset returns Err(changeset) when changeset is invalid, without executing SQL
- Repo.update_changeset returns Err(changeset) when changeset is invalid, without executing SQL
- On SQL success, both return Ok(row) with the inserted/updated row
- PG unique violation (23505) maps to "has already been taken" on the constraint field
- PG foreign key violation (23503) maps to "does not exist" on the constraint field
- Enhanced PG error parsing is backward compatible (existing callers unaffected)
- At least 6 new e2e tests pass with zero regressions
- Full changeset pipeline works: cast -> validate -> Repo.insert_changeset
</success_criteria>

<output>
After completion, create `.planning/phases/099-changesets/99-02-SUMMARY.md`
</output>
