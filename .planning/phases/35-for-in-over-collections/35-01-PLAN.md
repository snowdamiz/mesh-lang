---
phase: 35-for-in-over-collections
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/collections/list.rs
  - crates/snow-rt/src/collections/map.rs
  - crates/snow-rt/src/collections/set.rs
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "snow_list_builder_new and snow_list_builder_push exist in runtime for O(N) list construction"
    - "snow_map_entry_key and snow_map_entry_value provide indexed access to map entries"
    - "snow_set_element_at provides indexed access to set elements"
    - "Parser accepts {k, v} destructuring binding in for-in position"
    - "Type checker detects List<T>, Map<K,V>, Set<T> iterables and binds loop variables to correct element types"
    - "Type checker returns List<body_type> for all for-in expressions (comprehension semantics)"
    - "MIR has ForInList, ForInMap, ForInSet variants with correct field structures"
    - "MIR lowering dispatches to correct variant based on iterable type from typeck"
  artifacts:
    - path: "crates/snow-rt/src/collections/list.rs"
      provides: "snow_list_builder_new, snow_list_builder_push runtime functions"
      contains: "snow_list_builder_new"
    - path: "crates/snow-rt/src/collections/map.rs"
      provides: "snow_map_entry_key, snow_map_entry_value indexed access"
      contains: "snow_map_entry_key"
    - path: "crates/snow-rt/src/collections/set.rs"
      provides: "snow_set_element_at indexed access"
      contains: "snow_set_element_at"
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "DESTRUCTURE_BINDING CST node kind"
      contains: "DESTRUCTURE_BINDING"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "DestructureBinding AST node with accessors"
      contains: "DestructureBinding"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Collection-aware infer_for_in returning List<body_ty>"
      contains: "Ty::list"
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "ForInList, ForInMap, ForInSet MIR variants"
      contains: "ForInList"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Collection-type-dispatching lower_for_in_expr"
      contains: "ForInList"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "typeck types map stores iterable type; MIR lowerer reads it to choose variant"
      pattern: "get_ty.*text_range"
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "DESTRUCTURE_BINDING CST node cast to DestructureBinding AST"
      pattern: "DESTRUCTURE_BINDING"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "lowerer constructs ForInList/ForInMap/ForInSet variants"
      pattern: "MirExpr::ForInList"
---

<objective>
Add runtime functions, parser destructuring, typeck collection detection, and MIR variants for for-in over List/Map/Set.

Purpose: Establish the full pipeline from parsing through MIR lowering so that Plan 02 can implement LLVM codegen against well-defined MIR variants.
Output: Runtime has O(N) list builder + indexed collection access; parser accepts `{k, v}` destructuring; typeck returns `List<body_ty>` for all for-in; MIR has three new collection iteration variants.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-for-in-over-collections/35-RESEARCH.md
@.planning/phases/34-for-in-over-range/34-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add runtime functions for list builder and indexed collection access</name>
  <files>
    crates/snow-rt/src/collections/list.rs
    crates/snow-rt/src/collections/map.rs
    crates/snow-rt/src/collections/set.rs
  </files>
  <action>
Add three categories of runtime functions:

**List builder (crates/snow-rt/src/collections/list.rs):**

1. `snow_list_builder_new(capacity: i64) -> *mut u8` -- calls `alloc_list(capacity.max(0) as u64)` to pre-allocate a list with the given capacity. Length starts at 0. This is for O(N) result building in for-in codegen.

2. `snow_list_builder_push(list: *mut u8, element: u64)` -- in-place mutation: reads current `list_len(list)`, writes `element` at `list_data_mut(list).add(len)`, then increments the length field at `*(list as *mut u64) = (len + 1) as u64`. This is O(1) per call. SAFETY: only valid during construction before the list is shared.

Both functions should be `#[no_mangle] pub extern "C"` and marked `unsafe` internally (using `unsafe {}` block, not `unsafe fn`).

**Map indexed access (crates/snow-rt/src/collections/map.rs):**

3. `snow_map_entry_key(map: *mut u8, index: i64) -> u64` -- reads `map_len(map)`, panics if `index < 0 || index as u64 >= len`, then returns `(*map_entries(map).add(index as usize))[0]`.

4. `snow_map_entry_value(map: *mut u8, index: i64) -> u64` -- same bounds check, returns `(*map_entries(map).add(index as usize))[1]`.

**Set indexed access (crates/snow-rt/src/collections/set.rs):**

5. `snow_set_element_at(set: *mut u8, index: i64) -> u64` -- reads `set_len(set)`, panics if out of bounds, returns `*set_data(set).add(index as usize)`.

Add unit tests at the bottom of each file (in the existing `#[cfg(test)]` module) to verify:
- `snow_list_builder_new(3)` creates a list with length 0
- Three `snow_list_builder_push` calls produce a list with length 3 and correct elements (verify via `snow_list_get`)
- `snow_list_builder_new(0)` creates a valid empty list (length 0, no crash)
- `snow_map_entry_key`/`snow_map_entry_value` return correct key/value pairs at each index after building a map with `snow_map_put`
- `snow_set_element_at` returns the correct element after building a set with `snow_set_add`
  </action>
  <verify>
`cargo test -p snow-rt` passes, including the new builder and indexed-access tests.
  </verify>
  <done>
Runtime has `snow_list_builder_new`, `snow_list_builder_push`, `snow_map_entry_key`, `snow_map_entry_value`, and `snow_set_element_at` with passing unit tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Parser destructuring, typeck collection detection, MIR variants and lowering</name>
  <files>
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/ast/expr.rs
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**Parser -- {k, v} destructuring:**

1. In `crates/snow-parser/src/syntax_kind.rs`: Add `DESTRUCTURE_BINDING` to the composite node kinds (alongside FOR_IN_EXPR, WHILE_EXPR, etc.).

2. In `crates/snow-parser/src/parser/expressions.rs`: Modify `parse_for_in_expr`. After advancing past FOR_KW, check if the next token is `L_BRACE`. If so:
   - Open a marker for DESTRUCTURE_BINDING
   - Advance past L_BRACE
   - Parse first IDENT as NAME node
   - If COMMA, advance and parse second IDENT as NAME node
   - Expect R_BRACE
   - Close marker as DESTRUCTURE_BINDING
   Otherwise, keep existing single-IDENT NAME parsing unchanged. The rest of parse_for_in_expr (IN_KW, iterable expr, DO_KW, body, END_KW) stays the same.

3. In `crates/snow-parser/src/ast/expr.rs`: Add `DestructureBinding` AST node:
   ```
   ast_node!(DestructureBinding, DESTRUCTURE_BINDING);
   ```
   With a method `names(&self) -> Vec<Name>` that returns all NAME children using `child_nodes`. Add a new method on `ForInExpr`:
   ```
   pub fn destructure_binding(&self) -> Option<DestructureBinding> {
       child_node(&self.syntax)
   }
   ```

**Typeck -- collection type detection and comprehension return:**

4. In `crates/snow-typeck/src/infer.rs`: Rewrite `infer_for_in` to handle List/Map/Set/Range iterables:

   - Infer the iterable expression type (already done).
   - Apply the iterable type via `ctx.apply(iter_ty)` to resolve type variables.
   - Check if iterable is a DotDot binary expr (range) -- if so, keep existing Int-binding logic.
   - Otherwise, match the resolved iterable type:
     - `Ty::App(Con("List"), [elem_ty])` -- bind single loop var as `elem_ty`
     - `Ty::App(Con("Map"), [key_ty, val_ty])` -- check for destructure_binding on the ForInExpr; bind `k` as `key_ty`, `v` as `val_ty`. If no destructuring, emit a type error.
     - `Ty::App(Con("Set"), [elem_ty])` -- bind single loop var as `elem_ty`
     - Other -- emit a type error "cannot iterate over type X"
   - For map destructuring: read variable names from `for_in.destructure_binding().names()` (expect exactly 2 names).
   - Push scope, insert bindings, enter_loop, infer body, exit_loop, pop_scope (same structure as before).
   - **Return `Ty::list(body_ty)` instead of `Ty::Tuple(vec![])`.** This is the comprehension semantics change (FORIN-05). Use `Ty::list(body_ty)` where `body_ty` is the inferred type of the body expression.

**MIR -- new variants:**

5. In `crates/snow-codegen/src/mir/mod.rs`: Add three new variants to `MirExpr` enum after `ForInRange`:

   ```
   ForInList { var: String, collection: Box<MirExpr>, body: Box<MirExpr>, elem_ty: MirType, body_ty: MirType, ty: MirType },
   ForInMap { key_var: String, val_var: String, collection: Box<MirExpr>, body: Box<MirExpr>, key_ty: MirType, val_ty: MirType, body_ty: MirType, ty: MirType },
   ForInSet { var: String, collection: Box<MirExpr>, body: Box<MirExpr>, elem_ty: MirType, body_ty: MirType, ty: MirType },
   ```

   All three have `ty: MirType` which is always `MirType::Ptr` (the result list pointer).

   Update the `ty()` method match to return `ty` for all three variants.

6. In `crates/snow-codegen/src/mir/lower.rs`: Rewrite `lower_for_in_expr`:

   - Keep the DotDot range detection: if iterable is a BinaryExpr with DOT_DOT op, build ForInRange as before. But change its `ty` from `MirType::Unit` to `MirType::Ptr` (since it now returns List<T> per comprehension semantics). Also add `body_ty` field to ForInRange if needed, OR handle the conversion in codegen by inspecting the body's ty() -- decide based on what's simpler. Note: ForInRange already has a `ty` field; changing it to `Ptr` is sufficient since codegen will use the body expression's type to determine element conversion.

   - For non-range iterables: look up the iterable's type from typeck results using `self.get_ty(iterable.syntax().text_range())`.
   - Add helper functions `extract_map_types(ty: &Ty) -> Option<(Ty, Ty)>` and `extract_set_elem_type(ty: &Ty) -> Option<Ty>` following the pattern of existing `extract_list_elem_type`. For Map: match `Ty::App(Con("Map"), [key_ty, val_ty])`. For Set: match `Ty::App(Con("Set"), [elem_ty])`.
   - Based on the iterable type, construct the appropriate MIR variant:
     - List: `MirExpr::ForInList { var, collection, body, elem_ty, body_ty, ty: MirType::Ptr }`
     - Map: `MirExpr::ForInMap { key_var, val_var, collection, body, key_ty, val_ty, body_ty, ty: MirType::Ptr }`. Extract key_var and val_var from `for_in.destructure_binding()`.
     - Set: `MirExpr::ForInSet { var, collection, body, elem_ty, body_ty, ty: MirType::Ptr }`
   - Use `self.resolve_type(&ty)` to convert Ty to MirType for elem_ty/body_ty/key_ty/val_ty.

   Update all match arms that handle `ForInRange` to also handle the three new variants:
   - `collect_free_vars`: ForInList/ForInSet -- collect from `collection` and `body` with `var` excluded from body. ForInMap -- collect from `collection` and `body` with `key_var` and `val_var` excluded.
   - `ty()` match in mod.rs (already covered above).

7. In `crates/snow-codegen/src/mir/mono.rs`: Add match arms for `ForInList`, `ForInMap`, `ForInSet` in `collect_function_refs` -- collect from `collection` and `body`.

8. In `crates/snow-codegen/src/pattern/compile.rs`: Add match arms for `ForInList`, `ForInMap`, `ForInSet` in `compile_expr_patterns` -- recurse into `collection` and `body`.

9. In `crates/snow-codegen/src/codegen/expr.rs`: Add placeholder match arms for `ForInList`, `ForInMap`, `ForInSet` that return a call to `snow_list_new()` (empty list). This prevents exhaustive match errors and lets the compiler build. Plan 02 will implement the real codegen.
  </action>
  <verify>
`cargo test -p snow-parser -p snow-typeck -p snow-codegen` passes. Verify with `cargo build` that the entire workspace compiles. Run `cargo test` to ensure all 1,273+ existing tests still pass.
  </verify>
  <done>
Parser accepts `for {k, v} in map_expr do body end` syntax. Type checker detects List/Map/Set iterables, binds correct element types, and returns `List<body_ty>`. MIR has ForInList/ForInMap/ForInSet variants. MIR lowerer dispatches to correct variant based on typeck iterable type. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- all tests pass (existing + new runtime tests)
2. `cargo build` -- full workspace compiles without errors
3. New runtime functions verified by unit tests in snow-rt
4. Parser handles both `for x in expr do...end` and `for {k, v} in expr do...end`
5. Typeck returns `List<T>` for for-in expressions (not Unit)
</verification>

<success_criteria>
- Runtime has 5 new extern "C" functions with passing unit tests
- Parser accepts {k, v} destructuring in for-in binding position
- Type checker returns List<body_ty> for all for-in forms
- MIR has ForInList, ForInMap, ForInSet variants
- MIR lowering selects correct variant based on iterable type
- All 1,273+ existing tests pass
- Workspace compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/35-for-in-over-collections/35-01-SUMMARY.md`
</output>
