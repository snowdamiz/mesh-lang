---
phase: 35-for-in-over-collections
plan: 02
type: execute
wave: 2
depends_on: ["35-01"]
files_modified:
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-codegen/src/codegen/mod.rs
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/e2e.rs
  - tests/e2e/for_in_list.snow
  - tests/e2e/for_in_map.snow
  - tests/e2e/for_in_set.snow
autonomous: true

must_haves:
  truths:
    - "User can write `for x in my_list do x * 2 end` and get a List<Int> of doubled values"
    - "User can write `for {k, v} in my_map do v end` and get a List of map values"
    - "User can write `for x in my_set do x end` and get a List of set elements"
    - "For-in over an empty list/map/set returns an empty list without error"
    - "break inside for-in returns the partially collected list"
    - "continue inside for-in skips the current element (not added to result list)"
    - "For-in over range now returns List<T> (comprehension semantics) instead of Unit"
    - "Result list is built with O(N) list builder (snow_list_builder_new + push), not O(N^2) append"
  artifacts:
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for snow_list_builder_new, snow_list_builder_push, snow_map_entry_key, snow_map_entry_value, snow_set_element_at"
      contains: "snow_list_builder_new"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "codegen_for_in_list, codegen_for_in_map, codegen_for_in_set functions"
      contains: "codegen_for_in_list"
    - path: "tests/e2e/for_in_list.snow"
      provides: "E2E test for for-in over list"
    - path: "tests/e2e/for_in_map.snow"
      provides: "E2E test for for-in over map"
    - path: "tests/e2e/for_in_set.snow"
      provides: "E2E test for for-in over set"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E test harness entries for for_in_list, for_in_map, for_in_set"
      contains: "for_in_list"
  key_links:
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "codegen calls get_intrinsic for snow_list_builder_new/push, snow_map_entry_key/value, snow_set_element_at"
      pattern: "get_intrinsic.*snow_list_builder"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "codegen emits calls to runtime list builder functions"
      pattern: "snow_list_builder_push"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "codegen_expr dispatches ForInList/ForInMap/ForInSet to codegen functions"
      pattern: "MirExpr::ForInList"
---

<objective>
Implement LLVM codegen for for-in over List/Map/Set with comprehension semantics, update ForInRange to return List<T>, and add comprehensive e2e tests.

Purpose: Complete the full for-in-over-collections feature so users can iterate any collection type and get a collected List of body results back.
Output: Working codegen for all three collection types + range comprehension + e2e tests proving correctness of iteration, empty collections, break, and continue.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-for-in-over-collections/35-RESEARCH.md
@.planning/phases/35-for-in-over-collections/35-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: LLVM codegen for for-in over collections and range comprehension update</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-codegen/src/codegen/mod.rs
    crates/snow-codegen/src/mir/mod.rs
  </files>
  <action>
**Intrinsic declarations (crates/snow-codegen/src/codegen/intrinsics.rs):**

Declare 5 new runtime functions in `declare_intrinsics`:

1. `snow_list_builder_new(capacity: i64) -> ptr` -- `ptr_type.fn_type(&[i64_type.into()], false)`
2. `snow_list_builder_push(list: ptr, element: u64) -> void` -- `void_type.fn_type(&[ptr_type.into(), i64_type.into()], false)`
3. `snow_map_entry_key(map: ptr, index: i64) -> u64` -- `i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false)`
4. `snow_map_entry_value(map: ptr, index: i64) -> u64` -- `i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false)`
5. `snow_set_element_at(set: ptr, index: i64) -> u64` -- `i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false)`

Add assertions for all 5 in the existing intrinsics test.

**codegen_for_in_list (crates/snow-codegen/src/codegen/expr.rs):**

Implement `codegen_for_in_list(&mut self, var: &str, collection: &MirExpr, body: &MirExpr, elem_ty: &MirType, body_ty: &MirType, _ty: &MirType) -> Result<BasicValueEnum<'ctx>, String>`:

Follow the four-block pattern from `codegen_for_in_range`:

1. **Entry:** Codegen collection expression. Call `snow_list_length(collection)` to get `len`. Call `snow_list_builder_new(len)` to pre-allocate result list. Store result in an alloca (`result_alloca`). Create counter alloca, store 0.

2. **Header:** Load counter, compare `SLT` against `len`. Branch to body (true) or merge (false).

3. **Body:** Call `snow_list_get(collection, counter)` to get element as u64. Convert from u64 to the typed value using a `convert_from_list_element` helper (inverse of `convert_to_list_element`):
   - MirType::Int -> use i64 directly
   - MirType::Bool -> `trunc i64 to i1`
   - MirType::Float -> `bitcast i64 to f64`
   - MirType::String/Ptr/Struct/SumType/Pid/Closure/FnPtr -> `inttoptr i64 to ptr`
   - MirType::Unit -> return unit struct const_zero

   Create alloca for loop variable, store typed element, insert into `self.locals` and `self.local_types` (save old values for restoration). Codegen body. If body block is not terminated: convert body result to u64 via `convert_to_list_element(body_val, body_ty)`, call `snow_list_builder_push(result_alloca_loaded, body_as_u64)`, branch to latch.

4. **Latch:** Load counter, add 1, store back. Call `emit_reduction_check()`. Branch to header.

5. **Cleanup:** Pop loop_stack. Restore old locals/local_types. Position at merge block. Load result_alloca and return as the for-in expression value.

Push `(latch_bb, merge_bb)` onto `self.loop_stack` before entering the loop, so break jumps to merge (returning partial list via alloca) and continue jumps to latch (skipping the append, incrementing counter).

**codegen_for_in_map:**

Same four-block structure as codegen_for_in_list, except:
- Use `snow_map_size(collection)` for length.
- In body: call `snow_map_entry_key(collection, counter)` and `snow_map_entry_value(collection, counter)` to get key and value as u64. Convert each to typed values. Create allocas for both `key_var` and `val_var`, insert both into locals/local_types.
- Codegen body, append body result to result list.
- Restore both key_var and val_var locals on cleanup.

**codegen_for_in_set:**

Same four-block structure as codegen_for_in_list, except:
- Use `snow_set_size(collection)` for length.
- In body: call `snow_set_element_at(collection, counter)` to get element.
- Everything else identical to list iteration.

**Update codegen_for_in_range for comprehension semantics:**

Modify the existing `codegen_for_in_range` to also build a result list:
- After computing start_val and end_val, compute range length: `max(0, end_val - start_val)`.
- Call `snow_list_builder_new(range_len)` and store in a result_alloca.
- In the body, after codegen'ing the body expression: convert body result to u64 via `convert_to_list_element`, call `snow_list_builder_push`.
- In the merge block: load result_alloca and return it (instead of Unit const_zero).
- Update the `ty` field on ForInRange to `MirType::Ptr` in the MIR lowerer (in 35-01's lower_for_in_expr, but if not done there, do it here).

**Dispatch in codegen_expr:**

In the main `codegen_expr` match, replace the placeholder arms for ForInList/ForInMap/ForInSet with calls to the real codegen functions:
```
MirExpr::ForInList { var, collection, body, elem_ty, body_ty, ty } => {
    self.codegen_for_in_list(var, collection, body, elem_ty, body_ty, ty)
}
MirExpr::ForInMap { key_var, val_var, collection, body, key_ty, val_ty, body_ty, ty } => {
    self.codegen_for_in_map(key_var, val_var, collection, body, key_ty, val_ty, body_ty, ty)
}
MirExpr::ForInSet { var, collection, body, elem_ty, body_ty, ty } => {
    self.codegen_for_in_set(var, collection, body, elem_ty, body_ty, ty)
}
```

**Add convert_from_list_element helper:**

Add this helper method to the codegen impl block (near `convert_to_list_element`). It takes a `BasicValueEnum` (which is an i64 from the runtime) and a target `MirType`, and returns the correctly-typed `BasicValueEnum`:
- Int: use the i64 value directly
- Bool: `build_int_truncate` to i1
- Float: `build_bit_cast` to f64
- String/Ptr/Struct/SumType/Pid/Closure/FnPtr: `build_int_to_ptr` to ptr
- Unit: return struct const_zero
  </action>
  <verify>
`cargo build -p snow-codegen` compiles without errors. `cargo test -p snow-codegen` passes, including the intrinsics assertion tests. Run `cargo test` to check all existing tests still pass.
  </verify>
  <done>
LLVM codegen generates correct four-block loop structure for ForInList, ForInMap, ForInSet. ForInRange updated to return List<T>. All collection for-in uses O(N) list builder. break returns partial list via alloca. continue skips element by not reaching the push call. Intrinsics declared for all 5 new runtime functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E tests and formatter verification for for-in over collections</name>
  <files>
    tests/e2e/for_in_list.snow
    tests/e2e/for_in_map.snow
    tests/e2e/for_in_set.snow
    crates/snowc/tests/e2e.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
**E2E test fixtures:**

Create `tests/e2e/for_in_list.snow`:
```snow
fn main() do
  let nums = [1, 2, 3]
  let doubled = for x in nums do
    x * 2
  end
  let len = List.length(doubled)
  println("${len}")

  let empty_result = for x in [] do
    x
  end
  let empty_len = List.length(empty_result)
  println("${empty_len}")
end
```
Expected output: "2\n0\n" -- wait, the length of [1,2,3] doubled is 3, so output should be "3\n0\n". But we need to verify actual values too. Use `List.length` to check the count since printing a list needs Display. Check how e2e tests work in the existing codebase -- they capture stdout and compare.

Actually, use the pattern from `for_in_range.snow`: use `println("${expr}")` for individual values. For lists, we can iterate the result list and print each element. But that requires nested for-in which is fine.

Better approach: test individual element access and length:

```snow
fn main() do
  let nums = [1, 2, 3]
  let doubled = for x in nums do
    x * 2
  end
  println("${List.length(doubled)}")
  println("${List.get(doubled, 0)}")
  println("${List.get(doubled, 1)}")
  println("${List.get(doubled, 2)}")
end
```
Expected output: "3\n2\n4\n6\n"

Wait -- check if `List.get` exists and what it returns. The runtime has `snow_list_get` which returns u64. Check if there's a Snow-level `List.get` exposed. Look at existing e2e tests for patterns.

Use the simplest approach that works with existing infrastructure. The for_in_range tests use string interpolation to print loop iteration values. Do the same: iterate the result and print:

Create `tests/e2e/for_in_list.snow`:
```snow
fn main() do
  let nums = [1, 2, 3]
  let doubled = for x in nums do
    x * 2
  end
  for d in doubled do
    println("${d}")
  end
end
```
Expected output: "2\n4\n6\n"

This is a clean test: it tests both for-in over a list AND that the comprehension result is itself iterable. However, the nested for-in's own result is unused -- we just want the side effects (println). Since for-in now returns a list, the outer for-in's result (a list of Unit values from println) is discarded since it's the last expression in main's body. This should be fine.

Create `tests/e2e/for_in_list.snow` with tests for:
- Basic list iteration with comprehension (for x in [1,2,3] do x*2 end -> print results)
- Empty list iteration (for x in [] do x end -> no output)
- Break in list iteration (partial results)

Create `tests/e2e/for_in_map.snow` with tests for:
- Map destructuring iteration (for {k, v} in map do ... end)
- Print values from map iteration

Create `tests/e2e/for_in_set.snow` with tests for:
- Set iteration (for x in set do x end)

Note on map/set tests: Map and Set are created via `Map.new()` + `Map.put()` and `Set.new()` + `Set.add()`. Check how existing tests create maps and sets. Use string interpolation `${}` for printing (not Int.to_string which has known issues with nested module calls).

**E2E test harness (crates/snowc/tests/e2e.rs):**

Add test functions following the existing pattern (look at `for_in_range` tests for the exact macro/function pattern):

```rust
e2e_test!(for_in_list, "tests/e2e/for_in_list.snow", "2\n4\n6\n");
e2e_test!(for_in_map, "tests/e2e/for_in_map.snow", "<expected output>");
e2e_test!(for_in_set, "tests/e2e/for_in_set.snow", "<expected output>");
```

Adjust the expected output strings based on the actual Snow program behavior. For the break test, use a conditional break pattern: `if x == 2 do break end`.

**Formatter verification (crates/snow-fmt/src/walker.rs):**

The existing `walk_for_in_expr` from Phase 34 should handle collection for-in without changes, since the outer syntax structure (FOR_KW name/destructure IN_KW expr DO_KW body END_KW) is the same. However, check that the DESTRUCTURE_BINDING node is walked correctly. If not, add a walk_destructure_binding that outputs `{`, walks NAME children with comma separators, and outputs `}`. Add a formatter test to verify `for {k, v} in m do body end` round-trips correctly.

**Additional codegen unit tests (crates/snow-codegen/src/codegen/mod.rs):**

Add 2-3 codegen unit tests verifying:
- ForInList generates four basic blocks (header, body, latch, merge)
- ForInRange now returns a non-Unit value (Ptr type)
  </action>
  <verify>
`cargo test` passes all tests including the new e2e tests. Verify the e2e test output matches expected strings exactly. Run `cargo test -p snow-fmt` to confirm formatter tests pass.
  </verify>
  <done>
E2E tests demonstrate: for-in over list produces correct List<T> result, for-in over map with {k,v} destructuring works, for-in over set works, empty collections return empty lists, break returns partial list. ForInRange returns List<T>. Formatter handles destructuring syntax. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- all tests pass (existing 1,273+ plus new e2e and unit tests)
2. E2E: `for x in [1,2,3] do x*2 end` produces list [2,4,6]
3. E2E: `for {k, v} in map do v end` iterates map entries
4. E2E: `for x in set do x end` iterates set elements
5. E2E: for-in over empty collection returns empty list
6. E2E: break in for-in returns partial list
7. ForInRange returns List<T> (not Unit)
8. Formatter round-trips `for {k, v} in m do body end` correctly
</verification>

<success_criteria>
- Users can write `for x in list do body end` and get List<T> back
- Users can write `for {k, v} in map do body end` with destructuring
- Users can write `for x in set do body end`
- Empty collections produce empty lists without error
- break returns partially collected list
- O(N) list builder used (snow_list_builder_new + push), not O(N^2) append
- ForInRange updated to comprehension semantics
- All e2e tests pass with correct expected output
- All 1,273+ existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/35-for-in-over-collections/35-02-SUMMARY.md`
</output>
