---
phase: 34-for-in-over-range
plan: 02
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-codegen/src/mir/mono.rs
  - crates/snow-codegen/src/pattern/compile.rs
  - crates/snow-codegen/src/codegen/mod.rs
  - crates/snow-fmt/src/walker.rs
  - crates/snowc/tests/e2e.rs
  - tests/e2e/for_in_range.snow
autonomous: true

must_haves:
  truths:
    - "User can write `for i in 0..10 do body end` and the body executes once for each integer 0 through 9"
    - "Range iteration compiles to pure integer arithmetic with an alloca counter -- no heap allocation for the range"
    - "The loop variable is scoped to the loop body and does not leak into the surrounding scope"
    - "continue inside for-in jumps to the latch (increment+reduction check), not the header"
    - "break inside for-in exits the loop immediately"
    - "Empty range (10..0) executes zero iterations"
    - "Tight for-in loop does not starve other actors (reduction check at back-edge)"
    - "Formatter produces `for i in 0..10 do\\n  body\\nend` with proper indentation"
  artifacts:
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "MirExpr::ForInRange variant with var, start, end, body, ty fields"
      contains: "ForInRange"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "lower_for_in_expr that extracts start/end from DotDot binary expr"
      contains: "lower_for_in_expr"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "codegen_for_in_range with four-block LLVM structure (header/body/latch/merge)"
      contains: "codegen_for_in_range"
    - path: "crates/snow-fmt/src/walker.rs"
      provides: "walk_for_in_expr formatter function"
      contains: "walk_for_in_expr"
    - path: "tests/e2e/for_in_range.snow"
      provides: "E2E test fixture for for-in over range"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E test functions for for-in range"
      contains: "for_in_range"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "lower_for_in_expr produces MirExpr::ForInRange"
      pattern: "MirExpr::ForInRange"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/mod.rs"
      via: "codegen_for_in_range pushes (latch_bb, merge_bb) onto loop_stack"
      pattern: "loop_stack\\.push.*latch"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/expr.rs"
      via: "codegen_for_in_range calls emit_reduction_check in latch block"
      pattern: "emit_reduction_check"
    - from: "tests/e2e/for_in_range.snow"
      to: "crates/snowc/tests/e2e.rs"
      via: "e2e test compiles and runs the fixture, checking stdout"
      pattern: "for_in_range"
---

<objective>
Add MirExpr::ForInRange, MIR lowering, four-block LLVM codegen, formatter support, and e2e tests for for-in over integer ranges.

Purpose: Complete the for-in over range pipeline so users can write `for i in 0..10 do body end` and it compiles to zero-allocation integer arithmetic with correct break/continue semantics.
Output: Working for-in range loops with e2e test coverage, formatter support, and all existing tests passing.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-for-in-over-range/34-RESEARCH.md
@.planning/phases/33-while-loop-loop-control-flow/33-02-SUMMARY.md
@.planning/phases/34-for-in-over-range/34-01-SUMMARY.md

Key patterns from Phase 33 Plan 02:
- While loop uses three-block structure (cond_check/body/merge); for-in uses four blocks (header/body/latch/merge)
- loop_stack: Vec<(BasicBlock, BasicBlock)> where first = continue target, second = break target
- While pushes (cond_bb, merge_bb); for-in pushes (latch_bb, merge_bb) -- continue/break functions unchanged
- emit_reduction_check() at back-edge (for while: end of body; for for-in: in latch block)
- Terminator guard: check get_terminator().is_none() before emitting branch after body codegen
- Exhaustive match arms needed in mono.rs (collect_function_refs) and pattern/compile.rs (compile_expr_patterns)
- walk_while_expr in formatter is the model for walk_for_in_expr
- E2E tests use compile-and-run pattern with expected stdout
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MirExpr::ForInRange, MIR lowering, LLVM codegen, and formatter</name>
  <files>
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-codegen/src/mir/mono.rs
    crates/snow-codegen/src/pattern/compile.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
1. **MIR variant** (`crates/snow-codegen/src/mir/mod.rs`):
   - Add `ForInRange` variant to `MirExpr` in the "Loop primitives" section (after Continue, before SupervisorStart):
     ```rust
     /// For-in loop over an integer range: `for var in start..end do body end`.
     /// Desugared to integer counter iteration with no heap allocation.
     ForInRange {
         /// Loop variable name.
         var: String,
         /// Start value (inclusive).
         start: Box<MirExpr>,
         /// End value (exclusive).
         end: Box<MirExpr>,
         /// Loop body.
         body: Box<MirExpr>,
         /// Result type (Unit for Phase 34).
         ty: MirType,
     },
     ```
   - Add the `ty()` match arm: `MirExpr::ForInRange { ty, .. } => ty,`

2. **MIR lowering** (`crates/snow-codegen/src/mir/lower.rs`):
   - Replace the placeholder `Expr::ForInExpr(_) => MirExpr::Unit` arm from Plan 01 with actual lowering.
   - Add `lower_for_in_expr` function. It must:
     a. Extract binding name from `for_in.binding_name()` via `.and_then(|n| n.text())`, default to `"_"`.
     b. Extract start and end from the iterable: if iterable is `Expr::BinaryExpr(bin)`, lower `bin.lhs()` and `bin.rhs()` as start and end. If not a BinaryExpr (shouldn't happen for Phase 34 but defensive), default both to `MirExpr::IntLit(0, MirType::Int)`.
     c. Lower the body: push scope, insert the loop variable (`var_name: MirType::Int`) into scope, lower the body block, pop scope.
     d. Return `MirExpr::ForInRange { var, start: Box::new(start), end: Box::new(end), body: Box::new(body), ty: MirType::Unit }`.
   - In `collect_free_vars` (the function that walks MirExpr to find captured variables), add an arm for `ForInRange { var, start, end, body, .. }`: recurse into start, end, and body, but exclude `var` from free vars (it's locally bound).
   - In the main lower_expr match, replace the placeholder with: `Expr::ForInExpr(for_in) => self.lower_for_in_expr(&for_in),`

3. **Exhaustive match arms** (`crates/snow-codegen/src/mir/mono.rs`, `crates/snow-codegen/src/pattern/compile.rs`):
   - In `mono.rs` `collect_function_refs`: add `MirExpr::ForInRange { start, end, body, .. } => { collect_function_refs(start, refs); collect_function_refs(end, refs); collect_function_refs(body, refs); }`
   - In `pattern/compile.rs` `compile_expr_patterns` (or similar exhaustive match): add `MirExpr::ForInRange { start, end, body, .. } => { /* recurse into start, end, body */ }` following the While pattern.

4. **LLVM codegen** (`crates/snow-codegen/src/codegen/expr.rs`):
   - In the main codegen_expr match, add: `MirExpr::ForInRange { var, start, end, body, ty } => self.codegen_for_in_range(var, start, end, body, ty),`
   - Add `codegen_for_in_range` method. Four-block structure:

     a. **Entry setup:** Codegen start_expr and end_expr to get i64 values. Create an alloca for the counter (`let i64_ty = self.context.i64_type(); let counter = self.builder.build_alloca(i64_ty, var)`). Store start_val into counter. Create four basic blocks: `forin_header`, `forin_body`, `forin_latch`, `forin_merge`. Push `(latch_bb, merge_bb)` onto `self.loop_stack`. Branch to header.

     b. **Header block:** Position at header. Load counter value. Compare `icmp slt` (signed less-than, NOT less-than-or-equal) against end_val. Conditional branch: true -> body, false -> merge. CRITICAL: use `IntPredicate::SLT` for half-open range semantics [start, end).

     c. **Body block:** Position at body. Save previous local binding: `let old_alloca = self.locals.insert(var.to_string(), counter); let old_type = self.local_types.insert(var.to_string(), MirType::Int);`. Codegen the body expression. After body, check `get_terminator().is_none()` before emitting unconditional branch to latch (body may have break/continue that already terminated the block).

     d. **Latch block:** Position at latch. Load counter, add 1, store back. Call `self.emit_reduction_check()`. Unconditional branch to header (the back-edge).

     e. **Cleanup:** Pop loop_stack. Restore previous local binding (if `old_alloca` was Some, restore; else remove from locals). Same for `old_type` and `local_types`. Position builder at merge block. Return Unit value (`self.context.struct_type(&[], false).const_zero().into()`).

   CRITICAL DETAILS:
   - Continue target is latch_bb (NOT header_bb). This is achieved by pushing `(latch_bb, merge_bb)` onto loop_stack. The existing `codegen_continue` jumps to the first element, which will be the latch. This means continue increments the counter before re-checking the condition, preventing infinite loops.
   - Break target is merge_bb (second element of loop_stack entry). Existing `codegen_break` handles this.
   - The loop variable alloca IS the counter alloca. No separate alloca needed. The body reads from it, the latch increments it.
   - Reduction check goes in the LATCH block, not the body. This ensures continue doesn't skip the reduction check.

5. **Formatter** (`crates/snow-fmt/src/walker.rs`):
   - Add `walk_for_in_expr` function, modeled on `walk_while_expr`. It should:
     - Iterate over children_with_tokens of the node
     - FOR_KW: emit "for" + space
     - IN_KW: emit space + "in" + space
     - DO_KW: emit space + "do"
     - END_KW: emit hardline + "end"
     - NEWLINE: skip
     - NAME node: emit via walk_node
     - BLOCK node: emit indent(concat([hardline, walk_block_body]))
     - Other nodes (iterable expression): emit via walk_node
     - Other tokens: use add_token_with_context
   - In the main walk_node/walk_expr dispatch, add `SyntaxKind::FOR_IN_EXPR => walk_for_in_expr(&node),` next to the WHILE_EXPR case.
  </action>
  <verify>
Run `cargo check --workspace` -- must compile without errors. Run `cargo test --workspace` -- all existing tests (1,273+) must pass.
  </verify>
  <done>
MirExpr::ForInRange exists with var/start/end/body/ty fields. lower_for_in_expr extracts range bounds from DotDot binary expr. codegen_for_in_range emits four-block LLVM structure with alloca counter, SLT comparison, latch-based continue, and reduction check. Formatter handles for-in syntax. All exhaustive matches updated. Workspace compiles and all tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests and unit tests for for-in over range</name>
  <files>
    tests/e2e/for_in_range.snow
    crates/snowc/tests/e2e.rs
    crates/snow-codegen/src/codegen/mod.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
1. **E2E fixture** (`tests/e2e/for_in_range.snow`):
   Create a Snow program that exercises for-in over range. Since Snow has no mutable variables, use println to demonstrate iteration:

   ```snow
   fn main() do
     # FORIN-02: Basic range iteration
     for i in 0..5 do
       println(i)
     end

     # Separator
     println("---")

     # FORIN-08: Loop variable scoped to body (use i as name again)
     for i in 10..13 do
       println(i)
     end

     println("done")
   end
   ```

   Expected output:
   ```
   0
   1
   2
   3
   4
   ---
   10
   11
   12
   done
   ```

2. **E2E test functions** (`crates/snowc/tests/e2e.rs`):
   Add test functions following the existing pattern (look at how `while_loop` and `break_continue` tests are structured):

   a. `test_for_in_range_basic` -- compile and run `for_in_range.snow`, check stdout matches expected output above.

   b. `test_for_in_range_empty` -- inline test or separate fixture: `for i in 5..5 do println(i) end; println("empty")` should output just "empty" (zero iterations for equal start/end).

   c. `test_for_in_range_reverse` -- inline test: `for i in 10..0 do println(i) end; println("reverse")` should output just "reverse" (zero iterations for start > end, since SLT check fails immediately).

   d. `test_for_in_range_break` -- test break inside for-in: `for i in 0..100 do; if i == 3 do break end; println(i); end; println("after")` should output "0\n1\n2\nafter".

   e. `test_for_in_range_continue` -- test continue inside for-in: Print only even numbers using an if/continue pattern. Since Snow has no modulo yet in this context, use a simpler pattern: `for i in 0..6 do; if i == 2 do continue end; if i == 4 do continue end; println(i); end` should output "0\n1\n3\n5".

   Note: Check the exact e2e test helper pattern used in the codebase. Some tests use `compile_and_run("fixture_name")` and others use inline source. Follow the existing convention.

3. **Codegen unit tests** (`crates/snow-codegen/src/codegen/mod.rs`):
   Add unit tests in the existing test module (where while loop codegen tests exist):

   a. Test that for-in range produces four basic blocks with expected names (forin_header, forin_body, forin_latch, forin_merge).
   b. Test that the LLVM IR contains `icmp slt` (not `sle`).
   c. Test that the latch block contains a call to `snow_reduction_check`.

   Follow the exact pattern of the existing while loop codegen unit tests.

4. **MIR lowering unit tests** (`crates/snow-codegen/src/mir/lower.rs`):
   Add a unit test verifying that `for i in 0..10 do println(i) end` lowers to `MirExpr::ForInRange { var: "i", start: IntLit(0), end: IntLit(10), body: ..., ty: Unit }`.

5. **Formatter tests** (`crates/snow-fmt/src/walker.rs`):
   Add formatter tests in the existing test module:
   a. Basic formatting: `for i in 0..10 do\n  println(i)\nend`
   b. Idempotency: format twice, output identical
   c. Normalize whitespace: `for  i  in  0..10  do  println(i)  end` -> properly formatted
  </action>
  <verify>
Run `cargo test --workspace` -- all tests must pass including new ones. Specifically verify:
- `cargo test -p snowc -- for_in_range` -- all e2e tests pass
- `cargo test -p snow-codegen -- for_in` -- codegen and MIR unit tests pass
- `cargo test -p snow-fmt -- for_in` -- formatter tests pass
  </verify>
  <done>
E2E tests confirm: basic range iteration produces correct output (0..5 prints 0-4), empty range (5..5) produces zero iterations, reverse range (10..0) produces zero iterations, break exits early, continue skips to next iteration via latch. Codegen unit tests verify four-block structure and SLT comparison. Formatter tests verify proper indentation and idempotency. All workspace tests pass (1,273 + new tests).
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles without errors
2. `cargo test --workspace` -- all tests pass (existing + new)
3. E2E: `for i in 0..5 do println(i) end` prints 0,1,2,3,4
4. E2E: `for i in 5..5 do println(i) end` prints nothing (empty range)
5. E2E: break inside for-in exits the loop
6. E2E: continue inside for-in skips to next iteration (increments counter)
7. LLVM IR contains `icmp slt` (not `sle`) for half-open range
8. LLVM IR contains `snow_reduction_check` in latch block
9. No heap allocation for the range counter (alloca only)
10. Formatter produces properly indented output
</verification>

<success_criteria>
- FORIN-02: `for i in 0..10 do body end` iterates 0 through 9
- FORIN-07: Range iteration uses alloca counter with integer arithmetic, no heap allocation
- FORIN-08: Loop variable scoped to body, does not leak after end
- break/continue work correctly inside for-in (continue goes to latch, break goes to merge)
- Empty and reverse ranges produce zero iterations
- Reduction check prevents actor starvation in tight loops
- Formatter handles for-in syntax with proper indentation
- All existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-for-in-over-range/34-02-SUMMARY.md`
</output>
