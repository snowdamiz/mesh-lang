---
phase: 34-for-in-over-range
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-lsp/src/analysis.rs
autonomous: true

must_haves:
  truths:
    - "for i in 0..10 do body end parses without error and produces a FOR_IN_EXPR CST node"
    - "ForInExpr AST wrapper provides binding_name(), iterable(), and body() accessors"
    - "Type checker infers for-in over range as Unit, binds loop variable as Int, and scopes it to the body"
    - "break/continue inside for-in bodies are validated by existing loop_depth tracking"
    - "Loop variable is not accessible after end (scoped to body only)"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "FOR_IN_EXPR composite node kind"
      contains: "FOR_IN_EXPR"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "ForInExpr AST wrapper with accessors"
      contains: "ForInExpr"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "parse_for_in_expr parser function"
      contains: "parse_for_in_expr"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "infer_for_in type inference with scoped loop variable"
      contains: "infer_for_in"
  key_links:
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "FOR_KW triggers parse_for_in_expr which closes as FOR_IN_EXPR"
      pattern: "FOR_KW.*parse_for_in_expr"
    - from: "crates/snow-parser/src/ast/expr.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "Expr::cast matches FOR_IN_EXPR to ForInExpr variant"
      pattern: "FOR_IN_EXPR.*ForInExpr"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "infer_expr dispatches Expr::ForInExpr to infer_for_in"
      pattern: "ForInExpr.*infer_for_in"
---

<objective>
Add FOR_IN_EXPR to parser, ForInExpr to AST, and infer_for_in to type checker -- the front-half of the for-in over range pipeline.

Purpose: Establish the syntactic and semantic foundation so that `for i in 0..10 do body end` parses, type-checks (loop variable scoped as Int, result is Unit), and reaches MIR lowering (with a placeholder).
Output: Parsing, AST, and type inference for for-in over range. All existing tests pass.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-for-in-over-range/34-RESEARCH.md
@.planning/phases/33-while-loop-loop-control-flow/33-01-SUMMARY.md

Key patterns from Phase 33 Plan 01:
- While/break/continue added FOR_KW-style: SyntaxKind variant, From<TokenKind> already exists, AST wrapper, parser function, typeck inference
- InferCtx.loop_depth with enter_loop/exit_loop for break/continue validation inside loops
- Placeholder match arms needed in snow-codegen/src/mir/lower.rs and snow-lsp/src/analysis.rs for exhaustive match
- FOR_KW and IN_KW already exist as keywords (no lexer changes needed)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FOR_IN_EXPR CST node, ForInExpr AST wrapper, and parse_for_in_expr parser</name>
  <files>
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/ast/expr.rs
    crates/snow-parser/src/parser/expressions.rs
  </files>
  <action>
1. In `crates/snow-parser/src/syntax_kind.rs`:
   - Add `FOR_IN_EXPR,` to the "Loop node kinds" section (after CONTINUE_EXPR, line ~287). Add a comment: `/// For-in expression: for binding in iterable do body end`.
   - Add `SyntaxKind::FOR_IN_EXPR,` to the `syntax_kind_has_enough_variants` test array in the Loop node kinds section (after CONTINUE_EXPR around line 673). Update the assert count from `>= 79` to `>= 80`.

2. In `crates/snow-parser/src/ast/expr.rs`:
   - Add `ForInExpr(ForInExpr),` variant to the `Expr` enum in the "Loop expression types" section (after ContinueExpr, around line 38).
   - Add `SyntaxKind::FOR_IN_EXPR => Some(Expr::ForInExpr(ForInExpr { syntax: node })),` to `Expr::cast` in the "Loop expressions" section (after CONTINUE_EXPR match arm, around line 78).
   - Add `Expr::ForInExpr(n) => &n.syntax,` to `Expr::syntax()` in the loop expressions section (after ContinueExpr arm, around line 113).
   - Add the `ForInExpr` AST wrapper after the ContinueExpr section (around line 576):

```rust
// -- For-In Expression -----------------------------------------------

ast_node!(ForInExpr, FOR_IN_EXPR);

impl ForInExpr {
    /// The loop variable name (NAME child).
    pub fn binding_name(&self) -> Option<super::item::Name> {
        child_node(&self.syntax)
    }

    /// The iterable expression (e.g., 0..10).
    pub fn iterable(&self) -> Option<Expr> {
        self.syntax.children().find_map(Expr::cast)
    }

    /// The loop body block.
    pub fn body(&self) -> Option<Block> {
        child_node(&self.syntax)
    }
}
```

3. In `crates/snow-parser/src/parser/expressions.rs`:
   - Add `parse_for_in_expr` function. Model it on `parse_while_expr`. The function should:
     - Open a marker, advance past FOR_KW
     - Parse the binding name: if at IDENT, open a marker, advance, close as NAME; else emit error "expected loop variable name after `for`"
     - Expect IN_KW
     - Parse the iterable expression by calling `expr(p)` (this will parse `0..10` as a BINARY_EXPR with DOT_DOT operator)
     - Record `do_span` via `p.current_span()`, expect DO_KW
     - Call `parse_block_body(p)` for the body
     - Check for END_KW: if missing, emit `error_with_related("expected \`end\` to close \`for\` block", do_span, "\`do\` block started here")`; if present, advance
     - Close as FOR_IN_EXPR
   - In the main expression dispatch (the function that handles prefix tokens like IF_KW, WHILE_KW, etc.), add a case for `SyntaxKind::FOR_KW => parse_for_in_expr(p)` right next to the WHILE_KW case.

  </action>
  <verify>
Run `cargo check -p snow-parser` from the workspace root. Must compile without errors.
  </verify>
  <done>
FOR_IN_EXPR is a valid SyntaxKind. ForInExpr is a variant in Expr with binding_name/iterable/body accessors. `for i in 0..10 do body end` parses into a FOR_IN_EXPR CST node. cargo check passes for snow-parser.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add infer_for_in to type checker with scoped loop variable and placeholder MIR/LSP arms</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-lsp/src/analysis.rs
  </files>
  <action>
1. In `crates/snow-typeck/src/infer.rs`:
   - Add `use crate::ast::expr::ForInExpr;` if not already imported (check existing use of WhileExpr pattern).
   - In the main `infer_expr` match, add a case for `Expr::ForInExpr(for_in) => infer_for_in(ctx, env, &for_in, types, type_registry, trait_registry, fn_constraints),` next to the WhileExpr case.
   - Add the `infer_for_in` function (follow the signature pattern of `infer_while`). The function must:
     a. Infer the iterable expression. Since the iterable is a BinaryExpr with DotDot op in the for-in context, the general infer_binary will handle it (producing a fresh type var since DotDot falls through). But we need to validate: if the iterable is a `BinaryExpr` with a `DOT_DOT` operator, unify both sides with `Ty::int()`. If the iterable is not a DotDot binary expr, still allow it for now (Phase 35 will handle collection iterables), but this is expected to be a range for Phase 34.
     b. Extract the binding name from `for_in.binding_name()` -- use `.and_then(|n| n.text())` to get the String. Fall back to `"_"`.
     c. Push a new scope on env (`let saved = env.vars.len();` or use the existing scope push pattern).
     d. Bind the loop variable: `env.insert(var_name.clone(), Scheme::mono(Ty::int()));` -- the loop variable is Int for range iteration.
     e. Call `ctx.enter_loop()` to increment loop_depth (enables break/continue validation).
     f. Infer the body block if present. Discard the body type (for-in returns Unit in Phase 34).
     g. Call `ctx.exit_loop()`.
     h. Pop the scope (restore env to saved state).
     i. Return `Ok(Ty::Tuple(vec![]))` -- Unit type.

   IMPORTANT: The typeck already infers the iterable via the existing infer_expr dispatch (which handles BinaryExpr). Do NOT double-infer. The pattern is: call infer_expr on the iterable to get its type, THEN additionally validate that it's a DotDot with Int operands. The existing infer_binary handles the DotDot as `_ => fresh_var()`, which is fine -- we just need to additionally unify the operands.

   Actually, looking at the pattern more carefully: infer_expr on the iterable will recurse into infer_binary which infers both sides. The sides will get types. We need to unify those types with Int. The cleanest approach is to call infer_expr on the iterable (which handles the whole expression), then if the iterable is a BinaryExpr with DotDot, additionally look up the LHS/RHS types in the `types` map (they were recorded by infer_binary) and unify each with Int. OR, more directly: after calling infer_expr on the iterable, check the AST structure and if it's a DotDot, infer the LHS and RHS again (they'll just return cached results from the types map, or re-unify harmlessly). The research code example shows the second approach.

2. In `crates/snow-codegen/src/mir/lower.rs`:
   - Find the match in the main lowering function where `Expr::WhileExpr` is handled. Add a case for `Expr::ForInExpr(_for_in) => MirExpr::Unit,` as a placeholder (same pattern as Phase 33 Plan 01 used for while/break/continue). This prevents exhaustive match errors. The real lowering comes in Plan 02.

3. In `crates/snow-lsp/src/analysis.rs`:
   - Check if adding ForInExpr to the Expr enum breaks any exhaustive matches in the LSP analysis code. If so, add a pass-through arm (like was done for WhileExpr). No new TypeError variants are needed for Phase 34 (we reuse BreakOutsideLoop/ContinueOutsideLoop from Phase 33).

After all changes, run `cargo check` on the full workspace and then `cargo test --workspace` to verify zero regressions.
  </action>
  <verify>
Run `cargo check --workspace` -- must compile without errors. Run `cargo test --workspace` -- all existing tests (1,273+) must pass.
  </verify>
  <done>
infer_for_in validates DotDot operands as Int, binds loop variable in scoped env, uses enter_loop/exit_loop for break/continue support, and returns Unit. Placeholder MIR arm prevents exhaustive match errors. Full workspace compiles and all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles without errors
2. `cargo test --workspace` -- all existing tests pass (1,273+)
3. Parser accepts `for i in 0..10 do println(i) end` without parse errors (verified via cargo check on a test program if needed)
</verification>

<success_criteria>
- FOR_IN_EXPR is a valid SyntaxKind in the CST
- ForInExpr variant exists in Expr enum with binding_name(), iterable(), body() accessors
- parse_for_in_expr produces FOR_IN_EXPR CST node from `for ... in ... do ... end` syntax
- infer_for_in type-checks the loop: Int operands for DotDot range, Int loop variable scoped to body, Unit result
- break/continue work inside for-in bodies via existing loop_depth infrastructure
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/34-for-in-over-range/34-01-SUMMARY.md`
</output>
