---
phase: 45-error-propagation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-typeck/src/unify.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-fmt/src/walker.rs
autonomous: true

must_haves:
  truths:
    - "Parser recognizes `expr?` as a postfix try expression at POSTFIX_BP precedence"
    - "Type checker validates ? operand is Result<T,E> or Option<T>"
    - "Type checker validates enclosing function returns compatible Result/Option type"
    - "Compiler emits E0036 error when ? is used in function not returning Result or Option"
    - "fn_return_type_stack correctly tracks return types through nested closures"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "TRY_EXPR SyntaxKind variant"
      contains: "TRY_EXPR"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "Postfix ? parsing in expr_bp loop"
      contains: "TRY_EXPR"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "TryExpr AST node and Expr::TryExpr variant"
      contains: "TryExpr"
    - path: "crates/snow-typeck/src/unify.rs"
      provides: "fn_return_type_stack field on InferCtx"
      contains: "fn_return_type_stack"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "infer_try_expr function with type extraction and validation"
      contains: "infer_try_expr"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "TryIncompatibleReturn error variant"
      contains: "TryIncompatibleReturn"
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "E0036 diagnostic rendering for TryIncompatibleReturn"
      contains: "E0036"
  key_links:
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "TRY_EXPR SyntaxKind maps to Expr::TryExpr in Expr::cast"
      pattern: "TRY_EXPR.*TryExpr"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/unify.rs"
      via: "infer_try_expr reads fn_return_type_stack from InferCtx"
      pattern: "fn_return_type_stack"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "infer_try_expr pushes TryIncompatibleReturn error"
      pattern: "TryIncompatibleReturn"
---

<objective>
Add parser support for postfix `?` operator and type checker validation for Result/Option propagation.

Purpose: Enable the compiler frontend to parse `expr?` syntax and validate that the ? operator is used in functions returning compatible Result<T,E> or Option<T> types, with clear E0036 diagnostics when misused.

Output: Parser produces TRY_EXPR nodes, typeck validates and infers correct types for ? expressions, diagnostics emit actionable error messages.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-error-propagation/45-RESEARCH.md
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/expressions.rs
@crates/snow-parser/src/ast/expr.rs
@crates/snow-typeck/src/unify.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-fmt/src/walker.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TRY_EXPR to parser and AST</name>
  <files>
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-parser/src/ast/expr.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
**1. Add TRY_EXPR to SyntaxKind** (`crates/snow-parser/src/syntax_kind.rs`):
- Add `TRY_EXPR` variant in the composite node kinds section, after the loop/actor kinds but before service kinds (around line 310). Comment: `/// Try expression: expr? for Result/Option propagation`.
- Add `SyntaxKind::TRY_EXPR` to the `syntax_kind_has_enough_variants` test array (update the count assertion accordingly -- currently checks >= 81, bump to >= 82).

**2. Add postfix ? parsing** (`crates/snow-parser/src/parser/expressions.rs`):
- In the `expr_bp` function's postfix loop (after the index access check at line 132, before the infix operators section at line 135), add a new postfix block:
```rust
// ── Postfix: try operator ──
if current == SyntaxKind::QUESTION && POSTFIX_BP >= min_bp {
    let m = p.open_before(lhs);
    p.advance(); // consume ?
    lhs = p.close(m, SyntaxKind::TRY_EXPR);
    continue;
}
```
This gives `?` the same binding power (25) as field access, calls, and indexing, so `expr.method()?` and `expr?.method()` both parse correctly.

**3. Add TryExpr AST node** (`crates/snow-parser/src/ast/expr.rs`):
- Add `TryExpr(TryExpr)` variant to the `Expr` enum (after `LinkExpr`).
- Add the cast arm in `Expr::cast`: `SyntaxKind::TRY_EXPR => Some(Expr::TryExpr(TryExpr { syntax: node }))`.
- Add the syntax arm in `Expr::syntax`: `Expr::TryExpr(n) => &n.syntax`.
- Add the AST node definition after LinkExpr:
```rust
// -- Try Expression -------------------------------------------------------
ast_node!(TryExpr, TRY_EXPR);

impl TryExpr {
    /// The operand expression (the expression before `?`).
    pub fn operand(&self) -> Option<Expr> {
        self.syntax.children().find_map(Expr::cast)
    }
}
```

**4. Update formatter walker** (`crates/snow-fmt/src/walker.rs`):
- In the `walk_node` function's match, add a case for `TRY_EXPR`. Since TRY_EXPR wraps an expression child + a QUESTION token, handle it like other simple postfix nodes -- walk children preserving token ordering. Add it to the leaf/passthrough match arm alongside patterns like `LITERAL`, `NAME`, etc. (the `_` fallback arm already handles unknown nodes by walking children, but explicitly adding it is cleaner):
```rust
SyntaxKind::TRY_EXPR => walk_children(node),
```
Or if there's no `walk_children` helper, add it to the fallback arm that walks all children generically. The key is that formatting does NOT break when encountering a TRY_EXPR node.
  </action>
  <verify>
Run `cargo build -p snow-parser -p snow-fmt` -- must compile with no errors.
Run `cargo test -p snow-parser` -- all existing parser tests pass plus the new SyntaxKind count test.
  </verify>
  <done>
TRY_EXPR is a recognized SyntaxKind, the Pratt parser produces TRY_EXPR nodes for `expr?` syntax, the AST exposes TryExpr with an operand() accessor, and the formatter handles TRY_EXPR without panicking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add type checking for ? operator with fn_return_type_stack</name>
  <files>
    crates/snow-typeck/src/unify.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/diagnostics.rs
  </files>
  <action>
**1. Add fn_return_type_stack to InferCtx** (`crates/snow-typeck/src/unify.rs`):
- Add a new field to `InferCtx`: `pub fn_return_type_stack: Vec<Option<Ty>>` -- a stack of enclosing function return types. `None` means the return type is not yet known (inferred). Pushed when entering a function/closure body, popped when leaving.
- Initialize to `Vec::new()` in `InferCtx::new()`.
- Add helper methods:
```rust
/// Push a function return type onto the stack (call when entering a function body).
pub fn push_fn_return_type(&mut self, ty: Option<Ty>) {
    self.fn_return_type_stack.push(ty);
}

/// Pop a function return type from the stack (call when leaving a function body).
pub fn pop_fn_return_type(&mut self) {
    self.fn_return_type_stack.pop();
}

/// Get the current enclosing function's return type (top of stack).
pub fn current_fn_return_type(&self) -> Option<&Ty> {
    self.fn_return_type_stack.last().and_then(|t| t.as_ref())
}
```

**2. Add TryIncompatibleReturn error** (`crates/snow-typeck/src/error.rs`):
- Add a new variant to the `TypeError` enum:
```rust
/// `?` operator used in function that doesn't return Result or Option.
TryIncompatibleReturn {
    /// The type of the operand (e.g., Result<Int, String>).
    operand_ty: Ty,
    /// The enclosing function's return type (e.g., Int).
    fn_return_ty: Ty,
    span: TextRange,
},
```
- Add Display impl arm:
```rust
TypeError::TryIncompatibleReturn { operand_ty, fn_return_ty, .. } => {
    write!(f, "`?` operator requires function to return `Result` or `Option`, found `{}`", fn_return_ty)
}
```

**3. Push/pop fn_return_type in infer.rs**:
- Find where top-level functions are inferred (the function that processes FN_DEF items). Before inferring the function body, push the declared return type (if annotated) or `None` (if inferred). After body inference, pop. Look for patterns where `infer_block` or similar is called for function bodies.
- Find where closures are inferred (the `infer_closure_expr` or similar function). Before inferring the closure body, save the stack state via `enter_closure` pattern. Push the closure's return type (typically None/inferred) before the body, pop after. This ensures `?` inside closures validates against the closure's return type, not the outer function's.
- CRITICAL: Also push at the top-level function inference entry points. Search for where function bodies are inferred and wrap with push/pop. The pattern follows `enter_closure`/`exit_closure` for loop_depth -- same save/restore discipline.

**4. Add infer_try_expr** (`crates/snow-typeck/src/infer.rs`):
- Add `Expr::TryExpr(try_expr)` arm to the `infer_expr` match:
```rust
Expr::TryExpr(try_expr) => {
    infer_try_expr(ctx, env, try_expr, types, type_registry, trait_registry, fn_constraints)?
}
```
- Implement `infer_try_expr`:
  1. Get the operand expression via `try_expr.operand()`.
  2. Infer the operand type: `let operand_ty = infer_expr(ctx, env, &operand, ...)?`.
  3. Resolve the operand type: `let resolved = ctx.resolve(operand_ty.clone())`.
  4. Check if it's Result or Option by examining the resolved type. Use the existing Ty structure -- Result and Option are `Ty::App(Box<Ty::Con(TyCon { name: "Result"|"Option", .. })>, args)`.
  5. Get the enclosing function return type from `ctx.current_fn_return_type()`.
  6. **For Result<T, E>**: Extract T (success type) and E (error type) from args. If fn return type exists, try to unify E with the error type of the fn return. The expression result type is T.
  7. **For Option<T>**: Extract T from args. If fn return type exists, verify it's also an Option type. The expression result type is T.
  8. **If operand is neither Result nor Option**, or if the fn return type is incompatible: push `TryIncompatibleReturn` error to ctx.errors and return a fresh type variable (to allow continued type checking).
  9. **If no fn return type on stack** (shouldn't happen in normal code, but defensive): emit error.
  10. **Type variable approach** (per research Pitfall 3): Create fresh type vars, unify operand with `Result<fresh_t, fresh_e>` or `Option<fresh_t>`, then unify the fn return type's error/option type accordingly. Return `fresh_t` as the expression type. This handles cases where types are not yet fully resolved.

**5. Add E0036 diagnostic** (`crates/snow-typeck/src/diagnostics.rs`):
- In the `error_code` function, add: `TypeError::TryIncompatibleReturn { .. } => "E0036"`.
- In the `severity` function, add it as an "error" (not warning).
- In the JSON span extraction section (around line 484-495), add `TypeError::TryIncompatibleReturn { span, .. }` to the span extraction arm.
- Add a rendering case in the main render_error function:
```rust
TypeError::TryIncompatibleReturn { operand_ty, fn_return_ty, span } => {
    let msg = format!("`?` operator requires function to return `Result` or `Option`");
    let range = clamp(text_range_to_range(*span));

    Report::build(ReportKind::Error, (fname.clone(), range.clone()))
        .with_code(code)
        .with_message(&msg)
        .with_config(config)
        .with_label(
            Label::new((fname.clone(), range))
                .with_message(format!("cannot use `?` here"))
                .with_color(Color::Red),
        )
        .with_note(format!(
            "the enclosing function returns `{}`, but `?` requires `Result<_, _>` or `Option<_>`",
            fn_return_ty
        ))
        .finish()
        .write((fname.clone(), ariadne::Source::from(source)), &mut buf)
        .ok();
}
```
Follow the exact pattern used by `BreakOutsideLoop` (E0032) as the closest model -- single span, simple message, note with context.
  </action>
  <verify>
Run `cargo build -p snow-typeck` -- must compile with no errors.
Run `cargo test -p snow-typeck` -- all existing typeck tests pass.
Run `cargo build --workspace` -- full workspace builds successfully.
  </verify>
  <done>
InferCtx has fn_return_type_stack with push/pop/current helpers. The type checker infers ? expressions on Result<T,E> and Option<T>, validates against the enclosing function return type, and emits E0036 TryIncompatibleReturn when misused. All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
- `cargo build --workspace` compiles without errors
- `cargo test -p snow-parser` passes (including updated SyntaxKind count)
- `cargo test -p snow-typeck` passes (no regressions)
- `cargo test --workspace` passes (all 111+ e2e tests)
</verification>

<success_criteria>
- TRY_EXPR is a valid SyntaxKind and the parser produces it for `expr?` syntax
- TryExpr AST node has operand() accessor
- InferCtx tracks enclosing function return types through a stack
- ? on Result<T,E> infers to type T, ? on Option<T> infers to type T
- ? in incompatible function produces E0036 error with helpful message
- Formatter does not panic on TRY_EXPR nodes
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/45-error-propagation/45-01-SUMMARY.md`
</output>
