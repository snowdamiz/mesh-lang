---
phase: 45-error-propagation
plan: 02
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "User can write `expr?` on a Result<T,E> value: unwraps Ok(v) to v, early-returns Err(e) on error"
    - "User can write `expr?` on an Option<T> value: unwraps Some(v) to v, early-returns None on absence"
    - "Compiler emits a clear error when ? is used in a function whose return type is not Result or Option"
    - "? works correctly in chained expressions like `fn_call()?.method()`"
    - "? works correctly inside closures (returns from closure, not outer function)"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "TryExpr desugaring to Match + Return(ConstructVariant)"
      contains: "lower_try_expr"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E tests for all three ERR requirements"
      contains: "try_operator"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "MirExpr::Match + MirExpr::Return + MirExpr::ConstructVariant"
      via: "lower_try_expr desugars ? to existing MIR primitives"
      pattern: "ConstructVariant.*Return"
    - from: "crates/snowc/tests/e2e.rs"
      to: "compile_and_run / compile_expect_error"
      via: "E2E test harness validates full pipeline"
      pattern: "compile_and_run|compile_expect_error"
---

<objective>
Implement MIR lowering for the ? operator and validate the complete feature with end-to-end tests.

Purpose: Complete the compiler pipeline by desugaring `expr?` to Match + Return(ConstructVariant) in MIR lowering, and prove all three requirements (ERR-01, ERR-02, ERR-03) work end-to-end with compiled Snow programs.

Output: Working ? operator that compiles and runs correctly for Result and Option types, with comprehensive e2e test coverage.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-error-propagation/45-RESEARCH.md
@.planning/phases/45-error-propagation/45-01-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/mod.rs
@crates/snow-codegen/src/mir/types.rs
@crates/snowc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MIR lowering for TryExpr</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**1. Add TryExpr arm to lower_expr** (around line 3230, in the `lower_expr` match):
- Add `Expr::TryExpr(try_expr) => self.lower_try_expr(try_expr)` to the match arms.

**2. Track current function return type in Lowerer**:
- Add a field to the `Lowerer` struct: `current_fn_return_type: Option<MirType>` -- set when entering a function body, used by lower_try_expr.
- Initialize to `None` in `Lowerer::new()`.
- Set it when lowering function bodies -- find where `lower_fn_body` or equivalent sets up function parameters and body. Before lowering the body expression, set `self.current_fn_return_type = Some(return_type.clone())`. After lowering, restore the previous value (save/restore pattern since functions can nest via closures).
- For closures: similarly save/restore when entering/exiting closure lowering.

**3. Implement lower_try_expr**:
```rust
fn lower_try_expr(&mut self, try_expr: &TryExpr) -> MirExpr {
    let operand = match try_expr.operand() {
        Some(e) => self.lower_expr(&e),
        None => return MirExpr::Unit,
    };

    let operand_ty = operand.ty();
    let fn_ret_ty = self.current_fn_return_type.clone().unwrap_or(MirType::Unit);

    // Determine if operand is Result or Option by examining the MirType
    match &operand_ty {
        MirType::SumType(name) if name.starts_with("Result_") => {
            self.lower_try_result(operand, name, &fn_ret_ty)
        }
        MirType::SumType(name) if name.starts_with("Option_") => {
            self.lower_try_option(operand, name, &fn_ret_ty)
        }
        _ => {
            // Should not happen if typeck validated correctly; fallback to Unit
            MirExpr::Unit
        }
    }
}
```

**4. Implement lower_try_result** -- desugar `result_expr?` to:
```
case result_expr do
  Ok(__try_val) -> __try_val
  Err(__try_err) -> return Err(__try_err)  # using fn return type's monomorphized name
end
```

In MIR terms:
- Extract the inner types from the operand's monomorphized sum type name. Look up the sum type definition in `self.sum_types` to get variant field types. The "Ok" variant's field type is the success type T, the "Err" variant's field type is the error type E.
- For the Err arm's return, construct the variant using the FUNCTION'S return type name (not the operand's type name). This is critical per research Pitfall 2 -- the function might return `Result<Bool, String>` while the operand is `Result<Int, String>`. The early return must construct `Result_Bool_String.Err`, not `Result_Int_String.Err`.
- Get the function return type's monomorphized name from `fn_ret_ty` (it should be `MirType::SumType("Result_X_Y")`).
- Ensure the sum type definition for the function return type exists by checking/registering it.
- Use unique binding names like `__try_val_{counter}` and `__try_err_{counter}` to avoid shadowing in nested `?` usage. Add a `try_counter: u32` field to Lowerer, increment per `?` usage.

Build the MIR:
```rust
MirExpr::Match {
    scrutinee: Box::new(operand),
    arms: vec![
        MirMatchArm {
            pattern: MirPattern::Constructor {
                type_name: operand_type_name.clone(),
                variant: "Ok".to_string(),
                fields: vec![MirPattern::Bind(val_name.clone(), success_ty.clone())],
                bindings: vec![(val_name.clone(), success_ty.clone())],
            },
            guard: None,
            body: MirExpr::Var(val_name, success_ty.clone()),
        },
        MirMatchArm {
            pattern: MirPattern::Constructor {
                type_name: operand_type_name.clone(),
                variant: "Err".to_string(),
                fields: vec![MirPattern::Bind(err_name.clone(), error_ty.clone())],
                bindings: vec![(err_name.clone(), error_ty.clone())],
            },
            guard: None,
            body: MirExpr::Return(Box::new(MirExpr::ConstructVariant {
                type_name: fn_return_type_name,  // fn return type, NOT operand type
                variant: "Err".to_string(),
                fields: vec![MirExpr::Var(err_name, error_ty)],
                ty: fn_ret_ty,
            })),
        },
    ],
    ty: success_ty,  // The ? expression's type is the unwrapped T
}
```

**5. Implement lower_try_option** -- desugar `option_expr?` to:
```
case option_expr do
  Some(__try_val) -> __try_val
  None -> return None
end
```

Same pattern as Result but simpler:
- "Some" variant has one field (the inner type T).
- "None" variant has zero fields.
- The early return constructs `None` using the function return type's monomorphized name.
- The `None` construction is `ConstructVariant` with empty fields vec.

**6. Handle MirPattern variant names**: Check the existing MirPattern enum to see if `Bind` is the right variant name for binding patterns. It might be `Var`, `Variable`, or a different name. Look at how `lower_case_expr` constructs match arms -- replicate that pattern exactly for the try desugaring.

IMPORTANT: Do NOT add a new MirExpr variant for try. The entire desugaring uses existing MirExpr::Match, MirExpr::Return, MirExpr::ConstructVariant, and MirExpr::Var. Zero codegen changes needed.
  </action>
  <verify>
Run `cargo build -p snow-codegen` -- must compile with no errors.
Run `cargo test --workspace` -- all existing tests pass (no regressions).
  </verify>
  <done>
The MIR lowerer desugars `expr?` on Result<T,E> to Match{Ok(v)->v, Err(e)->return Err(e)} and `expr?` on Option<T> to Match{Some(v)->v, None->return None}, using existing MIR primitives. The function return type's monomorphized name is used for early-return variant construction. Zero codegen changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive e2e tests for ? operator</name>
  <files>
    crates/snowc/tests/e2e.rs
  </files>
  <action>
Add a test section for the ? operator at the end of the e2e test file. Each test uses the existing `compile_and_run` or `compile_expect_error` harness.

**ERR-01 tests (Result<T,E> propagation):**

1. `try_operator_result_ok_path` -- ? on Ok value unwraps and continues:
```snow
fn safe_divide(a :: Int, b :: Int) :: Result<Int, String> do
  if b == 0 do
    Err("division by zero")
  else
    Ok(a / b)
  end
end

fn compute(x :: Int) :: Result<Int, String> do
  let result = safe_divide(x, 2)?
  Ok(result + 10)
end

fn main() do
  case compute(20) do
    Ok(v) -> println(v)
    Err(e) -> println(e)
  end
end
```
Expected output: `20` (20/2 = 10, +10 = 20)

2. `try_operator_result_err_path` -- ? on Err value early-returns:
```snow
fn safe_divide(a :: Int, b :: Int) :: Result<Int, String> do
  if b == 0 do
    Err("division by zero")
  else
    Ok(a / b)
  end
end

fn compute(x :: Int) :: Result<Int, String> do
  let result = safe_divide(x, 0)?
  Ok(result + 10)
end

fn main() do
  case compute(20) do
    Ok(v) -> println(v)
    Err(e) -> println(e)
  end
end
```
Expected output: `division by zero`

3. `try_operator_result_multiple` -- Multiple ? in sequence:
```snow
fn parse_int(s :: String) :: Result<Int, String> do
  if s == "42" do
    Ok(42)
  else
    Err("parse error")
  end
end

fn add_parsed(a :: String, b :: String) :: Result<Int, String> do
  let x = parse_int(a)?
  let y = parse_int(b)?
  Ok(x + y)
end

fn main() do
  case add_parsed("42", "42") do
    Ok(v) -> println(v)
    Err(e) -> println(e)
  end
end
```
Expected output: `84`

**ERR-02 tests (Option<T> propagation):**

4. `try_operator_option_some_path` -- ? on Some value unwraps:
```snow
fn first(list :: List<Int>) :: Option<Int> do
  let h = List.head(list)?
  Some(h + 1)
end

fn main() do
  case first([10, 20, 30]) do
    Some(v) -> println(v)
    None -> println("empty")
  end
end
```
Expected output: `11`

5. `try_operator_option_none_path` -- ? on None early-returns:
```snow
fn first(list :: List<Int>) :: Option<Int> do
  let h = List.head(list)?
  Some(h + 1)
end

fn main() do
  case first([]) do
    Some(v) -> println(v)
    None -> println("empty")
  end
end
```
Expected output: `empty`

**ERR-03 tests (error diagnostics):**

6. `try_operator_incompatible_return_type` -- ? in non-Result/Option function:
```snow
fn add(a :: Int, b :: Int) :: Int do
  let x = Ok(a)?
  x + b
end

fn main() do
  println(add(1, 2))
end
```
Use `compile_expect_error` -- expected to contain `E0036` or `?` or `Result` or `Option` in the error output.

7. `try_operator_result_in_option_fn` -- Result? in Option-returning function should error:
```snow
fn bad() :: Option<Int> do
  let x = Ok(42)?
  Some(x)
end

fn main() do
  println("hi")
end
```
Use `compile_expect_error` -- should fail because Result? requires Result return type, not Option.

**Note on test adaptation:** The exact Snow syntax for Result/Option construction and List.head may need adjustment based on what actually works in the current compiler. If `List.head` returns `Option<T>`, great. If not, use a manual `Some(x)` / `None` construction for the Option tests. Check 45-01-SUMMARY.md for any implementation notes about how Result/Option types are represented.

Each test should use `assert!(output.contains("expected_string"))` or `assert_eq!(output.trim(), "expected")` following the existing test patterns in e2e.rs.
  </action>
  <verify>
Run `cargo test --test e2e` -- all new try_operator tests pass.
Run `cargo test --workspace` -- all tests pass (111+ existing + new ones).
  </verify>
  <done>
At least 5 e2e tests pass covering: Result Ok path, Result Err path, multiple ? in sequence, Option Some path, Option None path, and incompatible return type error diagnostic. All three requirements (ERR-01, ERR-02, ERR-03) have test coverage.
  </done>
</task>

</tasks>

<verification>
- `cargo test --test e2e` -- all try_operator tests pass
- `cargo test --workspace` -- zero regressions, all 111+ existing tests pass
- Manual verification: compile and run a Snow program with `?` on Result and Option
- Error diagnostic: compile a program with `?` in non-Result function, verify E0036 error
</verification>

<success_criteria>
- `expr?` on Result<T,E> unwraps Ok(v) to v and early-returns Err(e) -- proven by e2e tests
- `expr?` on Option<T> unwraps Some(v) to v and early-returns None -- proven by e2e tests
- Compiler emits clear E0036 error when ? used in incompatible function -- proven by compile_expect_error test
- Multiple ? in sequence work correctly (both succeed, first fails)
- Zero regressions in existing test suite
- Zero new runtime functions, zero new Rust dependencies, zero codegen changes
</success_criteria>

<output>
After completion, create `.planning/phases/45-error-propagation/45-02-SUMMARY.md`
</output>
