---
phase: 45-error-propagation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snowc/tests/e2e.rs
  - tests/e2e/try_error_incompatible_return.snow
  - tests/e2e/try_error_non_result_option.snow
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Compiler emits E0036 error when ? is used in a function whose return type is not Result or Option"
    - "Compiler emits E0037 error when ? is used on a value that is not Result or Option"
  artifacts:
    - path: "crates/snowc/tests/e2e.rs"
      provides: "compile_expect_error tests for ERR-03"
      contains: "e2e_try_incompatible_return_type"
    - path: "tests/e2e/try_error_incompatible_return.snow"
      provides: "Test fixture: ? used in fn returning Int (triggers E0036)"
    - path: "tests/e2e/try_error_non_result_option.snow"
      provides: "Test fixture: ? used on Int value (triggers E0037)"
  key_links:
    - from: "crates/snowc/tests/e2e.rs"
      to: "tests/e2e/try_error_incompatible_return.snow"
      via: "read_fixture in compile_expect_error test"
      pattern: "read_fixture.*try_error_incompatible_return"
    - from: "crates/snowc/tests/e2e.rs"
      to: "tests/e2e/try_error_non_result_option.snow"
      via: "read_fixture in compile_expect_error test"
      pattern: "read_fixture.*try_error_non_result_option"
---

<objective>
Close the single verification gap from 45-VERIFICATION.md: ERR-03 error diagnostics exist but lack e2e test coverage. Add compile_expect_error tests verifying the compiler emits E0036 (? in incompatible return type function) and E0037 (? on non-Result/Option value) errors.

Purpose: Prove ERR-03 works end-to-end and prevent regressions in error diagnostic emission.
Output: 2 test fixtures + 2 e2e tests appended to existing Phase 45 test section.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-error-propagation/45-VERIFICATION.md
@crates/snowc/tests/e2e.rs
@crates/snow-typeck/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures for ? operator error cases</name>
  <files>tests/e2e/try_error_incompatible_return.snow, tests/e2e/try_error_non_result_option.snow</files>
  <action>
Create two Snow test fixture files that trigger compile errors:

1. `tests/e2e/try_error_incompatible_return.snow` -- Triggers E0036 (TryIncompatibleReturn):
   A function returning `Int` (not `Result` or `Option`) that uses `?` on a `Result` value.
   Example structure:
   ```
   fn might_fail(x :: Int) -> Int!String do
     if x == 0 do return Err("zero") end
     Ok(x)
   end

   fn bad_caller() -> Int do
     let val = might_fail(5)?
     val + 1
   end

   fn main() do
     println("${bad_caller()}")
   end
   ```
   The `?` inside `bad_caller` (which returns `Int`, not `Result`) should trigger E0036.

2. `tests/e2e/try_error_non_result_option.snow` -- Triggers E0037 (TryOnNonResultOption):
   A function that uses `?` on a plain `Int` value (not a `Result` or `Option`).
   Example structure:
   ```
   fn compute(x :: Int) -> Int!String do
     let val = x?
     Ok(val + 1)
   end

   fn main() do
     let r = compute(5)
     case r do
       Ok(v) -> println("${v}")
       Err(e) -> println(e)
     end
   end
   ```
   The `?` on `x` (which is `Int`, not `Result` or `Option`) should trigger E0037.

Use the Snow language syntax established in existing try_*.snow fixtures: `Int!String` for `Result<Int, String>`, `do`/`end` blocks, `case`/`do` pattern matching.
  </action>
  <verify>Both fixture files exist at the correct paths: `ls tests/e2e/try_error_incompatible_return.snow tests/e2e/try_error_non_result_option.snow`</verify>
  <done>Two .snow fixture files exist that each contain code designed to trigger a specific ? operator compile error (E0036 and E0037 respectively).</done>
</task>

<task type="auto">
  <name>Task 2: Add compile_expect_error e2e tests for ERR-03</name>
  <files>crates/snowc/tests/e2e.rs</files>
  <action>
Append two new test functions to the Phase 45 section of `crates/snowc/tests/e2e.rs` (after the existing `e2e_try_chained_result` test at line 2456).

1. `e2e_try_incompatible_return_type` -- Tests E0036:
   ```rust
   /// Phase 45: ? in a function that doesn't return Result or Option (E0036).
   /// bad_caller returns Int but uses ? -- compiler must reject with E0036.
   #[test]
   fn e2e_try_incompatible_return_type() {
       let source = read_fixture("try_error_incompatible_return.snow");
       let error = compile_expect_error(&source);
       assert!(
           error.contains("E0036") || error.contains("requires function to return"),
           "Expected E0036 TryIncompatibleReturn error, got:\n{}",
           error
       );
   }
   ```

2. `e2e_try_on_non_result_option` -- Tests E0037:
   ```rust
   /// Phase 45: ? on a value that is not Result or Option (E0037).
   /// Using ? on a plain Int -- compiler must reject with E0037.
   #[test]
   fn e2e_try_on_non_result_option() {
       let source = read_fixture("try_error_non_result_option.snow");
       let error = compile_expect_error(&source);
       assert!(
           error.contains("E0037") || error.contains("requires `Result` or `Option`"),
           "Expected E0037 TryOnNonResultOption error, got:\n{}",
           error
       );
   }
   ```

Key details:
- Use `read_fixture` (not inline source) to match the pattern of the other Phase 45 tests.
- Use `compile_expect_error` (not `compile_and_run`) since these should fail compilation.
- Assert on both the error code AND the message text (with `||`) for resilience.
- Include descriptive failure messages showing actual error output for debugging.

After adding, run `cargo test -p snowc e2e_try_incompatible_return_type e2e_try_on_non_result_option` to verify both tests pass.
  </action>
  <verify>`cargo test -p snowc e2e_try_incompatible_return_type e2e_try_on_non_result_option` -- both tests pass (exit code 0, "2 passed" in output).</verify>
  <done>Two compile_expect_error tests exist in e2e.rs that verify E0036 and E0037 error diagnostics are emitted during compilation. Both tests pass green.</done>
</task>

</tasks>

<verification>
1. `cargo test -p snowc e2e_try` -- all 7 Phase 45 e2e tests pass (5 existing + 2 new)
2. `cargo test -p snowc` -- full test suite still passes (no regressions)
3. Both new tests use `compile_expect_error` and assert on error code/message content
</verification>

<success_criteria>
- ERR-03 has end-to-end test coverage via compile_expect_error tests
- E0036 (TryIncompatibleReturn) verified: ? in fn returning Int triggers compile error
- E0037 (TryOnNonResultOption) verified: ? on Int value triggers compile error
- All 7 Phase 45 e2e tests pass
- No regressions in broader test suite
</success_criteria>

<output>
After completion, create `.planning/phases/45-error-propagation/45-03-SUMMARY.md`
</output>
