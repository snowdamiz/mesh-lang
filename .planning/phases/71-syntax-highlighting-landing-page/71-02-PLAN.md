---
phase: 71-syntax-highlighting-landing-page
plan: 02
type: execute
wave: 2
depends_on: ["71-01"]
files_modified:
  - website/docs/.vitepress/theme/composables/useShiki.ts
  - website/docs/.vitepress/theme/components/landing/LandingPage.vue
  - website/docs/.vitepress/theme/components/landing/HeroSection.vue
  - website/docs/.vitepress/theme/components/landing/FeatureShowcase.vue
  - website/docs/.vitepress/theme/components/landing/WhyMesh.vue
  - website/docs/.vitepress/theme/Layout.vue
  - website/docs/index.md
autonomous: true

must_haves:
  truths:
    - "The landing page hero section displays a tagline, a highlighted Mesh code sample, and a CTA link to the docs"
    - "A feature showcase section presents 3-4 key Mesh capabilities (actors, pattern matching, type inference, pipe operator) with real highlighted code examples"
    - "A 'Why Mesh?' section explains Mesh's positioning relative to Elixir, Rust, and Go"
    - "Code examples on the landing page render with syntax highlighting matching the site theme"
  artifacts:
    - path: "website/docs/.vitepress/theme/composables/useShiki.ts"
      provides: "Shared Shiki highlighter instance for programmatic code highlighting"
      exports: ["getHighlighter"]
    - path: "website/docs/.vitepress/theme/components/landing/LandingPage.vue"
      provides: "Landing page composition component"
      min_lines: 10
    - path: "website/docs/.vitepress/theme/components/landing/HeroSection.vue"
      provides: "Hero with tagline, code sample, CTA"
      min_lines: 40
    - path: "website/docs/.vitepress/theme/components/landing/FeatureShowcase.vue"
      provides: "Feature cards with code examples"
      min_lines: 80
    - path: "website/docs/.vitepress/theme/components/landing/WhyMesh.vue"
      provides: "Comparison section vs Elixir/Rust/Go"
      min_lines: 40
    - path: "website/docs/.vitepress/theme/Layout.vue"
      provides: "Frontmatter-based routing (home layout vs default)"
      contains: "frontmatter.layout"
    - path: "website/docs/index.md"
      provides: "Landing page entry with layout: home frontmatter"
      contains: "layout: home"
  key_links:
    - from: "website/docs/.vitepress/theme/Layout.vue"
      to: "website/docs/.vitepress/theme/components/landing/LandingPage.vue"
      via: "v-if on frontmatter.layout === 'home'"
      pattern: "frontmatter\\.layout.*home"
    - from: "website/docs/.vitepress/theme/components/landing/HeroSection.vue"
      to: "website/docs/.vitepress/theme/composables/useShiki.ts"
      via: "import and call getHighlighter for code rendering"
      pattern: "getHighlighter"
    - from: "website/docs/.vitepress/theme/components/landing/FeatureShowcase.vue"
      to: "website/docs/.vitepress/theme/composables/useShiki.ts"
      via: "import and call getHighlighter for code rendering"
      pattern: "getHighlighter"
    - from: "website/docs/index.md"
      to: "website/docs/.vitepress/theme/Layout.vue"
      via: "frontmatter layout: home triggers LandingPage render"
      pattern: "layout: home"
---

<objective>
Build the landing page with hero section (tagline + highlighted Mesh code + CTA), feature showcase (4 features with code), and "Why Mesh?" comparison section, all using programmatic Shiki highlighting for inline code examples.

Purpose: The landing page is the first thing visitors see. It communicates what Mesh is (expressive concurrent programming), why it matters (vs Elixir/Rust/Go), and how it looks (real highlighted code examples).
Output: Landing page Vue components, Shiki composable, Layout.vue routing, updated index.md.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/71-syntax-highlighting-landing-page/71-RESEARCH.md
@.planning/phases/71-syntax-highlighting-landing-page/71-01-SUMMARY.md
@website/docs/.vitepress/theme/Layout.vue
@website/docs/.vitepress/theme/styles/main.css
@website/docs/.vitepress/theme/components/NavBar.vue
@website/docs/.vitepress/config.mts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Shiki composable and landing page Vue components</name>
  <files>
    website/docs/.vitepress/theme/composables/useShiki.ts
    website/docs/.vitepress/theme/components/landing/LandingPage.vue
    website/docs/.vitepress/theme/components/landing/HeroSection.vue
    website/docs/.vitepress/theme/components/landing/FeatureShowcase.vue
    website/docs/.vitepress/theme/components/landing/WhyMesh.vue
  </files>
  <action>
**Shiki composable (`composables/useShiki.ts`):**
Create a singleton Shiki highlighter that loads the Mesh grammar and both themes once, then caches:

```typescript
import type { Highlighter } from 'shiki'

let highlighter: Highlighter | null = null
let highlighterPromise: Promise<Highlighter> | null = null

export async function getHighlighter(): Promise<Highlighter> {
  if (highlighter) return highlighter
  if (highlighterPromise) return highlighterPromise

  highlighterPromise = (async () => {
    const { createHighlighter } = await import('shiki')
    const meshGrammar = (await import('../../../../../editors/vscode-mesh/syntaxes/mesh.tmLanguage.json')).default
    const meshLight = (await import('../shiki/mesh-light.json')).default
    const meshDark = (await import('../shiki/mesh-dark.json')).default

    highlighter = await createHighlighter({
      themes: [meshLight as any, meshDark as any],
      langs: [{ ...meshGrammar, name: 'mesh' } as any],
    })
    return highlighter!
  })()

  return highlighterPromise
}

export function highlightCode(hl: Highlighter, code: string): string {
  return hl.codeToHtml(code, {
    lang: 'mesh',
    themes: { light: 'mesh-light', dark: 'mesh-dark' },
  })
}
```

The import path from `composables/` to `editors/` goes: composables -> theme -> .vitepress -> docs -> website -> repo root -> editors. That's 5 levels up: `../../../../../editors/...`. IMPORTANT: Verify this path carefully. The composable is at `website/docs/.vitepress/theme/composables/useShiki.ts`. Going up: theme(1) -> .vitepress(2) -> docs(3) -> website(4) -> repo-root(5). So `../../../../../editors/vscode-mesh/syntaxes/mesh.tmLanguage.json` is correct. Similarly `../shiki/mesh-light.json` goes up from composables to theme, then into shiki.

**HeroSection.vue:**
A full-width section with:
- Centered layout, generous vertical padding (py-24 on desktop, py-16 on mobile)
- Tagline: "Expressive. Concurrent. Type-safe." as a large heading (text-4xl md:text-6xl, font-bold, tracking-tight)
- Subtitle: "Mesh combines Elixir-style concurrency with static type inference, compiling to fast native binaries." (text-lg md:text-xl, text-muted-foreground, max-w-2xl mx-auto)
- Highlighted code sample: Use the hero HTTP server example from the research. Call `getHighlighter()` in `onMounted`, then `highlightCode(hl, code)` to get HTML. Render with `v-html`. Show a `<pre>` with the raw code as fallback until highlighting loads.
- CTA: A shadcn-vue Button (import from `@/components/ui/button`) linking to `/docs/getting-started/` with text "Get Started". Add a secondary plain link "View on GitHub" next to it.
- The code block should be in a styled container: rounded corners, border, max-w-2xl, mx-auto, mt-8.
- Use Tailwind classes from the existing palette (bg-muted, border-border, etc.)

**FeatureShowcase.vue:**
A section with title "What makes Mesh special" and 4 feature cards in a 2-column grid (md:grid-cols-2, gap-6):

Feature 1 - "Lightweight Actors":
Description: "Spawn millions of lightweight actors with crash isolation and supervision trees. Each actor has its own heap and message queue."
Code: The actor Counter example from research.

Feature 2 - "Pattern Matching":
Description: "First-class pattern matching with exhaustiveness checking. Destructure any value -- structs, tuples, sum types, lists."
Code: The pattern matching example from research.

Feature 3 - "Type Inference":
Description: "Hindley-Milner type inference means you rarely write type annotations. The compiler catches errors at compile time."
Code: The type inference example from research.

Feature 4 - "Pipe Operator":
Description: "Chain transformations naturally with the pipe operator. Data flows left to right, just like you read it."
Code: The pipe operator example from research.

Each card: rounded border (border border-border rounded-lg), padding (p-6), title (text-lg font-semibold), description (text-sm text-muted-foreground, mt-2), code block (mt-4, using v-html with highlighted code from useShiki).

Use `onMounted` to highlight all 4 code blocks. Store them in a reactive ref object.

**WhyMesh.vue:**
A section with title "Why Mesh?" and comparison content. Structure:

A brief intro paragraph: "Mesh sits at a unique intersection in the programming language landscape."

Then a 3-item comparison grid or stacked cards:

1. **vs Elixir**: "Mesh shares Elixir's actor model and `let-it-crash` philosophy, but adds static types with full inference. No runtime type errors, no dialyzer setup, and it compiles to native binaries instead of running on the BEAM."

2. **vs Rust**: "Mesh provides Rust-level native performance without borrow checking complexity. Mesh uses per-actor garbage collection instead of ownership, making concurrent code dramatically simpler to write."

3. **vs Go**: "Like Go, Mesh compiles to fast native binaries with lightweight concurrency. But Mesh adds pattern matching, algebraic types, type inference, and supervision trees -- making it more expressive and fault-tolerant."

Style: Each comparison as a card or bordered section with the language name as a subheading. Text-foreground for headings, text-muted-foreground for body. No code blocks in this section (it's prose-focused).

At the bottom, a subtle closing line: "Mesh is open source and under active development." with a link to GitHub.

**LandingPage.vue:**
Simple composition component:
```vue
<template>
  <div>
    <HeroSection />
    <FeatureShowcase />
    <WhyMesh />
  </div>
</template>
```
Import all three section components. Wrap in a div, no extra styling (sections handle their own padding/margins).
  </action>
  <verify>
All 5 files exist: `ls website/docs/.vitepress/theme/composables/useShiki.ts website/docs/.vitepress/theme/components/landing/LandingPage.vue website/docs/.vitepress/theme/components/landing/HeroSection.vue website/docs/.vitepress/theme/components/landing/FeatureShowcase.vue website/docs/.vitepress/theme/components/landing/WhyMesh.vue`
  </verify>
  <done>
Five files created: Shiki composable with singleton highlighter, HeroSection with tagline/code/CTA, FeatureShowcase with 4 feature cards and highlighted code, WhyMesh with language comparisons, LandingPage composing all three.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire landing page into Layout and update index.md</name>
  <files>
    website/docs/.vitepress/theme/Layout.vue
    website/docs/index.md
  </files>
  <action>
**Update Layout.vue:**
Replace the current Layout.vue with frontmatter-based routing. The current layout always shows `<Content />` in a max-w-4xl container. Change it to:
- If `frontmatter.layout === 'home'`, render `<LandingPage />` instead of the `<main>` content wrapper
- Otherwise, keep the existing `<main class="mx-auto max-w-4xl px-4 py-8"><Content /></main>`

```vue
<script setup lang="ts">
import { useData } from 'vitepress'
import NavBar from './components/NavBar.vue'
import LandingPage from './components/landing/LandingPage.vue'

const { frontmatter } = useData()
</script>

<template>
  <div class="min-h-screen bg-background text-foreground">
    <NavBar />
    <LandingPage v-if="frontmatter.layout === 'home'" />
    <main v-else class="mx-auto max-w-4xl px-4 py-8">
      <Content />
    </main>
  </div>
</template>
```

Keep the NavBar import and rendering from Phase 70. Add the LandingPage import and the v-if/v-else conditional.

**Update index.md:**
Replace the current placeholder content with:
```markdown
---
layout: home
title: Mesh Programming Language
---
```

No markdown body content -- the LandingPage.vue component handles everything when `layout: home` is set.

**Verify build:**
Run `cd /Users/sn0w/Documents/dev/snow/website && npm run build` to confirm the full site builds successfully with the landing page.

If the build fails due to SSR issues with the Shiki composable (async imports in SSR context), wrap the `onMounted` calls in the landing page components with `import.meta.env.SSR` checks, or use `__VITEPRESS__` to detect SSR mode. The code blocks can show raw `<pre>` in SSR output and highlight on client hydration.
  </action>
  <verify>
Run `cd /Users/sn0w/Documents/dev/snow/website && npm run build` -- must succeed. Verify the built `website/docs/.vitepress/dist/index.html` contains the hero tagline text "Expressive. Concurrent. Type-safe." and the feature section title "What makes Mesh special". Verify Layout.vue contains `frontmatter.layout === 'home'`. Verify index.md contains `layout: home`.
  </verify>
  <done>
Layout.vue routes to LandingPage for home layout. index.md uses `layout: home` frontmatter. Full site builds successfully. Landing page HTML contains hero tagline, feature showcase, and Why Mesh sections.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/sn0w/Documents/dev/snow/website && npm run build` completes without errors
2. Built index.html contains "Expressive. Concurrent. Type-safe." (hero tagline)
3. Built index.html contains "What makes Mesh special" (feature section)
4. Built index.html contains "Why Mesh?" (comparison section)
5. Layout.vue conditionally renders LandingPage vs Content based on frontmatter
6. Code examples in landing page components reference real Mesh syntax (actors, pattern matching, pipes, type inference)
</verification>

<success_criteria>
- Landing page hero shows tagline, highlighted Mesh code sample, and CTA button
- Feature showcase shows 4 features (actors, pattern matching, type inference, pipe operator) with code
- "Why Mesh?" explains positioning vs Elixir, Rust, and Go
- All code examples use the Shiki composable for programmatic highlighting
- Full VitePress build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/71-syntax-highlighting-landing-page/71-02-SUMMARY.md`
</output>
