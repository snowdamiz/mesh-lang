---
phase: 75-numeric-traits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-typeck/src/builtins.rs
  - crates/mesh-typeck/src/infer.rs
autonomous: true

must_haves:
  truths:
    - "Arithmetic traits (Add/Sub/Mul/Div/Mod) each have a type Output associated type"
    - "Built-in impls for Int and Float set Output = Int and Output = Float respectively"
    - "Neg trait is registered with method neg(self) and type Output"
    - "infer_trait_binary_op resolves Output associated type for result type instead of returning LHS type"
    - "infer_unary checks Neg trait for non-primitive user types and resolves Output"
    - "Primitive arithmetic (Int + Int, Float * Float, -42) still works unchanged"
  artifacts:
    - path: "crates/mesh-typeck/src/builtins.rs"
      provides: "Output associated type on arithmetic traits + Neg trait registration"
      contains: "AssocTypeDef"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Output resolution in binary/unary inference"
      contains: "resolve_associated_type"
  key_links:
    - from: "crates/mesh-typeck/src/builtins.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "AssocTypeDef in TraitDef.associated_types and Output binding in ImplDef.associated_types"
      pattern: "AssocTypeDef.*Output"
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "trait_registry.resolve_associated_type call in infer_trait_binary_op"
      pattern: "resolve_associated_type.*Output"
---

<objective>
Add Output associated type to all arithmetic traits, register the Neg trait, and update type inference to resolve Output for operator result types.

Purpose: This is the type-system foundation for NUM-01, NUM-02, NUM-03. Without Output on arithmetic traits, binary operators always return the operand type (wrong for cases like Meter * Meter = SquareMeter). Without the Neg trait, unary minus cannot dispatch to user-defined implementations.

Output: builtins.rs with Output on all arithmetic traits + Neg trait registered; infer.rs with Output resolution in infer_trait_binary_op and Neg check in infer_unary
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/75-numeric-traits/75-RESEARCH.md
@crates/mesh-typeck/src/builtins.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-typeck/src/traits.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Output associated type to arithmetic traits and register Neg trait</name>
  <files>crates/mesh-typeck/src/builtins.rs</files>
  <action>
In `register_compiler_known_traits`:

1. **Add Output to arithmetic traits (Add/Sub/Mul/Div/Mod):**
   - Change `associated_types: vec![]` to `associated_types: vec![AssocTypeDef { name: "Output".to_string() }]` in the arithmetic trait registration loop (around line 835).
   - In the Int/Float impl registration loop (around line 854), change `associated_types: FxHashMap::default()` to a map containing `"Output" -> ty.clone()`. This means `Output = Int` for Int impls and `Output = Float` for Float impls.

2. **Register Neg trait (after the arithmetic traits loop, before Eq):**
   - Register `TraitDef` with name "Neg", one method `TraitMethodSig { name: "neg", has_self: true, param_count: 0, return_type: None, has_default_body: false }`, and `associated_types: vec![AssocTypeDef { name: "Output".to_string() }]`.
   - Register impls for Int and Float, each with method `ImplMethodSig { has_self: true, param_count: 0, return_type: Some(ty.clone()) }` and `associated_types` map with `"Output" -> ty.clone()`.

3. **Import AssocTypeDef** if not already in scope (it is defined in traits.rs and should already be imported from the Phase 74 work, but verify).

Do NOT modify Eq or Ord traits -- they do not need Output (they always return Bool).
Do NOT add any mixed-type arithmetic support.
  </action>
  <verify>
Run `cargo build -p mesh-typeck` -- must compile without errors.
Run `cargo test -p mesh-typeck` -- all existing tests must pass (no regressions from adding Output to trait defs).
  </verify>
  <done>
All 5 arithmetic traits have `type Output` in their TraitDef. Int and Float impls bind Output to their own type. Neg trait registered with neg(self) method and Output. All existing mesh-typeck tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update type inference to resolve Output for binary and unary operators</name>
  <files>crates/mesh-typeck/src/infer.rs</files>
  <action>
1. **Modify `infer_trait_binary_op` (around line 3508):**
   - After the existing `if trait_registry.has_impl(trait_name, &resolved)` check succeeds (line 3524), instead of `Ok(resolved)`, attempt to resolve the Output associated type:
   ```
   if let Some(output_ty) = trait_registry.resolve_associated_type(trait_name, "Output", &resolved) {
       Ok(output_ty)
   } else {
       Ok(resolved)  // fallback for backward compat
   }
   ```
   - The `trait_registry` parameter is already passed in. The `resolve_associated_type` method exists on `TraitRegistry` (from Phase 74).
   - Keep the existing unification of lhs and rhs (same-type constraint).
   - Keep the existing type-variable early return.

2. **Modify `infer_unary` (around line 3538):**
   - In the `Some(SyntaxKind::MINUS)` arm (line 3562), instead of unconditionally returning `Ok(operand_ty)`:
     - First resolve the operand type: `let resolved = ctx.resolve(operand_ty.clone());`
     - If `resolved` is a type variable, return `Ok(resolved)` (deferred).
     - If `resolved` is Int or Float (check with `matches!(resolved, Ty::Con(ref tc) if tc.name == "Int" || tc.name == "Float")`), return `Ok(resolved)` -- fast path for primitives, no trait check needed.
     - Otherwise (user type), check `trait_registry.has_impl("Neg", &resolved)`. If true, resolve Output: `trait_registry.resolve_associated_type("Neg", "Output", &resolved)` and return the Output type (falling back to `resolved` if no Output).
     - If no Neg impl, emit `TypeError::TraitNotSatisfied { ty: resolved, trait_name: "Neg".to_string(), origin: ConstraintOrigin::Builtin }` and return Err.
   - The `trait_registry` parameter is already available in `infer_unary`'s signature.

Do NOT change the `SyntaxKind::BANG | SyntaxKind::NOT_KW` arm -- Not/Bang remains Bool -> Bool.
Do NOT change anything in `infer_binary` -- it already dispatches through `infer_trait_binary_op`.
  </action>
  <verify>
Run `cargo build -p mesh-typeck` -- must compile.
Run `cargo test -p mesh-typeck` -- all existing tests pass. Specifically: basic arithmetic type inference (Int + Int = Int, Float * Float = Float) must continue to work because Output = Int for Int impls and Output = Float for Float impls.
Run `cargo test --workspace` -- full workspace must compile and pass (check for downstream breakage in mesh-codegen, meshc, mesh-lsp).
  </verify>
  <done>
`infer_trait_binary_op` returns the Output associated type instead of the operand type. `infer_unary` checks Neg trait for non-primitive types. All existing workspace tests pass (primitive arithmetic unchanged because Output = Self for Int/Float).
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with zero failures
2. Existing arithmetic E2E tests (if any) produce identical results
3. The type of `1 + 2` is still inferred as Int (not broken by Output resolution)
4. The type of `3.0 * 4.0` is still inferred as Float
</verification>

<success_criteria>
- All 5 arithmetic traits have `type Output` associated type
- Neg trait registered with impls for Int and Float
- `infer_trait_binary_op` resolves Output associated type for result type
- `infer_unary` checks Neg trait for user types and resolves Output
- All workspace tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/75-numeric-traits/75-01-SUMMARY.md`
</output>
