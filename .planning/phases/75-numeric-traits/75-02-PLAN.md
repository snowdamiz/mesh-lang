---
phase: 75-numeric-traits
plan: 02
type: execute
wave: 2
depends_on: ["75-01"]
files_modified:
  - crates/mesh-codegen/src/mir/lower.rs
  - tests/e2e/numeric_traits.mpl
  - tests/e2e/numeric_neg.mpl
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "User can impl Add for a custom struct with type Output and use + operator on instances"
    - "Binary operators infer result type from Output associated type, not hardcoded to operand type or Bool"
    - "Div and Mod operators dispatch through trait methods for user types"
    - "User can impl Neg for a custom struct and use unary minus on instances"
    - "Primitive arithmetic (Int + Int, -42, 10 / 3) still works identically"
  artifacts:
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Fixed binary dispatch (Div/Mod, correct return type) and Neg unary dispatch"
      contains: "Neg__neg"
    - path: "tests/e2e/numeric_traits.mpl"
      provides: "E2E test for custom Add/Sub/Mul/Div with Output"
    - path: "tests/e2e/numeric_neg.mpl"
      provides: "E2E test for custom Neg with Output"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "Test harness entries for numeric trait E2E tests"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "trait_registry.has_impl for Neg lookup and known_functions for mangled name"
      pattern: "has_impl.*Neg"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "resolve_range"
      via: "Uses typeck Output type from types map for arithmetic dispatch return type"
      pattern: "resolve_range.*text_range"
    - from: "tests/e2e/numeric_traits.mpl"
      to: "crates/meshc/tests/e2e.rs"
      via: "read_fixture + compile_and_run test harness"
      pattern: "numeric_traits"
---

<objective>
Fix MIR binary operator dispatch for user types (correct return type, add Div/Mod), add Neg unary dispatch for user types, and write E2E tests proving all three requirements work end-to-end.

Purpose: Plan 01 made the type checker produce correct Output types. This plan makes the code generator honor those types (fixing the MirType::Bool bug) and adds the Neg dispatch path. E2E tests prove the full pipeline from source code to correct runtime output.

Output: Fixed lower_binary_expr with correct return types and Div/Mod support; lower_unary_expr with Neg trait dispatch; E2E test files for custom arithmetic and custom Neg
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/75-numeric-traits/75-RESEARCH.md
@.planning/phases/75-numeric-traits/75-01-SUMMARY.md
@crates/mesh-codegen/src/mir/lower.rs
@crates/meshc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix MIR binary dispatch and add Neg unary dispatch</name>
  <files>crates/mesh-codegen/src/mir/lower.rs</files>
  <action>
1. **Fix `lower_binary_expr` user-type dispatch (around line 5083):**

   a. **Add Div and Mod to the dispatch table** (around line 5085-5095). Currently the table has Add, Sub, Mul, Eq, NotEq, Lt, Gt, LtEq, GtEq. Add:
      - `BinOp::Div => Some(("Div", "div", false, false)),`
      - `BinOp::Mod => Some(("Mod", "mod", false, false)),`

   b. **Fix return type from MirType::Bool to correct type for arithmetic ops.** Currently lines 5109-5121 hardcode `MirType::Bool` for both `fn_ty` and `call.ty`. The fix:
      - Determine result type based on operation category:
        ```
        let result_ty = match op {
            BinOp::Eq | BinOp::NotEq | BinOp::Lt | BinOp::Gt
            | BinOp::LtEq | BinOp::GtEq => MirType::Bool,
            _ => ty.clone(),  // ty from resolve_range = typeck Output type
        };
        ```
      - Use `result_ty` in both the `MirType::FnPtr` return type and the `MirExpr::Call { ty }` field.
      - Keep `MirType::Bool` for comparison operators (Eq/Ord) -- they genuinely return Bool.

2. **Add Neg dispatch to `lower_unary_expr` (around line 5219):**
   After computing `op`, `operand`, and `ty`, but before the final `MirExpr::UnaryOp` return:
   - Check if `op == UnaryOp::Neg` (the unary minus case).
   - Get `operand_ty` from `operand.ty().clone()`.
   - Check `is_user_type`: `matches!(operand_ty, MirType::Struct(_) | MirType::SumType(_))`.
   - If user type, compute: `ty_for_lookup = mir_type_to_ty(&operand_ty)`, `type_name = mir_type_to_impl_name(&operand_ty)`, `mangled = format!("Neg__neg__{}", type_name)`.
   - Check `has_impl`: `self.trait_registry.has_impl("Neg", &ty_for_lookup) || self.known_functions.contains_key(&mangled)`.
   - If has_impl, return a `MirExpr::Call` with func `MirExpr::Var(mangled, MirType::FnPtr(vec![operand_ty], Box::new(ty.clone())))`, args `vec![operand]`, and `ty: ty`.
   - If not user type or no impl, fall through to the existing `MirExpr::UnaryOp` return.

This follows the exact same pattern as the existing binary dispatch at line 5097-5134. Use `mir_type_to_ty` and `mir_type_to_impl_name` from the existing imports.

Do NOT change the codegen layer (codegen/expr.rs) -- the Call dispatch path already handles function calls correctly.
Do NOT change primitive arithmetic -- the `is_user_type` check ensures Int/Float still use hardware ops.
  </action>
  <verify>
Run `cargo build -p mesh-codegen` -- must compile.
Run `cargo test --workspace` -- all existing tests pass (no regressions from dispatch table changes).
  </verify>
  <done>
Binary operator dispatch for user types uses correct Output type (not Bool) for arithmetic ops. Div and Mod included in dispatch table. Unary minus dispatches to Neg__neg__TypeName for user types. Primitives unaffected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write E2E tests for numeric traits and Neg</name>
  <files>tests/e2e/numeric_traits.mpl, tests/e2e/numeric_neg.mpl, crates/meshc/tests/e2e.rs</files>
  <action>
1. **Create `tests/e2e/numeric_traits.mpl`:**
   Test user-defined arithmetic with Output associated type. The test should:
   - Define a `struct Vec2 do x :: Float y :: Float end`
   - `impl Add for Vec2` with `type Output = Vec2` and `fn add(self, other) -> Vec2` that adds components
   - `impl Sub for Vec2` with `type Output = Vec2` and `fn sub(self, other) -> Vec2` that subtracts components
   - `impl Mul for Vec2` with `type Output = Vec2` and `fn mul(self, other) -> Vec2` that multiplies components
   - In `fn main`: create two Vec2 instances, test `v1 + v2`, `v1 - v2`, `v1 * v2`, print results using `.x.to_string()` and `.y.to_string()`
   - Also test backward compat: `let a = 1 + 2` and `let b = 3.0 * 4.0` and print them
   - Also test operator chaining: `v1 + v2 + v3` (verifies Output = Vec2 feeds back into Add)
   - Expected output should be deterministic string lines

2. **Create `tests/e2e/numeric_neg.mpl`:**
   Test user-defined Neg with Output associated type. The test should:
   - Define a `struct Point do x :: Float y :: Float end`
   - `impl Neg for Point` with `type Output = Point` and `fn neg(self) -> Point` that negates components (use `0.0 - self.x` pattern since unary neg on Float is primitive)
   - In `fn main`: create a Point, test `-p`, print results
   - Also test primitive neg still works: `let a = -42` and `let b = -3.14` and print them
   - Expected output should be deterministic string lines

3. **Add test entries to `crates/meshc/tests/e2e.rs`:**
   Following the existing pattern (see the `e2e_assoc_type_basic` test around line 2527):
   ```rust
   // Phase 75: User-defined arithmetic operators with Output associated type.
   #[test]
   fn e2e_numeric_traits() {
       let source = read_fixture("numeric_traits.mpl");
       let output = compile_and_run(&source);
       assert_eq!(output, "EXPECTED_OUTPUT_HERE\n");
   }

   // Phase 75: User-defined Neg trait for unary minus.
   #[test]
   fn e2e_numeric_neg() {
       let source = read_fixture("numeric_neg.mpl");
       let output = compile_and_run(&source);
       assert_eq!(output, "EXPECTED_OUTPUT_HERE\n");
   }
   ```
   Replace EXPECTED_OUTPUT_HERE with the actual expected output matching the println calls in the .mpl files.

Ensure .mpl files use the exact Mesh syntax conventions: `do...end` blocks, `::` for type annotations, `fn name(params) -> RetType do ... end` for methods.
  </action>
  <verify>
Run `cargo test -p meshc --test e2e -- e2e_numeric_traits` -- must pass.
Run `cargo test -p meshc --test e2e -- e2e_numeric_neg` -- must pass.
Run `cargo test --workspace` -- all tests pass including new ones.
  </verify>
  <done>
E2E tests prove: (1) User can impl Add/Sub/Mul for Vec2 and use +, -, * operators; (2) Output type is correctly inferred (not Bool, not hardcoded to operand type); (3) User can impl Neg and use unary minus; (4) Primitive arithmetic and negation still work; (5) Operator chaining works.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with zero failures
2. `cargo test -p meshc --test e2e -- e2e_numeric` runs both new E2E tests successfully
3. Custom Vec2 arithmetic (v1 + v2) produces correct Vec2 result, not Bool
4. Custom Point negation (-p) produces correct Point result
5. Primitive arithmetic (1 + 2 = 3, -42 = -42) unchanged
6. All 3 requirements satisfied: NUM-01 (user impl Add/Sub/Mul/Div with Output), NUM-02 (Output for result type), NUM-03 (Neg trait for unary minus)
</verification>

<success_criteria>
- MIR dispatch table includes Div and Mod for user types
- Arithmetic dispatch uses Output type (from resolve_range), not MirType::Bool
- Neg dispatch emits Call to Neg__neg__TypeName for user types
- E2E tests pass for custom arithmetic and custom Neg
- All existing workspace tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/75-numeric-traits/75-02-SUMMARY.md`
</output>
