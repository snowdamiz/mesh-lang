---
phase: 58-struct-to-row-mapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/db/row.rs
  - crates/snow-rt/src/db/mod.rs
  - crates/snow-rt/src/db/pg.rs
  - crates/snow-rt/src/db/pool.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "Runtime row parsing functions exist and can parse strings to Int, Float, Bool with correct error handling"
    - "snow_row_from_row_get extracts column values from Map<String, String> with descriptive error for missing columns"
    - "snow_pg_query_as and snow_pool_query_as combine query + row mapping via function pointer callback"
    - "All new runtime functions have LLVM declarations and known_functions entries (three-point registration)"
  artifacts:
    - path: "crates/snow-rt/src/db/row.rs"
      provides: "Row parsing runtime functions"
      contains: "snow_row_from_row_get"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for all row runtime functions"
      contains: "snow_row_parse_int"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "known_functions entries for row functions"
      contains: "snow_row_from_row_get"
  key_links:
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/db/row.rs"
      via: "LLVM extern function declarations matching runtime #[no_mangle] signatures"
      pattern: "snow_row_parse_int.*snow_row_parse_float.*snow_row_parse_bool"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "known_functions names matching LLVM declaration names"
      pattern: "snow_row_from_row_get"
---

<objective>
Implement the runtime row-parsing functions and register them through the full LLVM pipeline.

Purpose: Provides the runtime foundation that Plan 02's generated MIR will call -- `snow_row_from_row_get` for column extraction, `snow_row_parse_int/float/bool` for type conversion, and `snow_pg_query_as/snow_pool_query_as` for query+map in one call.

Output: New `row.rs` file with 4 row parsing functions, `query_as` functions in pg.rs and pool.rs, LLVM declarations for all 7 functions, and known_functions entries in lower.rs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/58-struct-to-row-mapping/58-RESEARCH.md
@.planning/phases/49-json-serde-structs/49-01-SUMMARY.md
@.planning/phases/57-connection-pooling-transactions/57-03-SUMMARY.md
@crates/snow-rt/src/db/pg.rs
@crates/snow-rt/src/db/pool.rs
@crates/snow-rt/src/db/mod.rs
@crates/snow-rt/src/io.rs
@crates/snow-rt/src/string.rs
@crates/snow-rt/src/collections/map.rs
@crates/snow-rt/src/collections/list.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create row.rs runtime functions and add query_as to pg.rs and pool.rs</name>
  <files>
    crates/snow-rt/src/db/row.rs
    crates/snow-rt/src/db/mod.rs
    crates/snow-rt/src/db/pg.rs
    crates/snow-rt/src/db/pool.rs
  </files>
  <action>
    **Create `crates/snow-rt/src/db/row.rs`** with 4 extern "C" functions following the SnowResult return pattern from io.rs:

    1. **`snow_row_from_row_get(row: *mut u8, col_name: *mut u8) -> *mut u8`**
       - Cast col_name as u64 key for `snow_map_has_key(row, key)`
       - If key exists: `snow_map_get(row, key)` -> wrap in `alloc_result(0, val as *mut u8)`
       - If key missing: build error string "missing column: {name}" using `snow_string_new`, wrap in `alloc_result(1, err_str)`
       - The col_name is a `*const SnowString` -- read the string content via `SnowString::as_str()` for the error message
       - Use `snow_map_has_key` and `snow_map_get` from `crate::collections::map`
       - Use `alloc_result` from `crate::io`
       - Use `snow_string_new` from `crate::string`

    2. **`snow_row_parse_int(s: *mut u8) -> *mut u8`**
       - Cast s as `*const SnowString`, call `.as_str().trim()`
       - `text.parse::<i64>()` -- if Ok(val): `alloc_result(0, val as *mut u8)`
       - If Err: `alloc_result(1, snow_string_new("cannot parse '{}' as Int"))` using format string
       - All inside unsafe block

    3. **`snow_row_parse_float(s: *mut u8) -> *mut u8`**
       - Same pattern as parse_int but `parse::<f64>()`
       - **CRITICAL:** Pre-normalize PostgreSQL-specific representations before parsing:
         - "Infinity" -> "inf"
         - "-Infinity" -> "-inf"
         - All other values pass through unchanged
       - On Ok: `alloc_result(0, f64::to_bits(val) as *mut u8)` -- MUST use to_bits for float-to-u64 encoding, matching the existing Snow Float convention
       - On Err: descriptive error string

    4. **`snow_row_parse_bool(s: *mut u8) -> *mut u8`**
       - Read string, `.trim().to_lowercase()`
       - Match: "true" | "t" | "1" | "yes" -> `alloc_result(0, 1i64 as *mut u8)` (Snow true = 1)
       - Match: "false" | "f" | "0" | "no" -> `alloc_result(0, 0i64 as *mut u8)` (Snow false = 0)
       - Otherwise: `alloc_result(1, "cannot parse '{}' as Bool")`
       - PostgreSQL typically returns "t"/"f" for booleans in text format -- this MUST work

    **Add unit tests** in row.rs (behind `#[cfg(test)] mod tests`) covering:
    - Parse int success (positive, negative, zero)
    - Parse int failure (non-numeric string)
    - Parse float success (normal, infinity variants)
    - Parse float failure
    - Parse bool success (all 8 accepted values)
    - Parse bool failure

    **Update `crates/snow-rt/src/db/mod.rs`:** Add `pub mod row;`

    **Add `snow_pg_query_as` to `crates/snow-rt/src/db/pg.rs`:**
    ```rust
    #[no_mangle]
    pub extern "C" fn snow_pg_query_as(
        conn_handle: u64,
        sql: *mut u8,      // *const SnowString
        params: *mut u8,   // List<String>
        from_row_fn: *mut u8, // fn(*mut u8) -> *mut u8
    ) -> *mut u8
    ```
    - Define type alias: `type FromRowFn = unsafe extern "C" fn(*mut u8) -> *mut u8;`
    - Call `snow_pg_query(conn_handle, sql as *const SnowString, params)` to get the query result
    - Check result tag via `SnowResult` struct cast -- if tag != 0, return as-is (propagate query error)
    - If Ok: extract the rows list from result.value
    - Use `snow_list_length(rows_list)` and `snow_list_get(rows_list, i)` to iterate rows
    - For each row: `std::mem::transmute::<*mut u8, FromRowFn>(from_row_fn)(row as *mut u8)` to call the from_row callback
    - Collect results into a new list via `snow_list_new()` + `snow_list_append(list, mapped as u64)`
    - Return `alloc_result(0, result_list as *mut u8)` wrapping the list of per-row Results

    **Add `snow_pool_query_as` to `crates/snow-rt/src/db/pool.rs`:**
    - Same signature as `snow_pg_query_as` but first param is `pool_handle: u64` instead of `conn_handle`
    - Internally: checkout from pool, call `snow_pg_query_as(conn_handle, sql, params, from_row_fn)`, checkin, return result
    - Follow the exact same checkout/query/checkin pattern used by `snow_pool_query`
    - On checkout failure, return `alloc_result(1, error_string)`
  </action>
  <verify>
    `cargo test -p snow-rt -- row` passes all unit tests.
    `cargo build -p snow-rt` compiles without warnings.
  </verify>
  <done>
    row.rs exists with 4 extern "C" functions + unit tests.
    pg.rs has snow_pg_query_as.
    pool.rs has snow_pool_query_as.
    mod.rs exports row module.
    All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Three-point LLVM and known_functions registration for all 7 new functions</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
    **Add LLVM declarations in `intrinsics.rs`** (in the database section, after the existing Pg/Pool declarations):

    For all row parsing functions, the signature pattern is `(ptr) -> ptr` or `(ptr, ptr) -> ptr`:

    1. `snow_row_from_row_get(ptr, ptr) -> ptr` -- row map + column name string -> SnowResult
    2. `snow_row_parse_int(ptr) -> ptr` -- string -> SnowResult
    3. `snow_row_parse_float(ptr) -> ptr` -- string -> SnowResult
    4. `snow_row_parse_bool(ptr) -> ptr` -- string -> SnowResult
    5. `snow_pg_query_as(i64, ptr, ptr, ptr) -> ptr` -- conn_handle + sql + params + from_row_fn -> SnowResult
    6. `snow_pool_query_as(i64, ptr, ptr, ptr) -> ptr` -- pool_handle + sql + params + from_row_fn -> SnowResult
    7. `snow_string_length(ptr) -> i64` -- **check if already declared** -- needed for NULL empty-string check in generated MIR

    For each, use `module.add_function("name", type.fn_type(&[...], false), None)`.

    Follow the exact pattern from the existing `snow_pg_query` declaration (line ~514).

    **Add test assertions** in the existing `test_all_intrinsics_declared` test for all new functions.

    **Add known_functions entries in `lower.rs`** in the `new()` method where Pg/Pool functions are registered (~line 684-706):

    For each runtime function, insert into `known_functions` with the correct `MirType::FnPtr`:
    - `"snow_row_from_row_get"` -> `FnPtr(vec![Ptr, Ptr], Box::new(Ptr))`
    - `"snow_row_parse_int"` -> `FnPtr(vec![Ptr], Box::new(Ptr))`
    - `"snow_row_parse_float"` -> `FnPtr(vec![Ptr], Box::new(Ptr))`
    - `"snow_row_parse_bool"` -> `FnPtr(vec![Ptr], Box::new(Ptr))`
    - `"snow_pg_query_as"` -> `FnPtr(vec![Int, Ptr, Ptr, Ptr], Box::new(Ptr))`
    - `"snow_pool_query_as"` -> `FnPtr(vec![Int, Ptr, Ptr, Ptr], Box::new(Ptr))`

    Also add `map_builtin_name` entries (~line 9039-9058) for:
    - `("Pg", "query_as")` -> `"snow_pg_query_as"`
    - `("Pool", "query_as")` -> `"snow_pool_query_as"`

    **Check if `snow_string_length` is already in known_functions.** If not, add it -- it's needed by Plan 02 for NULL (empty string) detection in from_row MIR generation.
  </action>
  <verify>
    `cargo test -p snow-codegen -- intrinsics` passes (assertion test confirms all declarations).
    `cargo build` compiles the full workspace without errors.
  </verify>
  <done>
    All 6-7 new functions have LLVM declarations in intrinsics.rs.
    All functions have known_functions entries in lower.rs.
    map_builtin_name maps Pg.query_as and Pool.query_as to correct runtime names.
    Three-point registration complete for all new functions.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p snow-rt -- row` -- row parsing unit tests pass
- `cargo test -p snow-codegen -- intrinsics` -- LLVM declaration test passes
- `cargo build` -- full workspace compiles cleanly
- `cargo test` -- all existing tests still pass (no regressions)
</verification>

<success_criteria>
- row.rs exists with 4 extern "C" parsing functions that handle PostgreSQL text format edge cases
- pg.rs has snow_pg_query_as combining query + from_row_fn callback iteration
- pool.rs has snow_pool_query_as with checkout/query_as/checkin pattern
- All 6+ new functions have three-point registration (runtime, LLVM, known_functions)
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/58-struct-to-row-mapping/58-01-SUMMARY.md`
</output>
