---
phase: 55-postgresql-tls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/Cargo.toml
  - crates/snow-rt/src/gc.rs
  - crates/snow-rt/src/db/pg.rs
autonomous: true

must_haves:
  truths:
    - "Snow program can connect to a PostgreSQL database with sslmode=require and queries execute over encrypted TLS connection"
    - "Snow program can connect with sslmode=prefer and driver upgrades to TLS when server supports it, falls back to plaintext otherwise"
    - "Snow program can connect with sslmode=disable and connection works identically to v2.0 behavior (no TLS negotiation)"
    - "Existing v2.0 PostgreSQL code (plaintext connections with no sslmode param) continues to work without modification"
  artifacts:
    - path: "crates/snow-rt/Cargo.toml"
      provides: "Direct rustls, webpki-roots, rustls-pki-types dependencies"
      contains: "rustls"
    - path: "crates/snow-rt/src/gc.rs"
      provides: "Ring CryptoProvider installation at runtime startup"
      contains: "install_default"
    - path: "crates/snow-rt/src/db/pg.rs"
      provides: "PgStream enum, SslMode enum, SSLRequest handshake, sslmode URL parsing, refactored read_message"
      contains: "PgStream"
  key_links:
    - from: "crates/snow-rt/src/gc.rs"
      to: "rustls::crypto::ring"
      via: "CryptoProvider install in snow_rt_init"
      pattern: "ring::default_provider.*install_default"
    - from: "crates/snow-rt/src/db/pg.rs"
      to: "rustls::StreamOwned"
      via: "PgStream::Tls variant wrapping TcpStream"
      pattern: "PgStream::Tls\\(StreamOwned"
    - from: "crates/snow-rt/src/db/pg.rs"
      to: "read_message"
      via: "All callers pass &mut PgStream instead of &mut TcpStream"
      pattern: "read_message\\(&mut.*stream"
    - from: "crates/snow-rt/src/db/pg.rs"
      to: "PgUrl"
      via: "sslmode field parsed from URL query string"
      pattern: "sslmode.*SslMode"
---

<objective>
Add TLS support to the PostgreSQL driver so Snow programs can connect to TLS-required cloud databases (AWS RDS, Supabase, Neon) via the SSLRequest protocol upgrade.

Purpose: Cloud PostgreSQL providers require encrypted connections. Without TLS, Snow cannot connect to production databases.
Output: PgStream enum abstraction, SSLRequest handshake, sslmode URL parsing, CryptoProvider installation -- all within snow-rt.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-postgresql-tls/55-RESEARCH.md
@crates/snow-rt/src/db/pg.rs
@crates/snow-rt/src/gc.rs
@crates/snow-rt/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TLS dependencies and install CryptoProvider at runtime startup</name>
  <files>crates/snow-rt/Cargo.toml, crates/snow-rt/src/gc.rs</files>
  <action>
1. In `crates/snow-rt/Cargo.toml`, add three direct dependencies after the existing Phase 54 deps:

```toml
# Phase 55: TLS for PostgreSQL connections
# All three crates are already compiled as transitive deps of ureq 2.12.
# Adding them as direct deps costs zero additional compile time.
rustls = { version = "0.23", default-features = false, features = ["ring", "tls12", "logging", "std"] }
webpki-roots = "0.26"
rustls-pki-types = "1"
```

Use `default-features = false` to prevent pulling in `aws-lc-rs`. The `ring` feature enables the ring crypto provider. The `tls12` feature ensures compatibility with PostgreSQL servers that only support TLS 1.2. These exact feature flags match what ureq already enables.

2. In `crates/snow-rt/src/gc.rs`, add the CryptoProvider installation inside `snow_rt_init()` AFTER the arena initialization block (after `*guard = Some(arena);` and the closing brace of the `if guard.is_none()` block, but BEFORE the function closing brace). Add this line:

```rust
// Install ring crypto provider for TLS (PostgreSQL + ureq HTTP client).
// Idempotent: ignore Err if already installed by another path.
let _ = rustls::crypto::ring::default_provider().install_default();
```

This MUST run before any TLS operation. Since `snow_rt_init()` is called from the LLVM-generated `main` wrapper before any Snow code executes, this guarantees the provider is available for both PG TLS connections and ureq HTTP requests.
  </action>
  <verify>
Run `cargo build -p snow-rt 2>&1` -- must compile with zero new crate downloads (all deps already cached as transitive deps of ureq). Run `cargo test -p snowc 2>&1 | tail -5` -- existing tests must still pass (the CryptoProvider install is idempotent and does not affect non-TLS code paths).
  </verify>
  <done>snow-rt compiles with rustls/webpki-roots/rustls-pki-types as direct deps. snow_rt_init() installs ring CryptoProvider. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement PgStream enum, SSLRequest handshake, sslmode parsing, and refactor connection flow</name>
  <files>crates/snow-rt/src/db/pg.rs</files>
  <action>
This task modifies `crates/snow-rt/src/db/pg.rs` to add TLS support. All changes are in this single file.

**A. Add imports** at the top (after existing imports):

```rust
use std::sync::Arc;
use rustls::{ClientConfig, ClientConnection, RootCertStore, StreamOwned};
use rustls_pki_types::ServerName;
```

**B. Add SslMode enum** (before or after the PgUrl struct):

```rust
#[derive(Clone, Copy, PartialEq)]
enum SslMode {
    Disable,
    Prefer,
    Require,
}
```

**C. Add sslmode field to PgUrl struct:**

Change PgUrl to include `sslmode: SslMode` as the last field.

**D. Replace PgConn.stream type:**

Change `struct PgConn { stream: TcpStream }` to `struct PgConn { stream: PgStream }`.

**E. Create PgStream enum** with Read+Write delegation:

```rust
enum PgStream {
    Plain(TcpStream),
    Tls(StreamOwned<ClientConnection, TcpStream>),
}

impl Read for PgStream {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        match self {
            PgStream::Plain(s) => s.read(buf),
            PgStream::Tls(s) => s.read(buf),
        }
    }
}

impl Write for PgStream {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        match self {
            PgStream::Plain(s) => s.write(buf),
            PgStream::Tls(s) => s.write(buf),
        }
    }
    fn flush(&mut self) -> std::io::Result<()> {
        match self {
            PgStream::Plain(s) => s.flush(),
            PgStream::Tls(s) => s.flush(),
        }
    }
}
```

**F. Refactor `read_message` signature:**

Change `fn read_message(stream: &mut TcpStream)` to `fn read_message(stream: &mut PgStream)`. The body is unchanged because PgStream implements Read (it uses `stream.read_exact` which requires Read, not TcpStream specifically).

**G. Add sslmode URL parsing:**

Add a `parse_sslmode` helper function:

```rust
fn parse_sslmode(query_str: &str) -> SslMode {
    for param in query_str.split('&') {
        if let Some(value) = param.strip_prefix("sslmode=") {
            return match value {
                "disable" => SslMode::Disable,
                "require" => SslMode::Require,
                "prefer" => SslMode::Prefer,
                _ => SslMode::Prefer,
            };
        }
    }
    SslMode::Prefer
}
```

Modify `parse_pg_url` to split off query string BEFORE existing parsing. At the start, after stripping the `postgres://` or `postgresql://` prefix:

```rust
// Split off query string before parsing host/credentials
let (rest, query_str) = if let Some((r, q)) = rest.split_once('?') {
    (r, q)
} else {
    (rest, "")
};
let sslmode = parse_sslmode(query_str);
```

Then continue with existing parsing on the `rest` variable. Add `sslmode` to the returned PgUrl.

**H. Add TLS upgrade function:**

```rust
fn upgrade_to_tls(
    stream: TcpStream,
    hostname: &str,
) -> Result<StreamOwned<ClientConnection, TcpStream>, String> {
    let root_store = RootCertStore::from_iter(
        webpki_roots::TLS_SERVER_ROOTS.iter().cloned()
    );
    let config = ClientConfig::builder()
        .with_root_certificates(root_store)
        .with_no_client_auth();
    let server_name = ServerName::try_from(hostname.to_string())
        .map_err(|_| format!("invalid hostname for TLS: {}", hostname))?;
    let conn = ClientConnection::new(Arc::new(config), server_name)
        .map_err(|e| format!("TLS connection: {}", e))?;
    Ok(StreamOwned::new(conn, stream))
}
```

**I. Add SSLRequest + negotiation function:**

```rust
fn negotiate_tls(
    mut stream: TcpStream,
    hostname: &str,
    sslmode: SslMode,
) -> Result<PgStream, String> {
    if sslmode == SslMode::Disable {
        return Ok(PgStream::Plain(stream));
    }

    // SSLRequest: Int32(8) Int32(80877103) -- no message type byte
    let mut ssl_request = [0u8; 8];
    ssl_request[0..4].copy_from_slice(&8_i32.to_be_bytes());
    ssl_request[4..8].copy_from_slice(&80877103_i32.to_be_bytes());
    stream.write_all(&ssl_request)
        .map_err(|e| format!("send SSLRequest: {}", e))?;

    // Read exactly 1 byte response (CVE-2021-23222: do NOT read more)
    let mut response = [0u8; 1];
    stream.read_exact(&mut response)
        .map_err(|e| format!("read SSL response: {}", e))?;

    match response[0] {
        b'S' => {
            let tls = upgrade_to_tls(stream, hostname)?;
            Ok(PgStream::Tls(tls))
        }
        b'N' => match sslmode {
            SslMode::Require => Err("server does not support SSL".to_string()),
            SslMode::Prefer => Ok(PgStream::Plain(stream)),
            SslMode::Disable => unreachable!(),
        },
        other => Err(format!("unexpected SSL response: 0x{:02x}", other)),
    }
}
```

**J. Refactor `snow_pg_connect` to use negotiate_tls:**

After the TCP connect and timeout setting (lines 509-516 in current pg.rs), REPLACE the section that immediately sends the StartupMessage. Insert the TLS negotiation between TCP connect + timeouts and StartupMessage:

```rust
// Set read/write timeouts BEFORE TLS wrapping (StreamOwned inherits them)
let _ = stream.set_read_timeout(Some(Duration::from_secs(30)));
let _ = stream.set_write_timeout(Some(Duration::from_secs(10)));

// Negotiate TLS based on sslmode
let mut stream = match negotiate_tls(stream, &pg_url.host, pg_url.sslmode) {
    Ok(s) => s,
    Err(e) => return err_result(&format!("TLS: {}", e)),
};
```

Then the StartupMessage and everything after uses `stream` which is now a `PgStream`. Since `PgStream` implements `Write`, `stream.write_all(...)` works. Since `PgStream` is passed to `read_message`, all the `read_message(&mut stream)` calls work.

The `PgConn` creation becomes: `let conn = Box::new(PgConn { stream });` which now stores a PgStream.

**K. Update `snow_pg_close`:**

In `snow_pg_close`, the line `let _ = conn.stream.write_all(&buf);` works unchanged because `PgStream` implements `Write`.

**L. Update `snow_pg_execute` and `snow_pg_query`:**

These functions access `conn.stream` which is now `PgStream` instead of `TcpStream`. Since they call `conn.stream.write_all(...)` (Write trait) and `read_message(&mut conn.stream)` (now accepts PgStream), they compile without changes to their logic. Verify no direct TcpStream-specific methods are called on `conn.stream`.

**IMPORTANT anti-patterns to avoid:**
- Do NOT use `Box<dyn Read + Write>` -- use the PgStream enum (zero-cost dispatch)
- Do NOT read more than 1 byte after SSLRequest (CVE-2021-23222)
- Do NOT send TLS ClientHello without SSLRequest first
- Do NOT forget that timeouts must be set BEFORE TLS wrapping
- Do NOT break the existing URL parsing for URLs without `?sslmode=`
  </action>
  <verify>
1. `cargo build -p snow-rt 2>&1` -- must compile cleanly (warnings acceptable)
2. `cargo test -p snowc 2>&1 | tail -20` -- all existing tests pass (0 failures). The E2E PG test is `#[ignore]` so it does not run.
3. Manually verify with grep that:
   - `read_message` accepts `&mut PgStream` (not `&mut TcpStream`)
   - `PgConn` stores `PgStream` (not `TcpStream`)
   - `PgUrl` has `sslmode: SslMode` field
   - `negotiate_tls` function exists
   - `upgrade_to_tls` function exists
   - Default sslmode is `Prefer` when no `?sslmode=` in URL
  </verify>
  <done>PgStream enum abstracts Plain/Tls streams. read_message and all wire protocol functions work on PgStream. SSLRequest negotiation handles sslmode=disable/prefer/require. URL parser handles ?sslmode= query parameter with Prefer default. All existing tests pass. Existing v2.0 code (no sslmode param) works unchanged because Prefer falls back to plain when server declines SSL.</done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles with zero errors
2. `cargo test -p snowc` passes all tests (0 failures)
3. `grep -n "PgStream" crates/snow-rt/src/db/pg.rs` shows enum definition, Read+Write impl, usage in PgConn and read_message
4. `grep -n "SslMode" crates/snow-rt/src/db/pg.rs` shows enum definition, usage in PgUrl and negotiate_tls
5. `grep -n "install_default" crates/snow-rt/src/gc.rs` shows CryptoProvider installation in snow_rt_init
6. `grep -n "rustls" crates/snow-rt/Cargo.toml` shows direct dependency
7. `grep -n "negotiate_tls" crates/snow-rt/src/db/pg.rs` shows SSLRequest handshake function
8. Backward compatibility: URLs without `?sslmode=` default to Prefer, which tries TLS but falls back to plain -- identical observable behavior to v2.0 when connecting to a non-TLS server
</verification>

<success_criteria>
- snow-rt compiles with rustls/webpki-roots/rustls-pki-types direct deps
- snow_rt_init installs ring CryptoProvider before any Snow code runs
- PgStream enum replaces TcpStream throughout pg.rs (PgConn, read_message, all callers)
- SslMode enum with Disable/Prefer/Require variants
- parse_pg_url handles ?sslmode= query parameter, defaults to Prefer
- negotiate_tls sends SSLRequest, reads 1-byte response, upgrades or falls back per sslmode
- All existing E2E and unit tests pass (0 failures)
- No new compiler changes needed (Pg module API unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/55-postgresql-tls/55-01-SUMMARY.md`
</output>
