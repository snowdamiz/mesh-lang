---
phase: 74-associated-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-parser/src/syntax_kind.rs
  - crates/mesh-parser/src/parser/items.rs
  - crates/mesh-parser/src/ast/item.rs
autonomous: true

must_haves:
  truths:
    - "Parser accepts `type Item` inside interface bodies without error"
    - "Parser accepts `type Item = Int` inside impl bodies without error"
    - "AST exposes associated type declarations via InterfaceDef.assoc_types()"
    - "AST exposes associated type bindings via ImplDef.assoc_type_bindings()"
  artifacts:
    - path: "crates/mesh-parser/src/syntax_kind.rs"
      provides: "ASSOC_TYPE_DEF and ASSOC_TYPE_BINDING SyntaxKind variants"
      contains: "ASSOC_TYPE_DEF"
    - path: "crates/mesh-parser/src/parser/items.rs"
      provides: "parse_assoc_type_decl and parse_assoc_type_binding functions"
      contains: "parse_assoc_type_decl"
    - path: "crates/mesh-parser/src/ast/item.rs"
      provides: "AssocTypeDef and AssocTypeBinding AST nodes"
      contains: "AssocTypeDef"
  key_links:
    - from: "crates/mesh-parser/src/parser/items.rs"
      to: "crates/mesh-parser/src/syntax_kind.rs"
      via: "SyntaxKind::ASSOC_TYPE_DEF used in parser close()"
      pattern: "ASSOC_TYPE_DEF"
    - from: "crates/mesh-parser/src/ast/item.rs"
      to: "crates/mesh-parser/src/syntax_kind.rs"
      via: "ast_node! macro uses SyntaxKind"
      pattern: "ast_node.*AssocTypeDef"
---

<objective>
Add parser and AST support for associated type declarations in interface blocks (`type Item`) and associated type bindings in impl blocks (`type Item = ConcreteType`).

Purpose: This is the syntactic foundation for associated types. Without parser support, the type checker cannot see associated type declarations or bindings. This plan adds the syntax nodes, parser functions, and AST accessors needed by the type checker (Plan 02).

Output: Modified parser that accepts `type` declarations inside interface/impl blocks, with two new SyntaxKind variants and corresponding AST node types.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/74-associated-types/74-RESEARCH.md
@crates/mesh-parser/src/syntax_kind.rs
@crates/mesh-parser/src/parser/items.rs
@crates/mesh-parser/src/ast/item.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SyntaxKind variants for associated types</name>
  <files>crates/mesh-parser/src/syntax_kind.rs</files>
  <action>
Add two new composite node SyntaxKind variants for associated types. Place them near the existing INTERFACE_DEF/INTERFACE_METHOD/IMPL_DEF cluster (around line 229-233):

1. `ASSOC_TYPE_DEF` -- An associated type declaration inside an interface body (e.g., `type Item`). This is a composite node containing TYPE_KW and a NAME child.
2. `ASSOC_TYPE_BINDING` -- An associated type binding inside an impl body (e.g., `type Item = Int`). This is a composite node containing TYPE_KW, NAME, EQ, and a type expression.

Also add both variants to the `non_trivially_recursive` set (the array around line 652) alongside INTERFACE_DEF, INTERFACE_METHOD, IMPL_DEF, and TYPE_ALIAS_DEF.

IMPORTANT: Do NOT modify the keyword section or token mapping. TYPE_KW already exists. These are composite NODE kinds only (like INTERFACE_METHOD is a node kind, not a token kind).
  </action>
  <verify>
`cargo check -p mesh-parser` compiles without errors. Grep for `ASSOC_TYPE_DEF` and `ASSOC_TYPE_BINDING` in syntax_kind.rs confirms both variants exist.
  </verify>
  <done>SyntaxKind enum has ASSOC_TYPE_DEF and ASSOC_TYPE_BINDING variants, both included in the non_trivially_recursive set.</done>
</task>

<task type="auto">
  <name>Task 2: Add parser functions and AST nodes for associated types</name>
  <files>crates/mesh-parser/src/parser/items.rs, crates/mesh-parser/src/ast/item.rs</files>
  <action>
**Parser changes (items.rs):**

1. In `parse_interface_def` (line 514 loop body): Before the existing `parse_interface_method(p)` call, add a check for `TYPE_KW`. If `p.at(SyntaxKind::TYPE_KW)`, call `parse_assoc_type_decl(p)` instead of `parse_interface_method(p)`. Use an if/else:
   ```
   if p.at(SyntaxKind::TYPE_KW) {
       parse_assoc_type_decl(p);
   } else {
       parse_interface_method(p);
   }
   ```

2. Add `parse_assoc_type_decl` function: Opens a marker, advances past TYPE_KW, expects an IDENT (wrapped in NAME node), then closes with `SyntaxKind::ASSOC_TYPE_DEF`. This handles `type Item` (declaration only, no `=`).

3. In `parse_item_block_body` (line 894, used by impl blocks): This currently delegates to `parse_item_or_stmt`. The problem is that `type` at the top level would be parsed as a sum type or type alias. Instead, modify the impl body parsing. The cleanest approach: in `parse_impl_def` (line 658-661), replace the `parse_item_block_body(p)` call with an inline loop similar to `parse_interface_def`'s body loop. The loop checks: if `TYPE_KW`, call `parse_assoc_type_binding(p)`; if `FN_KW`/`DEF_KW`, call `parse_fn_def(p)`; else break/error. Wrap the loop body in a BLOCK node to match the existing impl body structure (impl bodies use a BLOCK child node per the AST's `ImplDef.methods()` which looks for FN_DEF inside BLOCK children).

4. Add `parse_assoc_type_binding` function: Opens a marker, advances past TYPE_KW, expects an IDENT (wrapped in NAME node), expects EQ token, then calls `parse_type(p)` for the concrete type, then closes with `SyntaxKind::ASSOC_TYPE_BINDING`. This handles `type Item = Int`.

IMPORTANT: The `parse_interface_method` error message currently says "expected method signature (fn)" when it encounters a non-fn/def token. The TYPE_KW check in parse_interface_def must happen BEFORE calling parse_interface_method, not inside it.

IMPORTANT: In the impl body loop, associated type bindings (`type Item = Int`) must be parsed BEFORE trying parse_fn_def, because TYPE_KW would otherwise fall through to parse_item_or_stmt which treats `type` as a sum type definition.

**AST changes (item.rs):**

1. Add `AssocTypeDef` AST node: `ast_node!(AssocTypeDef, ASSOC_TYPE_DEF)` with a `name()` method returning `Option<Name>` via `child_node`.

2. Add `AssocTypeBinding` AST node: `ast_node!(AssocTypeBinding, ASSOC_TYPE_BINDING)` with:
   - `name()` -> `Option<Name>` via `child_node`
   - `type_annotation()` -> access the type expression. Since the concrete type follows `=`, use the same pattern as TypeAliasDef -- find the TYPE_ANNOTATION child node, or alternatively collect tokens after EQ. The simplest approach: in the parser, wrap the type after `=` in a TYPE_ANNOTATION node so the existing `resolve_type_name` infrastructure works. Alternatively, provide a `type_expr()` method that returns the SyntaxNode of the type. Use the TYPE_ANNOTATION wrapper approach for consistency.

   Actually, looking at the parser more carefully: `parse_type(p)` emits a TYPE_REF node. So the binding node will contain TYPE_KW, NAME, EQ, and a TYPE_REF child. Add a method to extract the type: iterate children looking for a node that is a type reference.

3. Extend `InterfaceDef` impl block: Add `assoc_types()` method that returns `impl Iterator<Item = AssocTypeDef>` using `child_nodes(&self.syntax)`.

4. Extend `ImplDef` impl block: Add `assoc_type_bindings()` method. Since impl body is inside a BLOCK child, iterate BLOCK children looking for ASSOC_TYPE_BINDING nodes:
   ```rust
   pub fn assoc_type_bindings(&self) -> impl Iterator<Item = AssocTypeBinding> + '_ {
       self.syntax
           .children()
           .filter(|n| n.kind() == SyntaxKind::BLOCK)
           .flat_map(|block| block.children().filter_map(AssocTypeBinding::cast))
   }
   ```
   This mirrors the existing `methods()` pattern which looks for FN_DEF inside BLOCK children.
  </action>
  <verify>
`cargo check -p mesh-parser` compiles. Write a quick parser test: parse the string `interface Foo do type Item fn next(self) -> Int end` and verify the CST contains an ASSOC_TYPE_DEF node. Parse `impl Foo for Bar do type Item = Int fn next(self) -> Int do 42 end end` and verify it contains an ASSOC_TYPE_BINDING node.
  </verify>
  <done>Parser accepts `type X` in interface bodies and `type X = T` in impl bodies. AST provides InterfaceDef.assoc_types() and ImplDef.assoc_type_bindings() iterators. All existing tests pass (`cargo test -p mesh-parser`).</done>
</task>

</tasks>

<verification>
- `cargo test -p mesh-parser` -- all existing parser tests pass (zero regressions)
- `cargo check -p mesh-parser` -- clean compilation
- Parse `interface Iterator do type Item fn next(self) -> Int end` -- produces ASSOC_TYPE_DEF child
- Parse `impl Iterator for MyList do type Item = Int fn next(self) -> Int do 42 end end` -- produces ASSOC_TYPE_BINDING child
</verification>

<success_criteria>
The mesh-parser crate accepts associated type syntax in interface and impl blocks, exposes it through typed AST nodes, and all existing tests pass without regression.
</success_criteria>

<output>
After completion, create `.planning/phases/74-associated-types/74-01-SUMMARY.md`
</output>
