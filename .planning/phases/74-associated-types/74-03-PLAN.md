---
phase: 74-associated-types
plan: 03
type: execute
wave: 3
depends_on: ["74-02"]
files_modified:
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-typeck/src/lib.rs
  - tests/e2e/assoc_types.mpl
  - tests/compile_fail/assoc_type_missing.mpl
  - tests/compile_fail/assoc_type_extra.mpl
autonomous: true

must_haves:
  truths:
    - "A Mesh program with associated types compiles and runs end-to-end producing correct output"
    - "Associated types flow correctly through cross-module compilation (ExportedSymbols carries them)"
    - "MIR lowering handles trait method dispatch when methods reference associated types in their signatures"
    - "Compiler produces clear error when impl is missing an associated type"
    - "Compiler produces clear error when impl provides an extra associated type"
    - "HM inference resolves associated types through generic function calls"
  artifacts:
    - path: "tests/e2e/assoc_types.mpl"
      provides: "End-to-end test for associated types"
      contains: "type Item"
    - path: "tests/compile_fail/assoc_type_missing.mpl"
      provides: "Compile-fail test for missing associated type"
      contains: "type Item"
    - path: "tests/compile_fail/assoc_type_extra.mpl"
      provides: "Compile-fail test for extra associated type"
      contains: "type Item"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "MIR reads TraitRegistry to resolve associated types during dispatch"
      pattern: "associated_types|resolve_associated_type"
    - from: "crates/mesh-typeck/src/lib.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "ExportedSymbols carries TraitDef/ImplDef with associated_types field"
      pattern: "trait_defs|trait_impls"
---

<objective>
Wire associated types through MIR lowering and codegen, ensure cross-module exports work, and write comprehensive E2E and compile-fail tests covering all five ASSOC requirements.

Purpose: Plans 01 and 02 added parsing and type-checking for associated types. This plan ensures they work end-to-end: programs compile, run, and produce correct output. It also validates the error paths and ensures cross-module export works.

Output: A fully working associated types feature with E2E tests and compile-fail tests covering ASSOC-01 through ASSOC-05.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/74-associated-types/74-RESEARCH.md
@.planning/phases/74-associated-types/74-01-SUMMARY.md
@.planning/phases/74-associated-types/74-02-SUMMARY.md
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/mir/types.rs
@crates/mesh-typeck/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ensure MIR lowering and cross-module export handle associated types</name>
  <files>crates/mesh-codegen/src/mir/lower.rs, crates/mesh-typeck/src/lib.rs</files>
  <action>
**Cross-module export (lib.rs):**

Verify that `ExportedSymbols` (lib.rs line 107-109) correctly carries the extended `TraitDef` and `ImplDef` structs with their `associated_types` fields. Since `ExportedSymbols.trait_defs: Vec<TraitDef>` and `ExportedSymbols.trait_impls: Vec<TraitImplDef>` already clone these structs, and Plan 02 added `associated_types` as a field ON the structs (not in a separate map), the export pipeline should work automatically. Confirm by reading the code path: TraitRegistry -> ExportedSymbols -> ImportContext -> downstream TraitRegistry.

If for any reason the `ExportedSymbols` construction strips or ignores associated types, fix it. The typical pattern is that `ExportedSymbols` is built from the `TraitRegistry`'s stored `TraitDef`s and `ImplDef`s, so fields on those structs propagate automatically.

**MIR lowering (lower.rs):**

The MIR lowerer resolves trait method calls by constructing mangled names like `Trait__method__Type`. Associated types affect this in two ways:

1. **Method return types:** When the MIR lowerer processes a trait method call and the method's return type was `Self.Item`, it needs to use the concrete type. Since Plan 02 already resolves `Self.Item` eagerly in the type checker (before MIR), the types map (`FxHashMap<TextRange, Ty>`) already contains the concrete resolved type. The MIR lowerer reads from this types map. Verify that no additional changes are needed -- if the type checker resolved `Self.Item` -> `String`, the MIR lowerer sees `String` and mangles correctly.

2. **Name mangling:** For Phase 74, the associated types do NOT affect name mangling directly. The mangled name is based on the implementing type (e.g., `Iterator__next__ListIter_Int`), not on the associated type binding. Two different types implementing the same trait with different associated type bindings already have different implementing types, so their mangled names differ. Name mangling changes are NOT needed in Phase 74.

   Exception: if two different GENERIC impls produce the same mangled name but different associated type bindings (unlikely for Phase 74 use cases), this could be a problem. For now, skip mangling changes -- the research notes this as Pitfall 4 but acknowledges it only matters "when associated types affect the function's behavior." Since Phase 74 is foundational, this is deferred.

3. **Skipping associated type bindings in impl body lowering:** The MIR lowerer iterates through items in impl block bodies looking for FN_DEF nodes. After Plan 01, impl bodies may also contain ASSOC_TYPE_BINDING nodes. The MIR lowerer must skip these (they are declarative, not executable). Verify that the MIR lowerer's iteration pattern (filtering for FN_DEF) already ignores unknown node types. If it uses a match/filter on SyntaxKind::FN_DEF, ASSOC_TYPE_BINDING nodes are automatically skipped. If it iterates ALL children, add a filter.

Search `lower.rs` for where it processes impl block bodies (look for IMPL_DEF handling, trait method lowering, or iteration over impl items). Ensure ASSOC_TYPE_BINDING nodes are safely ignored.

Also check `parse_item_block_body` usage path -- since the parser wraps impl body in a BLOCK node with FN_DEF and ASSOC_TYPE_BINDING children, and the MIR lowerer only looks for FN_DEF children (matching ImplDef.methods() AST accessor), it should already skip bindings.

CRITICAL: Do not over-engineer this task. The key insight from the research is "every projection must normalize before MIR." Plan 02's eager normalization ensures this. The MIR lowerer should Just Work with resolved types.
  </action>
  <verify>
`cargo check` -- full workspace compiles. Write a simple test program that declares an interface with `type Item`, implements it, and calls a method that returns `Self.Item`. Compile and run it: the method should return the concrete type's value.
  </verify>
  <done>Cross-module export correctly carries associated types in TraitDef/ImplDef. MIR lowering skips ASSOC_TYPE_BINDING nodes and uses eagerly-resolved types from the type checker. Full workspace compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive E2E and compile-fail tests</name>
  <files>tests/e2e/assoc_types.mpl, tests/compile_fail/assoc_type_missing.mpl, tests/compile_fail/assoc_type_extra.mpl</files>
  <action>
**E2E test (tests/e2e/assoc_types.mpl):**

Write a Mesh program that exercises all happy-path associated type features:

1. **ASSOC-01 + ASSOC-02:** Declare an interface with an associated type and implement it:
   ```mesh
   interface Container do
     type Item
     fn first(self) -> Self.Item
   end

   struct IntBox do
     value :: Int
   end

   impl Container for IntBox do
     type Item = Int
     fn first(self) -> Int do
       self.value
     end
   end
   ```

2. **ASSOC-03:** Reference Self.Item in method signatures and have it resolve correctly:
   ```mesh
   fn main() do
     let box = IntBox { value: 42 }
     let result = box.first()
     IO.puts(Int.to_string(result))  # Should print "42"
   end
   ```

3. **ASSOC-04:** Test that HM inference resolves associated types through generic calls. Define a generic function that takes a Container and calls first():
   ```mesh
   fn get_first<T>(c :: T) -> Int where T: Container do
     c.first()
   end
   ```
   (Note: the return type must be annotated since we don't yet have `T.Item` projection in generic signatures. The inference resolves when the generic is instantiated with a concrete type.)

4. Also test with String associated type to verify it's not hardcoded:
   ```mesh
   struct StringBox do
     value :: String
   end

   impl Container for StringBox do
     type Item = String
     fn first(self) -> String do
       self.value
     end
   end
   ```

The test should print expected values. Follow the existing E2E test pattern -- look at a recent E2E test like `tests/e2e/adts.mpl` for the expected structure.

**Compile-fail test (tests/compile_fail/assoc_type_missing.mpl):**

Write a program where an impl is missing a required associated type:
```mesh
interface HasItem do
  type Item
  fn get(self) -> Self.Item
end

struct Foo do end

impl HasItem for Foo do
  fn get(self) -> Int do
    42
  end
end
# Missing: type Item = Int
# Expected error: impl `HasItem` for `Foo` is missing associated type `Item`
```

**Compile-fail test (tests/compile_fail/assoc_type_extra.mpl):**

Write a program where an impl provides an associated type the trait doesn't declare:
```mesh
interface Simple do
  fn name(self) -> String
end

struct Bar do end

impl Simple for Bar do
  type Item = Int  # Extra -- Simple doesn't declare type Item
  fn name(self) -> String do
    "bar"
  end
end
# Expected error: impl `Simple` for `Bar` provides associated type `Item` which is not declared by the trait
```

**Run the test suite:**

After writing the tests, run:
- `cargo test` -- full test suite including new E2E tests
- Verify the E2E test produces correct output
- Verify compile-fail tests are detected as compilation failures (check how existing compile_fail tests work -- they may use a test harness that expects specific error messages, or they may just verify non-zero exit code)

Check how compile_fail tests are integrated. Look at the test runner in `crates/snowc/` or the workspace-level test configuration to understand the pattern. Follow that exact pattern for the new tests.

IMPORTANT: Keep the E2E test simple but comprehensive. Each test case should exercise one specific aspect of associated types. Use IO.puts to verify output so the test runner can compare actual vs expected.
  </action>
  <verify>
`cargo test` passes -- all new tests pass, all existing tests pass. The E2E test compiles, runs, and produces expected output. The compile-fail tests produce the expected error messages. Zero regressions across the full test suite.
  </verify>
  <done>E2E test demonstrates interface with `type Item`, impl with `type Item = Int`, Self.Item resolution, and method dispatch returning the concrete associated type. Compile-fail tests verify MissingAssocType and ExtraAssocType errors. All 5 ASSOC requirements (ASSOC-01 through ASSOC-05) are covered by tests. Full test suite passes.</done>
</task>

</tasks>

<verification>
- `cargo test` -- full suite passes, including new associated type tests
- `cargo build` -- compiler binary builds clean
- E2E test: `./target/debug/meshc run tests/e2e/assoc_types.mpl` produces expected output
- Compile-fail: `./target/debug/meshc check tests/compile_fail/assoc_type_missing.mpl` exits non-zero with MissingAssocType
- Compile-fail: `./target/debug/meshc check tests/compile_fail/assoc_type_extra.mpl` exits non-zero with ExtraAssocType
- No regressions in any existing E2E, compile-fail, or unit tests
</verification>

<success_criteria>
Associated types work end-to-end: declaration, binding, resolution, method dispatch, and error reporting. All 5 ASSOC requirements are satisfied and verified by automated tests. The feature is ready for downstream phases (75-79) to build upon.
</success_criteria>

<output>
After completion, create `.planning/phases/74-associated-types/74-03-SUMMARY.md`
</output>
