---
phase: 74-associated-types
plan: 02
type: execute
wave: 2
depends_on: ["74-01"]
files_modified:
  - crates/mesh-typeck/src/traits.rs
  - crates/mesh-typeck/src/error.rs
  - crates/mesh-typeck/src/infer.rs
autonomous: true

must_haves:
  truths:
    - "TraitDef stores associated type declarations from interface definitions"
    - "ImplDef stores associated type bindings from impl blocks"
    - "register_impl validates missing and extra associated types, producing clear errors"
    - "Self.Item in method signatures resolves to the concrete type from the impl's associated type bindings"
    - "freshen_type_params handles multi-character type parameter names (not just single-letter A-Z)"
    - "Compiler infers associated type projections through generic function calls"
  artifacts:
    - path: "crates/mesh-typeck/src/traits.rs"
      provides: "AssocTypeDef struct, extended TraitDef/ImplDef, resolve_associated_type, extended freshen_type_params"
      contains: "associated_types"
    - path: "crates/mesh-typeck/src/error.rs"
      provides: "MissingAssocType and ExtraAssocType error variants"
      contains: "MissingAssocType"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Associated type collection in infer_interface_def/infer_impl_def, Self.Item resolution"
      contains: "assoc_type"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "TraitDef and ImplDef struct construction with associated_types field"
      pattern: "associated_types"
    - from: "crates/mesh-typeck/src/traits.rs"
      to: "crates/mesh-typeck/src/error.rs"
      via: "register_impl emits MissingAssocType/ExtraAssocType errors"
      pattern: "MissingAssocType|ExtraAssocType"
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "resolve_associated_type called during Self.Item resolution"
      pattern: "resolve_associated_type"
---

<objective>
Extend the type checker to support associated types: store them in TraitDef/ImplDef, validate bindings at registration, resolve Self.Item references, and fix freshen_type_params for multi-character names.

Purpose: This is the semantic core of associated types. The parser (Plan 01) provides syntax; this plan provides meaning. After this plan, the compiler understands associated type declarations, validates impl completeness, and resolves Self.Item to concrete types during inference.

Output: A type checker that correctly handles associated types through the trait registry, with clear error messages for missing/extra bindings.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/74-associated-types/74-RESEARCH.md
@.planning/phases/74-associated-types/74-01-SUMMARY.md
@crates/mesh-typeck/src/traits.rs
@crates/mesh-typeck/src/error.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-typeck/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TraitDef/ImplDef and add validation + error variants</name>
  <files>crates/mesh-typeck/src/traits.rs, crates/mesh-typeck/src/error.rs</files>
  <action>
**error.rs changes:**

Add three new TypeError variants:

1. `MissingAssocType { trait_name: String, assoc_name: String, impl_ty: String }` -- an impl block is missing a required associated type declared by the trait. Error message: "impl `{trait_name}` for `{impl_ty}` is missing associated type `{assoc_name}`".

2. `ExtraAssocType { trait_name: String, assoc_name: String, impl_ty: String }` -- an impl block provides an associated type not declared by the trait. Error message: "impl `{trait_name}` for `{impl_ty}` provides associated type `{assoc_name}` which is not declared by the trait".

3. `UnresolvedAssocType { assoc_name: String, span: TextRange }` -- an associated type reference (Self.Item) could not be resolved. Error message: "cannot resolve associated type `{assoc_name}` -- Self.Item can only be used inside an impl block".

Add Display impls for all three following the existing pattern in error.rs (look at MissingTraitMethod's Display impl for the pattern).

**traits.rs changes:**

1. Add `AssocTypeDef` struct (near line 30, after TraitMethodSig):
   ```rust
   #[derive(Clone, Debug)]
   pub struct AssocTypeDef {
       pub name: String,
   }
   ```

2. Extend `TraitDef` struct: Add `pub associated_types: Vec<AssocTypeDef>` field after `methods`.

3. Extend `ImplDef` struct: Add `pub associated_types: FxHashMap<String, Ty>` field after `methods`.

4. In `register_impl` (line 97-157): After the existing method validation loop (lines 103-131), add associated type validation. This goes INSIDE the `if let Some(trait_def)` block:
   - Check for missing associated types: for each `assoc` in `trait_def.associated_types`, if `impl_def.associated_types` does not contain the name, push `TypeError::MissingAssocType`.
   - Check for extra associated types: for each `(name, _)` in `impl_def.associated_types`, if no `trait_def.associated_types` entry has that name, push `TypeError::ExtraAssocType`.

5. Add `resolve_associated_type` method to `TraitRegistry`:
   ```rust
   pub fn resolve_associated_type(
       &self,
       trait_name: &str,
       assoc_name: &str,
       impl_ty: &Ty,
   ) -> Option<Ty> {
       let impl_def = self.find_impl(trait_name, impl_ty)?;
       impl_def.associated_types.get(assoc_name).cloned()
   }
   ```

6. Fix `freshen_type_params` (line 333): Change the function signature to accept an optional slice of explicit type parameter names:
   ```rust
   fn freshen_type_params(ty: &Ty, ctx: &mut InferCtx) -> Ty {
       freshen_type_params_with_names(ty, ctx, &[])
   }

   fn freshen_type_params_with_names(ty: &Ty, ctx: &mut InferCtx, type_param_names: &[String]) -> Ty {
       let mut param_map: FxHashMap<String, Ty> = FxHashMap::default();
       freshen_recursive(ty, ctx, &mut param_map, type_param_names)
   }
   ```
   Then extend `freshen_recursive` to accept `type_param_names: &[String]` and add a second condition in the `Ty::Con` match arm:
   ```rust
   Ty::Con(c) => {
       if (c.name.len() == 1 && c.name.as_bytes()[0].is_ascii_uppercase())
           || type_param_names.iter().any(|n| n == &c.name)
       {
           param_map.entry(c.name.clone()).or_insert_with(|| ctx.fresh_var()).clone()
       } else {
           ty.clone()
       }
   }
   ```
   This keeps backward compatibility (all existing callers use `freshen_type_params` with empty names) while enabling multi-char freshening when needed.

7. Update all existing code that constructs `TraitDef` to include `associated_types: vec![]` and all code that constructs `ImplDef` to include `associated_types: FxHashMap::default()`. This includes:
   - All test helper functions in the `#[cfg(test)] mod tests` block
   - The `register_trait` and `register_impl` calls don't need changes (they take the whole struct)

CRITICAL: Do NOT modify unify.rs. Do NOT add a Ty::Projection variant. Associated types use eager normalization only.
  </action>
  <verify>
`cargo check -p mesh-typeck` compiles. `cargo test -p mesh-typeck` passes (all existing trait registry tests still work with the added `associated_types` field). Verify that the new `resolve_associated_type` method exists.
  </verify>
  <done>TraitDef has associated_types field, ImplDef has associated_types field, register_impl validates missing/extra associated types, three new TypeError variants exist with Display impls, resolve_associated_type method works, freshen_type_params extended for multi-char names. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire associated types through inference (infer_interface_def, infer_impl_def, Self.Item resolution)</name>
  <files>crates/mesh-typeck/src/infer.rs</files>
  <action>
**Extend infer_interface_def (line 2677):**

After collecting methods (the `for method in iface.methods()` loop), add a loop to collect associated type declarations from the AST:

```rust
let mut associated_types = Vec::new();
for assoc in iface.assoc_types() {
    if let Some(name) = assoc.name().and_then(|n| n.text()) {
        associated_types.push(crate::traits::AssocTypeDef { name });
    }
}
```

Then pass `associated_types` into the TraitDef construction (line 2738):
```rust
trait_registry.register_trait(TraitDef {
    name: trait_name,
    methods,
    associated_types,  // NEW
});
```

**Extend infer_impl_def (line 2745):**

1. After collecting methods (the `for method in impl_.methods()` loop), add associated type binding collection. Use the AST accessor from Plan 01:

```rust
let mut assoc_types = FxHashMap::default();
for binding in impl_.assoc_type_bindings() {
    if let Some(name) = binding.name().and_then(|n| n.text()) {
        // Resolve the concrete type from the binding's type expression
        // Use the same approach as method return types
        let concrete_ty = /* extract type from binding */;
        assoc_types.insert(name, concrete_ty);
    }
}
```

For extracting the concrete type from the binding: the ASSOC_TYPE_BINDING node contains a type after `=`. Use `resolve_type_name` on the binding's type annotation child, or walk the binding's syntax children to find the type tokens and use the existing type parsing infrastructure. The simplest approach: the binding node from Plan 01 should have a TYPE_ANNOTATION child (if the parser wraps the type in one) or a TYPE_REF child. Check what Plan 01 actually emitted and adapt. If the parser emits a bare type (from `parse_type`), collect tokens from the binding node after the EQ token and pass them through the type resolution pipeline.

The most pragmatic approach: iterate the binding's syntax children, find all IDENT tokens after the EQ token, and call `name_to_type` on the concatenated type name. This handles simple types (Int, String, T, etc.) and can be extended later for generic types.

2. Pass `assoc_types` into the ImplDef construction (around line 2887):
```rust
let errors = trait_registry.register_impl(TraitImplDef {
    trait_name,
    impl_type,
    impl_type_name,
    methods: impl_methods,
    associated_types: assoc_types,  // NEW
});
```

**Self.Item resolution in method body inference:**

When inferring method bodies inside `infer_impl_def`, the compiler encounters type annotations like `Self.Item`. Currently, `resolve_type_name` handles simple types. For Self.Item:

1. In the method body inference section of `infer_impl_def` (around line 2826-2870), before inferring each method body, make the current impl's associated type bindings available. The cleanest approach: when resolving type annotations in method parameter types and return types, check if the type name is of the form "Self.X" (a field access on Self). If so, look up X in the impl's `assoc_types` map.

2. Specifically, modify the return type resolution for impl methods: after `let return_type = method.return_type().and_then(|ann| resolve_type_name(&ann));` (line 2814), add Self.Item substitution. Check if the resolved type is a `Ty::Con` whose name starts with "Self." -- but actually, `resolve_type_name` won't parse dot-separated names. Instead, examine the TYPE_ANNOTATION syntax tree for a field-access pattern (IDENT "Self" DOT IDENT "Item").

The practical approach: Extend the type annotation resolution to handle `Self.X` patterns. In the TYPE_ANNOTATION, if we see tokens [SELF_KW, DOT, IDENT], treat this as an associated type reference. Look up the IDENT in the current impl's associated type bindings. If found, return that type. If not found, emit UnresolvedAssocType error.

To make this work, add a helper:
```rust
fn resolve_self_assoc_type(
    ann: &TypeAnnotation,
    assoc_types: &FxHashMap<String, Ty>,
) -> Option<Ty> {
    // Look for Self.X pattern in annotation tokens
    let tokens: Vec<_> = ann.syntax()
        .children_with_tokens()
        .filter_map(|t| t.into_token())
        .collect();
    // Check for [SELF_KW, DOT, IDENT] pattern
    // ... return assoc_types.get(ident_name).cloned()
}
```

Call this helper before the standard `resolve_type_name` call for method return types and parameter types inside infer_impl_def. If it returns Some, use that type. If None, fall back to resolve_type_name.

3. Also handle Self.Item in method parameter type annotations (line 2842-2845): apply the same substitution.

**Update all existing TraitImplDef constructions in infer.rs:**

Search for all `TraitImplDef {` constructions in the file (there are many -- deriving impls for Debug, Eq, Ord, Hash, Display, ToJson, FromJson, FromRow, etc.). Add `associated_types: FxHashMap::default()` to each one. There are approximately 15+ construction sites. Use the import at the top of the file (line 37) which already imports `ImplDef as TraitImplDef`.

CRITICAL: The Self.Item resolution must ONLY work inside impl blocks. If Self.Item is referenced outside an impl block, the resolution simply doesn't fire (returns None), and the standard type resolution will produce an unbound type error, which is the correct behavior.

CRITICAL: Do NOT modify unify.rs or ty.rs. All resolution is eager -- concrete types only enter the unification table.
  </action>
  <verify>
`cargo check -p mesh-typeck` compiles. `cargo test -p mesh-typeck` passes. Write a Mesh test program:
```
interface Foo do
  type Item
  fn get(self) -> Self.Item
end

impl Foo for Int do
  type Item = String
  fn get(self) -> String do
    "hello"
  end
end
```
Compile with `cargo run -- check test.mpl` (or equivalent) and verify no errors.
  </verify>
  <done>infer_interface_def collects associated type declarations into TraitDef. infer_impl_def collects associated type bindings into ImplDef. Self.Item in method signatures resolves to the concrete type from the impl. Missing/extra associated type validation works. All existing deriving impls compile with empty associated_types. All existing tests pass.</done>
</task>

</tasks>

<verification>
- `cargo test -p mesh-typeck` -- all existing tests pass (zero regressions)
- `cargo check` -- full workspace compiles clean
- Test program with `interface Foo do type Item end` + `impl Foo for Int do type Item = String end` compiles
- Test program with missing associated type in impl produces MissingAssocType error
- Test program with extra associated type in impl produces ExtraAssocType error
</verification>

<success_criteria>
The type checker correctly stores, validates, and resolves associated types. TraitDef and ImplDef carry associated type information. Self.Item references resolve eagerly to concrete types. Clear error messages for missing/extra bindings. All 93K+ lines of existing Rust code compile without regression.
</success_criteria>

<output>
After completion, create `.planning/phases/74-associated-types/74-02-SUMMARY.md`
</output>
