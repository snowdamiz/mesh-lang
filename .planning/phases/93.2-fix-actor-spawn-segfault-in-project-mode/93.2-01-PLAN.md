---
phase: 93.2-fix-actor-spawn-segfault-in-project-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-codegen/src/mir/lower.rs
  - tests/e2e/actors_with_args.mpl
  - crates/meshc/tests/e2e_actors.rs
autonomous: true

must_haves:
  truths:
    - "Actors spawned with arguments receive the correct argument values, not raw buffer pointers"
    - "Actors spawned with zero arguments continue to work (no regression)"
    - "Actors with tail-call recursion and arguments work correctly (TCE targets body, not wrapper)"
    - "Mesher project compiles and actors with arguments do not segfault at runtime"
  artifacts:
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Actor wrapper function generation in lower_actor_def"
      contains: "__actor_.*_body"
    - path: "tests/e2e/actors_with_args.mpl"
      provides: "E2E test fixture for actors spawned with arguments"
      contains: "actor.*counter.*initial"
    - path: "crates/meshc/tests/e2e_actors.rs"
      provides: "Rust test case invoking actors_with_args fixture"
      contains: "actors_with_args"
  key_links:
    - from: "lower_actor_def (MIR)"
      to: "codegen_actor_spawn (LLVM)"
      via: "Actor wrapper accepts Ptr and loads args at 8-byte offsets, matching spawn serialization"
      pattern: "MirType::Ptr.*__args_ptr"
    - from: "rewrite_tail_calls"
      to: "__actor_{name}_body"
      via: "TCE rewrites target the body function name, not the wrapper"
      pattern: "rewrite_tail_calls.*body"
---

<objective>
Fix the ABI mismatch that causes actors with arguments to segfault when spawned.

Purpose: The runtime calls actor entry functions with signature `extern "C" fn(*const u8)`, passing a pointer to a serialized args buffer. But actors are compiled with their actual parameter types (e.g., `fn health_checker(pool: i64)`), causing the raw pointer to be interpreted as the first argument value. This is a segfault for any actor with parameters.

Output: Modified `lower_actor_def()` that generates a wrapper function accepting `Ptr` and deserializing args before calling the actual actor body. New e2e tests for actors with arguments. All existing actor tests still pass.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/93.2-fix-actor-spawn-segfault-in-project-mode/93.2-RESEARCH.md
@crates/mesh-codegen/src/mir/lower.rs (lines 8477-8582 for lower_actor_def, lines 9450-9466 for service loop pattern)
@crates/mesh-codegen/src/codegen/expr.rs (lines 1946-2020 for codegen_actor_spawn, lines 3146-3205 for codegen_service_loop deserialization)
@crates/meshc/tests/e2e_actors.rs
@tests/e2e/actors_basic.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate actor wrapper function in lower_actor_def</name>
  <files>crates/mesh-codegen/src/mir/lower.rs</files>
  <action>
Modify `lower_actor_def()` (line 8477) to generate TWO functions when the actor has parameters, instead of one:

**1. Actor body function: `__actor_{name}_body`**
- Contains the actual actor logic (the current `body` expression)
- Has the original typed parameters (e.g., `pool: Int`)
- TCE (`rewrite_tail_calls`) targets THIS function name, since recursive calls like `health_checker(pool)` call back into the body with typed args
- Note: `rewrite_tail_calls` must be called with `__actor_{name}_body` as the target name, NOT the original `name`

**2. Actor wrapper function: `{name}` (keeps original name)**
- Accepts a single parameter: `("__args_ptr", MirType::Ptr)`
- The body should load each argument from the args buffer at 8-byte offsets and call `__actor_{name}_body` with the loaded values
- Use `MirExpr::PtrLoad` or equivalent MIR nodes to represent the deserialization. Since MIR does not have raw pointer field access, use the same approach as services: give the wrapper `MirExpr::Unit` as body and let codegen handle it via naming convention detection (function name pattern matching)

**Concrete approach (following service loop pattern):**

For actors WITH parameters (params.len() > 0):
1. Rename the body function to `__actor_{name}_body`
2. Run `rewrite_tail_calls(&mut body, &body_fn_name)` where `body_fn_name = format!("__actor_{}_body", name)` -- this ensures self-recursive tail calls target the body
3. Push the body function with `name: body_fn_name`, original typed params, the body, and `has_tail_calls` from rewrite
4. Register the body function in `known_functions` so codegen can find it
5. Push a wrapper function with `name: name` (original name), params `[("__args_ptr", MirType::Ptr)]`, body `MirExpr::Unit`, `has_tail_calls: false`
6. Register the wrapper in `known_functions` with `FnPtr(vec![Ptr], Unit)` so spawn references resolve correctly

For actors WITHOUT parameters (params.len() == 0):
- Keep existing behavior unchanged (single function, no wrapper needed). The runtime passes null as args_ptr which is harmlessly ignored.

**Codegen detection (in `crates/mesh-codegen/src/codegen/mod.rs`, `compile_function`):**
Add a check similar to the service loop detection at line 460:
```
if func.name.starts_with("__actor_") && func.name.ends_with("_body") {
    // This is an actor body, compile normally (it has typed params)
}
// No special handling needed for body functions -- they compile normally

// For wrapper functions: detect actor wrappers by checking if a matching
// __actor_{name}_body function exists in the module
```

Actually, the simpler approach: the wrapper function has `body: MirExpr::Unit` and params `[("__args_ptr", MirType::Ptr)]`. In `compile_function`, AFTER the service loop check, add a check for actor wrappers:

```rust
// Check if this is an actor wrapper function that needs arg deserialization.
// Actor wrappers have __args_ptr param and a matching __actor_{name}_body function.
let actor_body_name = format!("__actor_{}_body", func.name);
if func.params.len() == 1
    && func.params[0].0 == "__args_ptr"
    && func.params[0].1 == MirType::Ptr
    && self.functions.contains_key(&actor_body_name) {
    return self.codegen_actor_wrapper(&func.name, &actor_body_name);
}
```

Then implement `codegen_actor_wrapper` in `codegen/expr.rs` (or a new method on the codegen struct):
1. Get the `__actor_{name}_body` LLVM function from `self.functions`
2. Load `__args_ptr` parameter
3. For each parameter of the body function, load the value at offset `i * 8` from args_ptr (using GEP on `[N x i64]` array type, same as `codegen_actor_spawn` serialization)
4. If param type is pointer: use `inttoptr`; if int: use directly; if struct: load from pointer
5. Call the body function with loaded args
6. Build return (Unit)

**Important edge cases:**
- The terminate callback (`__terminate_{name}`) does NOT need a wrapper -- it already accepts `(Ptr, Ptr)` and is called directly by the runtime with the correct signature
- The `known_functions` entry for the wrapper must use `FnPtr(vec![Ptr], Unit)` so that `codegen_actor_spawn` emits the correct function pointer type
- Actor names in spawn expressions reference the wrapper (original name), which is correct since the wrapper keeps the original name
  </action>
  <verify>
Run `cargo build -p mesh-codegen` to verify the MIR lowering and codegen changes compile. Then run existing actor tests:
```bash
cargo test -p meshc --test e2e_actors -- --test-threads=1
```
All 8 existing tests (actors_basic, actors_messaging, actors_preemption, actors_linking, actors_typed_pid, actors_100k, actors_terminate, gc_bounded_memory) must pass. Zero-arg actors should be completely unaffected.
  </verify>
  <done>lower_actor_def generates a Ptr-accepting wrapper for actors with parameters, while actors without parameters remain unchanged. All existing actor e2e tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add e2e test for actors with arguments and verify Mesher builds</name>
  <files>tests/e2e/actors_with_args.mpl, crates/meshc/tests/e2e_actors.rs</files>
  <action>
**Create test fixture `tests/e2e/actors_with_args.mpl`:**

```mesh
# Test: actors spawned with arguments receive correct values.
# Covers single-arg, multi-arg, and recursive (TCE) actors with args.

actor counter(initial :: Int) do
  receive do
    msg ->
      let next = initial + msg
      println(next)
      counter(next)
  end
end

actor adder(a :: Int, b :: Int) do
  let sum = a + b
  println(sum)
end

fn main() do
  # Single-arg actor: initial value 10, send 5, expect 15 printed
  let pid = spawn(counter, 10)
  send(pid, 5)

  # Multi-arg actor: 30 + 12 = 42
  spawn(adder, 30, 12)

  Timer.sleep(200)
  println("args test done")
end
```

Key test behaviors:
- `counter(10)` receives message `5`, computes `10 + 5 = 15`, prints `15`, then tail-calls `counter(15)` (TCE)
- `adder(30, 12)` computes `30 + 12 = 42`, prints `42`
- Note: `Timer.sleep(200)` gives actors time to process. If the runtime imports are needed, adjust (the existing actor tests use `println` which works).

**Add test case in `crates/meshc/tests/e2e_actors.rs`:**

After the existing `actors_terminate` test, add:

```rust
/// Test 9: Actors with arguments -- spawn passes initial state correctly.
/// Actors receive typed arguments, not raw buffer pointers.
#[test]
fn actors_with_args() {
    let source = read_fixture("actors_with_args.mpl");
    let output = compile_and_run_with_timeout(&source, 10);
    assert!(
        output.contains("15"),
        "Expected '15' (counter 10 + msg 5) in output, got: {}",
        output
    );
    assert!(
        output.contains("42"),
        "Expected '42' (adder 30 + 12) in output, got: {}",
        output
    );
    assert!(
        output.contains("args test done"),
        "Expected 'args test done' in output, got: {}",
        output
    );
}
```

**Run the complete test suite:**
```bash
cargo test -p meshc --test e2e_actors -- --test-threads=1
```

All 9 tests must pass (8 existing + 1 new).

**Build Mesher project to verify no segfault:**
```bash
cd mesher && cargo run -p meshc -- build .
```

The Mesher project should compile cleanly. While we cannot run it without a PostgreSQL database, confirming it compiles without codegen errors proves the wrapper generation works for real-world actors.

If the test fixture needs adjustment (e.g., Timer.sleep not available without import, or the exact Mesh syntax for Int type annotations differs), adapt to match the language's actual syntax. Refer to existing test fixtures in `tests/e2e/` for the correct patterns.
  </action>
  <verify>
```bash
cargo test -p meshc --test e2e_actors -- --test-threads=1
```
All 9 tests pass. The `actors_with_args` test prints `15`, `42`, and `args test done`.

```bash
cargo run -p meshc -- build mesher
```
Mesher project compiles cleanly (exit code 0).
  </verify>
  <done>New e2e test confirms actors with single and multiple arguments work correctly. Mesher project compiles without codegen errors from actor wrapper generation.</done>
</task>

</tasks>

<verification>
1. `cargo test -p meshc --test e2e_actors -- --test-threads=1` -- all 9 tests pass (8 existing + 1 new)
2. `cargo build -p mesh-codegen` -- codegen crate compiles cleanly
3. `cargo run -p meshc -- build mesher` -- Mesher project compiles without errors
4. The `actors_with_args` test specifically validates that argument values (10+5=15, 30+12=42) are received correctly, not as raw pointer addresses
</verification>

<success_criteria>
- Actors with arguments receive correct typed values when spawned
- Zero-argument actors continue to work unchanged (no regression)
- Tail-call elimination works for recursive actors with arguments
- Mesher project compiles cleanly with all 5 parameterized actors
- New e2e test validates single-arg and multi-arg actor spawn
</success_criteria>

<output>
After completion, create `.planning/phases/93.2-fix-actor-spawn-segfault-in-project-mode/93.2-01-SUMMARY.md`
</output>
