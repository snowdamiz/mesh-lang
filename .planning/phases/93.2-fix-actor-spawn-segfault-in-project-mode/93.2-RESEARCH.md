# Phase 93.2 Research: Fix actor spawn segfault in project mode

## Objective

Answer: "What do I need to know to PLAN this phase well?"

## Root Cause Analysis

### The Bug: ABI Mismatch Between Spawn and Actor Entry Function

The segfault is caused by a **calling convention mismatch** between how `mesh_actor_spawn` calls the actor entry function and how the actor function is compiled.

**The spawn side** (codegen in `codegen_actor_spawn`, `crates/mesh-codegen/src/codegen/expr.rs:1946`):
1. Serializes actor arguments into a heap-allocated `*const u8` buffer (each arg stored as i64 at 8-byte offsets)
2. Calls `mesh_actor_spawn(fn_ptr, args_ptr, args_size, priority)`

**The runtime side** (`crates/mesh-rt/src/actor/mod.rs:131` and `crates/mesh-rt/src/actor/stack.rs:126`):
1. `mesh_actor_spawn` enqueues a `SpawnRequest { fn_ptr, args_ptr, ... }`
2. A worker thread creates a coroutine that calls `func(args as *const u8)` via `std::mem::transmute::<usize, extern "C" fn(*const u8)>(fn_ptr)`
3. The entry function is expected to have signature `extern "C" fn(args: *const u8)`

**The actor definition side** (MIR lowering in `lower_actor_def`, `crates/mesh-codegen/src/mir/lower.rs:8477`):
1. The actor function is compiled with its **actual parameter types** (e.g., `fn retention_cleaner(pool: i64) -> {}`)
2. There is NO wrapper function that accepts `*const u8` and deserializes the args

**Result**: When the runtime calls `retention_cleaner(args_buffer_ptr)`, the function receives the raw pointer value as its `pool` parameter. This pointer-as-integer is NOT a valid PoolHandle -- it's the address of the args buffer. When the actor tries to use this value for DB operations, it segfaults.

### LLVM IR Evidence

Generated actor function (wrong -- takes i64, not ptr):
```llvm
define {} @health_checker(i64 %0) {
  ; %0 is treated as pool handle, but it's actually a raw pointer to args buffer!
  ...
}
```

Generated spawn call (correctly serializes args to buffer):
```llvm
%spawn_args29 = call ptr @mesh_gc_alloc_actor(i64 8, i64 8)
%arg_ptr30 = getelementptr [1 x i64], ptr %spawn_args29, i32 0, i32 0
store i64 %pool28, ptr %arg_ptr30, align 4          ; serialize pool value into buffer
%pid31 = call i64 @mesh_actor_spawn(ptr @health_checker, ptr %spawn_args29, i64 8, i8 1)
```

For comparison, service loop functions do this correctly:
```llvm
define {} @__service_ratelimiter_loop(ptr %0) {
entry:
  %__args_ptr = alloca ptr, align 8
  store ptr %0, ptr %__args_ptr, align 8
  %args_ptr_val = load ptr, ptr %__args_ptr, align 8
  %init_state = load %RateLimitState, ptr %args_ptr_val, align 8
  ; ^^ Correctly: accepts ptr, loads actual state from buffer
```

### Why Existing Tests Pass

All e2e actor tests (`tests/e2e/actors_*.mpl`) use zero-argument actors:
```mesh
actor greeter() do    # no args
actor worker() do     # no args
actor tiny() do       # no args
```

When `spawn(greeter)` is called with no extra args, `args_ptr` is null and `args_size` is 0. The runtime calls `greeter(null)`. Since `greeter` takes no parameters, the null pointer passed in the first register is harmless -- the function simply ignores it.

The Mesher project is the first code that spawns actors **with arguments**:
```mesh
actor health_checker(pool :: PoolHandle) do ...
actor spike_checker(pool :: PoolHandle) do ...
actor alert_evaluator(pool :: PoolHandle) do ...
actor retention_cleaner(pool :: PoolHandle) do ...
actor stream_drain_ticker(stream_mgr_pid, interval :: Int) do ...
```

### Scope: ALL Actors With Arguments Are Affected

This is NOT specific to cross-module actor imports. Every actor with parameters will segfault. The cross-module import of `retention_cleaner` just happens to be the context where the bug was noticed.

Affected actors in the Mesher project:
- `health_checker(pool)` -- defined in `mesher/ingestion/pipeline.mpl`
- `spike_checker(pool)` -- defined in `mesher/ingestion/pipeline.mpl`
- `alert_evaluator(pool)` -- defined in `mesher/ingestion/pipeline.mpl`
- `stream_drain_ticker(stream_mgr_pid, interval)` -- defined in `mesher/ingestion/pipeline.mpl`
- `retention_cleaner(pool)` -- defined in `mesher/services/retention.mpl`, imported in pipeline.mpl

## Architecture Understanding

### Actor Spawn Flow

```
Mesh source:  spawn(my_actor, arg1, arg2)
    |
    v  (MIR lowering: lower_spawn_expr)
MIR:          ActorSpawn { func: Var("my_actor"), args: [arg1, arg2], ... }
    |
    v  (LLVM codegen: codegen_actor_spawn)
LLVM IR:      %buf = mesh_gc_alloc_actor(16, 8)
              store arg1 -> buf[0]
              store arg2 -> buf[8]
              mesh_actor_spawn(@my_actor, %buf, 16, 1)
    |
    v  (Runtime: scheduler.rs -> stack.rs)
Runtime:      transmute fn_ptr to extern "C" fn(*const u8)
              call fn_ptr(buf)
    |
    v  (PROBLEM: fn_ptr points to)
Actor fn:     define {} @my_actor(i64 %arg1, i64 %arg2)    <-- WRONG ABI
              ; receives buf address in %arg1, garbage in %arg2
```

### How Services Do It Right

Services generate a **wrapper function** (the "loop function") that correctly handles the args_ptr:

```
@__service_ratelimiter_loop(ptr %args_ptr):
  1. load initial_state from %args_ptr
  2. enter message dispatch loop
  3. call mesh_actor_receive(-1) for messages
```

The service loop function is the entry point for spawn, and it correctly accepts `ptr` and deserializes args. Actors need the same treatment.

### Key Code Locations

| File | Location | Role |
|------|----------|------|
| `crates/mesh-codegen/src/mir/lower.rs:8477` | `lower_actor_def()` | Produces the actor function with actual param types |
| `crates/mesh-codegen/src/mir/lower.rs:9470` | `lower_spawn_expr()` | Produces `MirExpr::ActorSpawn` with func reference |
| `crates/mesh-codegen/src/codegen/expr.rs:1946` | `codegen_actor_spawn()` | Serializes args to buffer, calls `mesh_actor_spawn` |
| `crates/mesh-rt/src/actor/mod.rs:131` | `mesh_actor_spawn()` | Runtime spawn entry -- passes fn_ptr + args_ptr |
| `crates/mesh-rt/src/actor/stack.rs:126` | `CoroutineHandle::new()` | Creates coroutine, calls `fn_ptr(args_ptr)` |
| `crates/mesh-rt/src/actor/scheduler.rs:157` | `Scheduler::spawn()` | Enqueues spawn request |

### Name Qualification (Non-Issue)

Actor names do NOT go through `qualify_name()` because they are not in `user_fn_defs` (only `FnDef` items are). Actor definitions are pushed with their raw unqualified name. Spawn references also use the unqualified name (since actors aren't in `user_fn_defs`). This means actor function names match between definition and reference -- name qualification is NOT a problem.

The `pub_fns` set (built from `e.functions.keys()` in `meshc/src/main.rs:358`) also does not include actors, but this is fine because actors are already unqualified on both sides.

## Fix Strategy

### Approach: Generate Actor Wrapper Function

The fix should generate a wrapper function for each actor that:
1. Accepts `*const u8` (the args buffer pointer) -- matching the runtime's expected ABI
2. Loads each actual argument from the buffer at the appropriate offset
3. Calls the actual actor body with the loaded arguments

This is analogous to what service loop functions already do (see `codegen_service_loop` in `crates/mesh-codegen/src/codegen/expr.rs`).

### Option A: Fix in MIR Lowering (Recommended)

Modify `lower_actor_def()` in `crates/mesh-codegen/src/mir/lower.rs` to generate TWO functions:
1. **Actor body** (inner function): `__actor_{name}_body(arg1: Type1, arg2: Type2) -> Unit` -- the actual actor logic
2. **Actor wrapper** (entry point): `{name}(args_ptr: Ptr) -> Unit` -- loads args from buffer, calls body

The spawn expression already references the actor by name, so the wrapper is what gets called.

**Pros**: Clean separation, mirrors service pattern, no codegen changes needed.
**Cons**: Adds complexity to MIR lowering, needs careful name management.

### Option B: Fix in LLVM Codegen

Modify `compile_function()` in `crates/mesh-codegen/src/codegen/mod.rs` to detect actor entry functions and generate the wrapper at the LLVM IR level.

**Pros**: Keeps MIR simple.
**Cons**: Harder to implement correctly, codegen already complex, would need to identify which functions are actors.

### Option C: Fix in codegen_actor_spawn (Simplest)

Instead of passing the actor function pointer directly to `mesh_actor_spawn`, generate an inline thunk at each spawn site that:
1. Accepts `*const u8`
2. Loads args from buffer
3. Calls the actual actor function with loaded args

**Pros**: Minimal changes, localized fix.
**Cons**: Duplicates wrapper for each spawn call, increases code size.

### Recommended: Option A (MIR-level wrapper)

This follows the established service pattern and keeps the architecture clean. The actor wrapper function would be named `{actor_name}` and the body would be `__actor_{actor_name}_body` (or the actor body could keep its name and the wrapper gets a different name, but the spawn reference must point to the wrapper).

Simplest variant of Option A: modify `lower_actor_def` to change the actor function signature to accept `Ptr` instead of the actual param types, and add args-loading logic at the start of the function body. This avoids creating two separate functions.

## Testing Strategy

1. **New e2e test**: Actor with arguments -- `spawn(counter, 42)` where the actor uses the argument
2. **New e2e test**: Actor with multiple arguments -- `spawn(worker, pid, count)`
3. **New e2e test**: Cross-module actor spawn with arguments (project mode test)
4. **Regression**: All existing actor tests must still pass
5. **Integration**: Build and run mesher project -- no segfault on actor spawn

## Complexity Assessment

- **Scope**: MIR lowering for actor definitions (single function: `lower_actor_def`)
- **Risk**: Medium -- must ensure wrapper correctly handles all arg types (int, ptr, float, string, struct)
- **Estimated size**: ~50-80 lines of MIR lowering changes, ~30 lines of test code
- **Dependencies**: None -- this is a standalone fix

## Key Decisions Needed

1. **Wrapper naming convention**: Should the wrapper be `{name}` and body be `__actor_{name}_body`? Or should we just modify the existing actor function to accept `Ptr` and add deserialization?
2. **Recursive tail calls**: Actor bodies use tail-call optimization (`rewrite_tail_calls`) for the recursive `my_actor(args...)` pattern. The TCE loop must target the BODY function (not the wrapper), since the recursive call passes actual typed args, not a raw pointer.
3. **Terminate callback**: The `__terminate_{name}` callback function also needs to be considered -- does it need a similar wrapper? (Likely not -- terminate callbacks already accept `(state_ptr: Ptr, reason_ptr: Ptr)`.)

## Files That Will Need Changes

| File | Change |
|------|--------|
| `crates/mesh-codegen/src/mir/lower.rs` | Modify `lower_actor_def()` to generate wrapper or modify actor function signature |
| `tests/e2e/actors_with_args.mpl` | New test fixture for actor spawn with arguments |
| `crates/meshc/tests/e2e_actors.rs` | New test case for actors with arguments |
