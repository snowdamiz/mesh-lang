---
phase: 67-remote-spawn-llvm-integration
plan: 02
type: execute
wave: 2
depends_on: ["67-01"]
files_modified:
  - crates/snow-rt/src/dist/node.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "A DIST_SPAWN message sent over the wire causes the remote node to spawn an actor and reply with its PID"
    - "snow_node_spawn blocks the calling actor until the spawn reply arrives, then returns the remote PID"
    - "snow_node_spawn with link_flag=1 establishes a bidirectional link between caller and spawned actor"
    - "If the function name is not found on the remote node, the spawn reply returns status=error and snow_node_spawn returns 0"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "DIST_SPAWN reader handler, DIST_SPAWN_REPLY reader handler, send_spawn_reply helper, snow_node_spawn extern C"
      contains: "DIST_SPAWN =>"
    - path: "crates/snow-rt/src/lib.rs"
      provides: "Re-export of snow_node_spawn"
      contains: "snow_node_spawn"
  key_links:
    - from: "crates/snow-rt/src/dist/node.rs (snow_node_spawn)"
      to: "crates/snow-rt/src/dist/node.rs (reader_loop_session DIST_SPAWN)"
      via: "DIST_SPAWN wire message over TLS session, reply via DIST_SPAWN_REPLY"
      pattern: "DIST_SPAWN"
    - from: "crates/snow-rt/src/dist/node.rs (DIST_SPAWN handler)"
      to: "crates/snow-rt/src/dist/node.rs (lookup_function)"
      via: "Function name lookup in FUNCTION_REGISTRY"
      pattern: "lookup_function"
    - from: "crates/snow-rt/src/dist/node.rs (DIST_SPAWN_REPLY handler)"
      to: "crates/snow-rt/src/actor/mod.rs (local_send)"
      via: "Deliver spawn reply as SPAWN_REPLY_TAG message to requester mailbox"
      pattern: "SPAWN_REPLY_TAG"
---

<objective>
Implement the remote spawn runtime protocol (EXEC-01, EXEC-02): DIST_SPAWN/DIST_SPAWN_REPLY wire messages, snow_node_spawn extern "C" API, and reader loop handlers.

Purpose: This is the core distributed spawn capability. When a Snow program calls Node.spawn(node, func, args), the runtime sends a DIST_SPAWN message to the target node, the remote node looks up the function name in the registry, spawns the actor locally, and replies with the new PID. The caller blocks (yields coroutine) until the reply arrives.

Output: Working remote spawn runtime -- the caller sends DIST_SPAWN, the remote side spawns and replies, the caller receives the PID.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-remote-spawn-llvm-integration/67-RESEARCH.md
@.planning/phases/67-remote-spawn-llvm-integration/67-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DIST_SPAWN reader handler and snow_node_spawn extern C API</name>
  <files>
    crates/snow-rt/src/dist/node.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
**1. DIST_SPAWN reader loop handler (remote side)**

In `reader_loop_session` in dist/node.rs, add a match arm for `DIST_SPAWN` (0x19). The wire format is:

```
[DIST_SPAWN tag: 0x19]
[u64 request_id LE]
[u64 requester_pid LE]
[u8 link_flag]               -- 0=spawn, 1=spawn_link
[u16 fn_name_len LE]
[fn_name bytes]
[remaining bytes = args_data] -- raw args buffer passed to snow_actor_spawn
```

Handler logic:
1. Parse req_id (bytes 1..9), requester_pid (bytes 9..17), link_flag (byte 17), fn_name_len (bytes 18..20), fn_name (bytes 20..20+fn_name_len), args_data (bytes 20+fn_name_len..)
2. Call `lookup_function(fn_name)` from the function registry (added in Plan 01)
3. If found:
   a. Call `snow_actor_spawn(fn_ptr, args_data.as_ptr(), args_data.len() as u64, 1)` to spawn the actor locally. Note: args_data is the raw packed i64 array from the caller side. Priority=1 (normal).
   b. The spawn returns a local PID (u64 with node_id=0)
   c. If link_flag == 1: Add requester_pid to the new process's links set. Also send a DIST_LINK back to the requester's node so it records the reverse link. Use the existing `send_dist_link` helper.
   d. Send DIST_SPAWN_REPLY back with status=0 (ok) and the local_id of the spawned process (extract via `ProcessId(spawned_pid).local_id()` -- the 40-bit counter part)
4. If not found:
   a. Send DIST_SPAWN_REPLY with status=1 (error) and pid=0

**2. send_spawn_reply helper**

Add a helper function:
```rust
fn send_spawn_reply(session: &NodeSession, req_id: u64, status: u8, spawned_local_id: u64) {
    let mut payload = Vec::with_capacity(18);
    payload.push(DIST_SPAWN_REPLY);
    payload.extend_from_slice(&req_id.to_le_bytes());
    payload.push(status);
    payload.extend_from_slice(&spawned_local_id.to_le_bytes());
    let mut stream = session.stream.lock().unwrap();
    let _ = write_msg(&mut *stream, &payload);
}
```

**3. DIST_SPAWN_REPLY reader loop handler (caller side)**

Add a match arm for `DIST_SPAWN_REPLY` (0x1A). Wire format:
```
[DIST_SPAWN_REPLY tag: 0x1A]
[u64 request_id LE]
[u8 status]
[u64 spawned_local_id LE]
```

Handler logic:
1. Parse req_id (bytes 1..9), status (byte 9), spawned_local_id (bytes 10..18)
2. Look up the requester PID from `session.pending_spawns.lock().unwrap().remove(&req_id)`
3. If found, deliver a spawn reply message to the requester's mailbox:
   - Build a message buffer containing `[u64 req_id][u8 status][u64 spawned_local_id]` (17 bytes)
   - Use `local_send(requester_pid, SPAWN_REPLY_TAG, msg_ptr, msg_len)` to deliver it
   - This will wake the requester if it's in Waiting state

**4. snow_node_spawn extern "C" function**

Add `#[no_mangle] pub extern "C" fn snow_node_spawn(...)` with this signature:
```rust
pub extern "C" fn snow_node_spawn(
    node_ptr: *const u8, node_len: u64,
    fn_name_ptr: *const u8, fn_name_len: u64,
    args_ptr: *const u8, args_size: u64,
    link_flag: u8,
) -> u64
```

Implementation:
1. Get current PID via `stack::get_current_pid()`. Return 0 if not in actor context.
2. Get node state. Return 0 if node not started.
3. Build node_name and fn_name from the raw pointers.
4. Look up session for the target node name from `state.sessions.read()`. Return 0 if not connected.
5. Generate a unique req_id from `SPAWN_REQUEST_ID.fetch_add(1, Ordering::Relaxed)`.
6. Register `(req_id -> my_pid)` in `session.pending_spawns.lock().unwrap().insert(req_id, my_pid)`.
7. Build the DIST_SPAWN payload: `[DIST_SPAWN][req_id LE][my_pid LE][link_flag][fn_name_len LE][fn_name][args_data]`
   - Copy args_data immediately into the payload Vec (do NOT retain a pointer to the GC heap)
8. Send via `write_msg(&mut *session.stream.lock().unwrap(), &payload)`. Return 0 on write error.
9. Enter a yield-wait loop for the spawn reply:
   a. Get the scheduler via `global_scheduler()`
   b. Get my process, set state to `ProcessState::Waiting`, drop the lock
   c. Yield to scheduler via `stack::yield_current()`
   d. When woken: scan my mailbox for a message with `type_tag == SPAWN_REPLY_TAG` where the first 8 bytes match req_id
   e. If found: extract status and spawned_local_id. If status==0, construct remote PID via `ProcessId::from_remote(session.node_id(), session.creation(), spawned_local_id)`. If link_flag==1, add the remote PID to my links. Return the remote PID as u64.
   f. If not found (woken by a different message), re-enter Waiting state and yield again.
   g. On status!=0 (error): return 0.

IMPORTANT: The mailbox scanning must handle the case where non-spawn messages arrive during the wait. Those messages must remain in the mailbox (do not consume them). Only consume the matching SPAWN_REPLY_TAG message.

To scan the mailbox for a specific message, iterate the mailbox VecDeque, find the index of the matching spawn reply, remove it with `remove(index)`, and leave all other messages untouched. This is a selective receive pattern.

**5. Re-export**

Add `snow_node_spawn` to the `pub use dist::node::` line in lib.rs.
  </action>
  <verify>
Run `cargo build` to verify the full project compiles. Run `cargo test` to verify all existing tests pass (393+). The remote spawn path cannot be integration-tested without two nodes, but verify:
- The DIST_SPAWN and DIST_SPAWN_REPLY match arms exist in reader_loop_session
- snow_node_spawn compiles and is exported
- The send_spawn_reply helper compiles
  </verify>
  <done>
DIST_SPAWN reader handler spawns actor locally via lookup_function + snow_actor_spawn and replies with PID. DIST_SPAWN_REPLY handler delivers spawn reply to requester's mailbox via local_send. snow_node_spawn sends DIST_SPAWN and blocks with selective receive until reply arrives, then constructs remote PID. spawn_link variant establishes bidirectional link (local link set + DIST_LINK back). All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- full project compiles with no errors
2. `cargo test` -- all existing tests pass (393+)
3. Verify DIST_SPAWN handler in reader_loop_session calls lookup_function and snow_actor_spawn
4. Verify DIST_SPAWN_REPLY handler looks up pending_spawns and delivers to mailbox
5. Verify snow_node_spawn constructs DIST_SPAWN payload, registers pending spawn, yields, and returns remote PID
6. Verify spawn_link (link_flag=1) adds to links set on both sides
</verification>

<success_criteria>
- DIST_SPAWN wire message is handled: function lookup, local spawn, reply with PID
- DIST_SPAWN_REPLY wire message is handled: deliver to requester mailbox
- snow_node_spawn blocks caller, waits for reply, returns constructed remote PID
- spawn_link variant establishes bidirectional links
- Function-not-found returns status=error, snow_node_spawn returns 0
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/67-remote-spawn-llvm-integration/67-02-SUMMARY.md`
</output>
