---
phase: 67-remote-spawn-llvm-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/dist/node.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/codegen/mod.rs
autonomous: true

must_haves:
  truths:
    - "Every top-level and actor function is registered by name at program startup"
    - "A function pointer can be looked up by name from the registry at runtime"
    - "All snow_node_* and snow_register_function intrinsics are declared in LLVM module"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "FUNCTION_REGISTRY static, snow_register_function extern C, lookup_function pub(crate)"
      contains: "FUNCTION_REGISTRY"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for snow_node_start, snow_node_connect, snow_node_self, snow_node_list, snow_node_monitor, snow_node_spawn, snow_register_function, snow_process_monitor, snow_process_demonitor, snow_actor_send_named"
      contains: "snow_node_spawn"
    - path: "crates/snow-codegen/src/codegen/mod.rs"
      provides: "Function registration loop in generate_main_wrapper"
      contains: "snow_register_function"
  key_links:
    - from: "crates/snow-codegen/src/codegen/mod.rs"
      to: "crates/snow-rt/src/dist/node.rs"
      via: "codegen emits snow_register_function calls that the runtime receives"
      pattern: "snow_register_function"
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/dist/node.rs"
      via: "LLVM declarations match extern C signatures in runtime"
      pattern: "snow_node_spawn"
---

<objective>
Build the function name registry for remote spawn (EXEC-03) and declare all new LLVM intrinsics for Phase 67.

Purpose: Remote spawn requires mapping function names to pointers so that differently-compiled binaries can spawn each other's functions. This plan creates the registry in the runtime, the registration API, and emits registration calls from the compiler's main wrapper. It also forward-declares all new intrinsics (Node.*, Process.monitor/demonitor, send_named) that Plans 02 and 03 depend on.

Output: Function registry in snow-rt, registration loop in codegen main wrapper, complete LLVM intrinsic declarations for all Phase 67 runtime functions.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-remote-spawn-llvm-integration/67-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add function name registry and LLVM intrinsic declarations</name>
  <files>
    crates/snow-rt/src/dist/node.rs
    crates/snow-rt/src/actor/mod.rs
    crates/snow-rt/src/lib.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
**Runtime: Function name registry (in dist/node.rs)**

Add the function name registry near the top of dist/node.rs (after the existing NodeState-related statics):

1. Add a `FUNCTION_REGISTRY` static using `OnceLock<RwLock<FxHashMap<String, *const u8>>>` (use parking_lot::RwLock which is already imported in the file, and rustc_hash::FxHashMap already used).

2. Add a `function_registry()` helper that calls `get_or_init` to lazily create the hashmap.

3. Add `snow_register_function` as `#[no_mangle] pub extern "C" fn`:
   - Signature: `(name_ptr: *const u8, name_len: u64, fn_ptr: *const u8)`
   - Build a String from the name bytes (unsafe from_utf8_unchecked + to_string)
   - Insert `(name, fn_ptr)` into the registry via `function_registry().write().insert(name, fn_ptr)`

4. Add `pub(crate) fn lookup_function(name: &str) -> Option<*const u8>` that reads from the registry.

5. Also add these new wire message constants (for Plan 02 to use):
   - `pub(crate) const DIST_SPAWN: u8 = 0x19;`
   - `pub(crate) const DIST_SPAWN_REPLY: u8 = 0x1A;`
   - `pub(crate) const SPAWN_REPLY_TAG: u64 = u64::MAX - 4;` (reserved type_tag for spawn reply messages in mailbox)

6. Add `static SPAWN_REQUEST_ID: AtomicU64 = AtomicU64::new(1);` for generating unique spawn request IDs.

7. Add `pending_spawns: std::sync::Mutex<FxHashMap<u64, ProcessId>>` field to the `NodeSession` struct. Initialize it as `std::sync::Mutex::new(FxHashMap::default())` wherever NodeSession is constructed (in the accept handler and connect handler).

**Runtime: Re-exports (lib.rs)**

Add `snow_register_function` to the `pub use dist::node::` line that already re-exports `snow_node_self`, `snow_node_list`, `snow_node_start`, `snow_node_connect`.

**LLVM Intrinsic Declarations (intrinsics.rs)**

Add to `declare_intrinsics()` function, in a new section `// ── Phase 67: Node distribution & remote spawn ──`:

1. `snow_node_start(name_ptr: ptr, name_len: i64, cookie_ptr: ptr, cookie_len: i64, port: i64) -> i64` -- Check the actual runtime signature of `snow_node_start` in dist/node.rs first and match it exactly.

2. `snow_node_connect(name_ptr: ptr, name_len: i64) -> i64`

3. `snow_node_self() -> ptr`

4. `snow_node_list() -> ptr`

5. `snow_node_monitor(node_ptr: ptr, node_len: i64) -> i64`

6. `snow_node_spawn(node_ptr: ptr, node_len: i64, fn_name_ptr: ptr, fn_name_len: i64, args_ptr: ptr, args_size: i64, link_flag: i8) -> i64`

7. `snow_register_function(name_ptr: ptr, name_len: i64, fn_ptr: ptr) -> void`

8. `snow_process_monitor(target_pid: i64) -> i64`

9. `snow_process_demonitor(monitor_ref: i64) -> i64`

10. `snow_actor_send_named(name_ptr: ptr, name_len: i64, node_ptr: ptr, node_len: i64, msg_ptr: ptr, msg_size: i64) -> void` -- Check the actual signature of `snow_actor_send_named` in actor/mod.rs first.

IMPORTANT: Before adding each intrinsic, read the actual extern "C" function signature in the runtime source to ensure the LLVM type signature matches exactly. The parameter types must agree (ptr for pointers, i64 for u64 params, i8 for u8/bool params, etc.).

Also add corresponding `assert!(module.get_function("snow_node_start").is_some());` etc. lines to the `test_declare_all_intrinsics` test.
  </action>
  <verify>
Run `cargo build -p snow-codegen` and `cargo test -p snow-codegen -- test_declare_all_intrinsics` to verify intrinsic declarations compile and the test passes. Run `cargo build -p snow-rt` to verify the function registry compiles.
  </verify>
  <done>
FUNCTION_REGISTRY static exists in dist/node.rs. snow_register_function and lookup_function APIs exist. All 10+ new intrinsics declared in intrinsics.rs. DIST_SPAWN/DIST_SPAWN_REPLY constants defined. pending_spawns field added to NodeSession. Intrinsics test passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Emit function registration calls in codegen main wrapper</name>
  <files>
    crates/snow-codegen/src/codegen/mod.rs
  </files>
  <action>
In `generate_main_wrapper()` in codegen/mod.rs, after the `snow_rt_init_actor` call and BEFORE the Snow entry function call, add a loop that registers all top-level functions:

```rust
// Register all top-level functions for remote spawn (Phase 67).
let register_fn = intrinsics::get_intrinsic(&self.module, "snow_register_function");
for mir_fn in &self.mir_functions {
    // Skip closure/lambda functions (they capture environment pointers,
    // cannot be spawned remotely) and compiler-internal functions.
    if mir_fn.is_closure_fn || mir_fn.name.starts_with("__") {
        continue;
    }

    // Create a global string constant for the function name.
    let name_global = self.builder.build_global_string_ptr(
        &mir_fn.name,
        &format!("fn_reg_{}", mir_fn.name),
    ).map_err(|e| e.to_string())?;

    let name_len = self.context.i64_type().const_int(
        mir_fn.name.len() as u64, false,
    );

    // Get the LLVM function value for this MIR function.
    if let Some(fn_val) = self.functions.get(&mir_fn.name) {
        self.builder.build_call(
            register_fn,
            &[
                name_global.as_pointer_value().into(),
                name_len.into(),
                fn_val.as_global_value().as_pointer_value().into(),
            ],
            "",
        ).map_err(|e| e.to_string())?;
    }
}
```

The registration must happen before the entry function runs because the entry function may call Node.spawn which needs the registry populated.

Verify that `self.mir_functions` is populated before `generate_main_wrapper` is called (it is -- set in `compile()` before step 5 which calls `generate_main_wrapper`).
  </action>
  <verify>
Run `cargo build -p snow-codegen` to verify compilation. Run `cargo test -p snow-codegen` to ensure all existing tests pass. Write a simple Snow program that defines a function and verify it compiles without error (the registration calls should be emitted in the main wrapper IR).
  </verify>
  <done>
generate_main_wrapper emits snow_register_function calls for every non-closure, non-internal MIR function. Function names are stored as global string constants in the LLVM module. Registration happens before the entry function executes. All existing tests pass (no regressions).
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- full project compiles
2. `cargo test` -- all existing tests pass (should be 393+)
3. Verify snow_register_function is declared as an LLVM intrinsic
4. Verify FUNCTION_REGISTRY static exists in dist/node.rs
5. Verify lookup_function returns None for unregistered names and Some for registered names
6. Verify generate_main_wrapper contains the registration loop
</verification>

<success_criteria>
- Function name registry is operational in snow-rt (register + lookup)
- All snow_node_* and snow_process_* intrinsics are declared in LLVM module
- Codegen emits registration calls for all top-level functions at program startup
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/67-remote-spawn-llvm-integration/67-01-SUMMARY.md`
</output>
