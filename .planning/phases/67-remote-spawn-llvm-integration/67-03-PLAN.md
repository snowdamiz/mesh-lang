---
phase: 67-remote-spawn-llvm-integration
plan: 03
type: execute
wave: 2
depends_on: ["67-01"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/expr.rs
autonomous: true

must_haves:
  truths:
    - "Node.start, Node.connect, Node.self, Node.list, Node.monitor compile to correct runtime calls"
    - "Node.spawn and Node.spawn_link compile to snow_node_spawn calls with function name as string"
    - "Process.monitor and Process.demonitor compile to snow_process_monitor and snow_process_demonitor calls"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Node and Process in STDLIB_MODULES, map_builtin_name entries for all node_* and process_* functions"
      contains: "\"Node\""
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "codegen_node_spawn helper that emits snow_node_spawn call with function name string constant"
      contains: "snow_node_spawn"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/expr.rs"
      via: "MIR lowering produces MirExpr::Call to snow_node_spawn, codegen emits the LLVM call"
      pattern: "snow_node_spawn"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "Lowered MIR calls reference intrinsics declared in Plan 01"
      pattern: "snow_node_start"
---

<objective>
Wire the Node and Process modules into the LLVM codegen pipeline so that Snow source code compiles to the correct runtime calls.

Purpose: The runtime has all the snow_node_* and snow_process_* extern "C" functions, and Plan 01 declared them as LLVM intrinsics, but the compiler does not know how to lower Snow source code like `Node.spawn(node, func, args)` or `Process.monitor(pid)` into calls to these functions. This plan adds "Node" and "Process" to STDLIB_MODULES, adds all the map_builtin_name entries, and handles the special lowering for Node.spawn/spawn_link where the function argument must be converted to a name string.

Output: Snow programs can use all Node.* and Process.monitor/demonitor APIs, and they compile to correct LLVM IR.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-remote-spawn-llvm-integration/67-RESEARCH.md
@.planning/phases/67-remote-spawn-llvm-integration/67-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Node and Process to STDLIB_MODULES and map_builtin_name</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**1. Add "Node" and "Process" to STDLIB_MODULES**

Find the `STDLIB_MODULES` constant (around line 9274) and add "Node" and "Process":

```rust
const STDLIB_MODULES: &[&str] = &[
    "String", "IO", "Env", "File", "List", "Map", "Set", "Tuple", "Range", "Queue", "HTTP", "JSON", "Json", "Request", "Job",
    "Math", "Int", "Float", "Timer", "Sqlite", "Pg", "Ws",
    "Node", "Process",  // Phase 67
];
```

**2. Add map_builtin_name entries**

In the `map_builtin_name` function, add entries for Node and Process functions. The stdlib lowering path converts `Node.spawn` to `node_spawn`, then `map_builtin_name` maps `node_spawn` to `snow_node_spawn`. Add:

```rust
// ── Phase 67: Node distribution functions ─────────────────────────
"node_start" => "snow_node_start".to_string(),
"node_connect" => "snow_node_connect".to_string(),
"node_self" => "snow_node_self".to_string(),
"node_list" => "snow_node_list".to_string(),
"node_monitor" => "snow_node_monitor".to_string(),
"node_spawn" => "snow_node_spawn".to_string(),
"node_spawn_link" => "snow_node_spawn_link".to_string(),
// ── Phase 67: Process monitor/demonitor ───────────────────────────
"process_monitor" => "snow_process_monitor".to_string(),
"process_demonitor" => "snow_process_demonitor".to_string(),
```

**3. Special handling for Node.spawn and Node.spawn_link**

The standard stdlib lowering path (`base_name.to_lowercase() + "_" + field` -> `map_builtin_name`) will produce `snow_node_spawn` for `Node.spawn`. However, `Node.spawn` has special semantics:
- The second argument is a function NAME (not a value) -- it must be lowered to a string constant, not evaluated as an expression.
- The third+ arguments are the actor args that need to be packed into an i64 array (same as local ActorSpawn).

This special lowering needs to happen BEFORE the generic stdlib path. In the field access lowering section where `STDLIB_MODULES.contains(&base_name.as_str())` is checked (around line 5811), add a special case check:

```rust
if base_name == "Node" {
    let field = fa.field().map(|t| t.text().to_string()).unwrap_or_default();
    if field == "spawn" || field == "spawn_link" {
        // Special lowering: Node.spawn(node_expr, func_name, args...)
        // The function_name argument must be converted to a string literal.
        // This is handled by codegen (expr.rs) -- lower as a special MirExpr.
        // Lower to MirExpr::RemoteSpawn { node, func_name, args, link }
        // OR: Lower to MirExpr::Call with snow_node_spawn and the func_name
        // extracted as a string constant from the AST.
        //
        // The approach: lower normally BUT intercept in the call site lowering
        // to replace the function argument with its name as a string.
        // For now, fall through to the standard path which produces
        // MirExpr::Var("snow_node_spawn", ...) -- the special func_name
        // handling will be done in codegen (expr.rs) via a NodeSpawn variant
        // or by detecting the snow_node_spawn call target.
    }
}
```

Actually, the cleanest approach is to NOT special-case in lower.rs. Instead:
- Let the standard stdlib path lower `Node.spawn(node, func, args)` to `MirExpr::Call { func: Var("snow_node_spawn"), args: [node_expr, func_ref, arg_exprs...] }`.
- The function reference (`func`) in the args will be a `MirExpr::Var("function_name", FnPtr(...))`.
- In codegen (expr.rs), when generating a call to `snow_node_spawn`, detect the function name argument and convert it to a string constant instead of evaluating it as a pointer.

So for lower.rs: Just let the standard path work. `Node.spawn` -> `node_spawn` -> `snow_node_spawn`. The call args are lowered normally. The func argument comes through as a MirExpr::Var with the function name.

For `Node.spawn_link`, map it to `snow_node_spawn` as well -- the codegen will pass `link_flag=1` vs `link_flag=0`. Actually, map `node_spawn_link` to a distinct name so codegen can differentiate:
- Option A: Map both to `snow_node_spawn` and use context to determine link_flag.
- Option B: Map `node_spawn_link` to `snow_node_spawn_link` (a codegen-only alias).

Use Option A: Both map to `snow_node_spawn`. The codegen for snow_node_spawn checks if the original MIR call was `snow_node_spawn_link` and sets link_flag accordingly.

Actually, simpler: just map them differently in map_builtin_name. `node_spawn` -> `snow_node_spawn`, `node_spawn_link` -> `snow_node_spawn_link`. Then in codegen, handle both `snow_node_spawn` and `snow_node_spawn_link` to the same intrinsic with different link_flag values.

For the simple case of `Node.start(name, cookie: cookie_str)` -- this is a keyword argument. Check how existing keyword arg patterns work. If `Node.start("name@host", cookie: "secret")` lowering converts `cookie:` to a positional arg, then the standard path works. If not, we need to handle keyword args specially. Check how existing code handles keyword args in stdlib calls. If there's no precedent, just use positional: `Node.start(name, cookie)`.

For the other simple Node.* calls (connect, self, list, monitor): the standard path works directly.
  </action>
  <verify>
Run `cargo build -p snow-codegen` to verify the lowering changes compile. Run `cargo test -p snow-codegen` to verify no regressions. Write a small Snow test that uses `Node.self()` and `Node.list()` and verify it compiles (these are the simplest Node calls to test).
  </verify>
  <done>
"Node" and "Process" are in STDLIB_MODULES. All node_* and process_* entries exist in map_builtin_name. Node.start/connect/self/list/monitor/spawn/spawn_link are lowered to correct snow_node_* runtime calls. Process.monitor/demonitor are lowered to snow_process_monitor/demonitor. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Node.spawn codegen with function name string conversion</name>
  <files>
    crates/snow-codegen/src/codegen/expr.rs
  </files>
  <action>
In expr.rs, find the section where `MirExpr::Call` is handled in codegen. When the callee function name is `"snow_node_spawn"` or `"snow_node_spawn_link"`, add special codegen handling:

**Detection:**
In the `MirExpr::Call { func, args, ty }` codegen, after resolving the callee name, check if it's `"snow_node_spawn"` or `"snow_node_spawn_link"`.

**Special codegen for Node.spawn:**

The call `Node.spawn(node_expr, func_ref, arg1, arg2, ...)` arrives as:
- args[0] = node expression (String -- the node name)
- args[1] = function reference (MirExpr::Var("function_name", FnPtr type))
- args[2..] = actor arguments

Generate this LLVM IR:
1. Codegen args[0] (node_expr) to get a SnowString pointer. Extract raw pointer and length from the SnowString (same pattern as `snow_actor_send_named` or `snow_node_connect` -- call the string's data_ptr and len accessors, or pass the SnowString ptr directly if the runtime handles it).

   Actually, check how `snow_node_start` and `snow_node_connect` receive their string args. They take `(name_ptr: *const u8, name_len: u64)`. The codegen for string-taking stdlib calls typically passes the SnowString pointer directly and the runtime extracts data/len. But looking at the intrinsic signatures from Plan 01, the functions take `(ptr, i64)` pairs. So the codegen needs to extract the raw pointer and length from the SnowString.

   Look at how existing string-arg functions are called in codegen. For `snow_node_connect`, the caller provides a string value. The convention in Snow codegen is: strings are passed as `ptr` (the SnowString pointer), and the runtime function dereferences to get data+len. Check the actual `snow_node_start` and `snow_node_connect` signatures -- if they take `(ptr, len)` pairs, we need string unpacking. If they take just `ptr` (SnowString), we pass the pointer.

   Read the actual snow_node_start signature: `snow_node_start(name_ptr: *const u8, name_len: u64, cookie_ptr: *const u8, cookie_len: u64, port: i64)`. So yes, it expects raw `(ptr, len)` pairs. The codegen must extract the raw bytes from the SnowString. Use the pattern: load the `data` field (offset 0 in SnowString) as ptr, and `len` field (offset 8 in SnowString) as i64.

   For simplicity, if strings in Snow are passed as i64 (ptrtoint'd SnowString pointers), the codegen would: inttoptr to get the SnowString*, then GEP to get data and len fields. Look at how existing string-passing stdlib codegen works (e.g., `snow_string_length` takes a ptr).

2. For args[1] (function reference): Extract the function NAME as a string constant. The MIR has `MirExpr::Var("function_name", FnPtr(...))`. In codegen, instead of evaluating this as a function pointer, emit a global string constant with the function name:
   ```rust
   let fn_name = /* extract name from args[1] -- it's a MirExpr::Var(name, _) */;
   let fn_name_global = self.builder.build_global_string_ptr(&fn_name, "spawn_fn_name");
   let fn_name_len = self.context.i64_type().const_int(fn_name.len() as u64, false);
   ```

3. For args[2..] (actor arguments): Pack into an i64 array on the stack, same as the existing `codegen_actor_spawn` does (see the ActorSpawn handling around line 1635). Allocate a stack buffer, store each arg as i64, get the pointer and size.

4. Emit the call:
   ```
   snow_node_spawn(node_ptr, node_len, fn_name_ptr, fn_name_len, args_buf_ptr, args_buf_size, link_flag)
   ```
   where link_flag is 0 for snow_node_spawn and 1 for snow_node_spawn_link.

5. The return value is a u64 (the remote PID). Return it as i64 (the Snow Pid representation).

**Also handle Node.start specially:**

`Node.start(name, cookie: cookie)` needs to unpack two string args into `(ptr, len)` pairs plus a port. For simplicity, support `Node.start(name, cookie)` as two positional args. The port can default to a constant (e.g., 0 meaning auto-assign, or read from the name string if it contains `:port`). Check the actual `snow_node_start` signature for the port parameter behavior. If port=0 means use default, pass 0.

Handle Node.start: codegen args[0] and args[1] as SnowString pointers, extract (data_ptr, len) from each, pass to `snow_node_start(name_ptr, name_len, cookie_ptr, cookie_len, 0)`.

**Also handle Node.connect:**

`Node.connect(node_name)` -- single string arg. Extract (data_ptr, len) and call `snow_node_connect(name_ptr, name_len)`.

**Node.self(), Node.list():** Zero-arg calls. `snow_node_self()` returns ptr (SnowString), `snow_node_list()` returns ptr (list). These should work via the standard call codegen path if the MIR is `MirExpr::Call { func: Var("snow_node_self"), args: [], ty: String }`.

**Node.monitor(node_name):** Single string arg. Extract (ptr, len) and call `snow_node_monitor(ptr, len)`.

**Process.monitor(pid):** Single i64 arg. Call `snow_process_monitor(pid)`. Returns u64 (monitor ref).

**Process.demonitor(ref):** Single i64 arg. Call `snow_process_demonitor(ref)`. Returns u64.

For Process.monitor and Process.demonitor, the standard codegen path should work since they take i64 and return i64 -- no string unpacking needed.

The key challenge is the STRING UNPACKING for Node.* functions. Create a helper in expr.rs:
```rust
fn codegen_unpack_string(&self, string_val: BasicValueEnum<'ctx>) -> Result<(PointerValue<'ctx>, IntValue<'ctx>), String>
```
that takes a SnowString pointer (as i64 via ptrtoint) and returns (data_ptr, len). Use GEP or direct pointer arithmetic to read the SnowString fields.

Check the SnowString struct layout in snow-rt/src/string.rs to know the field offsets. Typically: `{ data: *const u8, len: usize, ... }` or it might be a fat pointer. Read the actual definition.
  </action>
  <verify>
Run `cargo build -p snow-codegen` to verify compilation. Run `cargo test -p snow-codegen` to verify no regressions. Write a Snow program that uses `Node.self()` and `Process.monitor(some_pid)` and verify it compiles to correct LLVM IR. The full `Node.spawn` path requires both nodes running so it cannot be end-to-end tested here, but verify the IR generation is correct.
  </verify>
  <done>
Node.spawn/spawn_link codegen extracts function name as string constant and packs actor args into buffer. Node.start/connect codegen unpacks SnowString args to (ptr, len) pairs. Node.self/list/monitor codegen works via standard call path. Process.monitor/demonitor codegen works. All existing tests pass. Snow programs using Node.* and Process.* APIs compile.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- full project compiles
2. `cargo test` -- all existing tests pass (393+)
3. A Snow program with `Node.self()` compiles without error
4. A Snow program with `Process.monitor(pid)` compiles without error
5. A Snow program with `Node.spawn(node, func, arg)` compiles (even if it can't run without two nodes)
6. "Node" and "Process" are in STDLIB_MODULES
7. All node_* and process_* entries exist in map_builtin_name
</verification>

<success_criteria>
- All Node.* calls (start, connect, self, list, monitor, spawn, spawn_link) lower and codegen correctly
- Process.monitor and Process.demonitor lower and codegen correctly
- Node.spawn converts function reference to name string (EXEC-03 at compiler level)
- Node.spawn_link passes link_flag=1 to snow_node_spawn
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/67-remote-spawn-llvm-integration/67-03-SUMMARY.md`
</output>
