---
phase: 66-remote-links-monitors-failure-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/actor/process.rs
  - crates/snow-rt/src/actor/link.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/actor/scheduler.rs
  - crates/snow-rt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Process struct has monitors and monitored_by fields (FxHashMap<u64, ProcessId>)"
    - "ExitReason has a Noconnection variant with encode/decode tag 6"
    - "DOWN_SIGNAL_TAG constant exists (u64::MAX - 1) alongside EXIT_SIGNAL_TAG"
    - "snow_process_monitor returns a unique u64 monitor ref and registers the monitor on both processes"
    - "snow_process_demonitor removes the monitor from both processes"
    - "When a local monitored process exits, all monitoring processes receive DOWN messages"
    - "Monitoring an already-dead process immediately delivers DOWN with noproc reason"
  artifacts:
    - path: "crates/snow-rt/src/actor/process.rs"
      provides: "Noconnection ExitReason variant, monitors/monitored_by fields on Process"
      contains: "Noconnection"
    - path: "crates/snow-rt/src/actor/link.rs"
      provides: "DOWN_SIGNAL_TAG, encode_down_signal, next_monitor_ref, encode_reason/decode_reason pub(crate)"
      contains: "DOWN_SIGNAL_TAG"
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "snow_process_monitor, snow_process_demonitor extern C APIs"
      contains: "snow_process_monitor"
    - path: "crates/snow-rt/src/actor/scheduler.rs"
      provides: "DOWN message delivery in handle_process_exit for monitored_by"
      contains: "monitored_by"
  key_links:
    - from: "crates/snow-rt/src/actor/mod.rs"
      to: "crates/snow-rt/src/actor/link.rs"
      via: "next_monitor_ref, encode_down_signal, DOWN_SIGNAL_TAG"
      pattern: "link::next_monitor_ref|link::encode_down_signal|link::DOWN_SIGNAL_TAG"
    - from: "crates/snow-rt/src/actor/scheduler.rs"
      to: "crates/snow-rt/src/actor/link.rs"
      via: "DOWN message delivery using encode_down_signal on process exit"
      pattern: "encode_down_signal.*monitored_by"
---

<objective>
Add process monitor infrastructure: monitors/monitored_by fields on Process, Noconnection ExitReason variant, DOWN_SIGNAL_TAG, monitor ref generation, snow_process_monitor/snow_process_demonitor APIs, and DOWN delivery on process exit.

Purpose: Foundation for all distributed fault tolerance -- remote monitors (Plan 02) and remote links (Plan 03) both depend on monitor fields, Noconnection reason, and DOWN message encoding.
Output: Working local process monitoring with DOWN messages, ready for remote extension.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-remote-links-monitors-failure-handling/66-RESEARCH.md

@crates/snow-rt/src/actor/process.rs
@crates/snow-rt/src/actor/link.rs
@crates/snow-rt/src/actor/mod.rs
@crates/snow-rt/src/actor/scheduler.rs
@crates/snow-rt/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add monitor fields to Process, Noconnection to ExitReason, and monitor helpers to link.rs</name>
  <files>crates/snow-rt/src/actor/process.rs, crates/snow-rt/src/actor/link.rs</files>
  <action>
In `process.rs`:
1. Add `use rustc_hash::FxHashMap;` to imports.
2. Add `Noconnection` variant to `ExitReason` enum after `Custom(String)`:
   ```rust
   /// Node connection lost -- the remote process may still be alive.
   /// Delivered to linked processes when the remote node disconnects.
   Noconnection,
   ```
3. Add two fields to the `Process` struct after `trap_exit`:
   ```rust
   /// Processes being monitored by this process. Maps monitor_ref -> monitored_pid.
   pub monitors: FxHashMap<u64, ProcessId>,
   /// Processes monitoring this process. Maps monitor_ref -> monitoring_pid.
   pub monitored_by: FxHashMap<u64, ProcessId>,
   ```
4. In `Process::new()`, initialize both fields with `FxHashMap::default()`.

In `link.rs`:
1. Add `use std::sync::atomic::{AtomicU64, Ordering};` to imports.
2. Add `DOWN_SIGNAL_TAG` constant:
   ```rust
   pub const DOWN_SIGNAL_TAG: u64 = u64::MAX - 1;
   ```
3. Add `next_monitor_ref()` function:
   ```rust
   pub fn next_monitor_ref() -> u64 {
       static MONITOR_REF_COUNTER: AtomicU64 = AtomicU64::new(1);
       MONITOR_REF_COUNTER.fetch_add(1, Ordering::Relaxed)
   }
   ```
4. Make `encode_reason` and `decode_reason` `pub(crate)` instead of private (Plans 02 and 03 need them for wire messages).
5. Add Noconnection handling to `encode_reason` (tag 6, just the tag byte, no payload):
   ```rust
   ExitReason::Noconnection => {
       data.push(6);
   }
   ```
6. Add Noconnection handling to `decode_reason` (tag 6):
   ```rust
   6 => Some((ExitReason::Noconnection, 1)),
   ```
7. Add `encode_down_signal` function:
   ```rust
   /// Encode a DOWN message for monitor notification.
   /// Layout: [u64 monitor_ref][u64 monitored_pid][reason bytes via encode_reason]
   pub fn encode_down_signal(monitor_ref: u64, monitored_pid: ProcessId, reason: &ExitReason) -> Vec<u8> {
       let mut data = Vec::new();
       data.extend_from_slice(&monitor_ref.to_le_bytes());
       data.extend_from_slice(&monitored_pid.0.to_le_bytes());
       encode_reason(&mut data, reason);
       data
   }
   ```

In `scheduler.rs`, update `invoke_terminate_callback` to handle Noconnection:
   Add `ExitReason::Noconnection => 6,` to the reason_tag match.
  </action>
  <verify>Run `cargo build -p snow-rt 2>&1 | tail -20` -- no errors. Run `cargo test -p snow-rt -- link:: 2>&1 | tail -20` -- all link tests pass. Verify Process::new compiles with the new FxHashMap fields.</verify>
  <done>Process has monitors/monitored_by FxHashMap fields. ExitReason has Noconnection variant with tag 6. DOWN_SIGNAL_TAG, next_monitor_ref, encode_down_signal, and pub(crate) encode_reason/decode_reason exist in link.rs.</done>
</task>

<task type="auto">
  <name>Task 2: Add snow_process_monitor/demonitor APIs and DOWN delivery on process exit</name>
  <files>crates/snow-rt/src/actor/mod.rs, crates/snow-rt/src/actor/scheduler.rs, crates/snow-rt/src/lib.rs</files>
  <action>
In `actor/mod.rs`:
1. Add `snow_process_monitor` extern "C" function:
   - Get current PID via `stack::get_current_pid()` (return 0 if None)
   - Generate `monitor_ref` via `link::next_monitor_ref()`
   - If target `ProcessId(target_pid)` is local (`node_id() == 0` or `is_local()`):
     - Look up target via `sched.get_process(target)`
     - If target not found OR target is already `Exited`: deliver DOWN immediately to caller with reason `Error("noproc")`, return monitor_ref
     - If target alive: insert `(monitor_ref, target)` into caller's `monitors`, insert `(monitor_ref, my_pid)` into target's `monitored_by`
   - If target is remote: for now, just record `(monitor_ref, target)` in caller's `monitors` (remote DIST_MONITOR will be added in Plan 02)
   - Return `monitor_ref`

2. Add `snow_process_demonitor` extern "C" function:
   - Signature: `fn snow_process_demonitor(monitor_ref: u64) -> u64` (returns 0 on success, 1 on failure)
   - Get current PID, look up caller process
   - Remove `monitor_ref` from caller's `monitors` to get the `monitored_pid`
   - If monitored_pid is local, look up target process and remove `monitor_ref` from its `monitored_by`
   - Return 0

In `scheduler.rs`, modify `handle_process_exit`:
After step 2 (propagate exit signals to linked processes), add step 2.5:
   - Under the process lock, extract `monitored_by` with `std::mem::take(&mut proc.monitored_by)` (same pattern as extracting `links`)
   - Actually: extract `monitored_by` alongside `terminate_cb` and `linked_pids` in the initial lock. Add it to the tuple: `(terminate_cb, linked_pids, monitored_by_entries)`.
   - After propagating exit to links (step 2), iterate `monitored_by_entries`:
     ```rust
     for (monitor_ref, monitoring_pid) in &monitored_by_entries {
         if let Some(mon_proc_arc) = process_table.read().get(&monitoring_pid) {
             let mut mon_proc = mon_proc_arc.lock();
             // Remove the monitor ref from the monitoring process's monitors map
             mon_proc.monitors.remove(monitor_ref);
             // Deliver DOWN message
             let down_data = link::encode_down_signal(*monitor_ref, pid, &reason);
             let buffer = MessageBuffer::new(down_data, link::DOWN_SIGNAL_TAG);
             mon_proc.mailbox.push(Message { buffer });
             if matches!(mon_proc.state, ProcessState::Waiting) {
                 mon_proc.state = ProcessState::Ready;
                 // Note: we'll wake after dropping the lock
             }
         }
     }
     ```
   - Note: import `link::DOWN_SIGNAL_TAG` and `link::encode_down_signal` in scheduler.rs
   - Note: import `MessageBuffer` and `Message` from `super::heap` and `super::process` as needed

In `lib.rs`:
   Add `snow_process_monitor, snow_process_demonitor` to the `pub use actor::{...}` re-export.
  </action>
  <verify>Run `cargo build -p snow-rt 2>&1 | tail -20` -- no errors. Run `cargo test -p snow-rt 2>&1 | tail -5` -- all tests pass (including existing link tests, scheduler tests).</verify>
  <done>snow_process_monitor returns a unique ref and registers monitor bidirectionally. snow_process_demonitor removes the monitor. When a monitored process exits, all monitoring processes receive DOWN messages with the exit reason. Monitoring a dead/nonexistent process delivers DOWN(noproc) immediately.</done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
cargo build -p snow-rt 2>&1 | tail -5

# All existing tests pass (no regressions)
cargo test -p snow-rt 2>&1 | tail -10

# Verify new types/functions exist
grep -n "Noconnection" crates/snow-rt/src/actor/process.rs
grep -n "DOWN_SIGNAL_TAG" crates/snow-rt/src/actor/link.rs
grep -n "next_monitor_ref" crates/snow-rt/src/actor/link.rs
grep -n "snow_process_monitor" crates/snow-rt/src/actor/mod.rs
grep -n "snow_process_demonitor" crates/snow-rt/src/actor/mod.rs
grep -n "monitored_by" crates/snow-rt/src/actor/scheduler.rs
```
</verification>

<success_criteria>
1. Process struct has `monitors: FxHashMap<u64, ProcessId>` and `monitored_by: FxHashMap<u64, ProcessId>` fields
2. ExitReason::Noconnection variant exists with encode/decode tag 6
3. DOWN_SIGNAL_TAG = u64::MAX - 1 constant in link.rs
4. next_monitor_ref() generates unique u64 refs
5. encode_down_signal encodes [monitor_ref, monitored_pid, reason]
6. snow_process_monitor creates bidirectional monitor registration, returns ref
7. snow_process_demonitor removes monitor from both sides
8. handle_process_exit delivers DOWN messages to all monitoring processes
9. Monitoring a dead process delivers DOWN(noproc) immediately
10. All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/66-remote-links-monitors-failure-handling/66-01-SUMMARY.md`
</output>
