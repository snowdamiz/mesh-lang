---
phase: 39-cross-module-type-checking
plan: 02
type: execute
wave: 2
depends_on: ["39-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
autonomous: true
must_haves:
  truths:
    - "import Math.Vector makes Vector available as a qualified namespace; Vector.add(a, b) resolves to the add function from that module's exports"
    - "from Math.Vector import { add, scale } injects add and scale into the local TypeEnv as unqualified names"
    - "import NonExistent produces a TypeError::ImportModuleNotFound error"
    - "from Math.Vector import { nonexistent } produces a TypeError::ImportNameNotFound error"
    - "Existing stdlib imports (import String, from String import length) continue working unchanged"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Extended ImportDecl handling with user module check, extended FromImportDecl with user module check + error reporting, extended infer_field_access with qualified_modules map"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs (infer_item ImportDecl)"
      to: "ImportContext.module_exports"
      via: "Populate qualified_modules map from import_ctx when ImportDecl processed"
      pattern: "import_ctx\\.module_exports\\.get"
    - from: "crates/snow-typeck/src/infer.rs (infer_item FromImportDecl)"
      to: "ImportContext.module_exports"
      via: "Look up imported names in module exports, fall back to stdlib"
      pattern: "import_ctx\\.module_exports\\.get"
    - from: "crates/snow-typeck/src/infer.rs (infer_field_access)"
      to: "qualified_modules map"
      via: "Check user module namespace before stdlib for Foo.bar() access"
      pattern: "qualified_modules\\.get"
---

<objective>
Extend the inference engine to resolve user-defined module imports and qualified access. When `import Foo` is encountered, Foo becomes a namespace for qualified access (Foo.bar()). When `from Foo import { bar }` is encountered, bar is injected into local scope. Emit import errors for non-existent modules and names.

Purpose: This is the behavioral change that makes cross-module type checking work. Plan 01 added the data types and entry points; this plan wires them into the inference logic so imports actually resolve against user-defined modules.

Output: Modified infer.rs with working import resolution for both qualified and selective imports, error reporting for bad imports, and backward-compatible stdlib fallback.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-cross-module-type-checking/39-RESEARCH.md
@.planning/phases/39-cross-module-type-checking/39-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ImportDecl and FromImportDecl handling to resolve user-defined modules</name>
  <files>
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
This task modifies `infer_item` (and the main inference loop) to support user-defined module imports via the `ImportContext` passed in from `infer_with_imports`.

**Threading qualified_modules through inference:**

The `qualified_modules` map tracks which module names are available for qualified access (e.g., `Vector.add()`). It must be populated when `ImportDecl` items are processed and read when `infer_field_access` resolves `Foo.bar` expressions.

Add a `qualified_modules: &mut FxHashMap<String, FxHashMap<String, Scheme>>` parameter to `infer_item`. This map is populated during ImportDecl processing and read during field access resolution.

In `infer_with_imports`, declare `qualified_modules` before the main loop:
```rust
let mut qualified_modules: FxHashMap<String, FxHashMap<String, Scheme>> = FxHashMap::default();
```
Pass `&mut qualified_modules` to `infer_item`.

**Modify the ImportDecl match arm (around line 1391):**

Replace the current no-op handling:
```rust
Item::ImportDecl(ref import_decl) => {
    // Resolve import: check user modules first, then stdlib
    if let Some(path) = import_decl.module_path() {
        let segments = path.segments();
        let full_name = segments.join(".");
        let last_segment = segments.last().cloned().unwrap_or_default();

        // Check user-defined modules via ImportContext
        if let Some(mod_exports) = import_ctx.module_exports.get(&last_segment) {
            // Register the module namespace for qualified access
            qualified_modules.insert(last_segment.clone(), mod_exports.functions.clone());
            // Also register struct constructor functions for qualified access
            for (name, struct_def) in &mod_exports.struct_defs {
                let struct_ty = if struct_def.generic_params.is_empty() {
                    Ty::struct_ty(name, vec![])
                } else {
                    let type_args: Vec<Ty> = struct_def.generic_params.iter()
                        .map(|_| ctx.fresh_var()).collect();
                    Ty::struct_ty(name, type_args)
                };
                qualified_modules.entry(last_segment.clone())
                    .or_default()
                    .insert(name.clone(), Scheme::mono(struct_ty));
            }
            // Register sum type variant constructors for qualified access
            for (_name, sum_def) in &mod_exports.sum_type_defs {
                for variant in &sum_def.variants {
                    // Each variant constructor is already in mod_exports.functions
                    // (registered during the exporting module's type check).
                    // If not, add them explicitly.
                }
            }
        } else if is_stdlib_module(&last_segment) {
            // Stdlib module -- already handled in infer_field_access
            // No action needed (backward compat)
        } else {
            // IMPORT-06: Module not found
            ctx.errors.push(TypeError::ImportModuleNotFound {
                module_name: full_name,
                span: import_decl.syntax().text_range(),
                suggestion: None, // Could add fuzzy matching later
            });
        }
    }
    None
}
```

**Modify the FromImportDecl match arm (around line 1397):**

Replace the current stdlib-only handling:
```rust
Item::FromImportDecl(ref from_import) => {
    if let Some(path) = from_import.module_path() {
        let segments = path.segments();
        let full_name = segments.join(".");
        let last_segment = segments.last().cloned().unwrap_or_default();

        // Check user-defined modules first
        if let Some(mod_exports) = import_ctx.module_exports.get(&last_segment) {
            if let Some(import_list) = from_import.import_list() {
                for name_node in import_list.names() {
                    if let Some(name) = name_node.text() {
                        // Check functions
                        if let Some(scheme) = mod_exports.functions.get(&name) {
                            env.insert(name.clone(), scheme.clone());
                        }
                        // Check struct constructors
                        else if let Some(struct_def) = mod_exports.struct_defs.get(&name) {
                            let struct_ty = if struct_def.generic_params.is_empty() {
                                Ty::struct_ty(&name, vec![])
                            } else {
                                let type_args: Vec<Ty> = struct_def.generic_params.iter()
                                    .map(|_| ctx.fresh_var()).collect();
                                Ty::struct_ty(&name, type_args)
                            };
                            env.insert(name.clone(), Scheme::mono(struct_ty));
                            // Also register the struct in type_registry if not already there
                            type_registry.register_struct(struct_def.clone());
                        }
                        // Check sum type names (importing sum type brings constructors)
                        else if let Some(sum_def) = mod_exports.sum_type_defs.get(&name) {
                            type_registry.register_sum_type(sum_def.clone());
                            register_variant_constructors(
                                ctx, env,
                                &sum_def.name,
                                &sum_def.generic_params,
                                &sum_def.variants,
                            );
                        }
                        // Check if it's a variant constructor name (in functions map)
                        // Variant constructors like "Circle" are stored in the exporting
                        // module's functions map with their constructor scheme.
                        else {
                            // IMPORT-07: Name not found in module
                            let available: Vec<String> = mod_exports.functions.keys()
                                .chain(mod_exports.struct_defs.keys())
                                .chain(mod_exports.sum_type_defs.keys())
                                .cloned()
                                .collect();
                            ctx.errors.push(TypeError::ImportNameNotFound {
                                module_name: full_name.clone(),
                                name: name.clone(),
                                span: name_node.syntax().text_range(),
                                available,
                            });
                        }
                    }
                }
            }
        } else {
            // Fall back to stdlib modules (backward compat)
            let modules = stdlib_modules();
            if let Some(first_segment) = segments.first() {
                if let Some(mod_exports) = modules.get(first_segment.as_str()) {
                    if let Some(import_list) = from_import.import_list() {
                        for name_node in import_list.names() {
                            if let Some(name) = name_node.text() {
                                if let Some(scheme) = mod_exports.get(&name) {
                                    env.insert(name.clone(), scheme.clone());
                                    let prefixed = format!(
                                        "{}_{}",
                                        first_segment.to_lowercase(),
                                        name
                                    );
                                    env.insert(prefixed, scheme.clone());
                                }
                            }
                        }
                    }
                } else {
                    // Not a user module, not a stdlib module -> error
                    ctx.errors.push(TypeError::ImportModuleNotFound {
                        module_name: full_name,
                        span: from_import.syntax().text_range(),
                        suggestion: None,
                    });
                }
            }
        }
    }
    None
}
```

**CRITICAL: Backward compatibility.** The stdlib fallback must work exactly as before. Test by running all existing tests. The key pattern is: check user modules first (via import_ctx.module_exports), if not found check stdlib_modules(), if neither found emit error. When import_ctx is empty (single-file builds), the user module check finds nothing and falls through to stdlib -- identical to old behavior.

**Note on `infer_item` signature changes:** The function must now also accept `qualified_modules: &mut FxHashMap<String, FxHashMap<String, Scheme>>` in addition to the `import_ctx: &ImportContext` from Plan 01. Thread this parameter through all callers of `infer_item`.
  </action>
  <verify>
Run `cargo check -p snow-typeck` -- must compile.
Run `cargo test --workspace` -- ALL existing tests must pass. This is the critical backward compatibility check.
  </verify>
  <done>
ImportDecl populates qualified_modules from import_ctx.module_exports. FromImportDecl injects imported names into env from user modules, falls back to stdlib. ImportModuleNotFound emitted for unknown modules. ImportNameNotFound emitted for unknown names. All existing stdlib import tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend infer_field_access to resolve qualified access against user-defined modules</name>
  <files>
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
**Extend `infer_field_access` to check user-defined module namespaces.**

The function currently checks `is_stdlib_module(&base_name)` at line 4248 for qualified access like `String.length`. Add a check for user-defined modules BEFORE the stdlib check.

Add `qualified_modules: &FxHashMap<String, FxHashMap<String, Scheme>>` to the `infer_field_access` function signature.

In the block starting at line 4246 where `if let Expr::NameRef(ref name_ref) = base_expr`, add user module check BEFORE the existing stdlib check:

```rust
if let Expr::NameRef(ref name_ref) = base_expr {
    if let Some(base_name) = name_ref.text() {
        // Check user-defined modules first (from import context)
        if let Some(mod_fns) = qualified_modules.get(&base_name) {
            if let Some(scheme) = mod_fns.get(&field_name) {
                let ty = ctx.instantiate(scheme);
                return Ok(ty);
            }
            // Module exists but field not found -- could be a struct/sum type access
            // Fall through to existing checks below
        }

        // Then check stdlib modules (existing behavior)
        if is_stdlib_module(&base_name) {
            // ... existing code unchanged ...
        }
        // ... rest of existing checks (service, sum type variant) unchanged ...
    }
}
```

**Threading qualified_modules through call sites:**

1. `infer_field_access` is called from `infer_expr` (around line 2419) and from method resolution (around line 2720). Add `qualified_modules` to these call sites.

2. `infer_expr` must also receive `qualified_modules` as a parameter. Thread it through all callers of `infer_expr`:
   - `infer_item` calls `infer_expr` indirectly through various helpers
   - The main loop in `infer_with_imports` calls `infer_expr` directly for bare expressions

3. The threading chain is: `infer_with_imports` -> `infer_item` / `infer_expr` -> `infer_field_access`. All functions in this chain need the `qualified_modules` parameter added.

**IMPORTANT:** This is a large number of function signature changes since `infer_expr` is called from many places. The practical approach: add `qualified_modules: &FxHashMap<String, FxHashMap<String, Scheme>>` to `infer_expr`, `infer_field_access`, and every function that calls them. Many helper functions call `infer_expr` recursively (infer_if, infer_call, infer_case, infer_closure, etc.). Each must have the parameter threaded through.

**Alternative approach (simpler but less clean):** Store `qualified_modules` on the `InferCtx` struct instead of passing it as a parameter. Add a field `pub qualified_modules: FxHashMap<String, FxHashMap<String, Scheme>>` to `InferCtx`. Populate it in `infer_with_imports` before the main loop (initially empty, filled by ImportDecl processing). Access it via `ctx.qualified_modules` in `infer_field_access`. This avoids changing dozens of function signatures.

**Choose the InferCtx approach** -- it is far simpler and avoids a cascade of signature changes across 6000+ lines of infer.rs. The tradeoff (slightly less explicit data flow) is worth the implementation simplicity.

Steps:
1. Add `pub qualified_modules: FxHashMap<String, FxHashMap<String, Scheme>>` field to `InferCtx` in `crates/snow-typeck/src/unify.rs`.
2. Initialize it to `FxHashMap::default()` in `InferCtx::new()`.
3. In `infer_with_imports`: instead of a local `qualified_modules`, use `ctx.qualified_modules`.
4. In `infer_item` ImportDecl arm: populate `ctx.qualified_modules` instead of a local map.
5. In `infer_field_access`: check `ctx.qualified_modules` before `is_stdlib_module`.
6. Remove the local `qualified_modules` from function parameters (not needed since it's on ctx).

This approach minimizes code churn while achieving the same behavior.
  </action>
  <verify>
Run `cargo check -p snow-typeck` -- must compile.
Run `cargo test --workspace` -- ALL existing tests must pass.
Write a quick unit test (or rely on E2E tests in Plan 03) that verifies:
- When qualified_modules contains {"Vector": {"add": fn(Int, Int) -> Int}}, then infer_field_access resolves Vector.add to the correct type.
  </verify>
  <done>
infer_field_access checks ctx.qualified_modules for user-defined module namespaces before checking stdlib modules. ImportDecl processing populates ctx.qualified_modules. Qualified access `Vector.add(a, b)` resolves to the function scheme from the module's exports. Stdlib qualified access (String.length, etc.) still works. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p snow-typeck` compiles
2. `cargo test --workspace` -- zero regressions from all existing tests
3. Import resolution chain:
   - ImportDecl with user module -> populates qualified_modules
   - ImportDecl with stdlib module -> no-op (handled in field access)
   - ImportDecl with unknown module -> ImportModuleNotFound error
   - FromImportDecl with user module -> injects names into env
   - FromImportDecl with stdlib module -> existing behavior (backward compat)
   - FromImportDecl with unknown module -> ImportModuleNotFound error
   - FromImportDecl with unknown name -> ImportNameNotFound error
4. Qualified access: Vector.add() checks ctx.qualified_modules before stdlib
</verification>

<success_criteria>
- User module imports resolved from ImportContext.module_exports
- Stdlib imports work identically to before
- Import error variants emitted for non-existent modules/names
- Qualified access works for both user and stdlib modules
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/39-cross-module-type-checking/39-02-SUMMARY.md`
</output>
