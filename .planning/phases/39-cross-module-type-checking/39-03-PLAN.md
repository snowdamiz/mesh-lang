---
phase: 39-cross-module-type-checking
plan: 03
type: execute
wave: 3
depends_on: ["39-01", "39-02"]
files_modified:
  - crates/snowc/src/main.rs
  - crates/snowc/tests/e2e.rs
autonomous: true
must_haves:
  truths:
    - "snowc build type-checks ALL modules in topological order, not just the entry module"
    - "import Math.Vector brings Vector into scope; Vector.add(a, b) calls the function from that module"
    - "from Math.Vector import { add, scale } makes add(a, b) callable without qualification"
    - "A struct defined in module A can be constructed and field-accessed in module B after import"
    - "A sum type defined in module A can be pattern-matched in module B after import"
    - "Trait impls defined in any module are visible across all modules without explicit import"
    - "import NonExistent produces a clear error"
    - "from Foo import { nonexistent } produces a clear error"
    - "Existing single-file programs compile identically (zero regressions)"
  artifacts:
    - path: "crates/snowc/src/main.rs"
      provides: "Accumulator-pattern build pipeline: type-check all modules, collect exports, build ImportContext per module"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E tests for cross-module functions, structs, sum types, traits, and error cases"
  key_links:
    - from: "crates/snowc/src/main.rs (build)"
      to: "snow_typeck::check_with_imports"
      via: "Type-check each module with ImportContext from upstream exports"
      pattern: "snow_typeck::check_with_imports"
    - from: "crates/snowc/src/main.rs (build)"
      to: "snow_typeck::collect_exports"
      via: "Collect exports after each module type-check for downstream use"
      pattern: "snow_typeck::collect_exports"
    - from: "crates/snowc/src/main.rs (build_import_context)"
      to: "ImportContext"
      via: "Constructs ImportContext from all_exports for a specific module"
      pattern: "ImportContext"
---

<objective>
Integrate cross-module type checking into the snowc build pipeline and validate with comprehensive E2E tests. The build() function will type-check ALL modules in topological order using the accumulator pattern, building an ImportContext per module from already-checked dependency exports.

Purpose: This is where all the typeck infrastructure from Plans 01-02 becomes real. The build pipeline orchestrates cross-module type checking, and E2E tests prove that functions, structs, sum types, and traits work across module boundaries.

Output: Modified build() with accumulator pattern, build_import_context helper, and 8+ E2E tests covering all cross-module requirements.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-cross-module-type-checking/39-RESEARCH.md
@.planning/phases/39-cross-module-type-checking/39-01-SUMMARY.md
@.planning/phases/39-cross-module-type-checking/39-02-SUMMARY.md
@crates/snowc/src/main.rs
@crates/snowc/src/discovery.rs
@crates/snowc/tests/e2e.rs
@crates/snow-typeck/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify build() to type-check all modules with accumulator pattern</name>
  <files>
    crates/snowc/src/main.rs
  </files>
  <action>
Replace the current "type-check entry module only" section of `build()` (lines 286-295) with the accumulator pattern that type-checks ALL modules in topological order.

**Add a helper function `build_import_context`:**

```rust
/// Build an ImportContext for a module from already-checked dependency exports.
///
/// Reads the module's import declarations to determine which modules are imported,
/// then constructs an ImportContext with the exports of those modules. Trait defs
/// and impls from ALL already-checked modules are included (XMOD-05: globally visible).
fn build_import_context(
    graph: &snow_common::module_graph::ModuleGraph,
    all_exports: &[Option<snow_typeck::ExportedSymbols>],
    parse: &snow_parser::Parse,
    module_id: snow_common::module_graph::ModuleId,
) -> snow_typeck::ImportContext {
    use snow_parser::ast::item::Item;
    use snow_typeck::{ImportContext, ModuleExports};

    let mut ctx = ImportContext::empty();

    // Collect ALL trait defs and impls from ALL already-checked modules (XMOD-05)
    for exports_opt in all_exports.iter() {
        if let Some(exports) = exports_opt {
            ctx.all_trait_defs.extend(exports.trait_defs.iter().cloned());
            ctx.all_trait_impls.extend(exports.trait_impls.iter().cloned());
        }
    }

    // For each import declaration in this module, find the corresponding
    // module's exports and add them to the ImportContext.
    let tree = parse.tree();
    for item in tree.items() {
        let segments = match &item {
            Item::ImportDecl(import_decl) => {
                import_decl.module_path().map(|p| p.segments())
            }
            Item::FromImportDecl(from_import) => {
                from_import.module_path().map(|p| p.segments())
            }
            _ => None,
        };

        if let Some(segments) = segments {
            let full_name = segments.join(".");
            let last_segment = segments.last().cloned().unwrap_or_default();

            // Look up the module in the graph
            if let Some(dep_id) = graph.resolve(&full_name) {
                let idx = dep_id.0 as usize;
                if let Some(Some(exports)) = all_exports.get(idx) {
                    // Build ModuleExports from ExportedSymbols
                    let mod_exports = ModuleExports {
                        module_name: full_name.clone(),
                        functions: exports.functions.clone(),
                        struct_defs: exports.struct_defs.clone(),
                        sum_type_defs: exports.sum_type_defs.clone(),
                    };
                    ctx.module_exports.insert(last_segment, mod_exports);
                }
            }
            // If module not found in graph, that's fine -- the type checker
            // will emit ImportModuleNotFound when it processes the import.
        }
    }

    ctx
}
```

**Replace the type-check section of build():**

Remove lines 286-295 (the "Type-check the entry module only" section) and replace with:

```rust
// Type-check ALL modules in topological order (Phase 39)
let module_count = project.graph.module_count();
let mut all_exports: Vec<Option<snow_typeck::ExportedSymbols>> = (0..module_count).map(|_| None).collect();
let mut all_typeck: Vec<Option<snow_typeck::TypeckResult>> = (0..module_count).map(|_| None).collect();
let mut has_type_errors = false;

for &id in &project.compilation_order {
    let idx = id.0 as usize;
    let parse = &project.module_parses[idx];
    let source = &project.module_sources[idx];
    let module_path = dir.join(&project.graph.get(id).path);

    // Build ImportContext from already-checked dependencies
    let import_ctx = build_import_context(
        &project.graph,
        &all_exports,
        parse,
        id,
    );

    // Type-check this module with imports
    let typeck = snow_typeck::check_with_imports(parse, &import_ctx);

    // Report type-check diagnostics for this module
    let file_name = module_path.display().to_string();
    for error in &typeck.errors {
        has_type_errors = true;
        let rendered = snow_typeck::diagnostics::render_diagnostic(
            error, source, &file_name, diag_opts, None,
        );
        eprint!("{}", rendered);
    }

    // Report warnings
    for warning in &typeck.warnings {
        let rendered = snow_typeck::diagnostics::render_diagnostic(
            warning, source, &file_name, diag_opts, None,
        );
        eprint!("{}", rendered);
    }

    // Collect exports for downstream modules
    let exports = snow_typeck::collect_exports(parse, &typeck);
    all_exports[idx] = Some(exports);
    all_typeck[idx] = Some(typeck);
}

if has_type_errors {
    return Err("Compilation failed due to errors above.".to_string());
}

// Find entry module for codegen
let entry_idx = entry_id.0 as usize;
let entry_parse = &project.module_parses[entry_idx];
let entry_typeck = all_typeck[entry_idx].as_ref()
    .ok_or("Entry module was not type-checked")?;
```

**Also update the codegen section** (around line 315) to use `entry_typeck` (a reference) instead of the old `typeck` (owned). The codegen functions take `&TypeckResult`, so this should work. Change:
```rust
// Old:
snow_codegen::compile_to_binary(entry_parse, &typeck, &output_path, opt_level, target, None)?;
// New:
snow_codegen::compile_to_binary(entry_parse, entry_typeck, &output_path, opt_level, target, None)?;
```

Same for the `emit_llvm` section:
```rust
snow_codegen::compile_to_llvm_ir(entry_parse, entry_typeck, &ll_path, target)?;
```

**Remove the old `report_diagnostics` call for entry module** -- diagnostics are now reported in the per-module loop above. The `report_diagnostics` helper function can remain in the file (it's still used for the old per-module parse error reporting pattern), but it's no longer called in the type-check path.

**IMPORTANT:** The `report_diagnostics` function is NOT called for type checking anymore because we now report per-module type errors directly in the loop. However, the parse error loop at lines 236-283 still handles parse errors. Do NOT change the parse error loop -- it already handles all modules correctly.
  </action>
  <verify>
Run `cargo check -p snowc` -- must compile.
Run `cargo test --workspace` -- ALL existing tests must pass. This is the most critical check: single-file programs must compile identically.
  </verify>
  <done>
build() type-checks ALL modules in topological order using accumulator pattern. ImportContext is built per module from upstream exports. Diagnostics are reported per module. Entry module is compiled to binary. Single-file programs work identically (ImportContext is empty when no user modules are imported).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add E2E tests for cross-module type checking</name>
  <files>
    crates/snowc/tests/e2e.rs
  </files>
  <action>
Add comprehensive E2E tests to `crates/snowc/tests/e2e.rs` that validate all Phase 39 requirements. Use `tempfile::TempDir` and the multi-file project pattern established in Phase 38.

Each test creates a temp directory with multiple `.snow` files, writes them, calls `snowc build`, and checks the result (success or expected error output).

**Test 1: cross_module_qualified_function_call (XMOD-01, IMPORT-01)**
```
// math.snow
fn add(a :: Int, b :: Int) :: Int = a + b
fn mul(a :: Int, b :: Int) :: Int = a * b

// main.snow
import Math

fn main() :: Int =
  Math.add(2, 3)
```
- Place `math.snow` in the root directory (module name "Math")
- Expected: builds successfully, exit code 0

**Test 2: cross_module_selective_import (XMOD-02, IMPORT-02)**
```
// math.snow
fn add(a :: Int, b :: Int) :: Int = a + b
fn mul(a :: Int, b :: Int) :: Int = a * b

// main.snow
from Math import { add }

fn main() :: Int =
  add(10, 20)
```
- Expected: builds successfully

**Test 3: cross_module_struct (XMOD-03)**
```
// point.snow
struct Point { x :: Int, y :: Int }

fn origin() :: Point = Point { x: 0, y: 0 }

// main.snow
import Point

fn main() :: Int =
  let p = Point.origin()
  p.x
```
- Expected: builds successfully. Tests struct construction via qualified access and field access.

**Test 4: cross_module_sum_type (XMOD-04)**
```
// shapes.snow
type Shape = Circle(Int) | Rectangle(Int, Int)

fn area(s :: Shape) :: Int =
  case s do
    Circle(r) -> r * r
    Rectangle(w, h) -> w * h
  end

// main.snow
from Shapes import { Shape, Circle, Rectangle, area }

fn main() :: Int =
  let c = Circle(5)
  area(c)
```
- Expected: builds successfully. Tests sum type import with variant constructors and pattern matching.

Note: `from Shapes import { Shape, Circle, Rectangle, area }` -- importing Shape brings the type; importing Circle, Rectangle brings variant constructors (which are functions in the exports). If the variant constructors are already registered as part of importing the sum type definition, then importing `Shape` alone may suffice. But the explicit import is safer. If the implementation registers variant constructors when the sum type is pre-seeded (in infer_with_imports), then `Circle` and `Rectangle` are already in scope. Test both patterns.

Alternative simpler test if selective import of variants is tricky:
```
// shapes.snow
type Shape = Circle(Int) | Rectangle(Int, Int)

// main.snow
import Shapes

fn main() :: Int =
  let c = Shapes.Circle(5)
  42
```
-- Hmm, variant constructors via qualified access (Shapes.Circle) may not work if they're not in the qualified_modules functions map. Use whichever approach the implementation supports.

**Test 5: cross_module_trait_impls_visible (XMOD-05)**
```
// displayable.snow
interface Showable do
  fn show(self) :: String
end

struct Greeting { msg :: String }

impl Showable for Greeting do
  fn show(self) :: String = self.msg
end

// main.snow
import Displayable

fn main() :: String =
  let g = Displayable.Greeting { msg: "hello" }
  g.show()
```
- Expected: builds successfully. The Showable trait impl for Greeting is visible in main without explicit import.

Actually, this test needs to be adjusted. Trait impls are globally visible (XMOD-05), so main.snow should be able to call `.show()` on an imported `Greeting` even if main does not import the `Showable` trait. The trait impl is pre-seeded via ImportContext.all_trait_impls.

**Test 6: import_nonexistent_module_error (IMPORT-06)**
```
// main.snow
import NonExistent

fn main() :: Int = 42
```
- Expected: build fails with error containing "not found" and "NonExistent"

**Test 7: import_nonexistent_name_error (IMPORT-07)**
```
// math.snow
fn add(a :: Int, b :: Int) :: Int = a + b

// main.snow
from Math import { subtract }

fn main() :: Int = 42
```
- Expected: build fails with error containing "not exported" or "not found" and "subtract"

**Test 8: nested_module_qualified_access**
```
// math/vector.snow (nested in math/ directory)
fn dot(a :: Int, b :: Int) :: Int = a * b

// main.snow
import Math.Vector

fn main() :: Int =
  Vector.dot(3, 4)
```
- Expected: builds successfully. Tests that nested module paths work with qualified access.

**Implementation notes:**
- Use the pattern from existing multi-file E2E tests (Phase 38) for creating temp dirs and running the build
- Each test should create a `TempDir`, write `.snow` files into it, and call the build function (or the `snowc build` CLI)
- For tests expecting success, check exit code 0 or no errors
- For tests expecting failure, check that stderr contains the expected error message
- Make sure to create subdirectories for nested module tests (e.g., `math/vector.snow`)

CRITICAL: Use only valid Snow syntax. Snow uses:
- `::` for type annotations (not `:`)
- `fn name(params) :: RetType = body` for functions
- `do ... end` for blocks in case/impl/interface
- `println("text")` (not IO.puts)
- `struct Name { field :: Type }` (not `field: Type`)
- Struct literal: `Name { field: value }` (colon for values, double-colon for types)
- Import: `import ModuleName` and `from ModuleName import { name1, name2 }`
  </action>
  <verify>
Run `cargo test --workspace` -- ALL tests must pass, including the new cross-module tests.
Run the new tests individually to verify they exercise the cross-module type checking:
```
cargo test -p snowc --test e2e cross_module
cargo test -p snowc --test e2e import_nonexistent
cargo test -p snowc --test e2e nested_module
```
  </verify>
  <done>
8+ E2E tests pass covering:
- Qualified function calls across modules (XMOD-01, IMPORT-01)
- Selective imports with unqualified calls (XMOD-02, IMPORT-02)
- Cross-module struct construction and field access (XMOD-03)
- Cross-module sum type pattern matching (XMOD-04)
- Globally visible trait impls (XMOD-05)
- Import error for non-existent module (IMPORT-06)
- Import error for non-existent name (IMPORT-07)
- Nested module qualified access
All existing tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (existing + new)
2. Phase 39 success criteria from ROADMAP.md:
   - `import Math.Vector` brings `Vector` into scope; `Vector.add(a, b)` calls the function from that module
   - `from Math.Vector import { add, scale }` makes `add(a, b)` callable without qualification
   - A struct defined in module A can be constructed and field-accessed in module B after import
   - A sum type defined in module A can be pattern-matched with exhaustiveness checking in module B after import
   - Trait impls defined in any module are visible across all modules without explicit import
3. Single-file programs compile identically (zero regressions)
4. Import errors reported for non-existent modules and names
</verification>

<success_criteria>
- All 5 ROADMAP success criteria for Phase 39 are met
- All 9 ROADMAP requirements (IMPORT-01, IMPORT-02, IMPORT-06, IMPORT-07, XMOD-01-05) are covered by E2E tests
- All existing tests pass unchanged
- build() uses accumulator pattern with check_with_imports for all modules
</success_criteria>

<output>
After completion, create `.planning/phases/39-cross-module-type-checking/39-03-SUMMARY.md`
</output>
