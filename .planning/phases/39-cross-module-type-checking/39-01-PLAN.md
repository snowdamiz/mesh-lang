---
phase: 39-cross-module-type-checking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/lib.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/traits.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
autonomous: true
must_haves:
  truths:
    - "ImportContext, ModuleExports, and ExportedSymbols types exist with correct fields"
    - "check_with_imports() accepts a parse and ImportContext and returns TypeckResult"
    - "collect_exports() extracts function schemes, struct defs, sum type defs, trait defs, and trait impls from a TypeckResult"
    - "TypeError::ImportModuleNotFound and TypeError::ImportNameNotFound variants exist with spans"
    - "TraitRegistry exposes accessor methods for extracting trait defs and impls"
    - "TypeRegistry::register_struct and register_sum_type are pub"
    - "register_variant_constructors is pub and callable from outside infer.rs"
  artifacts:
    - path: "crates/snow-typeck/src/lib.rs"
      provides: "ImportContext, ModuleExports, ExportedSymbols types, check_with_imports, collect_exports"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "infer_with_imports entry point, pub register_variant_constructors, pub TypeRegistry methods"
    - path: "crates/snow-typeck/src/traits.rs"
      provides: "trait_defs() and trait_impls() accessor methods on TraitRegistry"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "ImportModuleNotFound, ImportNameNotFound TypeError variants"
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Diagnostic rendering for new import error variants"
  key_links:
    - from: "crates/snow-typeck/src/lib.rs"
      to: "crates/snow-typeck/src/infer.rs"
      via: "check_with_imports calls infer_with_imports"
      pattern: "infer::infer_with_imports"
    - from: "crates/snow-typeck/src/lib.rs"
      to: "crates/snow-typeck/src/traits.rs"
      via: "ImportContext uses TraitDef and ImplDef types"
      pattern: "traits::TraitDef"
---

<objective>
Add the cross-module type checking foundation to snow-typeck: data types for import contexts and exports, the check_with_imports entry point, export collection, new error variants, and visibility changes to enable external pre-seeding of TypeEnv/TypeRegistry/TraitRegistry.

Purpose: Without these types and entry points, the build pipeline (Plan 02/03) cannot orchestrate cross-module type checking. This plan creates the interface contract that the accumulator pattern relies on.

Output: ImportContext/ExportedSymbols types, check_with_imports/collect_exports functions, new TypeError variants with diagnostics, pub accessors on TraitRegistry and TypeRegistry.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-cross-module-type-checking/39-RESEARCH.md
@crates/snow-typeck/src/lib.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/traits.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ImportContext, ExportedSymbols, check_with_imports, and collect_exports to snow-typeck</name>
  <files>
    crates/snow-typeck/src/lib.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/traits.rs
  </files>
  <action>
**In crates/snow-typeck/src/traits.rs:**

Add two public accessor methods to `TraitRegistry`:

```rust
/// Return all registered trait definitions.
pub fn trait_defs(&self) -> impl Iterator<Item = &TraitDef> {
    self.traits.values()
}

/// Return all registered trait impls (flattened across all traits).
pub fn all_impls(&self) -> impl Iterator<Item = &ImplDef> {
    self.impls.values().flat_map(|v| v.iter())
}
```

**In crates/snow-typeck/src/infer.rs:**

1. Make `TypeRegistry::register_struct` and `TypeRegistry::register_sum_type` public by adding `pub` to their signatures (around lines 129 and 137). Also make `TypeRegistry::new()` public (around line 125).

2. Make `register_variant_constructors` public by changing `fn register_variant_constructors(` to `pub fn register_variant_constructors(` (around line 768). This function must be callable from lib.rs for pre-seeding imported sum type variant constructors.

3. Add a new public function `infer_with_imports` that is a copy of the existing `infer()` function (lines 497-646) but with an additional `import_ctx: &ImportContext` parameter. The differences from `infer()`:

   a. After `builtins::register_builtins` and `register_builtin_sum_types`, pre-seed trait registry with imported traits and impls:
   ```rust
   // Pre-seed with imported trait defs (XMOD-05: globally visible)
   for trait_def in &import_ctx.all_trait_defs {
       trait_registry.register_trait(trait_def.clone());
   }
   for impl_def in &import_ctx.all_trait_impls {
       let _ = trait_registry.register_impl(impl_def.clone());
   }
   ```

   b. Pre-seed TypeRegistry and TypeEnv with imported struct definitions:
   ```rust
   for mod_exports in import_ctx.module_exports.values() {
       for (name, struct_def) in &mod_exports.struct_defs {
           type_registry.register_struct(struct_def.clone());
           // Register struct constructor in env
           let struct_ty = if struct_def.generic_params.is_empty() {
               Ty::struct_ty(name, vec![])
           } else {
               let type_args: Vec<Ty> = struct_def.generic_params.iter()
                   .map(|_| ctx.fresh_var()).collect();
               Ty::struct_ty(name, type_args)
           };
           env.insert(name.clone(), Scheme::mono(struct_ty));
       }
   }
   ```

   c. Pre-seed with imported sum type definitions:
   ```rust
   for mod_exports in import_ctx.module_exports.values() {
       for (_name, sum_type_def) in &mod_exports.sum_type_defs {
           type_registry.register_sum_type(sum_type_def.clone());
           register_variant_constructors(
               &mut ctx, &mut env,
               &sum_type_def.name,
               &sum_type_def.generic_params,
               &sum_type_def.variants,
           );
       }
   }
   ```

   d. Build a `qualified_modules` map (FxHashMap<String, &ModuleExports>) to be used later by Plan 02 for import resolution. For now, just declare it so the signature is ready:
   ```rust
   let qualified_modules: FxHashMap<String, &ModuleExports> = FxHashMap::default();
   ```
   Store `import_ctx` and `qualified_modules` in a way accessible by `infer_item`. The cleanest approach: pass `import_ctx` down through `infer_item` as an additional parameter `import_ctx: &ImportContext`. Add this parameter to the `infer_item` function signature and thread it through all calls. In `infer_with_imports`, pass `import_ctx`; in the existing `infer()`, pass `&ImportContext::empty()`.

   IMPORTANT: The existing `infer()` function MUST remain unchanged in behavior. It should call `infer_with_imports(parse, &ImportContext::empty())` internally to avoid code duplication. This preserves backward compatibility.

4. Add `import_ctx: &ImportContext` parameter to `infer_item` function signature. The existing `ImportDecl` and `FromImportDecl` match arms remain unchanged for now (Plan 02 will extend them). Just thread the parameter through so the code compiles.

   Also add `import_ctx` parameter to `infer_multi_clause_fn` to keep the signature consistent (it does not use it, but needs to compile).

**In crates/snow-typeck/src/lib.rs:**

1. Add the following type definitions after the existing `use` statements and before `TypeckResult`:

```rust
use crate::traits::{TraitDef, ImplDef as TraitImplDef};
use crate::ty::Scheme;

/// Context built by the driver from already-checked dependency modules.
/// Pre-seeds the type checker's environments before inference begins.
#[derive(Debug, Default)]
pub struct ImportContext {
    /// Module namespace -> exported symbols.
    /// Key is the namespace name used for qualified access (last path segment
    /// for `import Math.Vector` -> key is "Vector").
    pub module_exports: FxHashMap<String, ModuleExports>,

    /// Trait definitions from ALL processed modules (globally visible).
    pub all_trait_defs: Vec<TraitDef>,

    /// Trait impls from ALL processed modules (globally visible, XMOD-05).
    pub all_trait_impls: Vec<TraitImplDef>,
}

impl ImportContext {
    /// Create an empty import context (for single-file / backward compat).
    pub fn empty() -> Self {
        Self::default()
    }
}

/// Exports from a single module.
#[derive(Debug, Default, Clone)]
pub struct ModuleExports {
    /// The full module name (e.g., "Math.Vector").
    pub module_name: String,

    /// Function/value type schemes, keyed by unqualified name.
    pub functions: FxHashMap<String, Scheme>,

    /// Struct definitions exported by this module.
    pub struct_defs: FxHashMap<String, StructDefInfo>,

    /// Sum type definitions exported by this module.
    pub sum_type_defs: FxHashMap<String, SumTypeDefInfo>,
}

/// Symbols exported by a module after type checking.
#[derive(Debug, Default, Clone)]
pub struct ExportedSymbols {
    /// Function type schemes (name -> scheme).
    pub functions: FxHashMap<String, Scheme>,
    /// Struct definitions.
    pub struct_defs: FxHashMap<String, StructDefInfo>,
    /// Sum type definitions.
    pub sum_type_defs: FxHashMap<String, SumTypeDefInfo>,
    /// Trait definitions declared in this module.
    pub trait_defs: Vec<TraitDef>,
    /// Trait impls declared in this module.
    pub trait_impls: Vec<TraitImplDef>,
}
```

2. Add `check_with_imports`:
```rust
/// Type-check a parsed Snow program with pre-resolved imports.
///
/// This is the multi-module entry point. The ImportContext contains
/// symbols from already-type-checked dependency modules.
pub fn check_with_imports(parse: &snow_parser::Parse, import_ctx: &ImportContext) -> TypeckResult {
    infer::infer_with_imports(parse, import_ctx)
}
```

3. Add `collect_exports`:
```rust
/// Collect exported symbols from a type-checked module.
///
/// Currently exports ALL top-level definitions (Phase 40 adds pub filtering).
/// Extracts function schemes from the typeck types map by scanning the parse
/// tree for FnDef items, struct/sum type defs from TypeRegistry, and
/// trait defs/impls from TraitRegistry.
pub fn collect_exports(
    parse: &snow_parser::Parse,
    typeck: &TypeckResult,
) -> ExportedSymbols {
    use snow_parser::ast::item::Item;
    use snow_parser::ast::AstNode;

    let tree = parse.tree();
    let mut exports = ExportedSymbols::default();

    for item in tree.items() {
        match item {
            Item::FnDef(fn_def) => {
                if let Some(name) = fn_def.name().and_then(|n| n.text()) {
                    // Look up the function's inferred type from the typeck result
                    let range = fn_def.syntax().text_range();
                    if let Some(ty) = typeck.types.get(&range) {
                        exports.functions.insert(
                            name,
                            Scheme::mono(ty.clone()),
                        );
                    }
                }
            }
            _ => {}
        }
    }

    // Copy struct and sum type defs from type_registry
    // (filter out builtins: Option, Result, Ordering are built-in)
    let builtin_sum_types = ["Option", "Result", "Ordering"];
    for (name, def) in &typeck.type_registry.struct_defs {
        exports.struct_defs.insert(name.clone(), def.clone());
    }
    for (name, def) in &typeck.type_registry.sum_type_defs {
        if !builtin_sum_types.contains(&name.as_str()) {
            exports.sum_type_defs.insert(name.clone(), def.clone());
        }
    }

    // Extract trait defs and impls from the registry
    // Only export locally-defined traits (not builtins).
    // Strategy: collect trait/impl names from AST InterfaceDef/ImplDef items,
    // then look them up in the registry.
    for item in tree.items() {
        match item {
            Item::InterfaceDef(iface) => {
                if let Some(name) = iface.name().and_then(|n| n.text()) {
                    if let Some(trait_def) = typeck.trait_registry.get_trait(&name) {
                        exports.trait_defs.push(trait_def.clone());
                    }
                }
            }
            Item::ImplDef(_impl_def) => {
                // ImplDefs register into the registry. Collect all impls that
                // were registered during this module (by scanning the AST).
                // For Phase 39, export all non-builtin impls.
                // We collect trait_name from the AST and find matching impls.
            }
            _ => {}
        }
    }

    // For trait impls: scan AST ImplDef items for trait names,
    // then collect matching impls from the registry.
    // The simplest approach: iterate all impls in the registry and
    // include those whose trait_name matches an ImplDef in this module's AST.
    let mut local_impl_traits: Vec<(String, String)> = Vec::new(); // (trait_name, type_name)
    for item in tree.items() {
        if let Item::ImplDef(ref impl_def) = item {
            let trait_name = impl_def.trait_name().and_then(|n| n.text());
            let type_name = impl_def.target_type().and_then(|n| n.text());
            if let (Some(tn), Some(ty)) = (trait_name, type_name) {
                local_impl_traits.push((tn, ty));
            }
        }
    }
    for impl_def in typeck.trait_registry.all_impls() {
        for (tn, ty) in &local_impl_traits {
            if impl_def.trait_name == *tn && impl_def.impl_type_name == *ty {
                exports.trait_impls.push(impl_def.clone());
            }
        }
    }

    exports
}
```

4. Re-export the new types:
```rust
pub use crate::infer::register_variant_constructors;
```

Make sure to add `ModuleExports` to the existing `pub use crate::infer::{...}` line if needed (ImportContext/ModuleExports/ExportedSymbols are defined in lib.rs, so no re-export needed for those).
  </action>
  <verify>
Run `cargo check -p snow-typeck` -- must compile with no errors.
Run `cargo test --workspace` -- all existing tests must pass (zero regressions).
Verify that `check_with_imports`, `collect_exports`, `ImportContext`, `ModuleExports`, `ExportedSymbols` are publicly accessible from the `snow_typeck` crate.
  </verify>
  <done>
ImportContext, ModuleExports, ExportedSymbols types exist with all documented fields. check_with_imports(parse, import_ctx) compiles and returns TypeckResult. collect_exports(parse, typeck) compiles and returns ExportedSymbols. TraitRegistry has trait_defs() and all_impls() accessors. TypeRegistry::register_struct and register_sum_type are pub. register_variant_constructors is pub. infer() still works unchanged (delegates to infer_with_imports with empty context). All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ImportModuleNotFound and ImportNameNotFound error variants with diagnostics</name>
  <files>
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/diagnostics.rs
  </files>
  <action>
**In crates/snow-typeck/src/error.rs:**

Add two new variants to the `TypeError` enum (before the closing `}`):

```rust
/// Module not found during import resolution (IMPORT-06).
ImportModuleNotFound {
    module_name: String,
    span: TextRange,
    /// Optional suggestion (closest module name match).
    suggestion: Option<String>,
},

/// Name not found in imported module (IMPORT-07).
ImportNameNotFound {
    module_name: String,
    name: String,
    span: TextRange,
    /// Available names in the module (for "did you mean?" suggestions).
    available: Vec<String>,
},
```

Add Display implementations in the `impl fmt::Display for TypeError` block:

```rust
TypeError::ImportModuleNotFound { module_name, suggestion, .. } => {
    if let Some(sug) = suggestion {
        write!(f, "module `{}` not found; did you mean `{}`?", module_name, sug)
    } else {
        write!(f, "module `{}` not found", module_name)
    }
}
TypeError::ImportNameNotFound { module_name, name, available, .. } => {
    if available.is_empty() {
        write!(f, "`{}` is not exported by module `{}`", name, module_name)
    } else {
        write!(f, "`{}` is not exported by module `{}`; available: {}", name, module_name, available.join(", "))
    }
}
```

**In crates/snow-typeck/src/diagnostics.rs:**

Add diagnostic rendering for the two new variants in the `render_diagnostic` function's match block. Follow the existing pattern used by other error variants:

For `ImportModuleNotFound`:
- Report kind: Error
- Message: "module not found"
- Label on span: "module `{module_name}` not found"
- If suggestion exists, add a note: "did you mean `{suggestion}`?"
- Code: "E0030" (next available after existing codes -- check the file for the last used code number and pick the next)

For `ImportNameNotFound`:
- Report kind: Error
- Message: "name not found in module"
- Label on span: "`{name}` is not exported by module `{module_name}`"
- If available names exist, add a note listing them
- Code: "E0031" (next after E0030)

Follow the exact ariadne Report pattern used by existing variants in the file. Check existing error code numbers before assigning -- use the next sequential codes.
  </action>
  <verify>
Run `cargo check -p snow-typeck` -- must compile.
Run `cargo test --workspace` -- all existing tests must pass.
  </verify>
  <done>
TypeError::ImportModuleNotFound and TypeError::ImportNameNotFound variants exist with Display impl. Diagnostics rendering produces labeled errors with optional suggestions. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p snow-typeck` compiles successfully
2. `cargo test --workspace` -- all tests pass with zero regressions
3. The following types and functions are public in `snow_typeck`:
   - `ImportContext`, `ModuleExports`, `ExportedSymbols`
   - `check_with_imports(parse, import_ctx) -> TypeckResult`
   - `collect_exports(parse, typeck) -> ExportedSymbols`
   - `register_variant_constructors` (re-exported)
   - `TraitRegistry::trait_defs()`, `TraitRegistry::all_impls()`
   - `TypeRegistry::register_struct()`, `TypeRegistry::register_sum_type()` (pub)
4. `check()` delegates to `check_with_imports` with empty ImportContext
5. `TypeError::ImportModuleNotFound` and `TypeError::ImportNameNotFound` have Display + diagnostics
</verification>

<success_criteria>
- All types compile and are publicly accessible
- check_with_imports with empty ImportContext produces identical results to check()
- collect_exports returns ExportedSymbols with functions, struct_defs, sum_type_defs, trait_defs, trait_impls
- All 1000+ existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/39-cross-module-type-checking/39-01-SUMMARY.md`
</output>
