# Phase 63: PID Encoding & Wire Format - Research

**Researched:** 2026-02-12
**Domain:** Binary serialization format + PID bit-packing for distributed actor system
**Confidence:** HIGH

## Summary

Phase 63 is the foundation for Snow's v5.0 Distributed Actors milestone. It delivers two independent subsystems -- PID bit-packing (encoding node identity into the existing u64 PID) and the Snow Term Format (STF) binary serializer/deserializer -- plus a locality check in the send path. Both subsystems are purely additive: they add new capabilities without changing any existing runtime behavior for single-node programs.

The PID encoding change is surgically precise. `ProcessId` is currently a newtype around `u64` (in `actor/process.rs:24`), generated by `AtomicU64::fetch_add(1, Relaxed)` starting from 0. By reserving the upper 16 bits for a node ID (0 = local), all existing PIDs remain valid because the counter never reaches 2^48 in practice. The new methods (`node_id()`, `local_id()`, `is_local()`, `from_remote()`) are purely additive. The `Display` format changes from `<0.N>` to `<node_id.N.creation>` to include node and creation information, but `node_id=0` for local PIDs makes this backward-compatible in behavior.

The STF encoder/decoder is a new module (`snow-rt/src/dist/wire.rs`) that converts Snow runtime values to/from a self-describing binary format. Snow values at runtime are either immediates (Int as i64, Float as f64, Bool as u8) or GC-heap pointers (String as `*SnowString` with `{len: u64, data: [u8]}`, List as `*{len, cap, data: [u64]}`, Map as `*{len, cap|key_type, entries: [(u64,u64)]}`, Set as `*{len, cap, data: [u64]}`, Tuple as `*{len, data: [u64]}`, structs as named LLVM struct types, sum types as `{tag: u8, payload...}`). The STF must handle all of these, including recursive nesting. Closures/function pointers must be detected and rejected with a clear runtime error.

**Primary recommendation:** Implement PID bit-packing and STF as two separate, independently testable subsystems in `snow-rt/src/dist/`. Add the locality check stub in `snow_actor_send` but keep the remote path as a no-op until Phase 65. Validate all 1,524 existing tests pass with zero regressions.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| (none -- zero new dependencies) | N/A | N/A | Project constraint: zero new crate dependencies for v5.0 milestone |

### Supporting (already in Cargo.toml)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| sha2 | 0.10 | HMAC-SHA256 for auth (future phases) | Already in snow-rt deps from Phase 54 |
| hmac | 0.12 | HMAC computation (future phases) | Already in snow-rt deps from Phase 54 |
| parking_lot | 0.12 | RwLock/Mutex for shared state | Already in snow-rt deps |
| rustc-hash | 2 | FxHashMap for PID/node lookups | Already in snow-rt deps |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom STF | Erlang ETF | ETF has atoms/funs/ports Snow doesn't have; ETF's `fun` deserialization is an RCE vector; Snow's type system is statically typed unlike Erlang's |
| Custom STF | serde + bincode | Would add a dependency and require implementing Serde traits for all runtime types; hand-rolled is consistent with existing PG wire protocol, HTTP parser, WS frame codec |
| Custom STF | MessagePack/CBOR | Additional dependency; Snow types don't map cleanly to generic formats (e.g., sum types, PIDs) |

**Installation:** No new dependencies. All work is within `snow-rt`.

## Architecture Patterns

### Recommended Project Structure
```
crates/snow-rt/src/
├── dist/                # NEW module for distribution
│   ├── mod.rs           # Public exports, feature flag
│   ├── pid.rs           # PID bit-packing helpers (node_id, local_id, creation, is_local)
│   └── wire.rs          # STF encoder/decoder (Snow Term Format)
├── actor/
│   ├── process.rs       # MODIFIED: Add methods to ProcessId (node_id, local_id, is_local, from_remote)
│   └── mod.rs           # MODIFIED: Add locality check to snow_actor_send
└── ... (existing files unchanged)
```

### Pattern 1: PID Bit-Packing in Existing u64
**What:** Encode node_id (16 bits), creation counter (8 bits), and local_id (40 bits) into the existing ProcessId(u64), preserving ABI compatibility.
**When to use:** Any code that needs to determine if a PID is local or remote.
**Layout:**
```
Bit 63                                                    Bit 0
[  16-bit node_id  |  8-bit creation  |  40-bit local_id  ]
    bits 63..48         bits 47..40         bits 39..0
```
**Example:**
```rust
// Source: Snow architecture research + codebase analysis
impl ProcessId {
    /// Extract the 16-bit node identifier (0 = local node).
    #[inline]
    pub fn node_id(self) -> u16 {
        (self.0 >> 48) as u16
    }

    /// Extract the 8-bit creation counter.
    #[inline]
    pub fn creation(self) -> u8 {
        ((self.0 >> 40) & 0xFF) as u8
    }

    /// Extract the 40-bit local process identifier.
    #[inline]
    pub fn local_id(self) -> u64 {
        self.0 & 0x0000_00FF_FFFF_FFFF
    }

    /// Check if this PID belongs to the local node (node_id == 0).
    #[inline]
    pub fn is_local(self) -> bool {
        self.0 >> 48 == 0
    }

    /// Construct a remote PID from components.
    pub fn from_remote(node_id: u16, creation: u8, local_id: u64) -> Self {
        debug_assert!(local_id < (1u64 << 40), "local_id exceeds 40 bits");
        ProcessId(
            (node_id as u64) << 48
            | (creation as u64) << 40
            | (local_id & 0x0000_00FF_FFFF_FFFF)
        )
    }

    /// Generate a fresh local PID (backward compatible -- high 24 bits stay 0).
    pub fn next() -> Self {
        static COUNTER: AtomicU64 = AtomicU64::new(0);
        ProcessId(COUNTER.fetch_add(1, Ordering::Relaxed))
    }
}
```

**Backward compatibility:** All existing PIDs have node_id=0 and creation=0 because the counter starts at 0 and increments sequentially. The upper 24 bits are always zero for any PID < 2^40 (~1 trillion), which is orders of magnitude beyond any realistic single-node workload.

### Pattern 2: Snow Term Format (STF) Type Tags
**What:** Self-describing binary format where each value is prefixed by a 1-byte type tag, enabling recursive serialization/deserialization.
**When to use:** Serializing any Snow value for inter-node transport.
**Tag assignments:**
```rust
// Source: Design based on Erlang ETF structure adapted for Snow's type system
pub const STF_VERSION: u8 = 1;     // Version byte (first byte of every STF payload)

// Scalar types
pub const TAG_INT: u8 = 1;         // i64, 8 bytes LE
pub const TAG_FLOAT: u8 = 2;       // f64, 8 bytes LE (IEEE 754)
pub const TAG_BOOL_TRUE: u8 = 3;   // no payload
pub const TAG_BOOL_FALSE: u8 = 4;  // no payload
pub const TAG_STRING: u8 = 5;      // u32 len + UTF-8 bytes
pub const TAG_UNIT: u8 = 6;        // no payload

// Container types
pub const TAG_LIST: u8 = 10;       // u32 count + count * encoded elements
pub const TAG_MAP: u8 = 11;        // u8 key_type + u32 count + count * (encoded key, encoded value)
pub const TAG_SET: u8 = 12;        // u32 count + count * encoded elements
pub const TAG_TUPLE: u8 = 13;      // u8 arity + arity * encoded elements

// Composite types
pub const TAG_STRUCT: u8 = 20;     // u16 name_len + name + u16 field_count + fields
pub const TAG_SUM_TYPE: u8 = 21;   // u16 type_name_len + type_name + u8 variant_tag + u16 field_count + fields

// Identity types
pub const TAG_PID: u8 = 30;        // u64 raw PID (includes node_id + creation + local_id)

// Option/Result (special-cased sum types for efficiency)
pub const TAG_OPTION_SOME: u8 = 40;  // + encoded inner value
pub const TAG_OPTION_NONE: u8 = 41;  // no payload
pub const TAG_RESULT_OK: u8 = 42;    // + encoded inner value
pub const TAG_RESULT_ERR: u8 = 43;   // + encoded inner value

// Error sentinel
pub const TAG_CLOSURE: u8 = 0xFF;  // NEVER written -- triggers runtime error on attempt

// Reserved for future: 50-99 for new types, 100-199 for distribution signals
```

### Pattern 3: Locality Check in send() -- Branch-Free Hot Path
**What:** Add a PID locality check at the top of `snow_actor_send` that routes to local or remote path. The local path is unchanged (zero regression). The remote path calls into the distribution module.
**When to use:** Every `snow_actor_send` call.
**Example:**
```rust
// Source: Snow architecture research -- integration point analysis
#[no_mangle]
pub extern "C" fn snow_actor_send(target_pid: u64, msg_ptr: *const u8, msg_size: u64) {
    // Locality check: upper 16 bits == 0 means local PID.
    // This is a single shift+compare -- essentially free on modern CPUs.
    if target_pid >> 48 == 0 {
        // Fast path: existing local send (completely unchanged)
        local_send(target_pid, msg_ptr, msg_size);
    } else {
        // Distribution path: route through NodeSession (Phase 65)
        // For now (Phase 63): this is unreachable in single-node programs.
        // Will be wired up in Phase 65.
        dist_send_stub(target_pid, msg_ptr, msg_size);
    }
}

// Extract existing snow_actor_send body into this function (no changes).
fn local_send(target_pid: u64, msg_ptr: *const u8, msg_size: u64) {
    let sched = global_scheduler();
    let pid = ProcessId(target_pid);
    // ... existing code verbatim ...
}

#[cold]
fn dist_send_stub(_target_pid: u64, _msg_ptr: *const u8, _msg_size: u64) {
    // Phase 65 will replace this with actual remote send.
    // For now, silently drop (remote PIDs should not exist in Phase 63).
}
```

### Pattern 4: STF Encode/Decode with Explicit Stack
**What:** Use an iterative approach with an explicit work stack for encoding/decoding nested structures, avoiding Rust stack overflow on deeply nested values.
**When to use:** Encoding or decoding any Snow value that may contain nested containers.
**Example:**
```rust
// Source: Standard binary serialization pattern; avoids recursion stack overflow
pub fn stf_encode(value: u64, type_hint: StfType, buf: &mut Vec<u8>) -> Result<(), StfError> {
    match type_hint {
        StfType::Int => {
            buf.push(TAG_INT);
            buf.extend_from_slice(&(value as i64).to_le_bytes());
            Ok(())
        }
        StfType::Float => {
            buf.push(TAG_FLOAT);
            buf.extend_from_slice(&f64::from_bits(value).to_le_bytes());
            Ok(())
        }
        StfType::String => {
            buf.push(TAG_STRING);
            let s = unsafe { &*(value as *const SnowString) };
            let bytes = unsafe { s.as_bytes() };
            buf.extend_from_slice(&(bytes.len() as u32).to_le_bytes());
            buf.extend_from_slice(bytes);
            Ok(())
        }
        StfType::Closure | StfType::FnPtr => {
            Err(StfError::ClosureNotSerializable)
        }
        // ... other types
    }
}
```

### Anti-Patterns to Avoid
- **Changing ProcessId to a wider type (u128 or struct):** This breaks every extern "C" function signature, every LLVM intrinsic, and all 1,524 tests. Use bit-packing within existing u64.
- **Adding serialization overhead to local sends:** The locality check must be the very first thing in `snow_actor_send`. Never serialize for local sends -- the existing raw byte copy is correct and fast for same-address-space delivery.
- **Recursive descent for STF encode/decode:** Deeply nested values (List of Maps of Lists) can overflow the Rust stack. Use an iterative approach with explicit work stack.
- **Allocating STF buffers on the actor GC heap:** Serialization buffers must live on the Rust system heap (Vec<u8>) to avoid being collected by the actor's mark-sweep GC. The GC only knows about objects reachable from the coroutine stack.
- **Serializing closures silently:** Closures contain function pointers that are address-space-local. Attempting to serialize a closure must produce a clear `StfError::ClosureNotSerializable` error, not silent corruption.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| N/A -- hand-rolling IS the standard here | N/A | N/A | This project hand-rolls all wire protocols (PG, HTTP, WebSocket). STF follows the same pattern. Zero new dependency constraint makes hand-rolling mandatory. |

**Key insight:** In this project, hand-rolling binary formats is the established pattern, not an anti-pattern. The PG wire protocol (`db/pg.rs`), HTTP parser (`http/server.rs`), and WebSocket frame codec (`ws/frame.rs`) are all hand-rolled. STF follows the same discipline.

## Common Pitfalls

### Pitfall 1: PID Counter Overflow into Node ID Bits
**What goes wrong:** If the AtomicU64 PID counter exceeds 2^40 (1,099,511,627,776), the upper bits spill into the creation and node_id fields, causing local PIDs to appear as remote PIDs.
**Why it happens:** The current counter has no upper bound. In theory, a program spawning ~1 trillion actors could overflow.
**How to avoid:** Add a debug_assert or mask in `ProcessId::next()` to ensure the counter stays within the lower 40 bits: `ProcessId(COUNTER.fetch_add(1, Ordering::Relaxed) & 0x0000_00FF_FFFF_FFFF)`. In practice, 1 trillion processes is unreachable, but the mask is defensive.
**Warning signs:** Local PIDs suddenly routing to the remote send path; tests failing with "no NodeSession for node_id X".

### Pitfall 2: STF Decode Trusting Untrusted Length Fields
**What goes wrong:** A malformed or malicious STF payload specifies a string length of 4GB. The decoder allocates 4GB of memory, causing OOM.
**Why it happens:** The STF format includes length fields (u32 for strings, u32 for list counts). If the decoder trusts these without bounds checking, it is vulnerable to resource exhaustion.
**How to avoid:** Cap all length fields at a reasonable maximum (e.g., 16MB for strings, 1M for collection counts). Reject payloads exceeding the cap with `StfError::PayloadTooLarge`. Also verify that the declared length does not exceed the remaining bytes in the buffer.
**Warning signs:** OOM crashes during STF decode; extremely slow deserialization.

### Pitfall 3: Display Format Change Breaks Snapshot Tests
**What goes wrong:** Changing `ProcessId::Display` from `<0.N>` to `<node_id.N.creation>` causes all insta snapshot tests that capture PID output to fail.
**Why it happens:** Snow uses insta for snapshot testing. Many tests capture output containing PID strings (e.g., `<0.1>`). If the display format changes, all these snapshots need updating.
**How to avoid:** For local PIDs where node_id=0 and creation=0, keep the display format as `<0.N>` (unchanged). Only use the extended format `<node_id.N.creation>` when node_id > 0 or creation > 0. This preserves all existing test output.
**Warning signs:** Mass snapshot test failures after PID encoding change.

### Pitfall 4: GC Collects Objects During STF Serialization
**What goes wrong:** An actor starts serializing a large value (e.g., a List of Strings). The serialization iterates over list elements, reading pointers to SnowString objects. If a GC cycle triggers between reading one element and the next, the SnowString objects may be collected (they are only referenced from the list, which is being read through a raw pointer).
**Why it happens:** GC triggers at yield points (`reduction_check`). STF serialization happens inline in the actor's execution context. If the actor hits a yield point during serialization (unlikely for a pure computation but possible if the serialize function calls any runtime function that does `reduction_check`), GC could run.
**How to avoid:** STF encode runs as a pure Rust function operating on raw pointers -- it does not call any Snow runtime functions that trigger `reduction_check`. The serialization output is a `Vec<u8>` on the Rust system heap (not the actor GC heap). As long as the encode function is a leaf function (no yield points), GC cannot trigger during serialization. Document this invariant explicitly.
**Warning signs:** Corrupted STF payloads (garbled string data, wrong list lengths) appearing intermittently under high GC pressure.

### Pitfall 5: Creation Counter Not Part of PID Causes Stale PID Confusion
**What goes wrong:** Without a creation counter in the PID, if a remote node crashes and restarts, its new processes get the same local IDs as the old ones. A cached PID on another node now refers to the wrong process.
**Why it happens:** The PID counter resets to 0 on every process start. Without a per-incarnation creation counter embedded in the PID, there is no way to distinguish "PID 42 from node B version 1" from "PID 42 from node B version 2".
**How to avoid:** Include an 8-bit creation counter in the PID layout (bits 47..40). Each node incarnation increments the creation counter. When receiving a PID, validate that the creation counter matches the current incarnation of that node. Stale PIDs (wrong creation) are treated as dead.
**Warning signs:** Messages delivered to wrong process after node restart; exit signals not firing for processes on restarted nodes.

### Pitfall 6: Forgetting to Handle Option/Result as Sum Types in STF
**What goes wrong:** Option and Result are sum types in Snow's type system, but at runtime they have a special `#[repr(C)] { tag: u8, value: *mut u8 }` layout (see `option.rs:17-20`). If the STF encoder treats them as generic sum types, it may not correctly dereference the pointer-based payload.
**Why it happens:** Option and Result use a `{ u8 tag, ptr value }` layout instead of the general `{ u8 tag, [N x i8] payload }` sum type layout. The encoder must handle both layouts.
**How to avoid:** Add dedicated STF tags for Option (TAG_OPTION_SOME/TAG_OPTION_NONE) and Result (TAG_RESULT_OK/TAG_RESULT_ERR) that understand the pointer-based layout. These are encoded more efficiently and decoded more safely than generic sum type handling.
**Warning signs:** Segfault when encoding Option<String> or Result<Int, String>; garbled values after round-trip.

## Code Examples

Verified patterns from the existing codebase:

### Existing Binary Encoding Pattern (exit signals in link.rs)
```rust
// Source: crates/snow-rt/src/actor/link.rs lines 62-100
// This is the existing pattern for binary encode/decode in Snow.
// STF follows the same style: tag byte + length-prefixed data.
pub fn encode_exit_signal(exiting_pid: ProcessId, reason: &ExitReason) -> Vec<u8> {
    let mut data = Vec::new();
    data.extend_from_slice(&exiting_pid.0.to_le_bytes());
    encode_reason(&mut data, reason);
    data
}

fn encode_reason(data: &mut Vec<u8>, reason: &ExitReason) {
    match reason {
        ExitReason::Normal => { data.push(0); }
        ExitReason::Error(msg) => {
            data.push(1);
            let bytes = msg.as_bytes();
            data.extend_from_slice(&(bytes.len() as u64).to_le_bytes());
            data.extend_from_slice(bytes);
        }
        // ... more variants
    }
}
```

### Existing Value Layout Reference (runtime memory layouts)
```rust
// Source: crates/snow-rt/src/string.rs lines 23-26
// String: { len: u64, data: [u8; len] }
#[repr(C)]
pub struct SnowString {
    pub len: u64,
    // data bytes follow immediately
}

// Source: crates/snow-rt/src/collections/list.rs lines 22-34
// List: { len: u64, cap: u64, data: [u64; cap] }  -- elements are uniform u64

// Source: crates/snow-rt/src/collections/map.rs lines 17-29
// Map: { len: u64, cap_with_tag: u64, entries: [(u64, u64); cap] }
//   upper 8 bits of cap field = key_type tag (0=int, 1=string)

// Source: crates/snow-rt/src/collections/set.rs lines 14-15
// Set: { len: u64, cap: u64, data: [u64; cap] }

// Source: crates/snow-rt/src/collections/tuple.rs lines 4-6
// Tuple: { len: u64, data: [u64; len] }

// Source: crates/snow-rt/src/option.rs lines 17-20
// Option: { tag: u8, value: *mut u8 }  -- tag 0=Some, 1=None

// Source: crates/snow-rt/src/json.rs lines 37-41
// Sum types (general): { tag: u8, payload: [u8; max_variant_size] }
```

### STF Encode for String (reference implementation pattern)
```rust
// Pattern for STF string encoding -- follows the same Vec<u8> builder
// pattern as link.rs encode_exit_signal.
fn stf_encode_string(s: *const SnowString, buf: &mut Vec<u8>) {
    buf.push(TAG_STRING);
    let snow_str = unsafe { &*s };
    let bytes = unsafe { snow_str.as_bytes() };
    // Use u32 length prefix (max 4GB per string, sufficient for any message)
    buf.extend_from_slice(&(bytes.len() as u32).to_le_bytes());
    buf.extend_from_slice(bytes);
}

fn stf_decode_string(data: &[u8], pos: &mut usize) -> Result<*mut u8, StfError> {
    if *pos + 4 > data.len() { return Err(StfError::UnexpectedEof); }
    let len = u32::from_le_bytes(data[*pos..*pos+4].try_into().unwrap()) as usize;
    *pos += 4;
    if *pos + len > data.len() { return Err(StfError::UnexpectedEof); }
    let str_ptr = snow_string_new(data[*pos..].as_ptr(), len as u64);
    *pos += len;
    Ok(str_ptr as *mut u8)
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Plain sequential u64 PID | Bit-packed u64 with node_id + creation + local_id | Phase 63 (this phase) | Enables location-transparent PIDs without ABI change |
| Raw byte-copy for all messages | Raw byte-copy for local + STF serialize for remote | Phase 63 (this phase) | Enables cross-node messaging |
| No creation counter | 8-bit creation counter in PID bits 47..40 | Phase 63 (this phase) | Prevents stale PID confusion after node restart |

**Deprecated/outdated:**
- Nothing is deprecated in this phase. All changes are additive.

## Open Questions

1. **STF type hints for serialization**
   - What we know: Snow's runtime stores all collection elements as uniform u64 values. A List element could be an Int, Float, Bool, String pointer, or nested List/Map pointer. The serializer needs to know the element type to encode correctly.
   - What's unclear: How does the encoder distinguish between an Int value `42` stored as u64 and a pointer to a SnowString also stored as u64? At runtime, the type information is erased.
   - Recommendation: The encoder must receive type hints from the codegen layer. For Phase 63, the STF encoder requires a companion `StfType` enum that mirrors MirType. The codegen emits type metadata alongside message data when the target is a remote PID. For the Phase 63 unit tests, type hints are provided manually. Phase 65 will wire this into the codegen.

2. **Creation counter assignment mechanism**
   - What we know: Each node incarnation needs a unique creation counter. The 8-bit field supports 256 values before wrapping.
   - What's unclear: Who assigns the creation counter? In BEAM, EPMD assigns it. Snow has no EPMD.
   - Recommendation: For Phase 63, define the creation counter field in the PID layout and provide `from_remote(node_id, creation, local_id)`. The actual assignment mechanism will be designed in Phase 64 (Node Connection & Authentication) where nodes exchange creation counters during handshake.

3. **STF for struct types: name-based vs. tag-based identification**
   - What we know: Struct fields are accessed by name in Snow source but by index at runtime. Two nodes must agree on struct layout.
   - What's unclear: Should STF encode struct fields by name (self-describing but verbose) or by index (compact but requires schema agreement)?
   - Recommendation: Encode struct type name + fields by name for self-describing format. This is more robust across different binary versions and matches the "correctness over micro-optimization" principle. Performance optimization (name caching, index-based encoding) can be added later with the atom cache (OPT-01).

4. **Testing strategy for STF round-trip coverage**
   - What we know: Every Snow value type must round-trip through encode/decode without data loss. There are 14+ type variants to cover.
   - What's unclear: How to construct complex nested values (List<Map<String, Set<Int>>>) in unit tests without the Snow compiler.
   - Recommendation: Build test helper functions that construct Snow values directly in Rust using the existing runtime allocator functions (`snow_gc_alloc`, `snow_string_new`, `snow_list_from_array`, `snow_map_new/put`, `snow_set_new/add`). This approach is already used in existing tests (see `heap.rs` tests, `tuple.rs` tests).

## Sources

### Primary (HIGH confidence)
- Snow codebase direct analysis:
  - `crates/snow-rt/src/actor/process.rs` -- ProcessId definition, PID counter (lines 23-37)
  - `crates/snow-rt/src/actor/mod.rs` -- snow_actor_send, snow_actor_spawn, message layout (lines 261-297)
  - `crates/snow-rt/src/actor/link.rs` -- encode/decode_exit_signal (existing binary format pattern, lines 62-167)
  - `crates/snow-rt/src/actor/heap.rs` -- MessageBuffer, ActorHeap (lines 576-608)
  - `crates/snow-rt/src/string.rs` -- SnowString layout (lines 23-70)
  - `crates/snow-rt/src/collections/list.rs` -- List layout (lines 1-60)
  - `crates/snow-rt/src/collections/map.rs` -- Map layout with key_type tag (lines 1-78)
  - `crates/snow-rt/src/collections/set.rs` -- Set layout (lines 1-47)
  - `crates/snow-rt/src/collections/tuple.rs` -- Tuple layout (lines 1-22)
  - `crates/snow-rt/src/option.rs` -- SnowOption layout (lines 17-33)
  - `crates/snow-rt/src/json.rs` -- SnowJson tagged union (lines 37-56)
  - `crates/snow-codegen/src/codegen/types.rs` -- MirType to LLVM mapping (lines 31-83)
  - `crates/snow-codegen/src/mir/mod.rs` -- MirType enum (lines 63-92)
  - `crates/snow-rt/Cargo.toml` -- existing dependencies (zero new deps constraint)
- `.planning/research/SUMMARY.md` -- v5.0 distributed actors research summary
- `.planning/research/ARCHITECTURE.md` -- PID bit-packing design, distribution router pattern
- `.planning/research/PITFALLS.md` -- Critical pitfalls 1-7 directly relevant to Phase 63
- `.planning/REQUIREMENTS.md` -- MSG-01, MSG-03, MSG-04, MSG-05, MSG-08, FT-05 requirement definitions

### Secondary (MEDIUM confidence)
- [Erlang External Term Format (erts v16.2)](https://www.erlang.org/doc/apps/erts/erl_ext_dist.html) -- Type tag numbering inspiration, version byte pattern
- [Erlang Distribution Protocol (erts v16.2)](https://www.erlang.org/doc/apps/erts/erl_dist_protocol.html) -- PID encoding with creation counter
- `.planning/research/FEATURES.md` -- Location-transparent PID expected behaviors

### Tertiary (LOW confidence)
- None -- all findings verified against codebase or official documentation

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- zero new deps verified against existing Cargo.toml; pattern consistent with PG/HTTP/WS implementations
- Architecture: HIGH -- based on direct analysis of all relevant source files; PID encoding impact verified against every existing ProcessId usage
- Pitfalls: HIGH -- verified against Snow's specific runtime architecture (GC heap, coroutine scheduling, raw pointer message passing)

**Research date:** 2026-02-12
**Valid until:** 60 days (stable foundation phase, no external dependency volatility)
