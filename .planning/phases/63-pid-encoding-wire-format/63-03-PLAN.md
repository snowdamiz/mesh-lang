---
phase: 63-pid-encoding-wire-format
plan: 03
type: execute
wave: 2
depends_on: ["63-02"]
files_modified:
  - crates/snow-rt/src/dist/wire.rs
autonomous: true

must_haves:
  truths:
    - "List, Map, Set, Tuple values round-trip through STF encode/decode without data loss"
    - "Struct and SumType values round-trip with field names preserved"
    - "Option<T> and Result<T, E> round-trip using dedicated efficient tags"
    - "Nested containers (List of Maps, Map of Lists, etc.) round-trip correctly"
    - "Collections exceeding MAX_COLLECTION_LEN produce StfError::PayloadTooLarge"
  artifacts:
    - path: "crates/snow-rt/src/dist/wire.rs"
      provides: "Complete STF encoder/decoder for all Snow types"
      contains: "TAG_LIST"
  key_links:
    - from: "crates/snow-rt/src/dist/wire.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "List layout reading for serialization"
      pattern: "list_len|list_data"
    - from: "crates/snow-rt/src/dist/wire.rs"
      to: "crates/snow-rt/src/collections/map.rs"
      via: "Map layout reading for serialization"
      pattern: "map_len|map_entries"
    - from: "crates/snow-rt/src/dist/wire.rs"
      to: "crates/snow-rt/src/option.rs"
      via: "SnowOption layout for Option encode/decode"
      pattern: "SnowOption"
---

<objective>
Complete STF with container types, composite types, and comprehensive round-trip tests.

Implement STF encode/decode for all remaining Snow types: List, Map, Set, Tuple (containers), Struct, SumType (composites), and Option/Result (special-cased sum types). Add comprehensive round-trip tests including nested containers.

Purpose: Completes the wire format so that ANY Snow value can be serialized for inter-node transport. This is the critical path -- without full type coverage, distributed messaging cannot work.
Output: Complete wire.rs with all 14+ type variants. Comprehensive test suite proving correctness.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/63-pid-encoding-wire-format/63-RESEARCH.md
@.planning/phases/63-pid-encoding-wire-format/63-02-SUMMARY.md
@crates/snow-rt/src/dist/wire.rs
@crates/snow-rt/src/collections/list.rs
@crates/snow-rt/src/collections/map.rs
@crates/snow-rt/src/collections/set.rs
@crates/snow-rt/src/collections/tuple.rs
@crates/snow-rt/src/option.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement STF encode/decode for container and composite types</name>
  <files>crates/snow-rt/src/dist/wire.rs</files>
  <action>
Replace the placeholder arms in `stf_encode` and `stf_decode` with full implementations for all remaining types.

**Container type encoding** (value is a pointer to GC-heap allocated data):

For all containers, read the runtime memory layout using unsafe pointer arithmetic matching the patterns in the collection modules. Do NOT import private helpers from collection modules -- duplicate the minimal pointer math inline (it's just 2-3 lines per type).

**List** (`StfType::List(elem_type)`):
- Encode: push TAG_LIST, read len from `*(value as *const u64)`, write len as u32, iterate data pointer `(value as *const u64).add(2)` for `len` elements, recursively encode each element with `elem_type`. Cap len at MAX_COLLECTION_LEN.
- Decode: read u32 count, validate <= MAX_COLLECTION_LEN, allocate list via `crate::gc::snow_gc_alloc_actor`, set len and cap fields, decode each element into data slots.

**Map** (`StfType::Map(key_type, val_type)`):
- Encode: push TAG_MAP, read len from `*(value as *const u64)`, extract key_type_tag from upper 8 bits of cap field `(*((value as *const u64).add(1))) >> 56`, write key_type_tag as u8, write len as u32, iterate entries at `(value as *const u64).add(2)` -- each entry is (u64 key, u64 value), recursively encode key with key_type and value with val_type.
- Decode: read u8 key_type_tag, read u32 count, allocate map, set len and cap (with key_type_tag in upper 8 bits), decode each (key, value) pair.

**Set** (`StfType::Set(elem_type)`):
- Encode: push TAG_SET, read len from `*(value as *const u64)`, write len as u32, iterate data at `(value as *const u64).add(2)`, encode each element.
- Decode: read u32 count, allocate set, decode elements into data slots.

**Tuple** (`StfType::Tuple(elem_types)`):
- Encode: push TAG_TUPLE, write arity as u8 (from elem_types.len()), iterate data at `(value as *const u64).add(1)` (tuple layout: `{u64 len, u64[len] data}`), encode each element with its corresponding type from elem_types.
- Decode: read u8 arity, allocate tuple, decode each element. Return StfType::Tuple with decoded element types.

**Struct** (`StfType::Struct(name, fields)`):
- Encode: push TAG_STRUCT, write name as u16 len + UTF-8 bytes, write field_count as u16, for each field write field_name (u16 len + UTF-8) then encode field value. Access struct fields via pointer arithmetic: fields are contiguous u64 values after any header.
- Decode: read u16 name_len + name, read u16 field_count, for each field read name then decode value.

Note on struct encoding: The value pointer points to a contiguous block of u64 fields (no header -- structs in Snow are just LLVM named struct types). The field order matches the StfType::Struct field order. Each field is a u64 that needs the corresponding field type from the StfType for recursive encoding.

**SumType** (`StfType::SumType(type_name, variants)`):
- Encode: push TAG_SUM_TYPE, write type_name (u16 len + UTF-8), read tag byte from `*(value as *const u8)` (first byte of the sum type layout is the variant tag), write variant_tag as u8, look up the variant by index in variants list, write field_count as u16, encode each field. Fields start at offset after the tag byte, padded to 8-byte alignment (so offset 8 from the start of the sum type).
- Decode: read type_name, read variant_tag, read field_count, decode fields, allocate sum type layout.

**Option** (`StfType::OptionOf(inner_type)`):
- Encode: read SnowOption layout at value pointer: `tag: u8` at offset 0, `value: *mut u8` at offset 8 (due to alignment). If tag == 0 (Some): push TAG_OPTION_SOME, encode inner value (dereference the pointer). If tag == 1 (None): push TAG_OPTION_NONE.
- Decode: TAG_OPTION_SOME: decode inner value, allocate SnowOption with tag=0. TAG_OPTION_NONE: allocate SnowOption with tag=1, value=null.

Use `crate::option::alloc_option` for Option allocation on decode.

**Result** (`StfType::ResultOf(ok_type, err_type)`):
- Same layout as Option (tag + pointer). Tag 0 = Ok, Tag 1 = Err.
- Encode: TAG_RESULT_OK or TAG_RESULT_ERR + encoded inner value.
- Decode: allocate with alloc_option (same layout).

**Important implementation notes:**
- All container/composite encode/decode must handle nesting by recursive calls to stf_encode/stf_decode.
- Use an iterative approach for deeply nested structures if needed, but for Phase 63 recursive calls are acceptable since typical message nesting is shallow (< 10 levels).
- All length reads must validate against remaining buffer size before proceeding.
- All collection lengths must be validated against MAX_COLLECTION_LEN.
- String field names in structs/sum types must be validated against MAX_STRING_LEN.
- STF buffers are Vec<u8> on the Rust system heap (NOT the actor GC heap). Only decoded values are allocated on the GC heap.
  </action>
  <verify>
Run `cargo check -p snow-rt` -- compiles without errors. Run `cargo test -p snow-rt dist::wire::tests` -- existing scalar tests still pass.
  </verify>
  <done>
All container and composite type encode/decode arms implemented in stf_encode and stf_decode. Compilation clean. Existing scalar tests unbroken.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive round-trip tests for all types</name>
  <files>crates/snow-rt/src/dist/wire.rs</files>
  <action>
Add comprehensive unit tests to the `#[cfg(test)] mod tests` block in `wire.rs`.

All tests that allocate GC objects must call `crate::gc::snow_rt_init()` at the start. Use the existing runtime allocation functions to construct test values:

**Container round-trip tests:**

1. `test_list_int_roundtrip`: Create a list of 3 ints using `snow_gc_alloc_actor` to allocate `{len: 3, cap: 3, data: [10, 20, 30]}`. Encode as `StfType::List(Box::new(StfType::Int))`, decode, verify len=3 and elements match.

2. `test_list_string_roundtrip`: Create a list of 2 strings. Allocate strings via `snow_string_new`, store pointers as u64 in list data. Encode as `StfType::List(Box::new(StfType::String))`, decode, verify string contents.

3. `test_map_roundtrip`: Create a map with 2 int->string entries. Allocate map with `snow_gc_alloc_actor` following the map layout (header + entries). Encode as `StfType::Map(Int, String)`, decode, verify key-value pairs.

4. `test_set_roundtrip`: Create a set of 3 ints. Encode, decode, verify elements.

5. `test_tuple_roundtrip`: Create a 3-tuple (Int, String, Bool). Allocate via `snow_gc_alloc_actor` with layout `{len: 3, data: [int_val, str_ptr, bool_val]}`. Encode as `StfType::Tuple(vec![Int, String, Bool])`, decode, verify.

**Composite round-trip tests:**

6. `test_struct_roundtrip`: Create a struct with 2 fields (name: String, age: Int). The value is just contiguous u64 values (LLVM struct layout). Encode as `StfType::Struct("Person", vec![("name", String), ("age", Int)])`, decode, verify field names and values.

7. `test_option_some_roundtrip`: Create SnowOption with tag=0 (Some), value=pointer to an int. Use `alloc_option(0, int_val_ptr)`. Encode as `StfType::OptionOf(Int)`, decode, verify tag=0 and inner value.

8. `test_option_none_roundtrip`: Create SnowOption with tag=1 (None). Encode, decode, verify tag=1.

9. `test_result_ok_roundtrip`: Like Option but with TAG_RESULT_OK. Encode as `StfType::ResultOf(Int, String)`, decode, verify.

10. `test_result_err_roundtrip`: Result with tag=1 (Err), inner is a string.

**Nesting tests:**

11. `test_nested_list_of_lists`: List containing 2 inner lists of ints. Encode as `StfType::List(Box::new(StfType::List(Box::new(StfType::Int))))`, decode, verify structure preserved.

12. `test_list_of_maps`: List containing maps. Verify nesting works.

**Error condition tests:**

13. `test_collection_too_large`: Try decoding a payload with count > MAX_COLLECTION_LEN, verify PayloadTooLarge error.

14. `test_string_too_large`: Try decoding a payload with string length > MAX_STRING_LEN, verify PayloadTooLarge error.

15. `test_unknown_tag`: Try decoding a payload with tag byte 0xFE, verify InvalidTag error.

**Helper function** for tests:
Create a helper `fn alloc_list_of_ints(values: &[i64]) -> *mut u8` that allocates a list with the given int values. Similarly `fn alloc_set_of_ints(values: &[i64]) -> *mut u8`. These reduce boilerplate across tests.

For struct tests: the value pointer points to a block of N contiguous u64 fields. Allocate via `snow_gc_alloc_actor(N * 8, 8)` and write fields sequentially.

For verifying decoded values: compare raw u64 values for Int/Float/Bool/PID. For String, dereference the returned pointer as `*const SnowString` and compare the byte content. For containers, read the decoded pointer's memory layout and compare elements.
  </action>
  <verify>
Run `cargo test -p snow-rt dist::wire::tests` -- all tests pass (scalar + container + composite + nesting + error). Run `cargo test` -- full workspace test suite passes (1,524+ tests plus new STF tests, no regressions).
  </verify>
  <done>
Every Snow value type (Int, Float, Bool, String, List, Map, Set, Tuple, Struct, SumType, Option, Result, PID) round-trips through STF encode/decode without data loss. Nested containers work. Closures/FnPtrs rejected. Error conditions handled cleanly. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-rt dist::wire::tests` -- all STF tests pass (scalar + container + composite)
2. `cargo test` -- full workspace test suite passes (no regressions)
3. Every Snow value type round-trips correctly
4. Nested containers (list of maps, etc.) round-trip correctly
5. Oversized payloads produce clean errors
6. Unknown tags produce clean errors
</verification>

<success_criteria>
- All 14+ Snow value types have working STF encode/decode
- Nested containers round-trip without data loss
- Option/Result use dedicated efficient tags
- Struct field names preserved through round-trip
- Collection length limits enforced
- Error conditions (truncated, oversized, unknown tag) handled cleanly
- All 1,524+ existing tests pass, plus 15+ new STF tests
</success_criteria>

<output>
After completion, create `.planning/phases/63-pid-encoding-wire-format/63-03-SUMMARY.md`
</output>
