---
phase: 63-pid-encoding-wire-format
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/dist/mod.rs
  - crates/snow-rt/src/dist/wire.rs
  - crates/snow-rt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "STF version byte is written as first byte of every encoded payload"
    - "Int, Float, Bool, String, Unit, and PID values round-trip through encode/decode without data loss"
    - "Attempting to encode a Closure or FnPtr type produces StfError::ClosureNotSerializable"
    - "Decoding a truncated payload produces StfError::UnexpectedEof, not a panic"
  artifacts:
    - path: "crates/snow-rt/src/dist/mod.rs"
      provides: "dist module declaration and public exports"
      contains: "pub mod wire"
    - path: "crates/snow-rt/src/dist/wire.rs"
      provides: "STF encoder/decoder for scalar types"
      contains: "TAG_INT"
    - path: "crates/snow-rt/src/lib.rs"
      provides: "dist module registration"
      contains: "pub mod dist"
  key_links:
    - from: "crates/snow-rt/src/dist/wire.rs"
      to: "crates/snow-rt/src/string.rs"
      via: "SnowString layout for string encode/decode"
      pattern: "SnowString"
    - from: "crates/snow-rt/src/lib.rs"
      to: "crates/snow-rt/src/dist/mod.rs"
      via: "module declaration"
      pattern: "pub mod dist"
---

<objective>
Create the Snow Term Format (STF) module with scalar type serialization.

Establish the `dist/` module structure in snow-rt and implement STF encode/decode for all scalar Snow types: Int (i64), Float (f64), Bool, String, Unit, and PID (u64). This includes the version byte, type tag constants, error types, and the StfType enum that mirrors Snow's runtime type system.

Purpose: Provides the serialization foundation that container types (Plan 03) build on. Scalar types are the leaf nodes of any STF payload -- containers recursively encode their elements as scalars or nested containers.
Output: New `crates/snow-rt/src/dist/` module with `wire.rs` containing STF constants, error type, and scalar encode/decode.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/63-pid-encoding-wire-format/63-RESEARCH.md
@crates/snow-rt/src/string.rs
@crates/snow-rt/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dist module scaffold with STF constants and types</name>
  <files>crates/snow-rt/src/dist/mod.rs, crates/snow-rt/src/dist/wire.rs, crates/snow-rt/src/lib.rs</files>
  <action>
1. Create directory `crates/snow-rt/src/dist/`.

2. Create `crates/snow-rt/src/dist/mod.rs`:
```rust
//! Distribution subsystem for Snow.
//!
//! Provides PID bit-packing helpers and the Snow Term Format (STF)
//! binary serializer/deserializer for inter-node message transport.

pub mod wire;
```

3. Create `crates/snow-rt/src/dist/wire.rs` with:

**Version constant:**
- `pub const STF_VERSION: u8 = 1;`

**Type tag constants** (exactly as specified in research):
- `TAG_INT: u8 = 1` (i64, 8 bytes LE)
- `TAG_FLOAT: u8 = 2` (f64, 8 bytes LE)
- `TAG_BOOL_TRUE: u8 = 3` (no payload)
- `TAG_BOOL_FALSE: u8 = 4` (no payload)
- `TAG_STRING: u8 = 5` (u32 len + UTF-8 bytes)
- `TAG_UNIT: u8 = 6` (no payload)
- `TAG_LIST: u8 = 10` (u32 count + elements)
- `TAG_MAP: u8 = 11` (u8 key_type + u32 count + entries)
- `TAG_SET: u8 = 12` (u32 count + elements)
- `TAG_TUPLE: u8 = 13` (u8 arity + elements)
- `TAG_STRUCT: u8 = 20` (u16 name_len + name + u16 field_count + fields)
- `TAG_SUM_TYPE: u8 = 21` (u16 type_name_len + name + u8 variant_tag + u16 field_count + fields)
- `TAG_PID: u8 = 30` (u64 raw PID)
- `TAG_OPTION_SOME: u8 = 40` (+ encoded inner)
- `TAG_OPTION_NONE: u8 = 41` (no payload)
- `TAG_RESULT_OK: u8 = 42` (+ encoded inner)
- `TAG_RESULT_ERR: u8 = 43` (+ encoded inner)
- `TAG_CLOSURE: u8 = 0xFF` (error sentinel, never written)

**StfType enum** -- mirrors MirType for type hints:
```rust
#[derive(Debug, Clone, PartialEq)]
pub enum StfType {
    Int,
    Float,
    Bool,
    String,
    Unit,
    Pid,
    List(Box<StfType>),         // element type
    Map(Box<StfType>, Box<StfType>), // key type, value type
    Set(Box<StfType>),          // element type
    Tuple(Vec<StfType>),        // element types
    Struct(std::string::String, Vec<(std::string::String, StfType)>), // name, fields
    SumType(std::string::String, Vec<(std::string::String, Vec<StfType>)>), // name, variants
    OptionOf(Box<StfType>),     // inner type
    ResultOf(Box<StfType>, Box<StfType>), // ok type, err type
    Closure,                    // always errors
    FnPtr,                      // always errors
}
```

**StfError enum:**
```rust
#[derive(Debug, Clone, PartialEq)]
pub enum StfError {
    UnexpectedEof,
    InvalidTag(u8),
    InvalidVersion(u8),
    ClosureNotSerializable,
    PayloadTooLarge(u32),
    InvalidUtf8,
}
```

**Safety limits:**
- `const MAX_STRING_LEN: u32 = 16 * 1024 * 1024;` (16 MB)
- `const MAX_COLLECTION_LEN: u32 = 1_000_000;` (1M elements)

4. Add `pub mod dist;` to `crates/snow-rt/src/lib.rs` (after the `pub mod ws;` line).
  </action>
  <verify>
Run `cargo check -p snow-rt` -- compiles without errors. Verify the dist module is accessible.
  </verify>
  <done>
`crates/snow-rt/src/dist/` exists with mod.rs and wire.rs. All STF constants, StfType, StfError are defined. Module registered in lib.rs. Project compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement STF encode/decode for scalar types with tests</name>
  <files>crates/snow-rt/src/dist/wire.rs</files>
  <action>
Add the following public functions to `crates/snow-rt/src/dist/wire.rs`:

**Encode function:**
```rust
pub fn stf_encode(value: u64, type_hint: &StfType, buf: &mut Vec<u8>) -> Result<(), StfError>
```

For Phase 63 Plan 02, implement these type_hint match arms:
- `StfType::Int` -- push TAG_INT, extend with `(value as i64).to_le_bytes()`
- `StfType::Float` -- push TAG_FLOAT, extend with `f64::from_bits(value).to_le_bytes()`
- `StfType::Bool` -- push TAG_BOOL_TRUE if value != 0, else TAG_BOOL_FALSE (no payload)
- `StfType::String` -- push TAG_STRING, dereference `value as *const SnowString`, read len and bytes via `unsafe { &*(value as *const SnowString) }` then `snow_str.as_bytes()`, write u32 len prefix + bytes. Cap string length at MAX_STRING_LEN, return PayloadTooLarge if exceeded.
- `StfType::Unit` -- push TAG_UNIT (no payload)
- `StfType::Pid` -- push TAG_PID, extend with `value.to_le_bytes()` (raw u64)
- `StfType::Closure | StfType::FnPtr` -- return `Err(StfError::ClosureNotSerializable)`
- All container/composite types -- for now, return `Err(StfError::InvalidTag(0))` with a comment "// Implemented in Plan 03"

**Top-level encode wrapper** that prepends the version byte:
```rust
pub fn stf_encode_value(value: u64, type_hint: &StfType) -> Result<Vec<u8>, StfError> {
    let mut buf = Vec::with_capacity(64);
    buf.push(STF_VERSION);
    stf_encode(value, type_hint, &mut buf)?;
    Ok(buf)
}
```

**Decode function:**
```rust
pub fn stf_decode(data: &[u8], pos: &mut usize) -> Result<(u64, StfType), StfError>
```

Read the tag byte at `data[*pos]`, then decode based on tag:
- `TAG_INT` -- read 8 bytes LE as i64, return as u64 bits
- `TAG_FLOAT` -- read 8 bytes LE as f64 bits, return as u64
- `TAG_BOOL_TRUE` -- return (1, StfType::Bool)
- `TAG_BOOL_FALSE` -- return (0, StfType::Bool)
- `TAG_STRING` -- read u32 len, validate <= MAX_STRING_LEN and within remaining buffer, allocate SnowString via `crate::string::snow_string_new(ptr, len)`, return pointer as u64
- `TAG_UNIT` -- return (0, StfType::Unit)
- `TAG_PID` -- read 8 bytes LE as u64, return (raw_pid, StfType::Pid)
- `TAG_CLOSURE` -- return `Err(StfError::ClosureNotSerializable)`
- Any unknown tag -- return `Err(StfError::InvalidTag(tag))`
- Container tags (10-13, 20-21, 40-43) -- return `Err(StfError::InvalidTag(tag))` for now (Plan 03)

Always check `*pos + N <= data.len()` before reading N bytes. Return `StfError::UnexpectedEof` if insufficient data.

**Top-level decode wrapper:**
```rust
pub fn stf_decode_value(data: &[u8]) -> Result<(u64, StfType), StfError> {
    if data.is_empty() { return Err(StfError::UnexpectedEof); }
    if data[0] != STF_VERSION { return Err(StfError::InvalidVersion(data[0])); }
    let mut pos = 1;
    stf_decode(data, &mut pos)
}
```

Import `use crate::string::{SnowString, snow_string_new};` at the top of wire.rs.

**Unit tests** in `#[cfg(test)] mod tests` block:
- `test_int_roundtrip`: encode i64 values (-1, 0, i64::MAX), decode, verify match
- `test_float_roundtrip`: encode f64 values (3.14, -0.0, f64::INFINITY, f64::NAN), decode, verify bits match
- `test_bool_roundtrip`: encode true (1) and false (0), decode, verify
- `test_string_roundtrip`: use `snow_string_new` to create a test string "hello", encode, decode, verify content matches. Need `use crate::gc::snow_rt_init;` and call `snow_rt_init()` first to initialize the allocator.
- `test_unit_roundtrip`: encode unit, decode, verify tag
- `test_pid_roundtrip`: encode a raw PID u64, decode, verify exact match
- `test_closure_rejected`: `stf_encode_value(0, &StfType::Closure)` returns `Err(ClosureNotSerializable)`
- `test_fnptr_rejected`: `stf_encode_value(0, &StfType::FnPtr)` returns `Err(ClosureNotSerializable)`
- `test_truncated_int_decode`: try decoding a TAG_INT with only 4 bytes of payload, verify UnexpectedEof
- `test_version_check`: try decoding with wrong version byte, verify InvalidVersion

For string tests, use unsafe to create test strings since snow_string_new requires GC init. Pattern from existing tests: call `crate::gc::snow_rt_init()` at start of test.
  </action>
  <verify>
Run `cargo test -p snow-rt dist::wire::tests` -- all scalar encode/decode tests pass. Run `cargo test` -- full suite still passes (1,524+ tests, no regressions).
  </verify>
  <done>
STF scalar encode/decode works for Int, Float, Bool, String, Unit, PID. Closures/FnPtrs correctly rejected. Version byte present. Truncated payloads produce clean errors. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p snow-rt` -- compiles cleanly
2. `cargo test -p snow-rt dist::wire::tests` -- all STF scalar tests pass
3. `cargo test` -- full workspace test suite passes (no regressions)
4. STF version byte is first byte of every encoded payload
5. Closure/FnPtr serialization produces clear error
</verification>

<success_criteria>
- dist/ module exists with wire.rs
- All 17 type tag constants defined
- StfType enum covers all Snow types
- StfError enum handles all error cases
- Scalar types (Int, Float, Bool, String, Unit, PID) round-trip through encode/decode
- Closures and function pointers produce StfError::ClosureNotSerializable
- Truncated payloads produce StfError::UnexpectedEof
- Version byte validation works
- All 1,524+ existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/63-pid-encoding-wire-format/63-02-SUMMARY.md`
</output>
