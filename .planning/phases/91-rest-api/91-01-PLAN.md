---
phase: 91-rest-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mesher/api/search.mpl
  - mesher/storage/queries.mpl
  - mesher/main.mpl
autonomous: true

must_haves:
  truths:
    - "User can filter issues by status, level, and assignment via query parameters on GET /api/v1/projects/:project_id/issues"
    - "User can search event messages via full-text search with GET /api/v1/projects/:project_id/events/search?q=..."
    - "User can filter events by tag key-value pairs with GET /api/v1/projects/:project_id/events/tags?key=...&value=..."
    - "Issue and event list endpoints use keyset pagination with cursor/cursor_id query parameters"
    - "All event queries default to last 24 hours when no time range is specified"
  artifacts:
    - path: "mesher/api/search.mpl"
      provides: "Search, filter, and pagination HTTP handlers"
    - path: "mesher/storage/queries.mpl"
      provides: "Extended with search/filter/pagination query functions"
    - path: "mesher/main.mpl"
      provides: "Updated with search route registration"
  key_links:
    - from: "mesher/api/search.mpl"
      to: "mesher/storage/queries.mpl"
      via: "imports search query functions"
    - from: "mesher/main.mpl"
      to: "mesher/api/search.mpl"
      via: "imports and registers search route handlers"
---

<objective>
Implement search, filtering, and keyset pagination endpoints for issues and events (SEARCH-01 through SEARCH-05).

Purpose: Enable users to query and browse issue and event data with filters (status, level, assignment, time range), full-text event message search via PostgreSQL tsvector, tag-based event filtering via JSONB containment, and cursor-based pagination for stable browsing of large result sets.

Output: New `api/search.mpl` with 4 GET endpoints, extended `queries.mpl` with parameterized search queries, updated `main.mpl` with route registration.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/91-rest-api/91-RESEARCH.md

@mesher/ingestion/routes.mpl
@mesher/storage/queries.mpl
@mesher/ingestion/pipeline.mpl
@mesher/main.mpl
@mesher/types/issue.mpl
@mesher/types/event.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search and filter query functions to queries.mpl</name>
  <files>mesher/storage/queries.mpl</files>
  <action>
Add the following new query functions to the END of storage/queries.mpl (after the existing extract_event_fields function). All functions use parameterized queries ($1, $2, etc.) -- NEVER interpolate user input into SQL strings. Use the SQL-side conditional pattern `($N = '' OR column = $N)` for optional filters.

**1. `list_issues_filtered` -- SEARCH-01 + SEARCH-05 (issue filtering with keyset pagination)**
```
pub fn list_issues_filtered(pool :: PoolHandle, project_id :: String, status :: String, level :: String, assigned_to :: String, cursor :: String, cursor_id :: String, limit_str :: String)
```
- Two SQL branches: with cursor (keyset `WHERE (last_seen, id) < ($cursor::timestamptz, $cursor_id::uuid)`) and without cursor (first page).
- Optional filters: `AND ($2 = '' OR status = $2) AND ($3 = '' OR level = $3) AND ($4 = '' OR assigned_to = $4::uuid)`
- ORDER BY last_seen DESC, id DESC, LIMIT $N::int
- SELECT columns: id::text, project_id::text, fingerprint, title, level, status, event_count::text, first_seen::text, last_seen::text, COALESCE(assigned_to::text, '') as assigned_to
- Returns raw `List<Map<String, String>>!String` (NOT Issue struct) -- the handler does JSON serialization from Map fields directly for flexibility and to avoid cross-module struct issues.
- Uses `if String.length(cursor) > 0 do ... else ... end` to branch.

**2. `search_events_fulltext` -- SEARCH-02 (full-text search)**
```
pub fn search_events_fulltext(pool :: PoolHandle, project_id :: String, search_query :: String, limit_str :: String)
```
- Uses inline `to_tsvector('english', message) @@ plainto_tsquery('english', $2)` (NOT stored tsvector column -- avoids partition complications per research).
- Includes `received_at > now() - interval '24 hours'` for default time range (SEARCH-04).
- Includes `ts_rank(to_tsvector('english', message), plainto_tsquery('english', $2))::text AS rank` for relevance ordering.
- SELECT columns: id::text, issue_id::text, level, message, received_at::text, rank
- ORDER BY rank DESC, received_at DESC, LIMIT $3::int

**3. `filter_events_by_tag` -- SEARCH-03 (tag filtering)**
```
pub fn filter_events_by_tag(pool :: PoolHandle, project_id :: String, tag_json :: String, limit_str :: String)
```
- Uses `tags @> $2::jsonb` for JSONB containment (leverages existing GIN index idx_events_tags).
- Includes `received_at > now() - interval '24 hours'` default time range (SEARCH-04).
- SELECT columns: id::text, issue_id::text, level, message, tags::text, received_at::text
- ORDER BY received_at DESC, LIMIT $3::int

**4. `list_events_for_issue` -- Event listing within an issue (for DETAIL-05 context + pagination)**
```
pub fn list_events_for_issue(pool :: PoolHandle, issue_id :: String, cursor :: String, cursor_id :: String, limit_str :: String)
```
- Two branches: with cursor (keyset on received_at, id) and without.
- SELECT columns: id::text, level, message, received_at::text
- ORDER BY received_at DESC, id DESC, LIMIT $N::int

All functions follow the established pattern: `let rows = Pool.query(pool, sql, params)?` with `?` operator for error propagation (decision [87.2-02]).
  </action>
  <verify>Run `cd /Users/sn0w/Documents/dev/snow && cargo build 2>&1 | tail -20` and verify no Rust compilation errors (queries.mpl is parsed by the Mesh compiler which runs inside cargo build). If there are Mesh syntax errors, they will appear in the build output.</verify>
  <done>Four new query functions added to queries.mpl with parameterized SQL, keyset pagination support, inline tsvector search, and JSONB containment filtering. All use `?` operator for error propagation.</done>
</task>

<task type="auto">
  <name>Task 2: Create search route handlers and register in main.mpl</name>
  <files>mesher/api/search.mpl, mesher/main.mpl</files>
  <action>
**Create `mesher/api/search.mpl`** with the following structure. Follow the EXACT handler pattern from ingestion/routes.mpl: get registry -> get pool -> extract params -> query -> serialize -> respond.

**CRITICAL:** Order functions bottom-up (leaf helpers first, pub handlers last) per decision [90-03]. Extract if/else logic into helper functions per decision [90-03].

**Imports:**
```
from Ingestion.Pipeline import PipelineRegistry
from Storage.Queries import list_issues_filtered, search_events_fulltext, filter_events_by_tag, list_events_for_issue
```

**Shared helpers (define at TOP of file, before handlers):**

1. `query_or_default(request, param :: String, default :: String) -> String` -- Extract optional query param with default. Uses `Request.query(request, param)` which returns `Option<String>`, case match to Some(v)->v, None->default.

2. `get_limit(request) -> String` -- Extract limit param, default "25", cap at 100. Parse with String.to_int, validate range, return as String for SQL param. If parse fails or > 100, return "25".

3. `row_to_issue_json(row) -> String` -- Convert a Map<String, String> row to JSON. Include all issue fields: id, title, level, status, event_count, first_seen, last_seen, assigned_to. Use `\"` quoting for string fields.

4. `row_to_event_json(row) -> String` -- Convert event search result row to JSON. Fields: id, issue_id, level, message, received_at. Use `\"` quoting.

5. `row_to_tag_event_json(row) -> String` -- Convert tag filter result row to JSON. Fields: id, issue_id, level, message, tags (raw JSONB -- embed without quoting), received_at.

6. `json_array_loop(items, i :: Int, total :: Int, acc :: String) -> String` -- Recursive JSON array builder. Same pattern as routes.mpl's issues_to_json_loop.

7. `to_json_array(items) -> String` -- Wrapper calling json_array_loop.

8. `build_paginated_response(json_array :: String, rows, limit :: Int) -> String` -- Build response with pagination metadata. Check if List.length(rows) == limit to set has_more. Extract last_seen and id from last row for next_cursor/next_cursor_id. Returns `{"data":..., "next_cursor":"...", "next_cursor_id":"...", "has_more":true/false}`.

**Handler functions (define AFTER all helpers):**

1. `pub fn handle_search_issues(request)` -- GET /api/v1/projects/:project_id/issues
   - Extract: project_id (Request.param), status (query_or_default ""), level (query_or_default ""), assigned_to (query_or_default ""), cursor (query_or_default ""), cursor_id (query_or_default ""), limit (get_limit)
   - Call: list_issues_filtered(pool, project_id, status, level, assigned_to, cursor, cursor_id, limit)
   - Serialize: map rows through row_to_issue_json, build paginated response
   - Response: HTTP.response(200, paginated_json)

2. `pub fn handle_search_events(request)` -- GET /api/v1/projects/:project_id/events/search
   - Extract: project_id, q (query param, required)
   - If q is empty, return HTTP.response(400, `{"error":"missing search query"}`)
   - Call: search_events_fulltext(pool, project_id, q, limit)
   - Serialize: map rows, to_json_array
   - Response: HTTP.response(200, json_array)

3. `pub fn handle_filter_by_tag(request)` -- GET /api/v1/projects/:project_id/events/tags
   - Extract: project_id, key (required), value (required)
   - Build tag_json: `{"key":"value"}` from params (for JSONB @> operator)
   - If key or value empty, return 400
   - Call: filter_events_by_tag(pool, project_id, tag_json, limit)
   - Serialize: map rows through row_to_tag_event_json, to_json_array
   - Response: HTTP.response(200, json_array)

4. `pub fn handle_list_issue_events(request)` -- GET /api/v1/issues/:issue_id/events
   - Extract: issue_id (Request.param), cursor, cursor_id, limit
   - Call: list_events_for_issue(pool, issue_id, cursor, cursor_id, limit)
   - Serialize with pagination metadata
   - Response: HTTP.response(200, paginated_json)

**Update `mesher/main.mpl`:**
- Add import: `from Api.Search import handle_search_issues, handle_search_events, handle_filter_by_tag, handle_list_issue_events`
- REMOVE the existing import of `handle_list_issues` from Ingestion.Routes (the new handle_search_issues replaces it with full filtering + pagination)
- Add 4 route registrations AFTER the existing issue management routes:
  ```
  let r = HTTP.on_get(r, "/api/v1/projects/:project_id/issues", handle_search_issues)
  let r = HTTP.on_get(r, "/api/v1/projects/:project_id/events/search", handle_search_events)
  let r = HTTP.on_get(r, "/api/v1/projects/:project_id/events/tags", handle_filter_by_tag)
  let r = HTTP.on_get(r, "/api/v1/issues/:issue_id/events", handle_list_issue_events)
  ```
- REPLACE the existing `handle_list_issues` route registration with the new `handle_search_issues` one (same path, new handler with filtering).

**Key constraints from accumulated decisions:**
- [87-01] UUID columns cast to ::text in SELECT
- [88-02] Single-expression case arms -- extract multi-line logic into helper functions
- [88-03] PipelineRegistry pattern for pool lookup
- [90-03] Helper functions ordered bottom-up (leaf first)
- [90-03] if/else guard logic extracted to helper functions
- Research: Request.query IS fully implemented -- use it for all filter parameters
- Research: NEVER interpolate user input into SQL -- use parameterized queries exclusively
  </action>
  <verify>Run `cd /Users/sn0w/Documents/dev/snow && cargo build 2>&1 | tail -30` and verify compilation succeeds. Check for any Mesh compilation errors in the output. The new api/search.mpl module should be picked up by the build system automatically.</verify>
  <done>Four search/filter/pagination endpoints exist and compile: issue listing with filters + pagination, full-text event search, tag-based event filtering, and per-issue event listing. All registered in main.mpl router. The old hardcoded handle_list_issues is replaced by the new filtered handle_search_issues.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. All 4 search query functions exist in queries.mpl with parameterized SQL
3. api/search.mpl exports 4 pub handler functions
4. main.mpl registers all 4 GET routes
5. No SQL string interpolation of user input anywhere in search.mpl or queries.mpl
6. Keyset pagination pattern used (cursor/cursor_id) not OFFSET
7. 24-hour default time range on event queries
</verification>

<success_criteria>
- SEARCH-01: Issue filtering by status, level, assignment via query params
- SEARCH-02: Full-text event search via PostgreSQL tsvector (inline, not stored column)
- SEARCH-03: Tag-based event filtering via JSONB containment operator
- SEARCH-04: Default 24-hour time range on all event queries
- SEARCH-05: Keyset pagination on issue and event list endpoints
- The existing handle_list_issues functionality preserved but upgraded with filtering
</success_criteria>

<output>
After completion, create `.planning/phases/91-rest-api/91-01-SUMMARY.md`
</output>
