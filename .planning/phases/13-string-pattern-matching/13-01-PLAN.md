---
phase: 13-string-pattern-matching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-codegen/src/codegen/pattern.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "case name do \"alice\" -> 1; \"bob\" -> 2; _ -> 0 end compiles and matches correctly at runtime"
    - "Exhaustiveness checker distinguishes different string patterns (\"alice\" vs \"bob\") instead of treating all as identical"
    - "Compiler warns when string case expression lacks wildcard/default clause"
    - "String binary comparison (\"hello\" == \"hello\") evaluates to true at runtime"
    - "String patterns work in multi-clause functions and closures (same codegen path)"
  artifacts:
    - path: "crates/snow-codegen/src/codegen/pattern.rs"
      provides: "String literal pattern codegen via snow_string_eq"
      contains: "snow_string_eq"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Correct string content extraction for exhaustiveness"
      contains: "STRING_CONTENT"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "String binary comparison via snow_string_eq"
      contains: "snow_string_eq"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E tests for string pattern matching and comparison"
      contains: "string_pattern"
  key_links:
    - from: "crates/snow-codegen/src/codegen/pattern.rs"
      to: "snow_string_eq runtime function"
      via: "get_intrinsic + build_call"
      pattern: "get_intrinsic.*snow_string_eq"
    - from: "crates/snow-codegen/src/codegen/pattern.rs"
      to: "codegen_string_lit helper"
      via: "self.codegen_string_lit(s)"
      pattern: "codegen_string_lit"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "LiteralPat syntax node children"
      via: "lit.syntax().children_with_tokens() for STRING_CONTENT"
      pattern: "STRING_CONTENT"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "snow_string_eq runtime function"
      via: "get_intrinsic + build_call"
      pattern: "get_intrinsic.*snow_string_eq"
---

<objective>
Fix three placeholder/buggy implementations that prevent string pattern matching and string comparison from working at runtime.

Purpose: The entire string pattern matching pipeline (parser -> typeck -> MIR -> pattern compilation -> decision tree) already works end-to-end. The ONLY gaps are: (1) codegen emits "always false" for string pattern tests, (2) exhaustiveness extracts the quote character instead of string content, and (3) binary string == always returns false. Fixing these three placeholders completes PAT-01 and PAT-02.

Output: Working string pattern matching in case expressions, multi-clause functions, and closures. Working string equality comparison in binary expressions. Correct exhaustiveness warnings for string patterns.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-string-pattern-matching/13-RESEARCH.md

@crates/snow-codegen/src/codegen/pattern.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snowc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix string codegen placeholders and exhaustiveness bug</name>
  <files>
    crates/snow-codegen/src/codegen/pattern.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
Three targeted fixes. Each replaces a placeholder/bug with a working implementation using existing infrastructure.

**Fix 1: codegen/pattern.rs -- codegen_test() MirLiteral::String branch (line ~320-324)**

Replace the placeholder:
```rust
MirLiteral::String(_) => {
    self.context.bool_type().const_int(0, false)
}
```

With a working implementation that:
1. Calls `self.codegen_string_lit(s)` to create a SnowString for the pattern literal (same helper used by string literal expressions in expr.rs:150-179)
2. Gets the `snow_string_eq` intrinsic via `get_intrinsic(&self.module, "snow_string_eq")` (already declared in intrinsics.rs:184-186, signature: `(ptr, ptr) -> i8`)
3. Calls `snow_string_eq(test_val, pattern_str)` via `build_call`
4. Extracts the i8 result via `.try_as_basic_value().basic()` -> `.into_int_value()`
5. Compares against zero via `build_int_compare(IntPredicate::NE, i8_result, i8_zero, "str_eq_bool")` to produce an i1 for the branch condition

The `MirLiteral::String(s)` variant contains the string content as `&str`. The `codegen_string_lit` method is defined in expr.rs and is accessible via `self` since both are `impl CodeGen`.

Add import `use super::intrinsics::get_intrinsic;` at the top of pattern.rs (it is NOT currently imported there -- expr.rs imports it but pattern.rs does not).

**Fix 2: infer.rs -- ast_pattern_to_abstract() STRING_START branch (line ~2982-2984)**

Replace:
```rust
SyntaxKind::STRING_START => AbsPat::Literal {
    value: token.text().to_string(),
    ty: AbsLitKind::String,
},
```

With code that extracts STRING_CONTENT from the LITERAL_PAT node:
```rust
SyntaxKind::STRING_START => {
    let mut content = String::new();
    for child in lit.syntax().children_with_tokens() {
        if child.kind() == SyntaxKind::STRING_CONTENT {
            if let Some(tok) = child.as_token() {
                content.push_str(tok.text());
            }
        }
    }
    AbsPat::Literal {
        value: content,
        ty: AbsLitKind::String,
    }
}
```

The `lit` variable is the `LiteralPat` from `Pattern::Literal(lit)` (line 2963). `lit.syntax()` returns a `&SyntaxNode` of kind LITERAL_PAT which has children: STRING_START ('"'), STRING_CONTENT ('alice'), STRING_END ('"'). The `AstNode` trait is already imported. `SyntaxKind::STRING_CONTENT` should already be available from the syntax kinds enum.

**Fix 3: codegen/expr.rs -- codegen_string_compare() (line ~419-434)**

Replace the placeholder that always returns false/true with a working implementation:
1. Get `snow_string_eq` via `get_intrinsic` (already imported in expr.rs:11)
2. Call `snow_string_eq(lhs, rhs)` -- both params are already `BasicValueEnum<'ctx>`, pass them as `.into()` args
3. Extract i8 result, compare against zero to get i1
4. For `BinOp::Eq`: return the i1 directly
5. For `BinOp::NotEq`: negate via `build_not(eq_result, "str_neq")`
6. Remove the leading underscores from `_lhs` and `_rhs` params since they're now used

See the research RESEARCH.md "Fix 3" code example for the exact implementation.
  </action>
  <verify>
Run `cargo test --lib` from the workspace root to confirm all existing unit tests still pass (no regressions from the codegen/typeck changes). Run `cargo build` to confirm the compiler builds cleanly with no warnings from the changed code.
  </verify>
  <done>
The three placeholders are replaced with working implementations. `codegen_test` calls `snow_string_eq` for string pattern tests. `ast_pattern_to_abstract` extracts STRING_CONTENT instead of STRING_START quote char. `codegen_string_compare` calls `snow_string_eq` for binary == and !=. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for string pattern matching and comparison</name>
  <files>
    crates/snowc/tests/e2e.rs
  </files>
  <action>
Add the following e2e tests to `crates/snowc/tests/e2e.rs` using the existing `compile_and_run` helper (writes a .snow source, invokes snowc build, runs binary, asserts stdout).

**Test 1: `test_string_pattern_matching`**
```snow
fn describe(name :: String) -> String do
  case name do
    "alice" -> "found alice"
    "bob" -> "found bob"
    _ -> "unknown"
  end
end

fn main() do
  println(describe("alice"))
  println(describe("bob"))
  println(describe("charlie"))
end
```
Expected output: `"found alice\nfound bob\nunknown\n"`

This tests PAT-01 (compile-time string comparison in case expressions) and PAT-02 (wildcard required for non-exhaustive string match).

**Test 2: `test_string_equality_comparison`**
```snow
fn main() do
  let x = "hello"
  if x == "hello" do
    println("equal")
  else
    println("not equal")
  end
  if x != "world" do
    println("different")
  else
    println("same")
  end
end
```
Expected output: `"equal\ndifferent\n"`

This tests that binary string == and != work correctly (Fix 3).

**Test 3: `test_string_pattern_mixed_with_variable`**
```snow
fn greet(name :: String) -> String do
  case name do
    "world" -> "Hello, world!"
    other -> "Hi, " <> other <> "!"
  end
end

fn main() do
  println(greet("world"))
  println(greet("Snow"))
end
```
Expected output: `"Hello, world!\nHi, Snow!\n"`

This tests Success Criteria 3: string patterns mixed with variable bindings in the same case expression.

Follow the existing test naming and structure patterns in e2e.rs. Each test is a `#[test]` function that calls `compile_and_run(source)` and asserts `assert_eq!(output, expected)`.
  </action>
  <verify>
Run `cargo test --test e2e test_string_pattern_matching test_string_equality_comparison test_string_pattern_mixed_with_variable` (or `cargo test --test e2e string` to match all three). All three tests must pass. Also run the full e2e test suite `cargo test --test e2e` to confirm no regressions.
  </verify>
  <done>
Three e2e tests pass: string pattern matching in case expressions selects the correct branch, string binary == and != evaluate correctly, and string patterns can be mixed with variable bindings. All existing e2e tests continue to pass (no regressions).
  </done>
</task>

</tasks>

<verification>
1. `cargo test --lib` -- all unit tests pass (no regressions from codegen/typeck changes)
2. `cargo test --test e2e` -- all e2e tests pass including the 3 new string tests
3. `cargo build` -- compiler builds cleanly
4. Manual sanity check: create a .snow file with string case expression, compile, run, verify correct output
</verification>

<success_criteria>
- PAT-01 satisfied: `case name do "alice" -> ... "bob" -> ... _ -> ... end` compiles and matches correctly
- PAT-02 satisfied: Exhaustiveness checker properly distinguishes string patterns and requires wildcard for non-exhaustive string matches
- Bonus: String binary == and != work correctly (no longer always false/true)
- All existing tests pass (zero regressions)
- Three new e2e tests prove the feature works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/13-string-pattern-matching/13-01-SUMMARY.md`
</output>
