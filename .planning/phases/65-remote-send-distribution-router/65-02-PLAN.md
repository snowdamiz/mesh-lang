---
phase: 65-remote-send-distribution-router
plan: 02
type: execute
wave: 2
depends_on: ["65-01"]
files_modified:
  - crates/snow-rt/src/dist/node.rs
  - crates/snow-rt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Connecting node A to node B causes B to send its peer list to A, and A connects to unknown peers"
    - "User can call Node.self() to get the current node's name as a Snow string"
    - "User can call Node.list() to get a list of all connected node names"
    - "Mesh connections are spawned on a separate thread to avoid deadlocking the reader loop"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "send_peer_list, handle_peer_list, DIST_PEER_LIST, snow_node_self, snow_node_list"
      contains: "DIST_PEER_LIST"
    - path: "crates/snow-rt/src/lib.rs"
      provides: "Re-exports for snow_node_self and snow_node_list"
      contains: "snow_node_self"
  key_links:
    - from: "crates/snow-rt/src/dist/node.rs (send_peer_list)"
      to: "crates/snow-rt/src/dist/node.rs (register_session + spawn_session_threads)"
      via: "called after spawn_session_threads in both accept_loop and snow_node_connect"
      pattern: "send_peer_list"
    - from: "crates/snow-rt/src/dist/node.rs (handle_peer_list)"
      to: "crates/snow-rt/src/dist/node.rs (snow_node_connect)"
      via: "spawns thread calling snow_node_connect for unknown peers"
      pattern: "std::thread::spawn"
    - from: "crates/snow-rt/src/dist/node.rs (reader_loop_session)"
      to: "crates/snow-rt/src/dist/node.rs (handle_peer_list)"
      via: "DIST_PEER_LIST branch in reader loop match"
      pattern: "DIST_PEER_LIST"
---

<objective>
Add automatic mesh formation via peer list exchange and Node.self()/Node.list() query APIs.

Purpose: Mesh formation means connecting to one node discovers the entire cluster. Query APIs let Snow programs inspect the cluster topology. Together these complete the Phase 65 requirements for NODE-06 and NODE-07.

Output: send_peer_list and handle_peer_list functions, DIST_PEER_LIST reader loop handler, snow_node_self and snow_node_list extern "C" APIs, lib.rs re-exports.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-remote-send-distribution-router/65-RESEARCH.md
@.planning/phases/65-remote-send-distribution-router/65-01-SUMMARY.md
@crates/snow-rt/src/dist/node.rs
@crates/snow-rt/src/lib.rs
@crates/snow-rt/src/string/mod.rs
@crates/snow-rt/src/collections/list.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Automatic mesh formation via peer list exchange</name>
  <files>crates/snow-rt/src/dist/node.rs</files>
  <action>
**In `crates/snow-rt/src/dist/node.rs`:**

1. Add the DIST_PEER_LIST constant near DIST_SEND/DIST_REG_SEND (added by Plan 01):
```rust
pub(crate) const DIST_PEER_LIST: u8 = 0x12; // [tag][u16 count][u16 name_len, name bytes, ...]
```

2. Add `send_peer_list` function that sends the current peer list to a newly connected node:
```rust
/// Send our current peer list to a newly connected node for mesh formation.
///
/// Wire format: [DIST_PEER_LIST][u16 count][u16 name_len][name bytes]...
/// Skips the receiving node's own name (no need to tell B about B).
fn send_peer_list(session: &Arc<NodeSession>) {
    let state = match node_state() {
        Some(s) => s,
        None => return,
    };

    let sessions = state.sessions.read();
    let peers: Vec<&String> = sessions.keys()
        .filter(|name| *name != &session.remote_name)
        .collect();

    if peers.is_empty() {
        return;
    }

    let mut payload = Vec::new();
    payload.push(DIST_PEER_LIST);
    payload.extend_from_slice(&(peers.len() as u16).to_le_bytes());
    for peer_name in &peers {
        let bytes = peer_name.as_bytes();
        payload.extend_from_slice(&(bytes.len() as u16).to_le_bytes());
        payload.extend_from_slice(bytes);
    }
    drop(sessions); // Release read lock before acquiring stream lock

    let mut stream = session.stream.lock().unwrap();
    let _ = write_msg(&mut *stream, &payload);
}
```

3. Add `handle_peer_list` function that processes incoming peer lists and connects to unknown peers:
```rust
/// Handle an incoming DIST_PEER_LIST -- connect to unknown peers on a separate thread.
///
/// Parses the peer list, filters out self and already-connected nodes,
/// then spawns a thread to connect to the remaining peers. The thread spawn
/// avoids deadlock (see Pitfall 7 in RESEARCH.md).
fn handle_peer_list(data: &[u8]) {
    if data.len() < 2 { return; }
    let count = u16::from_le_bytes(data[0..2].try_into().unwrap()) as usize;
    let mut pos = 2;
    let mut to_connect = Vec::new();

    let state = match node_state() {
        Some(s) => s,
        None => return,
    };

    for _ in 0..count {
        if pos + 2 > data.len() { break; }
        let name_len = u16::from_le_bytes(data[pos..pos+2].try_into().unwrap()) as usize;
        pos += 2;
        if pos + name_len > data.len() { break; }
        if let Ok(peer_name) = std::str::from_utf8(&data[pos..pos+name_len]) {
            // Skip self and already-connected nodes
            if peer_name != state.name {
                let sessions = state.sessions.read();
                if !sessions.contains_key(peer_name) {
                    to_connect.push(peer_name.to_string());
                }
            }
        }
        pos += name_len;
    }

    // Spawn connection attempts on a separate thread to avoid deadlock
    if !to_connect.is_empty() {
        std::thread::spawn(move || {
            for peer in to_connect {
                let bytes = peer.as_bytes();
                snow_node_connect(bytes.as_ptr(), bytes.len() as u64);
            }
        });
    }
}
```

4. Add DIST_PEER_LIST handler to `reader_loop_session`'s match block (after the DIST_SEND and DIST_REG_SEND handlers added by Plan 01):
```rust
DIST_PEER_LIST => {
    handle_peer_list(&msg[1..]);
}
```

5. Wire `send_peer_list` into both connection paths -- call it AFTER `spawn_session_threads`:
   - In the `accept_loop` function: after `spawn_session_threads(&session)`, add `send_peer_list(&session);`
   - In `snow_node_connect`: after `spawn_session_threads(&session)`, add `send_peer_list(&session);`

Both locations follow the same pattern: `register_session` -> `spawn_session_threads` -> `send_peer_list`. The peer list must be sent AFTER session threads are spawned so the receiving node can immediately use the connection.
  </action>
  <verify>
`cargo build -p snow-rt 2>&1 | head -20` compiles without errors. `cargo test -p snow-rt 2>&1 | tail -5` -- all tests pass. Verify: `grep "send_peer_list\|handle_peer_list\|DIST_PEER_LIST" crates/snow-rt/src/dist/node.rs` shows all three present.
  </verify>
  <done>
Peer list exchange is wired into both accept_loop and snow_node_connect. Reader loop dispatches DIST_PEER_LIST to handle_peer_list. Mesh connections spawn on separate thread to avoid deadlock. Self and already-connected nodes are filtered out to prevent infinite loops.
  </done>
</task>

<task type="auto">
  <name>Task 2: Node.self() and Node.list() extern "C" query APIs</name>
  <files>crates/snow-rt/src/dist/node.rs, crates/snow-rt/src/lib.rs</files>
  <action>
**In `crates/snow-rt/src/dist/node.rs`:**

1. Add `snow_node_self` extern "C" function:
```rust
/// Return the current node's name as a Snow string pointer.
///
/// Returns null pointer if node is not started (snow_node_start not called).
/// The returned string is GC-allocated via snow_string_new.
#[no_mangle]
pub extern "C" fn snow_node_self() -> *const u8 {
    match node_state() {
        Some(state) => {
            crate::string::snow_string_new(
                state.name.as_ptr(),
                state.name.len() as u64,
            )
        }
        None => std::ptr::null(),
    }
}
```

2. Add `snow_node_list` extern "C" function that returns a Snow list of string pointers:
```rust
/// Return a list of connected node names as a Snow list of strings.
///
/// Returns an empty list if node is not started or no connections exist.
/// Each element is a GC-allocated Snow string. The list itself is allocated
/// via snow_list_from_array.
#[no_mangle]
pub extern "C" fn snow_node_list() -> *mut u8 {
    let state = match node_state() {
        Some(s) => s,
        None => {
            return crate::collections::list::snow_list_new();
        }
    };

    let sessions = state.sessions.read();
    if sessions.is_empty() {
        return crate::collections::list::snow_list_new();
    }

    let names: Vec<String> = sessions.keys().cloned().collect();
    drop(sessions);

    // Build array of Snow string pointers, then create list from array
    let mut string_ptrs: Vec<u64> = Vec::with_capacity(names.len());
    for name in &names {
        let s = crate::string::snow_string_new(name.as_ptr(), name.len() as u64);
        string_ptrs.push(s as u64);
    }

    crate::collections::list::snow_list_from_array(
        string_ptrs.as_ptr(),
        string_ptrs.len() as i64,
    )
}
```

Note: `snow_list_new()` returns an empty list. `snow_list_from_array` takes `*const u64, i64` and builds a proper Snow list. `snow_string_new` returns `*const u8` which we cast to u64 for the list element (Snow stores all values as u64 internally).

**In `crates/snow-rt/src/lib.rs`:**

3. Add dist node re-exports after the existing re-export blocks:
```rust
pub use dist::node::{snow_node_self, snow_node_list, snow_node_start, snow_node_connect};
```

This adds `snow_node_start` and `snow_node_connect` to the re-exports as well (they were already pub extern "C" but not re-exported from lib.rs -- no functional change but consistent).
  </action>
  <verify>
`cargo build -p snow-rt 2>&1 | head -20` compiles without errors. `cargo test -p snow-rt 2>&1 | tail -5` -- all tests pass. Verify: `grep "snow_node_self\|snow_node_list" crates/snow-rt/src/lib.rs` shows both re-exported.
  </verify>
  <done>
snow_node_self returns the current node's name as a Snow string (null if not started). snow_node_list returns a Snow list of connected node name strings (empty list if not started or no connections). Both functions and snow_node_start/snow_node_connect are re-exported from lib.rs.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` -- compiles with no errors or warnings
2. `cargo test -p snow-rt` -- all tests pass (no regressions)
3. `grep "DIST_PEER_LIST" crates/snow-rt/src/dist/node.rs` -- constant exists
4. `grep "send_peer_list" crates/snow-rt/src/dist/node.rs` -- called in accept_loop and snow_node_connect
5. `grep "handle_peer_list" crates/snow-rt/src/dist/node.rs` -- called from reader loop
6. `grep "snow_node_self\|snow_node_list\|snow_node_start\|snow_node_connect" crates/snow-rt/src/lib.rs` -- all re-exported
</verification>

<success_criteria>
- Peer list is sent after every new connection (both incoming and outgoing)
- Receiving a peer list triggers connection attempts to unknown peers on a separate thread
- Self-connections and duplicate connections are prevented
- snow_node_self returns the node name as a Snow string or null
- snow_node_list returns a Snow list of connected node name strings or empty list
- All new extern "C" functions are re-exported from lib.rs
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/65-remote-send-distribution-router/65-02-SUMMARY.md`
</output>
