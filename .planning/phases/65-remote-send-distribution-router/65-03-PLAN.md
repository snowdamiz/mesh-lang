---
phase: 65-remote-send-distribution-router
plan: 03
type: execute
wave: 3
depends_on: ["65-02"]
files_modified:
  - crates/snow-rt/src/dist/node.rs
autonomous: true

must_haves:
  truths:
    - "A test proves that dist_send delivers a message to a remote actor's mailbox via DIST_SEND wire protocol"
    - "A test proves that DIST_REG_SEND delivers a message to a named process on the receiving node"
    - "A test proves that peer list exchange creates transitive connections for mesh formation"
    - "A test proves that snow_node_self returns the correct node name and snow_node_list returns connected nodes"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "Integration tests for remote send, named send, mesh formation, and node query APIs"
      contains: "test_dist_send"
  key_links:
    - from: "crates/snow-rt/src/dist/node.rs (tests)"
      to: "crates/snow-rt/src/dist/node.rs (dist_send, reader_loop, peer_list)"
      via: "tests exercise the full send->wire->receive pipeline"
      pattern: "DIST_SEND|DIST_REG_SEND|DIST_PEER_LIST"
---

<objective>
Comprehensive integration tests proving all Phase 65 features work end-to-end: remote send, named send, mesh formation, and node query APIs.

Purpose: Tests verify the complete message routing pipeline (send -> wire format -> TLS stream -> reader thread -> local delivery) and mesh formation logic. Without tests, we cannot verify that the wiring from Plans 01 and 02 actually works together.

Output: Test functions in the `#[cfg(test)]` module of `dist/node.rs` covering all Phase 65 success criteria.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-remote-send-distribution-router/65-RESEARCH.md
@.planning/phases/65-remote-send-distribution-router/65-01-SUMMARY.md
@.planning/phases/65-remote-send-distribution-router/65-02-SUMMARY.md
@crates/snow-rt/src/dist/node.rs
@crates/snow-rt/src/actor/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire format and message routing unit tests</name>
  <files>crates/snow-rt/src/dist/node.rs</files>
  <action>
Add tests to the existing `#[cfg(test)] mod tests` block in `dist/node.rs`. Follow the existing test patterns (e.g., `test_write_msg_read_msg_roundtrip`, `test_heartbeat_wire_format`).

**Test 1: `test_dist_send_wire_format`**
Verify the DIST_SEND wire format is correctly constructed and parseable:
- Build a DIST_SEND message manually: `[0x10][u64 target_pid LE][message bytes]`
- Write it with `write_msg` to an in-memory buffer
- Read it back with `read_dist_msg`
- Assert tag == DIST_SEND, target_pid parses correctly, message bytes match
- Test with empty message payload (msg_size == 0)
- Test with a larger payload (e.g., 8KB -- above old 4KB limit) to verify read_dist_msg works

**Test 2: `test_dist_reg_send_wire_format`**
Verify the DIST_REG_SEND wire format:
- Build a DIST_REG_SEND message: `[0x11][u16 name_len LE][name bytes][message bytes]`
- Write with `write_msg`, read with `read_dist_msg`
- Parse and assert name and message payload match
- Test with empty name (edge case)
- Test with name at max u16 boundary awareness (reasonable length like 255 chars)

**Test 3: `test_dist_peer_list_wire_format`**
Verify the DIST_PEER_LIST wire format:
- Build a peer list: `[0x12][u16 count LE][u16 name_len][name]...`
- Write with `write_msg`, read with `read_dist_msg`
- Parse and assert all peer names are correctly extracted
- Test with empty peer list (count=0)
- Test with multiple peers (3 names)

**Test 4: `test_read_dist_msg_accepts_large_messages`**
Verify read_dist_msg accepts messages larger than the old 4KB limit:
- Create a payload of 8KB (above MAX_HANDSHAKE_MSG but below MAX_DIST_MSG)
- Write with `write_msg`, read with `read_dist_msg` -- should succeed
- Create a payload exceeding MAX_DIST_MSG (use a length header trick, not actual 16MB allocation) -- verify read_dist_msg returns an error

**Test 5: `test_read_dist_msg_rejects_oversized`**
Write a length header claiming a message larger than MAX_DIST_MSG:
- Write `u32::to_le_bytes(MAX_DIST_MSG + 1)` to a buffer
- Call `read_dist_msg` on it
- Assert it returns an error with "dist message too large"

Use `std::io::Cursor` for all in-memory stream operations, matching the existing test patterns.
  </action>
  <verify>
`cargo test -p snow-rt test_dist_send_wire_format test_dist_reg_send_wire_format test_dist_peer_list_wire_format test_read_dist_msg 2>&1 | tail -10` -- all new tests pass. `cargo test -p snow-rt 2>&1 | tail -5` -- full test suite passes.
  </verify>
  <done>
Wire format tests verify correct construction and parsing of DIST_SEND, DIST_REG_SEND, and DIST_PEER_LIST messages. read_dist_msg correctly accepts large messages and rejects oversized ones. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Node query API and peer list handling tests</name>
  <files>crates/snow-rt/src/dist/node.rs</files>
  <action>
Add more tests to the `#[cfg(test)] mod tests` block.

**Test 6: `test_snow_node_self_returns_null_when_not_started`**
- Call `snow_node_self()` without having called `snow_node_start`
- Assert it returns a null pointer
- Note: This test must run in isolation or handle the OnceLock state. If NODE_STATE is already set by a prior test, skip the null check and instead verify the returned string matches the expected node name. Use the same pattern as `test_node_state_accessor_before_init`.

**Test 7: `test_snow_node_list_returns_empty_when_not_started`**
- Call `snow_node_list()` without snow_node_start
- The function should return a valid empty Snow list (not null, not a crash)
- Verify by calling `crate::collections::list::snow_list_length()` on the result == 0

**Test 8: `test_handle_peer_list_skips_self_and_connected`**
Test the peer list parsing and filtering logic without actual network connections:
- This is a logic test for the `handle_peer_list` function's parsing behavior
- Build a DIST_PEER_LIST payload with 3 peers including self-name and an already-connected name
- Since `handle_peer_list` requires NODE_STATE to be initialized, and spawns threads, this test should verify the wire format parsing is correct by testing the parsing logic inline:
  - Create a peer list buffer manually
  - Parse it using the same byte-reading logic used in `handle_peer_list`
  - Assert the correct names are extracted
  - Assert the self-name and already-known names would be filtered

**Test 9: `test_send_peer_list_wire_format_roundtrip`**
Verify `send_peer_list` produces a correctly formatted DIST_PEER_LIST message by testing the encoding logic:
- Build a peer list payload the same way `send_peer_list` does
- Parse it and verify all names are present
- Verify the count field matches the number of peers

Note on test isolation: Many of these tests operate on in-memory buffers using `Cursor` and do NOT require actual TLS connections or NODE_STATE initialization. For tests that need NODE_STATE, use the same pattern as `test_snow_node_start_binds_listener` (which calls `snow_node_start` with a unique port and cleans up).

Since Rust test execution is parallel, avoid tests that depend on the global NODE_STATE OnceLock unless they use a unique initialization. For tests that cannot use NODE_STATE (because it's already set by another test), test the underlying logic directly rather than the extern "C" wrapper.
  </action>
  <verify>
`cargo test -p snow-rt test_snow_node_self test_snow_node_list test_handle_peer_list test_send_peer_list 2>&1 | tail -10` -- all new tests pass. `cargo test -p snow-rt 2>&1 | tail -5` -- full test suite passes with no regressions.
  </verify>
  <done>
Node query API tests verify snow_node_self and snow_node_list behavior for both initialized and uninitialized states. Peer list tests verify wire format encoding/decoding and filtering logic. All tests pass with no regressions. Full Phase 65 test coverage achieved.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-rt` -- all tests pass including new Phase 65 tests
2. `cargo test -p snow-rt 2>&1 | grep -c "test result"` -- count test results to verify new tests are actually running
3. `cargo test -p snow-rt -- --list 2>&1 | grep "dist_send\|dist_reg_send\|peer_list\|node_self\|node_list"` -- verify all new test names appear
</verification>

<success_criteria>
- At least 8 new tests covering: DIST_SEND wire format, DIST_REG_SEND wire format, DIST_PEER_LIST wire format, read_dist_msg size limits, node_self, node_list, peer list parsing, peer list encoding
- All new tests pass
- All existing tests still pass (no regressions)
- Tests use in-memory buffers (Cursor) where possible, avoiding flaky network tests
</success_criteria>

<output>
After completion, create `.planning/phases/65-remote-send-distribution-router/65-03-SUMMARY.md`
</output>
