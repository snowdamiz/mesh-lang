---
phase: 65-remote-send-distribution-router
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/dist/node.rs
autonomous: true

must_haves:
  truths:
    - "A message sent to a remote PID is forwarded over the TLS stream to the correct node session"
    - "A message received on the reader thread for DIST_SEND is delivered to the local actor's mailbox"
    - "A message sent to {name, node} is forwarded as DIST_REG_SEND and delivered to the named process on the receiving node"
    - "Messages larger than 4KB can be sent and received between nodes (read_dist_msg with 16MB limit)"
  artifacts:
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "dist_send (replaces dist_send_stub), pub(crate) local_send, snow_actor_send_named"
      contains: "fn dist_send"
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "DIST_SEND/DIST_REG_SEND constants, read_dist_msg, reader loop message dispatch"
      contains: "DIST_SEND"
  key_links:
    - from: "crates/snow-rt/src/actor/mod.rs"
      to: "crates/snow-rt/src/dist/node.rs"
      via: "dist_send calls node_state(), write_msg via NodeSession.stream"
      pattern: "node_state\\(\\)"
    - from: "crates/snow-rt/src/dist/node.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "reader_loop_session calls crate::actor::local_send for incoming DIST_SEND"
      pattern: "crate::actor::local_send"
    - from: "crates/snow-rt/src/actor/mod.rs"
      to: "crates/snow-rt/src/dist/node.rs"
      via: "snow_actor_send_named calls write_msg via session.stream for DIST_REG_SEND"
      pattern: "DIST_REG_SEND"
---

<objective>
Replace the Phase 63 `dist_send_stub` with real remote message routing and add named remote send support.

Purpose: This is the core of Phase 65 -- making `send(pid, msg)` work transparently for remote PIDs and enabling `send({name, node}, msg)` for named remote processes. Without this plan, remote actors are unreachable.

Output: Working dist_send function, reader loop DIST_SEND/DIST_REG_SEND handlers, read_dist_msg with 16MB limit, snow_actor_send_named extern "C" API.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-remote-send-distribution-router/65-RESEARCH.md
@crates/snow-rt/src/actor/mod.rs
@crates/snow-rt/src/dist/node.rs
@crates/snow-rt/src/actor/registry.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace dist_send_stub with real dist_send and add reader loop message handlers</name>
  <files>crates/snow-rt/src/actor/mod.rs, crates/snow-rt/src/dist/node.rs</files>
  <action>
**In `crates/snow-rt/src/dist/node.rs`:**

1. Add distribution message tag constants near the existing HEARTBEAT_PING/PONG constants:
```rust
const DIST_SEND: u8 = 0x10;      // [tag][u64 target_pid][raw msg bytes]
const DIST_REG_SEND: u8 = 0x11;  // [tag][u16 name_len][name bytes][raw msg bytes]
```
Make these `pub(crate)` so `actor/mod.rs` can reference them.

2. Add `read_dist_msg` function for post-handshake message reading with a 16MB limit (replacing the 4KB `read_msg` limit for distribution messages):
```rust
const MAX_DIST_MSG: u32 = 16 * 1024 * 1024; // 16 MB

pub(crate) fn read_dist_msg(stream: &mut impl Read) -> io::Result<Vec<u8>> {
    let mut len_buf = [0u8; 4];
    stream.read_exact(&mut len_buf)?;
    let len = u32::from_le_bytes(len_buf);
    if len > MAX_DIST_MSG {
        return Err(io::Error::new(io::ErrorKind::InvalidData,
            format!("dist message too large: {} bytes (max {})", len, MAX_DIST_MSG)));
    }
    let mut buf = vec![0u8; len as usize];
    stream.read_exact(&mut buf)?;
    Ok(buf)
}
```

3. Make `write_msg` visibility `pub(crate)` (currently private; `dist_send` in actor/mod.rs needs it). Keep `read_msg` private (only used in handshake).

4. Update `reader_loop_session` to:
   - Replace `read_msg` with `read_dist_msg` in the reader loop (after handshake, messages can be larger than 4KB)
   - Replace the `_ => {}` catch-all with handlers for DIST_SEND and DIST_REG_SEND:

For DIST_SEND (tag 0x10):
- Parse target_pid as u64 from bytes [1..9] (little-endian)
- Extract message data from bytes [9..]
- Call `crate::actor::local_send(target_pid, msg_data.as_ptr(), msg_data.len() as u64)` to deliver to local mailbox

For DIST_REG_SEND (tag 0x11):
- Parse name_len as u16 from bytes [1..3] (little-endian)
- Extract name as UTF-8 from bytes [3..3+name_len]
- Look up PID via `crate::actor::registry::global_registry().whereis(name)`
- If found, extract message data from bytes [3+name_len..] and call `crate::actor::local_send(pid.as_u64(), msg_data.as_ptr(), msg_data.len() as u64)`
- If not found, silently drop (matches Erlang behavior)

Keep the `_ => {}` catch-all for unknown tags (forward compatibility).

**In `crates/snow-rt/src/actor/mod.rs`:**

5. Change `local_send` visibility from `fn` to `pub(crate) fn` so the dist module's reader thread can call it.

6. Replace `dist_send_stub` with real `dist_send`:
```rust
#[cold]
fn dist_send(target_pid: u64, msg_ptr: *const u8, msg_size: u64) {
    let state = match crate::dist::node::node_state() {
        Some(s) => s,
        None => return, // Node not started; silently drop
    };

    let node_id = (target_pid >> 48) as u16;
    let node_name = {
        let map = state.node_id_map.read();
        match map.get(&node_id) {
            Some(name) => name.clone(),
            None => return, // Unknown node; silently drop
        }
    };

    let session = {
        let sessions = state.sessions.read();
        match sessions.get(&node_name) {
            Some(s) => std::sync::Arc::clone(s),
            None => return, // Not connected; silently drop
        }
    };

    // Build wire message: [DIST_SEND][u64 target_pid][raw message bytes]
    let mut payload = Vec::with_capacity(1 + 8 + msg_size as usize);
    payload.push(crate::dist::node::DIST_SEND);
    payload.extend_from_slice(&target_pid.to_le_bytes());
    if !msg_ptr.is_null() && msg_size > 0 {
        let slice = unsafe { std::slice::from_raw_parts(msg_ptr, msg_size as usize) };
        payload.extend_from_slice(slice);
    }

    // Write to TLS stream; silently drop on error (Phase 66 adds :nodedown)
    let mut stream = session.stream.lock().unwrap();
    let _ = crate::dist::node::write_msg(&mut *stream, &payload);
}
```

Remove `dist_send_stub` entirely. Update the call site in `snow_actor_send` from `dist_send_stub(...)` to `dist_send(...)`. Remove the old `dist_send_stub` function and its comment about "Phase 65 will replace this."
  </action>
  <verify>
`cargo build -p snow-rt 2>&1 | head -20` compiles without errors. `cargo test -p snow-rt 2>&1 | tail -5` -- all existing tests pass. Verify `dist_send_stub` no longer exists in the codebase with `grep -r "dist_send_stub" crates/`.
  </verify>
  <done>
dist_send_stub replaced with real dist_send that routes messages via NodeSession TLS stream. Reader loop handles DIST_SEND and DIST_REG_SEND tags, delivering messages to local actors via local_send. read_dist_msg supports messages up to 16MB. All existing tests pass with no regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add snow_actor_send_named extern "C" API for send({name, node}, msg)</name>
  <files>crates/snow-rt/src/actor/mod.rs, crates/snow-rt/src/lib.rs</files>
  <action>
**In `crates/snow-rt/src/actor/mod.rs`:**

1. Add `snow_actor_send_named` extern "C" function below `snow_actor_send`:
```rust
/// Send a message to a named process on a remote node.
///
/// Called from compiled Snow code for `send({name, node}, msg)` syntax.
/// If the target node is ourselves, performs a local registry lookup + send.
/// Silently drops if node not started, name not found, or session unavailable.
#[no_mangle]
pub extern "C" fn snow_actor_send_named(
    name_ptr: *const u8, name_len: u64,
    node_ptr: *const u8, node_len: u64,
    msg_ptr: *const u8, msg_size: u64,
) {
    let name = unsafe {
        std::str::from_utf8(std::slice::from_raw_parts(name_ptr, name_len as usize))
    };
    let node = unsafe {
        std::str::from_utf8(std::slice::from_raw_parts(node_ptr, node_len as usize))
    };

    let (name, node) = match (name, node) {
        (Ok(n), Ok(nd)) => (n, nd),
        _ => return,
    };

    let state = match crate::dist::node::node_state() {
        Some(s) => s,
        None => return,
    };

    // If target node is ourselves, do local registry lookup + send
    if node == state.name {
        if let Some(pid) = crate::actor::registry::global_registry().whereis(name) {
            local_send(pid.as_u64(), msg_ptr, msg_size);
        }
        return;
    }

    // Look up remote session
    let session = {
        let sessions = state.sessions.read();
        match sessions.get(node) {
            Some(s) => std::sync::Arc::clone(s),
            None => return,
        }
    };

    // Build DIST_REG_SEND message: [tag][u16 name_len][name][msg bytes]
    let name_bytes = name.as_bytes();
    let mut payload = Vec::with_capacity(1 + 2 + name_bytes.len() + msg_size as usize);
    payload.push(crate::dist::node::DIST_REG_SEND);
    payload.extend_from_slice(&(name_bytes.len() as u16).to_le_bytes());
    payload.extend_from_slice(name_bytes);
    if !msg_ptr.is_null() && msg_size > 0 {
        let slice = unsafe { std::slice::from_raw_parts(msg_ptr, msg_size as usize) };
        payload.extend_from_slice(slice);
    }

    let mut stream = session.stream.lock().unwrap();
    let _ = crate::dist::node::write_msg(&mut *stream, &payload);
}
```

**In `crates/snow-rt/src/lib.rs`:**

2. Add `snow_actor_send_named` to the actor re-exports:
```rust
pub use actor::{
    snow_actor_link, snow_actor_receive, snow_actor_register, snow_actor_self, snow_actor_send,
    snow_actor_send_named,
    snow_actor_set_terminate, snow_actor_spawn, snow_actor_whereis, snow_reduction_check,
    snow_rt_init_actor, snow_rt_run_scheduler,
    snow_timer_sleep, snow_timer_send_after,
};
```
  </action>
  <verify>
`cargo build -p snow-rt 2>&1 | head -20` compiles without errors. `cargo test -p snow-rt 2>&1 | tail -5` -- all tests pass. Verify the function is exported: `grep "snow_actor_send_named" crates/snow-rt/src/lib.rs` shows the re-export.
  </verify>
  <done>
snow_actor_send_named extern "C" function exists, handles local self-send via registry lookup, and routes remote sends as DIST_REG_SEND wire messages. Re-exported in lib.rs for LLVM codegen access.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` -- compiles with no errors or warnings
2. `cargo test -p snow-rt` -- all existing tests pass (no regressions)
3. `grep -r "dist_send_stub" crates/` -- returns no results (stub fully replaced)
4. `grep "DIST_SEND\|DIST_REG_SEND" crates/snow-rt/src/dist/node.rs` -- both constants present
5. `grep "pub(crate) fn local_send" crates/snow-rt/src/actor/mod.rs` -- visibility upgraded
6. `grep "snow_actor_send_named" crates/snow-rt/src/lib.rs` -- re-exported
</verification>

<success_criteria>
- dist_send routes messages to the correct NodeSession's TLS stream based on PID node_id
- Reader loop delivers incoming DIST_SEND messages to local actor mailboxes via local_send
- Reader loop delivers incoming DIST_REG_SEND messages to named local processes via registry lookup
- snow_actor_send_named handles both local self-send and remote send paths
- read_dist_msg accepts messages up to 16MB (post-handshake)
- All failures (unknown node, disconnected session, write error) are silently dropped
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/65-remote-send-distribution-router/65-01-SUMMARY.md`
</output>
