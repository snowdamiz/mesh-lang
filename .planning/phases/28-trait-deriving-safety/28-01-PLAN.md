---
phase: 28-trait-deriving-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "deriving(Ord) without Eq on a struct emits a compile-time error, not a runtime crash"
    - "deriving(Ord) without Eq on a sum type emits a compile-time error, not a runtime crash"
    - "The error message explicitly suggests adding Eq to the deriving list"
    - "deriving(Eq, Ord) compiles and works correctly with no regression"
    - "No deriving clause (backward compat) still derives all defaults including both Eq and Ord"
  artifacts:
    - path: "crates/snow-typeck/src/error.rs"
      provides: "MissingDerivePrerequisite variant"
      contains: "MissingDerivePrerequisite"
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Error code E0029, diagnostic rendering with help text"
      contains: "E0029"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Validation check in both register_struct_def and register_sum_type_def"
      contains: "MissingDerivePrerequisite"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E tests for Ord-without-Eq error and Eq+Ord success"
      contains: "e2e_deriving_ord_without_eq"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "ctx.errors.push(TypeError::MissingDerivePrerequisite { .. })"
      pattern: "MissingDerivePrerequisite"
    - from: "crates/snow-typeck/src/diagnostics.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "match arm for MissingDerivePrerequisite in error_code, severity, render_diagnostic"
      pattern: "MissingDerivePrerequisite"
    - from: "crates/snowc/tests/e2e.rs"
      to: "crates/snow-typeck/src/infer.rs"
      via: "compile_expect_error triggers the validation check"
      pattern: "compile_expect_error"
---

<objective>
Add compile-time enforcement of trait deriving dependencies: deriving(Ord) requires Eq.

Purpose: Currently, `deriving(Ord)` without `Eq` causes a cryptic runtime/linker failure because the generated Ord MIR code references `Eq__eq__TypeName` symbols that were never generated. This phase catches the error at compile time with a clear diagnostic suggesting the fix.

Output: New `MissingDerivePrerequisite` error variant, validation checks in both struct and sum type registration, diagnostic rendering with help text, and e2e tests covering the error case, the success case, and backward compatibility.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-trait-deriving-safety/28-RESEARCH.md

@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-typeck/src/infer.rs
@crates/snowc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MissingDerivePrerequisite error variant, diagnostics, and validation checks</name>
  <files>
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/diagnostics.rs
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
**1. Add new error variant to `crates/snow-typeck/src/error.rs`:**

Add `MissingDerivePrerequisite` variant to the `TypeError` enum (after `UnsupportedDerive`):

```rust
/// A derived trait requires another trait that is not in the deriving list.
MissingDerivePrerequisite {
    trait_name: String,
    requires: String,
    type_name: String,
},
```

Add its `Display` impl in the `fmt::Display` match block (after the `UnsupportedDerive` arm):

```rust
TypeError::MissingDerivePrerequisite {
    trait_name,
    requires,
    type_name,
} => {
    write!(
        f,
        "deriving `{}` for `{}` requires `{}` to also be derived",
        trait_name, type_name, requires
    )
}
```

**2. Add error code and diagnostic rendering to `crates/snow-typeck/src/diagnostics.rs`:**

In `error_code()`, add after the `UnsupportedDerive` arm:
```rust
TypeError::MissingDerivePrerequisite { .. } => "E0029",
```

In `severity()`, no change needed -- the default `_ => "error"` arm covers it.

In `render_json_diagnostic()`, the existing `_ => { ... }` catch-all handles it (it falls through to the final branch that uses `0..source_len` span). No change needed.

In `render_diagnostic()`, add a new match arm BEFORE the `UnsupportedDerive` arm (or after it, order doesn't matter as long as it's in the match):

```rust
TypeError::MissingDerivePrerequisite {
    trait_name,
    requires,
    type_name,
} => {
    let msg = format!(
        "cannot derive `{}` for `{}` without `{}`",
        trait_name, type_name, requires
    );
    let span = clamp(0..source_len.max(1).min(source_len));

    Report::build(ReportKind::Error, span.clone())
        .with_code(code)
        .with_message(&msg)
        .with_config(config)
        .with_label(
            Label::new(span)
                .with_message(format!(
                    "`{}` requires `{}` for its implementation",
                    trait_name, requires
                ))
                .with_color(Color::Red),
        )
        .with_help(format!(
            "add `{}` to the deriving list: deriving({}, {})",
            requires, requires, trait_name
        ))
        .finish()
}
```

**3. Add validation checks to `crates/snow-typeck/src/infer.rs`:**

In `register_struct_def`, AFTER the existing "Validate derive trait names" loop (after line ~1514) and BEFORE the "Build the impl type" section (line ~1516), add:

```rust
// Check trait dependencies: Ord requires Eq.
if has_deriving && derive_list.iter().any(|t| t == "Ord") && !derive_list.iter().any(|t| t == "Eq") {
    ctx.errors.push(TypeError::MissingDerivePrerequisite {
        trait_name: "Ord".to_string(),
        requires: "Eq".to_string(),
        type_name: name.clone(),
    });
    // Early return: skip trait impl registration to avoid generating broken MIR.
    // Register the struct type info first so the rest of compilation doesn't crash.
    let struct_info = StructDefInfo {
        name: name.clone(),
        generic_params: generic_params.clone(),
        fields: fields.clone(),
    };
    type_registry.register_struct(struct_info);
    return;
}
```

IMPORTANT: Check whether `StructDefInfo` registration happens before or after the derive validation in the current code. If it's already registered before the derive section, then just `return;` after pushing the error without re-registering. Read the full function to determine this. The key point is: after emitting the error, do NOT proceed to register Ord trait impls. Either `return` early or skip the Ord registration block.

In `register_sum_type_def`, AFTER the existing "Validate derive trait names" loop (after line ~1795) and BEFORE the "Build the impl type" section (line ~1797), add the same check:

```rust
// Check trait dependencies: Ord requires Eq.
if has_deriving && derive_list.iter().any(|t| t == "Ord") && !derive_list.iter().any(|t| t == "Eq") {
    ctx.errors.push(TypeError::MissingDerivePrerequisite {
        trait_name: "Ord".to_string(),
        requires: "Eq".to_string(),
        type_name: name.clone(),
    });
    return;
}
```

Note: For sum types, `type_registry.register_sum_type(sum_info)` and `register_variant_constructors` are called BEFORE the derive section (lines ~1774-1777), so a simple `return` after pushing the error is correct.

For structs, check if `type_registry.register_struct(...)` is called before or after the derive section. If it's called after, you need to call it before returning. Read the full `register_struct_def` function to determine the correct approach.

**IMPORTANT anti-patterns to avoid:**
- Do NOT auto-add Eq when Ord is requested. The user opted into selective deriving; respect that and give a clear error.
- Do NOT check this when `has_deriving` is false. When there's no deriving clause, `derive_all` is true and ALL traits are derived together, so there's no dependency issue.
- Do NOT add checks in `snow-codegen`. The type checker is the right place for this.
  </action>
  <verify>
Run `cargo build` from the workspace root -- should compile with no errors:
```
cargo build -p snow-typeck
```

Run existing tests to ensure no regressions:
```
cargo test -p snow-typeck
cargo test -p snowc
```

All existing deriving tests must still pass:
- e2e_deriving_struct
- e2e_deriving_sum_type
- e2e_deriving_backward_compat
- e2e_deriving_selective
- e2e_deriving_empty
- e2e_deriving_unsupported_trait
  </verify>
  <done>
- `MissingDerivePrerequisite` variant exists in TypeError enum with Display impl
- Error code E0029 assigned in diagnostics.rs
- Ariadne rendering produces error with help text suggesting `deriving(Eq, Ord)`
- Validation check exists in both `register_struct_def` and `register_sum_type_def`
- Check only fires when `has_deriving` is true (explicit deriving clause)
- All existing tests pass with no regression
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for trait deriving safety</name>
  <files>
    crates/snowc/tests/e2e.rs
  </files>
  <action>
Add three new e2e tests in `crates/snowc/tests/e2e.rs`, in the "Phase 22: Auto-Derive" test section (near the existing `e2e_deriving_*` tests, around line 648), or create a new section header for Phase 28.

**Test 1: Struct with Ord but no Eq produces compile error (DERIVE-01, DERIVE-03)**

```rust
/// Phase 28: deriving(Ord) without Eq on a struct produces a compile-time error
/// that suggests adding Eq.
#[test]
fn e2e_deriving_ord_without_eq_struct() {
    let source = r#"
struct Foo do
  x :: Int
end deriving(Ord)

fn main() do
  let f = Foo { x: 1 }
  println("nope")
end
"#;
    let error = compile_expect_error(source);
    assert!(
        error.contains("Eq") && (error.contains("requires") || error.contains("without")),
        "Expected error about Ord requiring Eq, got: {}",
        error
    );
}
```

**Test 2: Sum type with Ord but no Eq produces compile error (DERIVE-01, DERIVE-03)**

```rust
/// Phase 28: deriving(Ord) without Eq on a sum type produces a compile-time error.
#[test]
fn e2e_deriving_ord_without_eq_sum() {
    let source = r#"
type Direction do
  North
  South
end deriving(Ord)

fn main() do
  println("nope")
end
"#;
    let error = compile_expect_error(source);
    assert!(
        error.contains("Eq") && (error.contains("requires") || error.contains("without")),
        "Expected error about Ord requiring Eq, got: {}",
        error
    );
}
```

**Test 3: Eq + Ord together works correctly -- no regression (DERIVE-02)**

```rust
/// Phase 28: deriving(Eq, Ord) together compiles and works correctly.
#[test]
fn e2e_deriving_eq_ord_together() {
    let source = r#"
struct Point do
  x :: Int
  y :: Int
end deriving(Eq, Ord)

fn main() do
  let a = Point { x: 1, y: 2 }
  let b = Point { x: 1, y: 3 }
  println("${a == b}")
  println("${a < b}")
end
"#;
    let output = compile_and_run(source);
    assert_eq!(output, "false\ntrue\n");
}
```

These three tests directly cover the three requirements:
- DERIVE-01: Tests 1 and 2 verify compile-time errors for both struct and sum type
- DERIVE-02: Test 3 verifies no regression when both Eq and Ord are derived
- DERIVE-03: Tests 1 and 2 verify the error message mentions Eq (the suggestion)
  </action>
  <verify>
Run the new tests specifically:
```
cargo test -p snowc e2e_deriving_ord_without_eq_struct -- --nocapture
cargo test -p snowc e2e_deriving_ord_without_eq_sum -- --nocapture
cargo test -p snowc e2e_deriving_eq_ord_together -- --nocapture
```

Run the full e2e test suite:
```
cargo test -p snowc
```

All three new tests pass, and all existing tests still pass.
  </verify>
  <done>
- `e2e_deriving_ord_without_eq_struct` passes: struct with `deriving(Ord)` produces error mentioning Eq
- `e2e_deriving_ord_without_eq_sum` passes: sum type with `deriving(Ord)` produces error mentioning Eq
- `e2e_deriving_eq_ord_together` passes: `deriving(Eq, Ord)` compiles and produces correct output
- Full `cargo test -p snowc` suite passes with no regressions
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds (no compile errors in workspace)
2. `cargo test -p snow-typeck` passes (type checker unit tests)
3. `cargo test -p snowc` passes (all e2e tests including new ones)
4. Specifically verify the three new e2e tests pass:
   - `e2e_deriving_ord_without_eq_struct`
   - `e2e_deriving_ord_without_eq_sum`
   - `e2e_deriving_eq_ord_together`
5. Existing deriving tests all pass (backward compat):
   - `e2e_deriving_struct`
   - `e2e_deriving_sum_type`
   - `e2e_deriving_backward_compat`
   - `e2e_deriving_selective`
   - `e2e_deriving_empty`
   - `e2e_deriving_unsupported_trait`
</verification>

<success_criteria>
- DERIVE-01: `deriving(Ord)` without `Eq` on both structs and sum types emits error code E0029 at compile time
- DERIVE-02: `deriving(Eq, Ord)` compiles and runs correctly, producing correct equality and ordering results
- DERIVE-03: Error diagnostic includes help text suggesting `add Eq to the deriving list: deriving(Eq, Ord)`
- No regression in any existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/28-trait-deriving-safety/28-01-SUMMARY.md`
</output>
