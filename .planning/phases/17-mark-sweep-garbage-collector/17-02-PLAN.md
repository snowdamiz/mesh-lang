---
phase: 17-mark-sweep-garbage-collector
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - crates/snow-rt/src/actor/heap.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/actor/process.rs
  - crates/snow-rt/src/actor/stack.rs
  - crates/snow-rt/src/gc.rs
autonomous: true

must_haves:
  truths:
    - "Mark phase traces from roots through all reachable objects using conservative stack scanning"
    - "Sweep phase frees unmarked objects and adds them to the free list"
    - "GC triggers automatically when actor heap exceeds pressure threshold at yield points"
    - "GC is per-actor only -- other actors are unaffected during collection"
  artifacts:
    - path: "crates/snow-rt/src/actor/heap.rs"
      provides: "collect(), mark_from_roots(), sweep() methods on ActorHeap"
      contains: "fn collect"
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "GC trigger in snow_reduction_check"
      contains: "should_collect"
    - path: "crates/snow-rt/src/gc.rs"
      provides: "snow_gc_collect implementation"
      contains: "snow_gc_collect"
  key_links:
    - from: "crates/snow-rt/src/actor/mod.rs"
      to: "crates/snow-rt/src/actor/heap.rs"
      via: "snow_reduction_check checks should_collect() and calls collect()"
      pattern: "should_collect|collect"
    - from: "crates/snow-rt/src/actor/heap.rs"
      to: "GcHeader all_objects list"
      via: "sweep walks all_objects, frees unmarked, builds free_list"
      pattern: "all_objects|free_list"
---

<objective>
Implement the mark-sweep garbage collection algorithm with conservative stack scanning and automatic triggering at actor yield points.

Purpose: This is the core GC logic. Without collection, the free-list from Plan 01 would never be populated and memory would grow unboundedly. The mark phase identifies reachable objects via conservative stack scanning; the sweep phase reclaims unreachable objects. Triggering at yield points ensures collection happens cooperatively without affecting other actors.

Output: Working per-actor mark-sweep GC that triggers automatically on heap pressure.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-mark-sweep-garbage-collector/17-RESEARCH.md
@.planning/phases/17-mark-sweep-garbage-collector/17-01-SUMMARY.md
@crates/snow-rt/src/actor/heap.rs
@crates/snow-rt/src/actor/mod.rs
@crates/snow-rt/src/actor/stack.rs
@crates/snow-rt/src/gc.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement mark-sweep collection in ActorHeap</name>
  <files>crates/snow-rt/src/actor/heap.rs</files>
  <action>
Add the mark-sweep GC algorithm to ActorHeap:

1. **`collect(&mut self, stack_bottom: *const u8, stack_top: *const u8)`**:
   Main entry point for GC. Sets `gc_in_progress = true`, calls `mark_from_roots()`, then `sweep()`, then clears `gc_in_progress`. Updates `total_allocated` to reflect post-collection size.

2. **`mark_from_roots(&mut self, stack_bottom: *const u8, stack_top: *const u8)`**:
   Conservative stack scanning + worklist-based marking.

   a) **Scan the stack conservatively**: Walk from `stack_top` to `stack_bottom` (stack grows downward on x86-64/ARM64, so stack_top has lower address). For each 8-byte-aligned word, check if it looks like a pointer into any of this heap's pages. Use `find_object_containing(ptr) -> Option<*mut GcHeader>` to check.

   b) **For each root found**: If the object is not already marked, mark it and push onto a worklist (Vec<*mut GcHeader> -- allocated via Rust Vec on the system heap, NOT on the GC heap per Research Pitfall 4).

   c) **Process the worklist** (tricolor marking): Pop an object from the worklist. Scan every 8-byte word in its body (from data_ptr to data_ptr + size). For each word that looks like a heap pointer (via find_object_containing), if the target is unmarked, mark it and push onto the worklist. Repeat until worklist is empty.

3. **`find_object_containing(&self, ptr: *const u8) -> Option<*mut GcHeader>`**:
   Check if `ptr` falls within any page's address range. If so, walk the all_objects list to find an object whose data range [data_ptr, data_ptr + size) contains `ptr`. This handles interior pointers (Research Pitfall 3).

   Optimization: First do a quick page-range check (is ptr within [page.as_ptr(), page.as_ptr() + page.len()) for any page?). Only if yes, walk the all_objects list.

4. **`sweep(&mut self)`**:
   Walk the all_objects list. For each object:
   - If marked: clear mark bit, keep in all_objects list.
   - If NOT marked: remove from all_objects list, set FREE_BIT, add to free_list, subtract (GC_HEADER_SIZE + size) from total_allocated.

   Rebuild the all_objects list in-place: use a prev pointer to unlink unmarked objects while walking.

5. **Add tests**:
   - `test_collect_frees_unreachable()`: Allocate 5 objects, don't reference them from a simulated stack, call collect with empty stack range. Verify all are freed (all_objects empty, free_list non-null).
   - `test_collect_retains_reachable()`: Allocate an object, create a fake stack frame containing its pointer, call collect. Verify object is NOT freed.
   - `test_collect_reduces_total_bytes()`: Allocate 10 objects, collect with empty roots. Verify total_bytes() decreased.
   - `test_gc_in_progress_guard()`: Verify gc_in_progress prevents re-entrant collection.

IMPORTANT: The mark phase uses a Rust Vec as the worklist (system heap allocation via malloc), NOT the GC heap. This avoids re-entrancy issues.

IMPORTANT: `find_object_containing` must check both that the pointer falls within a page AND that it points into a live object's body. A pointer to freed memory (in the free list) should NOT be treated as a root.
  </action>
  <verify>
Run: `cargo test -p snow-rt -- actor::heap::tests`
All heap tests pass including the new GC collection tests.
  </verify>
  <done>
Mark-sweep collection works: conservative scanning finds roots, mark phase traces reachable objects, sweep phase frees unreachable objects and adds them to free list. Re-entrancy guard prevents nested GC.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire GC trigger into snow_reduction_check and implement snow_gc_collect</name>
  <files>crates/snow-rt/src/actor/mod.rs, crates/snow-rt/src/gc.rs</files>
  <action>
1. **Update `snow_reduction_check()` in `actor/mod.rs`**:
   After the existing yield logic, add a GC trigger check. When the reduction counter hits zero AND the actor yields, also check if the actor's heap should collect:

   ```rust
   // After yield (or instead of yield if we want GC at the same point):
   // Check if GC should run
   if remaining == 0 {
       cell.set(DEFAULT_REDUCTIONS);
       // Check heap pressure before yielding
       try_trigger_gc();
       stack::yield_current();
   }
   ```

   Create `fn try_trigger_gc()`:
   - Get current PID via `stack::get_current_pid()`
   - Look up process in GLOBAL_SCHEDULER
   - Check `proc.heap.should_collect()` AND `!proc.heap.gc_in_progress`
   - If yes: capture stack bounds (stack_top = address of a local variable, stack_bottom = derive from the DefaultStack's base address stored on the process or from the coroutine)
   - Call `proc.heap.collect(stack_bottom, stack_top)`

   For stack bounds:
   - `stack_top`: Use `&local_var as *const _ as *const u8` to get current stack pointer approximation
   - `stack_bottom`: The coroutine stack bottom. Add a `stack_base: *const u8` field to the Process struct, set it when the coroutine starts in `CoroutineHandle::new()`. The corosensei DefaultStack allocates 64 KiB; the base is the highest address (stack grows down). Store `stack.base()` or compute from the Yielder's position.

   Alternative simpler approach for stack_bottom: Since we know the stack is 64 KiB (DEFAULT_STACK_SIZE), and stack_top is our current position, we can scan from stack_top to stack_top + some reasonable range. But the cleaner approach is to store the stack base.

   **Recommended approach**: Add `pub stack_base: Option<*const u8>` to the Process struct. In `stack.rs` `CoroutineHandle::new()`, right at the start of the coroutine body (before calling the entry function), capture a local variable's address as the stack base and store it on the process. The GC can then scan from current stack position to this stored base.

   Actually, the simplest safe approach: In the coroutine body in `CoroutineHandle::new()`, store the address of a local variable as the stack base. Pass it to the process via a thread-local or directly through the scheduler. Then in `try_trigger_gc()`, use this stored value as stack_bottom.

   Add `stack_base: *const u8` field to Process (default: null). In `CoroutineHandle::new()`, at the very start of the coroutine body, capture `let stack_anchor: u64 = 0; let base = &stack_anchor as *const u64 as *const u8;` and store it on the process.

2. **Implement `snow_gc_collect` in `gc.rs`**:
   Replace the stub with actual implementation:
   - Get current PID
   - Look up process
   - Get stack bounds (same approach as try_trigger_gc)
   - Call `proc.heap.collect(stack_bottom, stack_top)`
   - This allows explicit GC triggering from Snow code if needed in the future

3. **Add `stack_base` field to Process** in `process.rs` (this file is not in files_modified but is a single line addition -- add it as part of this task since it's a one-line change):
   - Add `pub stack_base: *const u8` to Process struct, default `std::ptr::null()`
   - In `CoroutineHandle::new()`, store the stack base on the process after setting up the yielder

4. **Update `stack.rs`**: Add a thread-local `STACK_BASE: Cell<*const u8>` that the coroutine body sets when it starts. `try_trigger_gc` reads this to get stack_bottom.

5. **Test**: The gc trigger test is hard to unit test (requires coroutine context). Instead, ensure `cargo test -p snow-rt` passes and add a doc comment explaining the trigger mechanism. The e2e test in Plan 04 will validate the full flow.
  </action>
  <verify>
Run: `cargo test -p snow-rt`
All runtime tests pass. `snow_reduction_check` compiles with the GC trigger. `snow_gc_collect` is no longer a stub.
  </verify>
  <done>
GC triggers automatically when an actor's heap exceeds the pressure threshold at yield points (snow_reduction_check). snow_gc_collect provides explicit collection. Stack scanning boundaries are correctly captured from the coroutine stack.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-rt` -- all runtime tests pass
2. `cargo build -p snow-rt` -- no warnings
3. Mark-sweep correctly identifies and frees unreachable objects in unit tests
4. GC trigger compiles and integrates with the existing reduction check mechanism
</verification>

<success_criteria>
- Conservative stack scanning identifies heap pointers from the coroutine stack
- Mark phase traces transitively through object bodies to find all reachable objects
- Sweep phase frees unmarked objects to the free list and updates total_allocated
- GC triggers at yield points when heap exceeds configurable threshold
- GC is guarded against re-entrancy
- Other actors are unaffected (GC runs within a single actor's yield)
</success_criteria>

<output>
After completion, create `.planning/phases/17-mark-sweep-garbage-collector/17-02-SUMMARY.md`
</output>
