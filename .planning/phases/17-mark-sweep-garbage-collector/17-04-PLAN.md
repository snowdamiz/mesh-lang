---
phase: 17-mark-sweep-garbage-collector
plan: 04
type: execute
wave: 3
depends_on: ["17-02", "17-03"]
files_modified:
  - tests/e2e/gc_bounded_memory.snow
  - crates/snow-rt/src/actor/heap.rs
autonomous: true

must_haves:
  truths:
    - "A long-running actor that allocates and discards data maintains bounded memory usage"
    - "GC collection actually reclaims memory in a real compiled Snow program"
    - "All existing e2e tests continue to pass with the GC-enabled runtime"
  artifacts:
    - path: "tests/e2e/gc_bounded_memory.snow"
      provides: "E2E test demonstrating bounded memory in long-running actor"
      min_lines: 15
  key_links:
    - from: "tests/e2e/gc_bounded_memory.snow"
      to: "crates/snow-rt/src/actor/heap.rs"
      via: "Actor allocations trigger GC which reclaims memory"
      pattern: "collect|gc_threshold"
---

<objective>
Create an end-to-end test that proves a long-running actor maintains bounded memory usage through automatic garbage collection, and verify the full GC integration works in a real compiled Snow program.

Purpose: This is the integration validation. Plans 01-03 built the pieces independently. This plan proves they work together: codegen emits actor-aware allocations, the runtime prepends GcHeaders, mark-sweep collects unreachable objects at yield points, and memory stays bounded.

Output: Passing e2e test demonstrating RT-01 through RT-04, full test suite green.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-mark-sweep-garbage-collector/17-RESEARCH.md
@.planning/phases/17-mark-sweep-garbage-collector/17-01-SUMMARY.md
@.planning/phases/17-mark-sweep-garbage-collector/17-02-SUMMARY.md
@.planning/phases/17-mark-sweep-garbage-collector/17-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create e2e test for bounded memory in long-running actor</name>
  <files>tests/e2e/gc_bounded_memory.snow</files>
  <action>
Create a Snow program that spawns a long-running actor which repeatedly allocates strings/lists, discards them (lets them go out of scope), and verifies that the program completes without running out of memory.

The test structure:

```snow
# A long-running actor that allocates and discards data in a loop.
# Without GC, this would grow memory unboundedly.
# With mark-sweep GC, unreachable allocations are reclaimed at yield points.

fn worker(iterations) do
  loop_work(iterations, 0)
end

fn loop_work(remaining, acc) do
  if remaining == 0 do
    acc
  else
    # Allocate temporary data that becomes unreachable each iteration
    temp = "hello world this is a string that takes up some memory"
    temp2 = temp <> " and some more data appended"
    temp3 = String.length(temp2)

    # The temp/temp2 strings from previous iterations are unreachable
    # and should be collected by GC
    loop_work(remaining - 1, acc + temp3)
  end
end

fn main() do
  # Run enough iterations to exceed the GC threshold multiple times
  # 256 KiB threshold, each iteration allocates ~150 bytes of strings
  # 5000 iterations = ~750 KiB of allocations, well over the threshold
  pid = spawn(fn -> worker(5000) end)

  # Wait for worker to complete
  Process.sleep(2000)

  IO.puts("GC test passed: actor completed without unbounded growth")
end
```

The key properties this test validates:
- RT-01: Per-actor heap uses mark-sweep (the actor allocates on its heap)
- RT-02: GC triggers automatically (no manual invocation -- the 5000 iterations generate enough pressure)
- RT-03: GC is per-actor (main actor is unaffected during worker's collection)
- RT-04: Memory stays bounded (5000 iterations of allocation without OOM)

Look at existing e2e tests for the exact test patterns used in this project (expected output format, how the test harness works). Match that pattern.

If the test harness expects specific output, use `IO.puts` to print the expected output. The test should be added to the e2e test runner.
  </action>
  <verify>
Run: `cargo test -p snowc --test e2e gc_bounded_memory`
The e2e test compiles and runs to completion. Output matches expected.
  </verify>
  <done>
E2E test proves a long-running actor with 5000+ iterations of allocation/discard completes successfully with bounded memory, demonstrating all four RT requirements.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite and fix any integration issues</name>
  <files>crates/snow-rt/src/actor/heap.rs</files>
  <action>
Run the complete test suite to verify the GC integration doesn't break anything:

1. `cargo test -p snow-rt` -- all runtime unit tests
2. `cargo test -p snow-codegen` -- all codegen tests
3. `cargo test -p snowc --test e2e` -- all 61+ e2e tests

If any test fails:
- Diagnose the failure by reading the error output
- Fix the issue (likely in heap.rs -- alignment, header offset, or conservative scanning false positives)
- Re-run until all tests pass

Common integration issues to watch for:
- **Alignment**: GcHeader is 16 bytes, but the user data after it needs the alignment requested by the caller. Ensure the bump allocator accounts for this: allocate GC_HEADER_SIZE + padding + size, where padding aligns the data pointer.
- **Conservative scanning false positives**: If integers happen to look like heap pointers, they'll be treated as roots. This is safe (retains too much, never too little) but shouldn't cause crashes.
- **Re-entrancy**: If a GC collection triggers while another is in progress (shouldn't happen with the guard, but verify).
- **Message deep-copy**: Messages copied into an actor's heap get GcHeaders. The copy_msg_to_actor_heap function allocates via proc.heap.alloc which now adds headers. The returned pointer is past the header, so the message layout is unchanged.

If any e2e test hangs (GC trigger causes infinite loop or deadlock), check:
- Is gc_in_progress being set/cleared correctly?
- Is the GC trigger running inside the process lock? (It shouldn't -- that would deadlock)
- Does try_trigger_gc properly acquire and release the process lock?
  </action>
  <verify>
Run: `cargo test --workspace`
All tests across all crates pass.
  </verify>
  <done>
Full test suite passes. GC is fully integrated with no regressions. All four RT requirements are satisfied.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass across all crates
2. `gc_bounded_memory.snow` e2e test passes
3. No existing e2e tests regressed
4. The GC test demonstrates bounded memory: 5000+ allocation cycles complete successfully
</verification>

<success_criteria>
- E2E test proves long-running actor maintains bounded memory
- All 61+ existing e2e tests pass without modification
- Full workspace test suite passes
- Requirements RT-01, RT-02, RT-03, RT-04 are all satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/17-mark-sweep-garbage-collector/17-04-SUMMARY.md`
</output>
