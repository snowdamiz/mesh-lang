---
phase: 17-mark-sweep-garbage-collector
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/actor/heap.rs
  - crates/snow-rt/src/gc.rs
autonomous: true

must_haves:
  truths:
    - "ActorHeap allocations prepend a 16-byte GcHeader before every object"
    - "Free-list allocator reuses freed memory blocks before bump-allocating new pages"
    - "All live objects are linked via an intrusive all-objects list for sweep traversal"
    - "snow_gc_alloc_actor returns pointers past the header (user-visible pointer unchanged)"
  artifacts:
    - path: "crates/snow-rt/src/actor/heap.rs"
      provides: "GcHeader struct, free-list allocator, all-objects list, mark/sweep stubs"
      contains: "GcHeader"
    - path: "crates/snow-rt/src/gc.rs"
      provides: "Updated snow_gc_alloc_actor routing through GC-aware ActorHeap"
      contains: "snow_gc_alloc_actor"
  key_links:
    - from: "crates/snow-rt/src/gc.rs"
      to: "crates/snow-rt/src/actor/heap.rs"
      via: "snow_gc_alloc_actor calls ActorHeap::alloc which prepends GcHeader"
      pattern: "proc\\.heap\\.alloc"
---

<objective>
Replace the bump allocator in ActorHeap with a GcHeader-prepended free-list allocator that tracks all live objects for future mark-sweep collection.

Purpose: This is the foundational data structure change that enables garbage collection. Every allocation gets a 16-byte header (size, flags, next pointer) and is linked into an all-objects list. The free-list allows memory reuse after sweep. Without this, mark-sweep has nothing to sweep.

Output: Modified `heap.rs` with GcHeader-aware allocator and updated `gc.rs` routing.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-mark-sweep-garbage-collector/17-RESEARCH.md
@crates/snow-rt/src/actor/heap.rs
@crates/snow-rt/src/gc.rs
@crates/snow-rt/src/actor/process.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GcHeader and free-list allocator in ActorHeap</name>
  <files>crates/snow-rt/src/actor/heap.rs</files>
  <action>
Replace the bump-only allocator in ActorHeap with a GcHeader-aware free-list allocator:

1. **Add GcHeader struct** (16 bytes, #[repr(C)]):
   ```rust
   #[repr(C)]
   struct GcHeader {
       size: u32,        // size of the user data (not including header)
       flags: u8,        // bit 0: marked, bit 1: free
       _pad: [u8; 3],    // padding for alignment
       next: *mut GcHeader,  // next in all-objects list (or free list)
   }
   ```
   Constants: `GC_HEADER_SIZE = 16`, `MARK_BIT = 0x01`, `FREE_BIT = 0x02`.
   Methods: `is_marked()`, `set_marked()`, `clear_marked()`, `is_free()`, `set_free()`, `clear_free()`, `data_ptr()` (returns pointer past header), `from_data_ptr(data: *mut u8) -> *mut GcHeader` (backs up 16 bytes).

2. **Add fields to ActorHeap**:
   - `all_objects: *mut GcHeader` -- head of intrusive linked list of all allocated objects (for sweep)
   - `free_list: *mut GcHeader` -- head of free list (freed blocks available for reuse)
   - `gc_threshold: usize` -- heap pressure threshold in bytes (default: 256 * 1024 = 256 KiB)
   - `gc_in_progress: bool` -- re-entrancy guard

3. **Rewrite `ActorHeap::alloc(size, align)`**:
   - First, try the free list: walk `free_list`, find first block where `header.size >= size` (first-fit). If found, unlink from free list, clear FREE_BIT, link into all_objects list, return `header.data_ptr()`.
   - If no suitable free block: bump-allocate `GC_HEADER_SIZE + size` bytes from pages (existing page logic). Initialize the header (size, flags=0, next=all_objects), link into all_objects list, return pointer past header.
   - Update `total_allocated` to include header sizes for accurate pressure tracking.

4. **Update `ActorHeap::reset()`**: Clear `all_objects` and `free_list` pointers to null, then clear pages as before.

5. **Add method `should_collect(&self) -> bool`**: Returns `total_allocated >= gc_threshold`.

6. **Update `MessageBuffer::deep_copy_to_heap()`**: This calls `heap.alloc()` which now prepends headers automatically -- no change needed to the call site, but verify the test still passes since the returned pointer is past the header.

7. **Update all existing tests** to account for the header overhead in `total_bytes()` (each alloc adds 16 bytes of header). Add new tests:
   - `test_gc_header_layout()`: Verify GcHeader is exactly 16 bytes, data_ptr/from_data_ptr round-trip.
   - `test_free_list_reuse()`: Allocate, manually free (set FREE_BIT, add to free_list), allocate same size -- should reuse.
   - `test_all_objects_list()`: Allocate 3 objects, walk all_objects list, verify count is 3.

IMPORTANT: Keep the page-level storage (Vec<Vec<u8>>) unchanged. The GcHeader is embedded within pages, not separately allocated. The bump pointer advances by GC_HEADER_SIZE + requested size.

IMPORTANT: The `alloc` method signature stays the same (`pub fn alloc(&mut self, size: usize, align: usize) -> *mut u8`) and returns the USER data pointer (past the header), keeping the ABI unchanged for all callers.
  </action>
  <verify>
Run: `cargo test -p snow-rt -- actor::heap::tests`
All existing heap tests pass (with updated size expectations). New GcHeader tests pass.
  </verify>
  <done>
GcHeader struct exists with 16-byte layout. ActorHeap::alloc() prepends headers and links objects into all_objects list. Free-list allocation works for reuse. All heap tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update gc.rs routing and ensure global arena unchanged</name>
  <files>crates/snow-rt/src/gc.rs</files>
  <action>
1. **Keep the global Arena unchanged** -- it does NOT use GcHeaders. Non-actor contexts (main thread, startup code) continue using the simple bump allocator. This is critical per Research Pitfall 1.

2. **Verify `snow_gc_alloc_actor` routes correctly**: The existing code already calls `proc.heap.alloc(size, align)` which now prepends GcHeader. No change needed to the routing logic, but add a doc comment noting that the returned pointer is past the GcHeader.

3. **Add `snow_gc_collect` extern "C" entry point** (stub for now, will be implemented in Plan 02):
   ```rust
   #[no_mangle]
   pub extern "C" fn snow_gc_collect() {
       // Will be implemented in Plan 02: triggers GC on current actor's heap.
       // For now, no-op.
   }
   ```

4. **Update existing tests**: Ensure `test_gc_alloc_extern` and `test_arena_*` tests still pass unchanged (global arena is not affected).

5. **Add a test** that verifies `snow_gc_alloc` (global) does NOT add headers (returns directly from arena), while actor heap alloc DOES add headers (verifiable by backing up 16 bytes and reading the GcHeader).
  </action>
  <verify>
Run: `cargo test -p snow-rt -- gc::tests`
All gc.rs tests pass. Global arena remains header-free. `snow_gc_collect` stub compiles.
  </verify>
  <done>
Global arena unchanged. snow_gc_alloc_actor correctly produces GcHeader-prefixed allocations via ActorHeap. snow_gc_collect stub exists for Plan 02.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-rt` -- all runtime tests pass
2. `cargo build -p snow-rt` -- no warnings
3. The ABI is unchanged: `snow_gc_alloc` and `snow_gc_alloc_actor` return user-visible pointers (past any header)
</verification>

<success_criteria>
- GcHeader is 16 bytes with mark/free bits, size, and next pointer
- ActorHeap tracks all objects in an intrusive linked list
- Free-list allocation reuses freed blocks before bump-allocating
- Global arena is completely unchanged (no headers)
- All existing tests pass with updated size expectations
- New tests verify header layout, free-list reuse, and all-objects tracking
</success_criteria>

<output>
After completion, create `.planning/phases/17-mark-sweep-garbage-collector/17-01-SUMMARY.md`
</output>
