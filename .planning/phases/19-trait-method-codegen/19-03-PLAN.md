---
phase: 19-trait-method-codegen
plan: 03
type: execute
wave: 3
depends_on: ["19-02"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "Where-clause violations that somehow bypass typeck produce a compiler panic instead of silent wrong code"
    - "Monomorphization depth exceeding the limit produces a compiler error instead of stack overflow"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Defense-in-depth assertion for trait method resolution and mono depth counter"
      contains: "mono_depth"
  key_links:
    - from: "lower_call_expr trait rewriting"
      to: "panic if find_method_traits returns empty for expected trait method"
      via: "assertion after failed resolution"
      pattern: "panic!.*trait method.*could not be resolved"
    - from: "lower_impl_method or lower_fn_def"
      to: "mono_depth counter"
      via: "increment/decrement around body lowering"
      pattern: "mono_depth.*max_mono_depth"
---

<objective>
Add defense-in-depth where-clause enforcement (assertion on unresolvable trait methods) and a monomorphization depth limit to prevent compiler stack overflow.

Purpose: The type checker already enforces where-clause constraints comprehensively (infer_call at infer.rs:2364-2405). The MIR lowerer adds a safety net: if a trait method call cannot be resolved via TraitRegistry (indicating a typeck bug or edge case), the compiler panics with a clear message instead of generating wrong code. The depth limit prevents infinite recursion during MIR lowering of deeply nested generic trait method calls. Addresses CODEGEN-04 and CODEGEN-05.

Output: Modified lower.rs with assertion on trait method resolution failure and configurable monomorphization depth counter.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-trait-method-codegen/19-RESEARCH.md
@.planning/phases/19-trait-method-codegen/19-01-SUMMARY.md
@.planning/phases/19-trait-method-codegen/19-02-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add where-clause defense-in-depth assertion in call-site resolution</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
In the trait method rewriting logic added by Plan 19-02 (inside lower_call_expr), add an assertion/warning path for the case where a callee looks like it SHOULD be a trait method but cannot be resolved.

The detection heuristic: a function call where the callee name is NOT in known_functions AND find_method_traits returns empty AND the callee name is NOT a local variable in the current scope. This indicates a potential where-clause violation that somehow bypassed typeck.

Specifically, after the existing trait method rewriting logic in lower_call_expr:
1. If the callee is `MirExpr::Var(name, _)` and `name` is NOT in known_functions and NOT in current scope:
   - If args are non-empty AND `find_method_traits` returned empty:
     - This could be a trait method whose constraint was not met. Since typeck should have caught this, emit an eprintln warning: `"[snow-codegen] warning: call to '{}' could not be resolved as a trait method for type '{}'. This may indicate a type checker bug."`, with the method name and first arg type name
     - Do NOT panic (error recovery: let it proceed as a regular call, which will likely fail at LLVM codegen with a clearer "undefined function" error)
   - This is defense-in-depth only. In normal operation with a working typeck, this path is never hit.

IMPORTANT: Do NOT re-implement where-clause checking in the lowerer. Do NOT thread FnConstraints through TypeckResult. The research explicitly recommends trusting typeck (Option A). This task adds a warning, not a full re-check.
  </action>
  <verify>
`cargo check -p snow-codegen` compiles cleanly. `cargo test -p snow-codegen --lib` passes all existing tests. The warning path is exercised only when typeck has a bug, so no test should trigger it in normal operation. Verify by reviewing the code that the warning is non-fatal (eprintln, not panic).
  </verify>
  <done>
A defense-in-depth warning exists in lower_call_expr that logs when a potential trait method call cannot be resolved. This catches where-clause violations that somehow bypass typeck without crashing the compiler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add monomorphization depth limit to MIR lowering</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Add a depth counter to the Lowerer struct to prevent stack overflow from deeply recursive trait method instantiation.

1. Add two fields to the `Lowerer` struct:
   ```
   mono_depth: u32,
   max_mono_depth: u32,
   ```

2. Initialize in the Lowerer constructor:
   ```
   mono_depth: 0,
   max_mono_depth: 64,
   ```

3. In `lower_impl_method` (created by Plan 19-01), wrap the body lowering with depth tracking:
   - Before lowering body: `self.mono_depth += 1;`
   - Check: `if self.mono_depth > self.max_mono_depth { /* emit error */ }`
   - If depth exceeded: return `MirExpr::Panic { message: format!("monomorphization depth limit ({}) exceeded", self.max_mono_depth), file: "<compiler>".to_string(), line: 0 }`
   - After lowering body: `self.mono_depth -= 1;`

4. Also add the same depth tracking in `lower_fn_def` for completeness, since regular functions can also trigger deep recursion through trait method calls.

NOTE: In the current architecture, MIR lowering is a single AST pass -- it does not recursively instantiate generic functions. The depth limit is primarily a safety net for future monomorphization work and for cases where trait method lowering triggers further lowering. The counter is cheap (one u32 increment/decrement per function body) and prevents compiler crashes.

Write a unit test `mono_depth_limit_prevents_overflow`:
1. Verify the Lowerer struct has mono_depth and max_mono_depth fields
2. The test should confirm that if max_mono_depth is set to a low value (e.g., 2), lowering a deeply nested structure eventually produces a MirExpr::Panic instead of infinite recursion
3. This is hard to trigger with real Snow code in the current architecture, so the test can directly manipulate the Lowerer state or simply verify the fields exist and the check is in place by examining the lowered output for a normal program (no Panic nodes present).
  </action>
  <verify>
`cargo check --workspace` compiles cleanly. `cargo test -p snow-codegen --lib` passes all existing tests plus the new depth limit test. The depth counter does not affect normal compilation (depth of typical programs is < 10).
  </verify>
  <done>
Lowerer has a configurable monomorphization depth limit (default 64). Exceeding the limit produces a MirExpr::Panic with a clear error message instead of stack overflow. Both lower_fn_def and lower_impl_method track depth.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles cleanly
2. `cargo test -p snow-codegen --lib` -- all tests pass
3. The warning in lower_call_expr is non-fatal and only triggers on typeck bugs
4. The depth counter exists and is checked in both lower_fn_def and lower_impl_method
</verification>

<success_criteria>
- CODEGEN-04: Where-clause constraints have defense-in-depth enforcement (warning on unresolvable trait method calls, trusting typeck for primary enforcement)
- CODEGEN-05: Monomorphization depth limit prevents infinite trait method instantiation (default limit 64, configurable)
- No regressions in existing tests
- No performance impact on normal compilation
</success_criteria>

<output>
After completion, create `.planning/phases/19-trait-method-codegen/19-03-SUMMARY.md`
</output>
