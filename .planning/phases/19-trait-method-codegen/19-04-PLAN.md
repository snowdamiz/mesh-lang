---
phase: 19-trait-method-codegen
plan: 04
type: execute
wave: 4
depends_on: ["19-03"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - tests/trait_codegen.snow
autonomous: true

must_haves:
  truths:
    - "A Snow program with interface, impl, struct, and trait method call compiles and produces correct output"
    - "Trait method calls resolve to mangled names visible in MIR"
    - "self parameter in impl methods receives the concrete struct value"
    - "Multiple traits with different methods for the same type all work correctly"
    - "Where-clause constrained functions reject calls with unsatisfied bounds at compile time"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "End-to-end integration tests for trait codegen"
      contains: "fn e2e_trait_method"
  key_links:
    - from: "test source code with interface + impl"
      to: "MirFunction with mangled name"
      via: "full lowering pipeline"
      pattern: "Greetable__greet__"
    - from: "test source code with trait method call"
      to: "MirExpr::Call with mangled name"
      via: "call-site resolution"
      pattern: "Call.*__.*__"
---

<objective>
Write end-to-end integration tests validating all five Phase 19 success criteria through the MIR lowering pipeline.

Purpose: Plans 19-01 through 19-03 built the individual pieces (method lowering, call-site resolution, operator dispatch, defense-in-depth, depth limit). This plan verifies they work together end-to-end. The tests serve as regression guards for all CODEGEN requirements.

Output: Comprehensive test suite in lower.rs proving the trait codegen pipeline is correct.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-trait-method-codegen/19-RESEARCH.md
@.planning/phases/19-trait-method-codegen/19-01-SUMMARY.md
@.planning/phases/19-trait-method-codegen/19-02-SUMMARY.md
@.planning/phases/19-trait-method-codegen/19-03-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: End-to-end trait codegen tests covering all success criteria</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Add integration tests to the `#[cfg(test)] mod tests` section at the bottom of lower.rs. Use the same test helper pattern already established in the file (parse source -> typeck -> lower_to_mir -> inspect MirProgram).

Create the following tests:

**Test 1: `e2e_trait_method_call_compiles`** (Success Criterion 1)
Source:
```
type Greeter do name :: String end

interface Greetable do
  fn greet(self) -> String
end

impl Greetable for Greeter do
  fn greet(self) -> String do
    "hello"
  end
end

fn main() do
  let g = Greeter("world")
  let result = greet(g)
  println(result)
end
```
Assertions:
- MirProgram contains a function named `Greetable__greet__Greeter`
- The main function body contains a `MirExpr::Call` whose func references `Greetable__greet__Greeter`
- No function named bare `greet` exists in the MirProgram functions list (only the mangled version)

**Test 2: `e2e_mangled_names_in_mir`** (Success Criterion 2)
Source: Same as Test 1 or a variant with a different trait/type pair.
Assertions:
- The MirFunction for the impl method has name matching pattern `{trait}__{method}__{type}` with double-underscore separators
- The name uses exactly 2 underscores as separators (verify by counting `__` occurrences)

**Test 3: `e2e_self_param_has_concrete_type`** (Success Criterion 3)
Source: Same as Test 1.
Assertions:
- The MirFunction `Greetable__greet__Greeter` has params list where first param is ("self", MirType::Struct("Greeter"))
- The type is NOT MirType::Unit, NOT MirType::Ptr, NOT MirType::Struct("self")

**Test 4: `e2e_multiple_traits_different_types`**
Source:
```
type Dog do name :: String end
type Cat do name :: String end

interface Speakable do
  fn speak(self) -> String
end

impl Speakable for Dog do
  fn speak(self) -> String do "woof" end
end

impl Speakable for Cat do
  fn speak(self) -> String do "meow" end
end

fn main() do
  let d = Dog("Rex")
  let c = Cat("Whiskers")
  println(speak(d))
  println(speak(c))
end
```
Assertions:
- MirProgram has `Speakable__speak__Dog` function
- MirProgram has `Speakable__speak__Cat` function
- Main body has calls to both mangled names (not bare `speak`)

**Test 5: `e2e_where_clause_enforcement`** (Success Criterion 4)
This tests that typeck catches where-clause violations. The MIR lowerer only sees valid programs.
Source that should FAIL typeck:
```
interface Displayable do
  fn display(self) -> String
end

fn show<T>(x :: T) -> String where T: Displayable do
  display(x)
end

fn main() do
  show(42)
end
```
(Assuming Int does NOT have a Displayable impl in this source)
Assertion: This should produce a typeck error (not a MIR lowering error). Run typeck and verify errors are non-empty. This confirms CODEGEN-04 is handled by typeck.

NOTE: If writing this test is complex due to test infrastructure, it can be simplified to verify that the lowerer's defense-in-depth warning path exists by code inspection rather than triggering it.

**Test 6: `e2e_depth_limit_field_exists`** (Success Criterion 5)
This verifies the depth limit machinery is in place. Since triggering the limit requires deeply recursive trait instantiation which is hard to construct:
- Lower a normal program and verify the resulting MirProgram has no MirExpr::Panic nodes (depth was not exceeded)
- Verify by reading the Lowerer struct definition that mono_depth and max_mono_depth fields exist

If the test infrastructure allows creating a Lowerer directly (not through the public API), create one with max_mono_depth=1 and verify that lowering a function produces a Panic node.

IMPORTANT: Follow the existing test patterns in lower.rs exactly. Use the same helper functions for parsing, typechecking, and lowering. Do NOT create a new test binary or test file -- add to the existing test module.

IMPORTANT: If any test cannot be written due to test infrastructure limitations (e.g., cannot inspect MirExpr tree easily), document it with a `#[ignore]` attribute and a comment explaining what it would test. Do not skip writing the test entirely.
  </action>
  <verify>
`cargo test -p snow-codegen --lib e2e_trait` -- all new tests pass.
`cargo test -p snow-codegen --lib` -- all existing tests still pass (no regressions).
`cargo check --workspace` -- full workspace compiles cleanly.
  </verify>
  <done>
At least 4 integration tests prove the trait codegen pipeline works end-to-end: mangled function names, self parameter typing, call-site resolution, and multi-type dispatch. Where-clause enforcement is confirmed as handled by typeck. Depth limit machinery is verified to exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Full workspace test suite validation and smoke test</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Run the complete test suite across all crates to verify no regressions from the entire Phase 19 work:

1. `cargo test --workspace` -- ALL tests across all crates must pass
2. `cargo test -p snow-typeck` -- typeck tests (227+) must all pass
3. `cargo test -p snow-codegen` -- codegen tests (85+ plus new) must all pass

If any tests fail, diagnose and fix. Common issues:
- MirExpr tree shape changed (tests that pattern-match on MirExpr variants)
- New fields in Lowerer not initialized in test helpers
- Mangled function names appearing where bare names were expected in existing tests

Create a Snow source file at `tests/trait_codegen.snow` as a smoke test that exercises the full trait codegen pipeline (this tests all the way through to LLVM codegen, not just MIR):
```
type Point do
  x :: Int
  y :: Int
end

interface Describable do
  fn describe(self) -> String
end

impl Describable for Point do
  fn describe(self) -> String do
    "a point"
  end
end

fn main() do
  let p = Point(1, 2)
  let desc = describe(p)
  println(desc)
end
```

Attempt to compile this with `cargo run -- tests/trait_codegen.snow` (or whatever the compiler binary invocation is). If it compiles and runs successfully (prints "a point"), that is the ultimate success criterion. If LLVM codegen fails (e.g., undefined function reference), document the exact error -- this would indicate codegen/expr.rs needs updates (which the research says it should NOT, since MirExpr::Call with mangled names should "just work" in codegen_call). Document the outcome either way.

IMPORTANT: The smoke test may fail at LLVM codegen if the codegen pass does not have the mangled functions available. This is expected if the mono pass removes them as unreachable. If this happens, check that:
1. The mangled function is in the MirProgram.functions list
2. The call site references the mangled name (not bare name)
3. The mono reachability analysis finds the mangled function as reachable

If the smoke test fails, document the failure clearly with the exact error. Do NOT attempt major fixes in this plan -- fixing LLVM codegen issues would be a gap closure plan.
  </action>
  <verify>
`cargo test --workspace` passes all tests.
The smoke test `tests/trait_codegen.snow` either:
- Compiles and runs (prints "a point") -- full success
- Fails with a documented error -- partial success with clear next steps
  </verify>
  <done>
Full workspace test suite passes with no regressions. Smoke test documents the end-to-end compilation status of a Snow program using trait method dispatch. Any remaining LLVM codegen gaps are clearly documented for gap closure.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass across all crates
2. New e2e tests cover all 5 Phase 19 success criteria
3. Smoke test attempts full compilation of a trait-using Snow program
4. No regressions in any existing test
</verification>

<success_criteria>
- All 5 Phase 19 success criteria are tested:
  1. interface + impl + call compiles and produces correct output (or documented gap)
  2. Mangled names visible in MIR
  3. self parameter has concrete struct type
  4. Where-clause enforcement confirmed (typeck handles it)
  5. Depth limit machinery in place
- Full workspace test suite passes
- Smoke test documents end-to-end status
</success_criteria>

<output>
After completion, create `.planning/phases/19-trait-method-codegen/19-04-SUMMARY.md`
</output>
