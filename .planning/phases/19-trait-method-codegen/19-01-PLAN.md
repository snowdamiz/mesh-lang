---
phase: 19-trait-method-codegen
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "ImplDef methods produce MirFunctions with Trait__Method__Type mangled names"
    - "self parameter in impl methods receives the concrete struct type, not Unit or an opaque type"
    - "Mangled trait method names are pre-registered in known_functions so call sites emit MirExpr::Call (not ClosureCall)"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "ImplDef pre-registration and method lowering with name mangling"
      contains: "format!(\"{}__{}__{}\""
  key_links:
    - from: "lower_item() ImplDef arm"
      to: "MirFunction with mangled name"
      via: "lower_impl_method helper"
      pattern: "Trait__.*__Type"
    - from: "pre-registration loop ImplDef arm"
      to: "known_functions HashMap"
      via: "insert with mangled name"
      pattern: "known_functions\\.insert.*__.*__"
---

<objective>
Lower impl block method bodies to MirFunctions with Trait__Method__Type mangled names, handle the self parameter as the first concrete-typed argument, and pre-register mangled names in known_functions.

Purpose: This is the foundation of trait codegen. Without mangled function names and pre-registration, call sites cannot resolve trait methods and the monomorphization pass will treat them as unreachable. CODEGEN-01 and CODEGEN-03 are addressed here.

Output: Modified lower.rs where ImplDef methods produce correctly named MirFunctions with self handled as a concrete-typed first parameter.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-trait-method-codegen/19-RESEARCH.md
@.planning/phases/18-trait-infrastructure/18-03-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pre-register ImplDef methods with mangled names in known_functions</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
In the pre-registration loop at `lower_source_file` (around line 149, the `for item in sf.items()` loop), replace the `_ => {}` fallthrough arm with an `Item::ImplDef` arm that:

1. Extracts trait name and type name from PATH children (same pattern as `infer_impl_def` in infer.rs:1682-1707):
   - Filter `impl_def.syntax().children()` for `SyntaxKind::PATH` nodes
   - First PATH's first IDENT token = trait name
   - Second PATH's first IDENT token = type name

2. For each method in `impl_def.methods()`:
   - Extract method name from `method.name().and_then(|n| n.text())`
   - Compute mangled name: `format!("{}__{}__{}", trait_name, method_name, type_name)`
   - Get the method's type from typeck: `self.resolve_range(method.syntax().text_range())`
   - Insert into `known_functions`: `self.known_functions.insert(mangled.clone(), fn_ty.clone())`

3. Keep the `_ => {}` arm for remaining unmatched items (InterfaceDef, TypeAliasDef, etc.)

IMPORTANT: Use `SyntaxKind::PATH` and `SyntaxKind::IDENT` from the parser. These are already imported in lower.rs. Do NOT create new parser methods or types -- reuse the exact PATH extraction pattern from infer.rs.

IMPORTANT: Do NOT insert the bare method name into known_functions -- only the mangled name. The bare name is already registered by typeck as a plain function. Pre-registration of the mangled name is what enables direct `MirExpr::Call` dispatch.
  </action>
  <verify>
`cargo check -p snow-codegen` compiles cleanly. Run `cargo test -p snow-codegen --lib` and confirm all existing tests pass (no regressions). The change is additive -- it adds a new arm to a match statement and inserts new entries into known_functions, so existing behavior should be untouched.
  </verify>
  <done>
The pre-registration loop has an `Item::ImplDef` arm that computes `Trait__Method__Type` mangled names for each method and inserts them into `known_functions`. Existing `_ => {}` still handles remaining items.
  </done>
</task>

<task type="auto">
  <name>Task 2: Lower ImplDef methods to MirFunctions with mangled names and self parameter</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Replace the current `Item::ImplDef` arm in `lower_item()` (line 427-432) with logic that:

1. Extracts trait name and type name using the same PATH extraction pattern as Task 1.

2. For each method in `impl_def.methods()`, calls a new helper `lower_impl_method(&method, &mangled_name, &type_name)` where mangled_name = `format!("{}__{}__{}", trait_name, method_name, type_name)`.

3. The `lower_impl_method` helper (new private method on Lowerer) does the following:
   a. Push a new scope
   b. Get the method's function type from typeck: `self.get_ty(method.syntax().text_range())`
   c. Extract parameters from param_list, BUT handle `self` specially:
      - For each param, check if the param node contains a `SELF_KW` token (not IDENT). Use: `param.syntax().children_with_tokens().any(|t| t.as_token().map_or(false, |tok| tok.kind() == SyntaxKind::SELF_KW))`
      - If it IS self: use param name "self", type = `resolve_type(&Ty::Con(TyCon::new(&type_name)), self.registry, false)` to get the concrete MirType (e.g., MirType::Struct("MyStruct"))
      - If it is NOT self: extract name and type normally (same as lower_fn_def)
      - Insert each param into scope via `self.insert_var()`
   d. Extract return type from the Ty::Fun, defaulting to MirType::Unit
   e. Lower the method body (block or expr_body, same as lower_fn_def)
   f. Pop scope
   g. Push MirFunction with the mangled name, params, return_type, body, is_closure_fn: false, captures: vec![]

IMPORTANT: The `self` param should be zipped with the Ty::Fun param types just like lower_fn_def does. The type checker stores the impl type as the first param type in the function's Ty::Fun. The special handling is ONLY for the parameter NAME -- when the parser yields SELF_KW instead of IDENT, use "self" as the name. For the TYPE, use the Ty::Fun param type (which should be the impl type) and resolve it normally. This avoids the Pitfall 6 misalignment.

IMPORTANT: Do NOT modify lower_fn_def. Create a separate lower_impl_method to keep concerns clean. The two functions handle self differently and will diverge further in future phases.

Extract the shared PATH-extraction logic into a small private helper `extract_impl_names(impl_def: &ImplDef) -> (String, String)` to avoid duplication between Task 1's pre-registration and Task 2's lowering.
  </action>
  <verify>
`cargo check -p snow-codegen` compiles cleanly. `cargo test -p snow-codegen --lib` passes all existing tests.

Write a unit test `impl_method_produces_mangled_mir_function` in the test module at the bottom of lower.rs that:
1. Creates a Snow source: `interface Greetable do fn greet(self) -> String end impl Greetable for Point do fn greet(self) -> String do "hello" end end type Point do x :: Int end`
2. Runs it through the lowerer
3. Asserts a MirFunction named `Greetable__greet__Point` exists
4. Asserts the first parameter is named "self" with type MirType::Struct("Point")
5. Run this test: `cargo test -p snow-codegen --lib impl_method_produces_mangled`
  </verify>
  <done>
ImplDef methods are lowered to MirFunctions with `Trait__Method__Type` mangled names. The `self` parameter is correctly typed as the concrete implementing struct. A unit test confirms both the mangled name and self parameter type.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles cleanly
2. `cargo test -p snow-codegen --lib` -- all existing + new tests pass
3. The MIR output for an ImplDef contains functions named with double-underscore mangling pattern
4. Self parameter in impl methods has the concrete struct type (not Unit, not a generic/opaque type)
</verification>

<success_criteria>
- CODEGEN-01: impl blocks lower to executable MIR functions with mangled names (Trait__Method__Type)
- CODEGEN-03: self parameter handled as first argument with concrete type in impl method bodies
- Pre-registration ensures known_functions contains all mangled impl method names
- At least one unit test proves mangled name and self type correctness
</success_criteria>

<output>
After completion, create `.planning/phases/19-trait-method-codegen/19-01-SUMMARY.md`
</output>
