---
phase: 19-trait-method-codegen
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/types.rs
autonomous: true

must_haves:
  truths:
    - "Trait method calls resolve to mangled function names via TraitRegistry lookup at call sites"
    - "A call greet(my_point) where greet is a trait method becomes a call to Greetable__greet__Point"
    - "Binary operators on user types (a + b where a: MyStruct with impl Add) emit MirExpr::Call to Add__add__MyStruct instead of MirExpr::BinOp"
  artifacts:
    - path: "crates/snow-codegen/src/mir/types.rs"
      provides: "mir_type_to_ty helper for reverse type mapping"
      contains: "fn mir_type_to_ty"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Call-site rewriting in lower_call_expr and operator dispatch in lower_binary_expr"
      contains: "find_method_traits"
  key_links:
    - from: "lower_call_expr"
      to: "TraitRegistry::find_method_traits"
      via: "mir_type_to_ty conversion then registry lookup"
      pattern: "find_method_traits.*mir_type_to_ty"
    - from: "lower_binary_expr"
      to: "TraitRegistry::has_impl"
      via: "check if operand type has Add/Sub/etc impl"
      pattern: "has_impl.*Add|has_impl.*Sub"
---

<objective>
Resolve trait method calls at call sites to mangled function names via TraitRegistry lookup, and dispatch binary operators on user types through trait method calls instead of hardcoded BinOp.

Purpose: Plan 19-01 created the mangled MirFunctions, but call sites still reference bare method names. Without call-site rewriting, the generated code calls non-existent bare-named functions. This completes CODEGEN-02 and enables operator overloading for user types.

Output: Modified lower_call_expr that rewrites trait method calls to mangled names, modified lower_binary_expr that emits trait method calls for user types, and a mir_type_to_ty helper in types.rs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-trait-method-codegen/19-RESEARCH.md
@.planning/phases/19-trait-method-codegen/19-01-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/types.rs
@crates/snow-typeck/src/traits.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mir_type_to_ty helper and type-name extraction helper</name>
  <files>crates/snow-codegen/src/mir/types.rs</files>
  <action>
Add two public helper functions to `types.rs`:

1. `pub fn mir_type_to_ty(mir_type: &MirType) -> Ty` -- converts MIR types back to typeck Ty for TraitRegistry lookups. Handle:
   - `MirType::Int` -> `Ty::int()` (which is `Ty::Con(TyCon::new("Int"))`)
   - `MirType::Float` -> `Ty::float()` (which is `Ty::Con(TyCon::new("Float"))`)
   - `MirType::String` -> `Ty::string()` (which is `Ty::Con(TyCon::new("String"))`)
   - `MirType::Bool` -> `Ty::bool()` (which is `Ty::Con(TyCon::new("Bool"))`)
   - `MirType::Struct(name)` -> `Ty::Con(TyCon::new(name))`
   - `MirType::SumType(name)` -> `Ty::Con(TyCon::new(name))`
   - All others -> `Ty::Con(TyCon::new("Unknown"))` (best-effort fallback; trait impls for complex types like tuples, closures, etc. are not expected in v1.3)

   Import `Ty` and `TyCon` from `snow_typeck` (these are already available since snow-codegen depends on snow-typeck).

2. `pub fn mir_type_to_impl_name(mir_type: &MirType) -> String` -- extracts the type name string used in mangled names. Handle:
   - `MirType::Int` -> `"Int"`
   - `MirType::Float` -> `"Float"`
   - `MirType::String` -> `"String"`
   - `MirType::Bool` -> `"Bool"`
   - `MirType::Struct(name)` -> `name.clone()`
   - `MirType::SumType(name)` -> `name.clone()`
   - All others -> `"Unknown"`

IMPORTANT: Check what imports already exist in types.rs. Add only the new imports needed (Ty, TyCon from snow_typeck). Do NOT modify existing functions.
  </action>
  <verify>
`cargo check -p snow-codegen` compiles cleanly. Write unit tests for both functions:
- `mir_type_to_ty` correctly maps Int -> Ty::int(), Struct("Point") -> Ty::Con(TyCon::new("Point"))
- `mir_type_to_impl_name` correctly maps Int -> "Int", Struct("Point") -> "Point"
Run `cargo test -p snow-codegen --lib mir_type_to`.
  </verify>
  <done>
Two helper functions exist in types.rs for converting MirType to Ty (for registry lookups) and MirType to type name string (for mangled name construction).
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite trait method calls to mangled names in lower_call_expr</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Modify `lower_call_expr` to detect and rewrite trait method calls. Insert the rewriting logic AFTER args are lowered but BEFORE the `is_known_fn` check (around line 1338). The logic:

1. Check if the callee is a `MirExpr::Var(name, ty)` where `name` is NOT in `known_functions` (it's a bare method name registered by typeck, not a known top-level function).

2. If it's not a known function AND there are args:
   a. Get the first argument's type: `args[0].ty()`
   b. Convert to Ty using `mir_type_to_ty(&first_arg_ty)` (import from types.rs)
   c. Call `self.trait_registry.find_method_traits(&name, &ty)` to check if this is a trait method
   d. If result is non-empty (it IS a trait method):
      - Take the first trait name (if multiple, typeck already reported ambiguity error; use first for error recovery per research recommendation)
      - Get the type name string: `mir_type_to_impl_name(&first_arg_ty)`
      - Compute mangled name: `format!("{}__{}__{}", trait_name, name, type_name)`
      - Replace callee with `MirExpr::Var(mangled.clone(), ty.clone())`
      - The mangled name IS in known_functions (pre-registered by 19-01), so the subsequent `is_known_fn` check will emit `MirExpr::Call` (direct call), not ClosureCall

3. If `find_method_traits` returns empty, leave the callee unchanged (it's a regular function or closure).

Import `mir_type_to_ty` and `mir_type_to_impl_name` from `super::types` (or `crate::mir::types`).

ALSO modify `lower_binary_expr` for operator dispatch on user types. After computing lhs, rhs, op, and ty, but BEFORE returning `MirExpr::BinOp`:

1. Check if the lhs type is a user type (not Int, Float, Bool, String):
   ```
   let lhs_ty = lhs.ty();
   let is_user_type = matches!(lhs_ty, MirType::Struct(_) | MirType::SumType(_));
   ```

2. If it IS a user type, map the BinOp to a trait name:
   - BinOp::Add -> "Add", method "add"
   - BinOp::Sub -> "Sub", method "sub"
   - BinOp::Mul -> "Mul", method "mul"
   - BinOp::Eq -> "Eq", method "eq"
   - BinOp::Lt -> "Ord", method "lt"
   - (Other operators: leave as BinOp for now; Add/Sub/Mul/Eq/Lt are the priority)

3. Check `self.trait_registry.has_impl(trait_name, &mir_type_to_ty(&lhs_ty))`. If there IS an impl:
   - Compute mangled: `format!("{}__{}__{}", trait_name, method_name, mir_type_to_impl_name(&lhs_ty))`
   - Emit `MirExpr::Call { func: Var(mangled, fn_type), args: vec![lhs, rhs], ty }` instead of BinOp
   - The fn_type can be looked up from `known_functions` or constructed as `MirType::FnPtr(vec![lhs_ty, rhs_ty], Box::new(ty))`

4. If no impl exists, fall through to the existing `MirExpr::BinOp` code (primitives use hardware ops).

IMPORTANT: The operator dispatch for user types is critical for Phase 20 (Eq, Ord protocols). Do not skip it.

IMPORTANT: Do NOT modify the variant constructor check, the Map key tagging check, or any other existing logic in lower_call_expr. Only ADD the trait method rewriting step.
  </action>
  <verify>
`cargo check --workspace` compiles cleanly. `cargo test -p snow-codegen --lib` passes all existing tests.

Write a unit test `call_site_rewrites_to_mangled_name` that:
1. Creates Snow source with interface, impl, struct, and a function that calls the trait method
2. Lowers to MIR
3. Walks the MIR to find a `MirExpr::Call` whose func is `Var("Greetable__greet__Point", _)`
4. Confirms the call uses the mangled name, not the bare name

Write a unit test `binop_on_user_type_emits_trait_call` that:
1. Creates Snow source with `interface Add do fn add(self, other) -> T end` and `impl Add for Vec2 do fn add(self, other) -> Vec2 do ... end end`
2. Creates a binary expression `a + b` where a, b are Vec2
3. Lowers to MIR
4. Confirms the result is `MirExpr::Call` to `Add__add__Vec2`, not `MirExpr::BinOp`

Run `cargo test -p snow-codegen --lib call_site_rewrites && cargo test -p snow-codegen --lib binop_on_user_type`.
  </verify>
  <done>
Trait method calls at call sites resolve to mangled names via TraitRegistry. Binary operators on user types with trait impls emit MirExpr::Call to the mangled trait method instead of MirExpr::BinOp. Unit tests confirm both behaviors.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles cleanly
2. `cargo test -p snow-codegen --lib` -- all tests pass including new call-site and operator dispatch tests
3. A trait method call `greet(point)` produces `MirExpr::Call { func: Var("Greetable__greet__Point"), ... }`
4. A binary op `a + b` on a user type with `impl Add` produces `MirExpr::Call` not `MirExpr::BinOp`
</verification>

<success_criteria>
- CODEGEN-02: Trait method calls at call sites resolve to mangled function names via TraitRegistry lookup
- Operator dispatch on user types works through trait method calls
- mir_type_to_ty correctly converts MIR types back to Ty for registry lookups
- No regressions in existing primitive operator behavior (BinOp still used for Int, Float, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/19-trait-method-codegen/19-02-SUMMARY.md`
</output>
