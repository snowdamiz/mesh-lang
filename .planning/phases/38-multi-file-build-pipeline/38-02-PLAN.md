---
phase: 38-multi-file-build-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["38-01"]
files_modified:
  - crates/snowc/src/main.rs
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "snowc build on a directory with multiple .snow files discovers, parses all files, and produces a working binary"
    - "Existing single-file programs compile and run identically to before -- zero regressions"
    - "A parse error in a non-entry module (not main.snow) causes the build to fail with a diagnostic"
    - "The entry module is type-checked and compiled through the existing codegen pipeline unchanged"
  artifacts:
    - path: "crates/snowc/src/main.rs"
      provides: "Multi-file-aware build() function using build_project"
      contains: "discovery::build_project"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E tests for multi-file builds"
      contains: "multi_file"
  key_links:
    - from: "crates/snowc/src/main.rs::build"
      to: "crates/snowc/src/discovery.rs::build_project"
      via: "function call replacing direct file read + parse"
      pattern: "discovery::build_project\\(dir\\)"
    - from: "crates/snowc/src/main.rs::build"
      to: "snow_typeck::check"
      via: "entry module type checking (unchanged pipeline)"
      pattern: "snow_typeck::check\\(&?entry_parse\\)"
    - from: "crates/snowc/src/main.rs::build"
      to: "snow_codegen::compile_to_binary"
      via: "entry module codegen (unchanged pipeline)"
      pattern: "snow_codegen::compile_to_binary"
---

<objective>
Modify the `build()` function in `snowc/src/main.rs` to use `build_project` for multi-file compilation, and add E2E tests verifying multi-file projects work and single-file backward compatibility is preserved.

Purpose: This connects Phase 37's module graph infrastructure and Plan 01's parse-retaining pipeline to the actual compiler build command. After this plan, `snowc build <dir>` discovers and parses ALL `.snow` files in a project, reports parse errors from any file, type-checks the entry module, and compiles it. This is the foundation for Phase 39's cross-module type checking.

Output: Modified `build()` function + 3 new E2E tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-multi-file-build-pipeline/38-RESEARCH.md
@.planning/phases/38-multi-file-build-pipeline/38-01-SUMMARY.md
@crates/snowc/src/main.rs
@crates/snowc/src/discovery.rs
@crates/snowc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify build() to use build_project pipeline</name>
  <files>crates/snowc/src/main.rs</files>
  <action>
Replace the core of the `build()` function (lines ~225-239: source reading, parsing, type checking) with the `build_project` pipeline. The function structure becomes:

1. **Keep existing validation** (dir exists, is_dir, main_snow exists) -- do NOT change these.

2. **Replace file reading + parsing with build_project:**
```rust
// Build the project: discover all files, parse, build module graph
let project = discovery::build_project(dir)?;
```

3. **Find the entry module:**
```rust
let entry_id = project.compilation_order.iter()
    .copied()
    .find(|id| project.graph.get(*id).is_entry)
    .ok_or("No entry module found in module graph")?;
let entry_idx = entry_id.0 as usize;
```

4. **Check parse errors in ALL modules** (not just main):
Iterate over all modules in `compilation_order`. For each module, check `project.module_parses[idx].errors()`. If any module has parse errors, report them using the existing parse-error reporting pattern from `report_diagnostics` (the loop over `parse.errors()` that generates ariadne reports or JSON). Set `has_errors = true` for any parse error in any module.

Use `dir.join(&project.graph.get(*id).path)` to get the full path for each module's diagnostics.

5. **Type-check the entry module only:**
```rust
let entry_parse = &project.module_parses[entry_idx];
let entry_source = &project.module_sources[entry_idx];
let typeck = snow_typeck::check(entry_parse);
```

6. **Report type-check diagnostics for entry module:**
Call the existing `report_diagnostics` with `entry_source`, `&main_snow`, `entry_parse`, `&typeck`, `diag_opts`. Combine with `has_errors`.

7. **Keep existing codegen pipeline** (determine output path, emit_llvm, compile_to_binary) -- identical to current code. Use `entry_parse` and `&typeck` where the current code uses `&parse` and `&typeck`.

**Critical backward-compatibility constraint:** For a single-file project (only `main.snow`), the new code path must produce IDENTICAL behavior: `build_project` discovers `["main.snow"]`, graph has 1 module, toposort returns `[Main]`, entry module is found, parse errors checked (for 1 file), type-checked, compiled. Same output, same errors, same binary.

**The `report_diagnostics` function stays UNCHANGED.** It already handles both parse errors and type errors for a single file. For non-entry modules, we only need to report PARSE errors (since they are not type-checked). Extract the parse-error reporting loop from `report_diagnostics` or inline a simplified version for non-entry modules. Keep it simple -- iterate modules, check for parse errors, report them.

A clean approach: Add a small helper `report_parse_errors_only(source, path, parse, diag_opts) -> bool` that only reports parse errors (the first section of `report_diagnostics`). Call it for every module. Then call `report_diagnostics` for the entry module for type-check errors. But to avoid complication, you can also just inline the parse-error loop for all modules and then call the existing diagnostics function for the entry module's type errors only.

Simplest correct approach:
- First loop: check parse errors for ALL modules (including entry). If any parse errors exist in any module, report them and set `has_errors = true`.
- If no parse errors: type-check entry module, report type errors via `report_diagnostics`. Since `report_diagnostics` also checks parse errors (which we know are empty at this point for the entry), this is safe -- it will only report type errors.
- If parse errors exist: skip type checking entirely (return early after reporting parse errors).

This avoids the issue of `report_diagnostics` double-reporting parse errors for the entry module.
  </action>
  <verify>
Run `cargo build -p snowc` to verify compilation. Then run `cargo test -p snowc -- e2e` to verify ALL existing E2E tests still pass (zero regressions).
  </verify>
  <done>
`build()` uses `build_project` pipeline. `cargo build -p snowc` compiles. All existing E2E tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add multi-file E2E tests</name>
  <files>crates/snowc/tests/e2e.rs</files>
  <action>
Add 3 new E2E tests to `crates/snowc/tests/e2e.rs` that verify multi-file build behavior.

**Test 1: e2e_multi_file_basic** - Verifies that `snowc build` works on a directory with multiple `.snow` files (even though main.snow does not import anything from the other files yet -- cross-module imports are Phase 39).

```rust
#[test]
fn e2e_multi_file_basic() {
    let temp_dir = tempfile::tempdir().expect("failed to create temp dir");
    let project_dir = temp_dir.path().join("project");
    std::fs::create_dir_all(&project_dir).expect("failed to create project dir");

    // main.snow does not import utils, but both files exist
    std::fs::write(
        project_dir.join("main.snow"),
        "fn main() do\n  IO.puts(\"hello multi\")\nend\n",
    ).unwrap();
    std::fs::write(
        project_dir.join("utils.snow"),
        "fn helper() do\n  42\nend\n",
    ).unwrap();

    let snowc = find_snowc();
    let output = Command::new(&snowc)
        .args(["build", project_dir.to_str().unwrap()])
        .output()
        .expect("failed to invoke snowc");

    assert!(
        output.status.success(),
        "snowc build failed on multi-file project:\nstderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    let binary = project_dir.join("project");
    let run_output = Command::new(&binary).output().expect("failed to run binary");
    assert!(run_output.status.success());
    assert_eq!(
        String::from_utf8_lossy(&run_output.stdout).trim(),
        "hello multi"
    );
}
```

**Test 2: e2e_multi_file_parse_error_in_non_entry** - Verifies that a parse error in a non-entry module causes the build to fail.

```rust
#[test]
fn e2e_multi_file_parse_error_in_non_entry() {
    let temp_dir = tempfile::tempdir().expect("failed to create temp dir");
    let project_dir = temp_dir.path().join("project");
    std::fs::create_dir_all(&project_dir).expect("failed to create project dir");

    std::fs::write(
        project_dir.join("main.snow"),
        "fn main() do\n  IO.puts(\"hello\")\nend\n",
    ).unwrap();
    // broken.snow has a syntax error
    std::fs::write(
        project_dir.join("broken.snow"),
        "fn incomplete(\n",
    ).unwrap();

    let snowc = find_snowc();
    let output = Command::new(&snowc)
        .args(["build", project_dir.to_str().unwrap()])
        .output()
        .expect("failed to invoke snowc");

    assert!(
        !output.status.success(),
        "expected build to fail due to parse error in broken.snow"
    );
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(
        stderr.contains("Parse error") || stderr.contains("error"),
        "expected parse error diagnostic, got: {}",
        stderr
    );
}
```

**Test 3: e2e_multi_file_nested_modules** - Verifies that nested directory modules are discovered and do not break the build.

```rust
#[test]
fn e2e_multi_file_nested_modules() {
    let temp_dir = tempfile::tempdir().expect("failed to create temp dir");
    let project_dir = temp_dir.path().join("project");
    std::fs::create_dir_all(project_dir.join("math")).expect("failed to create dirs");

    std::fs::write(
        project_dir.join("main.snow"),
        "fn main() do\n  IO.puts(\"nested ok\")\nend\n",
    ).unwrap();
    std::fs::write(
        project_dir.join("math/vector.snow"),
        "fn add(a: Int, b: Int) -> Int do\n  a + b\nend\n",
    ).unwrap();

    let snowc = find_snowc();
    let output = Command::new(&snowc)
        .args(["build", project_dir.to_str().unwrap()])
        .output()
        .expect("failed to invoke snowc");

    assert!(
        output.status.success(),
        "snowc build failed with nested modules:\nstderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    let binary = project_dir.join("project");
    let run_output = Command::new(&binary).output().expect("failed to run binary");
    assert!(run_output.status.success());
    assert_eq!(
        String::from_utf8_lossy(&run_output.stdout).trim(),
        "nested ok"
    );
}
```

Use the existing `find_snowc()` helper and `Command` pattern already established in the e2e test file. Add these tests at the end of the file.
  </action>
  <verify>
Run `cargo test -p snowc -- e2e_multi_file` to verify the 3 new tests pass. Then run `cargo test -p snowc` to verify all tests pass (existing + new).
  </verify>
  <done>
3 new E2E tests pass: multi-file basic build, parse error detection in non-entry module, nested directory modules. All existing E2E tests continue to pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snowc` -- ALL tests pass (existing Phase 37 unit tests + new build_project tests + existing E2E tests + new multi-file E2E tests)
2. `cargo test -p snow-common` -- module_graph tests still pass
3. `cargo test` -- full workspace test suite passes (zero regressions)
4. Manual verification: `snowc build` on the existing `examples/` directory (if it exists) or on a simple temp project confirms working compilation

**Phase 38 Success Criteria Check:**
- SC1: "Each .snow file is parsed into its own independent AST" -- verified by build_project tests and multi-file E2E tests
- SC2: "snowc build <dir> compiles all discovered files as a unified project" -- verified by e2e_multi_file_basic and e2e_multi_file_nested_modules
- SC3: "Existing single-file programs compile and run identically" -- verified by all existing E2E tests passing unchanged
</verification>

<success_criteria>
- `build()` in main.rs calls `discovery::build_project(dir)` and processes all modules
- Parse errors in ANY `.snow` file cause the build to fail with diagnostics
- Entry module is type-checked and compiled through the existing pipeline
- All existing E2E tests pass (zero regressions) -- this is the PRIMARY success criterion
- 3 new E2E tests pass (multi-file basic, parse error in non-entry, nested modules)
- `cargo test` full workspace passes
</success_criteria>

<output>
After completion, create `.planning/phases/38-multi-file-build-pipeline/38-02-SUMMARY.md`
</output>
