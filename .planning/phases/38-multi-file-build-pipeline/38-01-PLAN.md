---
phase: 38-multi-file-build-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snowc/src/discovery.rs
autonomous: true

must_haves:
  truths:
    - "build_project returns ProjectData containing graph, compilation_order, module_sources, and module_parses"
    - "build_module_graph continues to work identically as a thin wrapper around build_project"
    - "All 12 existing Phase 37 tests in discovery.rs pass without modification"
    - "Parse results in ProjectData are indexed by ModuleId.0 and match the corresponding module"
  artifacts:
    - path: "crates/snowc/src/discovery.rs"
      provides: "ProjectData struct, build_project function, backward-compatible build_module_graph wrapper"
      contains: "pub struct ProjectData"
  key_links:
    - from: "crates/snowc/src/discovery.rs::build_project"
      to: "crates/snowc/src/discovery.rs::discover_snow_files"
      via: "function call for file discovery"
      pattern: "discover_snow_files\\(project_root\\)"
    - from: "crates/snowc/src/discovery.rs::build_module_graph"
      to: "crates/snowc/src/discovery.rs::build_project"
      via: "wrapper delegation"
      pattern: "build_project\\(project_root\\)"
---

<objective>
Create the `build_project` pipeline function and `ProjectData` struct that discovers all project files, parses them, builds the module graph, and retains per-file source strings and Parse results for downstream compilation. Refactor the existing `build_module_graph` as a thin backward-compatible wrapper.

Purpose: Phase 37's `build_module_graph` parses files internally but discards the Parse results after extracting imports. Phase 38 needs those Parse results for compilation. This plan extends the pipeline to retain parse data while preserving the existing API for Phase 37 tests.

Output: `ProjectData` struct and `build_project` function in discovery.rs, plus `build_module_graph` refactored as a wrapper.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-multi-file-build-pipeline/38-RESEARCH.md
@.planning/phases/37-module-graph-foundation/37-02-SUMMARY.md
@crates/snowc/src/discovery.rs
@crates/snow-common/src/module_graph.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProjectData struct and build_project function</name>
  <files>crates/snowc/src/discovery.rs</files>
  <action>
Add a new `ProjectData` struct and `build_project` function to `discovery.rs`. This is the main deliverable of the plan.

**ProjectData struct** (add above `build_module_graph`):
```rust
/// Complete project data after discovery, parsing, and graph construction.
///
/// All Vecs are indexed by ModuleId.0 -- the i-th entry corresponds to
/// the module with ModuleId(i).
pub struct ProjectData {
    /// The module dependency graph.
    pub graph: ModuleGraph,
    /// Modules in compilation order (dependencies before dependents).
    pub compilation_order: Vec<ModuleId>,
    /// Source code for each module (indexed by ModuleId.0).
    pub module_sources: Vec<String>,
    /// Parsed AST for each module (indexed by ModuleId.0).
    pub module_parses: Vec<snow_parser::Parse>,
}
```

**build_project function** (add above `build_module_graph`):
Implement `pub fn build_project(project_root: &Path) -> Result<ProjectData, String>` with three phases:
1. Discover files via `discover_snow_files`, register each module, read source, parse via `snow_parser::parse`, store source and Parse in parallel Vecs.
2. Build dependency edges by iterating stored parses, calling `extract_imports`, resolving against the graph, adding edges (same logic as current `build_module_graph` Phase 2).
3. Run `topological_sort` and return `ProjectData`.

The logic is essentially the same as the current `build_module_graph`, except:
- Sources are stored in `module_sources: Vec<String>` instead of `module_sources: Vec<(ModuleId, String)>`.
- Parse results are stored in `module_parses: Vec<Parse>` instead of being created and discarded.
- The iteration in Phase 2 uses index-based access (`module_parses[id_val]`) instead of iterating over `(id, source)` pairs.

**Refactor build_module_graph as wrapper** (modify existing function):
Replace the entire body of `build_module_graph` with:
```rust
pub fn build_module_graph(project_root: &Path) -> Result<(ModuleGraph, Vec<ModuleId>), String> {
    let project = build_project(project_root)?;
    Ok((project.graph, project.compilation_order))
}
```

This preserves the exact same public API and return type. All 12 Phase 37 tests continue to call `build_module_graph` and pass without modification.

**Important:** Do NOT change any test code. The existing tests must pass unmodified -- this validates backward compatibility.
  </action>
  <verify>
Run `cargo test -p snowc -- discovery` to verify all existing Phase 37 tests pass. All 12 tests (6 unit + 6 integration) must pass without modification.
  </verify>
  <done>
`ProjectData` struct and `build_project` function exist in discovery.rs. `build_module_graph` is a thin wrapper around `build_project`. All 12 existing tests pass without any test code changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add build_project unit tests</name>
  <files>crates/snowc/src/discovery.rs</files>
  <action>
Add 2-3 new tests to the `#[cfg(test)] mod tests` block in discovery.rs that verify `build_project` directly (not through the `build_module_graph` wrapper).

**Test 1: test_build_project_simple** - Create a temp dir with `main.snow` and `utils.snow`. Call `build_project`. Assert:
- `project.graph.module_count() == 2`
- `project.module_sources.len() == 2`
- `project.module_parses.len() == 2`
- `project.compilation_order` names are `["Utils", "Main"]` (Utils first since Main imports it)
- `project.module_parses` are valid (no parse errors)
- `project.module_sources` contain the expected source text

**Test 2: test_build_project_single_file** - Create a temp dir with only `main.snow`. Call `build_project`. Assert:
- `project.graph.module_count() == 1`
- `project.module_sources.len() == 1`
- `project.module_parses.len() == 1`
- `project.compilation_order` has one entry with `is_entry == true`
- The single parse has no errors

**Test 3: test_build_project_parse_error_retained** - Create a temp dir with `main.snow` (valid) and `broken.snow` (with syntax error, e.g., `fn incomplete(`). Call `build_project`. Assert:
- `build_project` succeeds (it returns Ok -- it does NOT check parse errors, that is the build() function's job)
- `project.module_parses[broken_idx].errors()` is non-empty
- `project.module_parses[main_idx].errors()` is empty

These tests exercise the parse-retention contract that downstream code (Plan 02) relies on.
  </action>
  <verify>
Run `cargo test -p snowc -- build_project` to verify the new tests pass.
  </verify>
  <done>
3 new tests for `build_project` pass, validating that parse results, sources, and graph data are all correctly retained and indexed.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snowc` -- all tests pass (existing + new)
2. `cargo test -p snow-common` -- module_graph tests still pass
3. `cargo build -p snowc` -- compiles without warnings
</verification>

<success_criteria>
- `ProjectData` struct exists with `graph`, `compilation_order`, `module_sources`, `module_parses` fields
- `build_project` function discovers, parses, graphs, and toposorts, returning `ProjectData`
- `build_module_graph` is a thin wrapper calling `build_project` and returning `(graph, compilation_order)`
- All 12 Phase 37 tests pass unmodified
- 3 new `build_project` tests pass
- `cargo build -p snowc` compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/38-multi-file-build-pipeline/38-01-SUMMARY.md`
</output>
