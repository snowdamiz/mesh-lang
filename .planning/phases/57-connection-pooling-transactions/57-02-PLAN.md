---
phase: 57-connection-pooling-transactions
plan: 02
type: execute
wave: 2
depends_on: ["57-01"]
files_modified:
  - crates/snow-rt/src/db/pool.rs
  - crates/snow-rt/src/db/mod.rs
autonomous: true

must_haves:
  truths:
    - "snow_pool_open creates a pool with configurable min/max connections and checkout timeout"
    - "snow_pool_checkout returns an idle connection or creates a new one up to max_conns"
    - "snow_pool_checkout blocks with timeout when pool is exhausted"
    - "snow_pool_checkin returns a connection to idle state, sending ROLLBACK if txn_status != I"
    - "snow_pool_query performs automatic checkout-use-checkin for single queries"
    - "snow_pool_execute performs automatic checkout-use-checkin for write operations"
    - "snow_pool_close drains all connections and prevents new checkouts"
    - "Health check (SELECT 1) validates connections on checkout, replacing dead ones"
  artifacts:
    - path: "crates/snow-rt/src/db/pool.rs"
      provides: "PgPool struct with Mutex+Condvar, all snow_pool_* extern C functions"
      contains: "snow_pool_open"
    - path: "crates/snow-rt/src/db/mod.rs"
      provides: "pub mod pool"
      contains: "pub mod pool"
  key_links:
    - from: "snow_pool_checkout"
      to: "snow_pg_connect"
      via: "creates new PgConn when pool needs to grow"
      pattern: "snow_pg_connect"
    - from: "snow_pool_checkin"
      to: "PgConn.txn_status"
      via: "reads txn_status to decide if ROLLBACK needed"
      pattern: "txn_status.*b'I'"
    - from: "snow_pool_checkout"
      to: "health check"
      via: "sends SELECT 1 via pg_simple_command or similar before returning connection"
      pattern: "SELECT 1"
---

<objective>
Create a PostgreSQL connection pool with Mutex+Condvar synchronization, supporting checkout/checkin, automatic health checks, transaction state cleanup, and convenience query methods.

Purpose: Enables multiple Snow actors to share a bounded set of database connections efficiently, preventing connection exhaustion and providing transparent connection lifecycle management.

Output: New pool.rs file with complete pool implementation, updated mod.rs to export it.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-connection-pooling-transactions/57-RESEARCH.md
@.planning/phases/57-connection-pooling-transactions/57-01-SUMMARY.md
@crates/snow-rt/src/db/pg.rs
@crates/snow-rt/src/db/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pool.rs with full connection pool implementation</name>
  <files>crates/snow-rt/src/db/pool.rs, crates/snow-rt/src/db/mod.rs</files>
  <action>
**Step 1: Update mod.rs** to add `pub mod pool;`

**Step 2: Create pool.rs** with the following structure:

1. **Data structures:**
   ```rust
   use std::collections::VecDeque;
   use std::time::Instant;
   use parking_lot::{Mutex, Condvar};
   use crate::string::SnowString;
   use crate::io::alloc_result;
   // Import pg helpers -- make pg_simple_command and snow_pg_connect_internal accessible.
   // May need to refactor snow_pg_connect in pg.rs to expose an internal version
   // that returns Result<u64, String> instead of *mut u8. If that's too invasive,
   // just call snow_pg_connect and decode the SnowResult.
   ```

   ```rust
   struct PooledConn {
       handle: u64,          // PgConn handle (Box::into_raw as u64)
       last_used: Instant,
   }

   struct PoolInner {
       url: String,
       idle: VecDeque<PooledConn>,
       active_count: usize,
       total_created: usize,
       min_conns: usize,
       max_conns: usize,
       checkout_timeout_ms: u64,
       closed: bool,
   }

   struct PgPool {
       inner: Mutex<PoolInner>,
       available: Condvar,
   }
   ```

2. **snow_pool_open(url: *const SnowString, min_conns: i64, max_conns: i64, timeout_ms: i64) -> *mut u8:**
   - Parse min/max/timeout from i64, clamp to reasonable values (min >= 0, max >= 1, max >= min, timeout >= 100).
   - Extract the URL string from SnowString.
   - Create `PgPool` with `Mutex::new(PoolInner { ... })` and `Condvar::new()`.
   - Pre-create `min_conns` connections by calling `snow_pg_connect` internally. For each, decode the SnowResult. If any fail, close all created connections and return Err.
   - `Box::into_raw(Box::new(pool)) as u64` as the handle. Return via `alloc_result(0, handle as *mut u8)`.
   - To call snow_pg_connect internally: create a SnowString from the URL bytes using `snow_string_new`, then call `snow_pg_connect(url_snow)`. Read the result tag from the returned pointer: `let r = &*(result as *const crate::io::SnowResult); if r.tag == 0 { r.value as u64 } else { /* error */ }`.

3. **snow_pool_checkout(pool_handle: u64) -> *mut u8:**
   - Recover `&PgPool` from handle (do NOT Box::from_raw -- pool outlives checkout).
   - Lock `inner`. Loop:
     a. If `closed`, return Err("pool is closed").
     b. If `idle` is not empty, pop a PooledConn. **Health check:** send `SELECT 1` via the Extended Query protocol on the connection handle. Use the same approach as `snow_pg_query` but simplified -- just call `pg_simple_command(conn, "SELECT 1")` (which Plan 01 added). Access the PgConn via `&mut *(handle as *mut PgConn)`. If health check fails, close that connection (`snow_pg_close(handle)`), decrement `total_created`, and continue the loop (try next idle or create new).
     c. If no idle connections and `total_created < max_conns`, unlock, create a new connection (call `snow_pg_connect` as in open), lock, increment `total_created` and `active_count`, return the handle.
     d. If no idle and at capacity, wait on `available` condvar with timeout `checkout_timeout_ms`. Use `parking_lot::Condvar::wait_for(&mut guard, Duration::from_millis(timeout))`. If timeout expires (returns `WaitTimeoutResult` where `timed_out()` is true), return Err("pool checkout timeout").
   - On successful checkout: increment `active_count`, return `alloc_result(0, conn_handle as *mut u8)`.

4. **snow_pool_checkin(pool_handle: u64, conn_handle: u64):**
   - Recover `&PgPool`, lock `inner`.
   - If `closed`, just close the connection (`snow_pg_close(conn_handle)`) and decrement counters. Return.
   - **Transaction cleanup (POOL-05):** Read `PgConn.txn_status` via `(*(conn_handle as *const PgConn)).txn_status`. If not `b'I'` (idle), send ROLLBACK by calling `pg_simple_command(&mut *(conn_handle as *mut PgConn), "ROLLBACK")`. If ROLLBACK fails, the connection is broken -- close it and decrement `total_created` instead of returning to idle.
   - Push `PooledConn { handle: conn_handle, last_used: Instant::now() }` to `idle`.
   - Decrement `active_count`.
   - Notify one waiter: `self.available.notify_one()` (call on the PgPool, so need to unlock first or use the condvar directly).
   - NOTE: `parking_lot::Condvar::notify_one` works on the condvar itself, not the guard. So: after pushing to idle and adjusting counts, drop the guard (or let it go), then call `pool.available.notify_one()`.

5. **snow_pool_query(pool_handle: u64, sql: *const SnowString, params: *mut u8) -> *mut u8:**
   - Checkout a connection via the pool.
   - If checkout fails, return the Err result.
   - Call `snow_pg_query(conn_handle, sql, params)`.
   - Checkin the connection (always, even on error).
   - Return the query result.

6. **snow_pool_execute(pool_handle: u64, sql: *const SnowString, params: *mut u8) -> *mut u8:**
   - Same pattern as pool_query but calls `snow_pg_execute`.

7. **snow_pool_close(pool_handle: u64):**
   - Lock `inner`, set `closed = true`.
   - Drain all idle connections, calling `snow_pg_close` on each handle.
   - Notify all waiters: `pool.available.notify_all()` so blocked checkouts return with "pool is closed" error.
   - Do NOT Box::from_raw the pool -- active connections may still be checked out. The pool handle leaks (same pattern as server configs -- runs forever in practice).

**Important implementation notes:**
- Access to PgConn internals (txn_status field, pg_simple_command) requires either making those `pub(crate)` or using `pub(super)` since pool.rs is in the same `db` module. The `PgConn` struct, `pg_simple_command`, and `txn_status` field should be made `pub(super)` in pg.rs.
- Use `parking_lot::Mutex` (already a dependency of snow-rt) and `parking_lot::Condvar`.
- All extern "C" functions use `#[no_mangle]` and `unsafe` blocks as needed.
- Pool handle is opaque u64 (POOL-07), same pattern as PgConn/SqliteConn.
  </action>
  <verify>
    `cargo build -p snow-rt 2>&1 | tail -5` compiles without errors.
    Grep for `snow_pool_open` in pool.rs confirms the function exists.
    Grep for `snow_pool_checkout` confirms checkout with health check.
    Grep for `snow_pool_checkin` confirms transaction cleanup on checkin.
    Grep for `Condvar` in pool.rs confirms blocking with timeout.
    Grep for `SELECT 1` in pool.rs confirms health check.
    Grep for `pub mod pool` in mod.rs confirms module export.
  </verify>
  <done>
    pool.rs exists with PgPool (Mutex+Condvar), all 7 extern "C" functions (open, checkout, checkin, query, execute, close). Pool handles are opaque u64. Checkout blocks with timeout, performs health check. Checkin sends ROLLBACK if connection is in-transaction. Close drains idle connections. `cargo build -p snow-rt` succeeds.
  </done>
</task>

</tasks>

<verification>
- `cargo build -p snow-rt` compiles clean
- pool.rs contains all 7 snow_pool_* functions with #[no_mangle]
- PgPool uses parking_lot::Mutex + Condvar
- Health check validates connections on checkout
- Transaction cleanup on checkin (ROLLBACK if txn_status != 'I')
- Pool close drains connections and blocks new checkouts
</verification>

<success_criteria>
- Connection pool created with configurable min/max/timeout (POOL-01)
- Manual checkout/checkin works (POOL-02)
- Convenience query/execute with auto checkout-use-checkin (POOL-03)
- Health check on checkout replaces dead connections (POOL-04)
- Checkin resets connection state via ROLLBACK if needed (POOL-05)
- Pool close drains and prevents new checkouts (POOL-06)
- Pool handle is opaque u64 (POOL-07)
</success_criteria>

<output>
After completion, create `.planning/phases/57-connection-pooling-transactions/57-02-SUMMARY.md`
</output>
