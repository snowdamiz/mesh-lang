---
phase: 57-connection-pooling-transactions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/db/pg.rs
  - crates/snow-rt/src/db/sqlite.rs
autonomous: true

must_haves:
  truths:
    - "PgConn tracks transaction status byte (I/T/E) from every ReadyForQuery message"
    - "snow_pg_begin sends BEGIN and returns Ok/Err result"
    - "snow_pg_commit sends COMMIT and returns Ok/Err result"
    - "snow_pg_rollback sends ROLLBACK and returns Ok/Err result"
    - "snow_pg_transaction calls BEGIN, invokes closure, COMMITs on Ok, ROLLBACKs on Err or panic"
    - "snow_sqlite_begin/commit/rollback send the corresponding SQL to SQLite"
  artifacts:
    - path: "crates/snow-rt/src/db/pg.rs"
      provides: "PgConn.txn_status field, snow_pg_begin, snow_pg_commit, snow_pg_rollback, snow_pg_transaction"
      contains: "txn_status"
    - path: "crates/snow-rt/src/db/sqlite.rs"
      provides: "snow_sqlite_begin, snow_sqlite_commit, snow_sqlite_rollback"
      contains: "snow_sqlite_begin"
  key_links:
    - from: "crates/snow-rt/src/db/pg.rs"
      to: "ReadyForQuery handler"
      via: "txn_status = body[0] on every b'Z' match"
      pattern: "txn_status.*body\\[0\\]"
    - from: "snow_pg_transaction"
      to: "catch_unwind"
      via: "AssertUnwindSafe closure wrapping fn_ptr call"
      pattern: "catch_unwind.*AssertUnwindSafe"
---

<objective>
Add transaction management intrinsics for PostgreSQL and SQLite, plus PgConn transaction status tracking.

Purpose: Enables Snow programs to use BEGIN/COMMIT/ROLLBACK for manual transaction control, and Pg.transaction(conn, fn) for automatic commit/rollback with panic safety. Transaction status tracking in PgConn is also required by the connection pool (Plan 02) for clean connection checkin.

Output: Updated pg.rs with txn_status field + 4 new extern "C" functions, updated sqlite.rs with 3 new extern "C" functions.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-connection-pooling-transactions/57-RESEARCH.md
@crates/snow-rt/src/db/pg.rs
@crates/snow-rt/src/db/sqlite.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add txn_status to PgConn and PG transaction intrinsics</name>
  <files>crates/snow-rt/src/db/pg.rs</files>
  <action>
1. Add `txn_status: u8` field to the `PgConn` struct, initialized to `b'I'` (idle) in `snow_pg_connect`.

2. Update ALL THREE `b'Z'` (ReadyForQuery) match arms to extract the transaction status byte:
   - Line ~838 (post-auth loop in snow_pg_connect): `b'Z' => { conn_txn_status = if body.len() > 0 { body[0] } else { b'I' }; break; }` -- store in a local, then set on PgConn after creation.
     Actually, since `stream` is not yet wrapped in PgConn at this point, track it in a local `let mut last_txn_status: u8 = b'I';` before the loop, update it on Z, and set `PgConn { stream, txn_status: last_txn_status }`.
   - Line ~929 (snow_pg_execute): `b'Z' => { conn.txn_status = if body.len() > 0 { body[0] } else { b'I' }; break; }`
   - Line ~1060 (snow_pg_query): Same pattern as execute.

3. Add helper function to send a simple SQL command and wait for ReadyForQuery:
   ```rust
   /// Send a simple SQL command (BEGIN/COMMIT/ROLLBACK) using the Simple Query protocol.
   /// Returns Ok(()) or Err(error_message). Updates conn.txn_status from ReadyForQuery.
   fn pg_simple_command(conn: &mut PgConn, sql: &str) -> Result<(), String> {
       // Simple Query protocol: Byte1('Q') Int32(len) String(query)
       let mut buf = Vec::new();
       buf.push(b'Q');
       let body = format!("{}\0", sql);
       let len = (body.len() + 4) as i32;
       buf.extend_from_slice(&len.to_be_bytes());
       buf.extend_from_slice(body.as_bytes());
       conn.stream.write_all(&buf).map_err(|e| format!("send {}: {}", sql, e))?;

       let mut error_msg: Option<String> = None;
       loop {
           let (tag, body) = read_message(&mut conn.stream).map_err(|e| format!("read {}: {}", sql, e))?;
           match tag {
               b'C' => {} // CommandComplete
               b'E' => { error_msg = Some(parse_error_response(&body)); }
               b'Z' => {
                   conn.txn_status = if body.len() > 0 { body[0] } else { b'I' };
                   break;
               }
               _ => {}
           }
       }
       match error_msg {
           Some(msg) => Err(msg),
           None => Ok(()),
       }
   }
   ```

4. Add `snow_pg_begin`:
   ```rust
   #[no_mangle]
   pub extern "C" fn snow_pg_begin(conn_handle: u64) -> *mut u8 {
       unsafe {
           let conn = &mut *(conn_handle as *mut PgConn);
           match pg_simple_command(conn, "BEGIN") {
               Ok(()) => alloc_result(0, std::ptr::null_mut()) as *mut u8,
               Err(e) => err_result(&e),
           }
       }
   }
   ```

5. Add `snow_pg_commit` and `snow_pg_rollback` -- identical pattern to begin, just different SQL command strings ("COMMIT" and "ROLLBACK").

6. Add `snow_pg_transaction(conn_handle: u64, fn_ptr: *const u8, env_ptr: *const u8) -> *mut u8`:
   - Send BEGIN via `pg_simple_command`. On failure, return Err result immediately.
   - Call the Snow closure: `let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| { ... }))`.
     Inside the closure: cast fn_ptr to `extern "C" fn(*const u8, u64) -> *mut u8` and call `fn_ptr(env_ptr, conn_handle)`.
     The closure returns a `*mut u8` which is a SnowResult (tag 0 = Ok, tag 1 = Err).
   - On `Ok(result_ptr)`:
     - Read the result tag: `let tag = *(result_ptr as *const u64);`
     - If tag == 0 (Ok): send COMMIT via `pg_simple_command`. If COMMIT fails, ROLLBACK and return Err. Otherwise return the Ok result.
     - If tag == 1 (Err): send ROLLBACK via `pg_simple_command`. Return the Err result.
   - On `Err(_)` (panic caught): send ROLLBACK via `pg_simple_command`. Return `err_result("transaction aborted: panic in callback")`.
   - Use `crate::io::SnowResult` for tag reading (check the existing struct layout).
  </action>
  <verify>
    `cargo build -p snow-rt 2>&1 | tail -5` compiles without errors.
    Grep for `txn_status` in pg.rs shows the field in PgConn and updates at all 3 ReadyForQuery sites plus the simple_command helper.
    Grep for `snow_pg_begin` confirms the function exists with `#[no_mangle]`.
    Grep for `snow_pg_transaction` confirms the function exists.
    Grep for `catch_unwind` in pg.rs confirms panic-safe rollback.
  </verify>
  <done>
    PgConn has txn_status field updated on every ReadyForQuery. Four new extern "C" functions exist: snow_pg_begin, snow_pg_commit, snow_pg_rollback, snow_pg_transaction. Transaction function uses catch_unwind for panic rollback. `cargo build -p snow-rt` succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SQLite transaction intrinsics</name>
  <files>crates/snow-rt/src/db/sqlite.rs</files>
  <action>
Add three new extern "C" functions for SQLite transaction control. These use the existing sqlite3_exec FFI (or prepare+step) to send BEGIN/COMMIT/ROLLBACK SQL commands.

1. Add a helper that executes a bare SQL statement on a SqliteConn:
   ```rust
   /// Execute a bare SQL command (BEGIN/COMMIT/ROLLBACK) on a SQLite connection.
   fn sqlite_simple_exec(conn: &SqliteConn, sql: &str) -> *mut u8 {
       let sql_cstr = match CString::new(sql) {
           Ok(c) => c,
           Err(_) => return err_result("SQL contains null byte"),
       };
       unsafe {
           let rc = sqlite3_exec(conn.db, sql_cstr.as_ptr(), None, std::ptr::null_mut(), std::ptr::null_mut());
           if rc != SQLITE_OK {
               sqlite_err_result(conn.db)
           } else {
               alloc_result(0, std::ptr::null_mut()) as *mut u8
           }
       }
   }
   ```
   NOTE: `sqlite3_exec` is available from `libsqlite3_sys`. Verify it is imported. If not available or causes issues, use the existing prepare+step pattern with `BEGIN`/`COMMIT`/`ROLLBACK` SQL strings and `SQLITE_DONE` check.

2. Add `snow_sqlite_begin`:
   ```rust
   #[no_mangle]
   pub extern "C" fn snow_sqlite_begin(conn_handle: u64) -> *mut u8 {
       let conn = unsafe { &*(conn_handle as *const SqliteConn) };
       sqlite_simple_exec(conn, "BEGIN")
   }
   ```

3. Add `snow_sqlite_commit` -- same pattern, SQL = "COMMIT".

4. Add `snow_sqlite_rollback` -- same pattern, SQL = "ROLLBACK".

All three return `*mut u8` (SnowResult: tag 0 = Ok with null value for Unit, tag 1 = Err with error string).
  </action>
  <verify>
    `cargo build -p snow-rt 2>&1 | tail -5` compiles without errors.
    Grep for `snow_sqlite_begin` in sqlite.rs confirms the function exists with `#[no_mangle]`.
    All 3 functions (begin, commit, rollback) present.
  </verify>
  <done>
    Three new extern "C" functions exist: snow_sqlite_begin, snow_sqlite_commit, snow_sqlite_rollback. Each sends the corresponding SQL command via sqlite3_exec and returns a SnowResult. `cargo build -p snow-rt` succeeds.
  </done>
</task>

</tasks>

<verification>
- `cargo build -p snow-rt` compiles clean
- PgConn struct contains `txn_status: u8` field
- All 3 ReadyForQuery paths in pg.rs update txn_status
- 7 new `#[no_mangle] pub extern "C"` functions across pg.rs and sqlite.rs
- snow_pg_transaction uses catch_unwind + AssertUnwindSafe
</verification>

<success_criteria>
- PgConn tracks transaction status on every ReadyForQuery (I/T/E)
- Manual PG transaction control: BEGIN, COMMIT, ROLLBACK as intrinsics
- Block-based PG transaction: auto-commit on success, auto-rollback on error/panic
- Manual SQLite transaction control: BEGIN, COMMIT, ROLLBACK as intrinsics
- snow-rt builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/57-connection-pooling-transactions/57-01-SUMMARY.md`
</output>
