---
phase: 57-connection-pooling-transactions
plan: 03
type: execute
wave: 3
depends_on: ["57-01", "57-02"]
files_modified:
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/types.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/infer.rs
autonomous: true

must_haves:
  truths:
    - "Snow code can call Pool.open(url, min, max, timeout) and it type-checks and compiles"
    - "Snow code can call Pool.checkout(pool), Pool.checkin(pool, conn), Pool.close(pool)"
    - "Snow code can call Pool.query(pool, sql, params) and Pool.execute(pool, sql, params)"
    - "Snow code can call Pg.begin(conn), Pg.commit(conn), Pg.rollback(conn)"
    - "Snow code can call Pg.transaction(conn, fn(conn) do ... end) with closure argument"
    - "Snow code can call Sqlite.begin(conn), Sqlite.commit(conn), Sqlite.rollback(conn)"
    - "PoolHandle type resolves to MirType::Int (opaque u64)"
    - "cargo test passes for all crates"
  artifacts:
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for all new snow_pool_*, snow_pg_begin/commit/rollback/transaction, snow_sqlite_begin/commit/rollback"
      contains: "snow_pool_open"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "known_functions entries and map_builtin_name mappings for all new functions"
      contains: "snow_pool_open"
    - path: "crates/snow-codegen/src/mir/types.rs"
      provides: "PoolHandle => MirType::Int mapping"
      contains: "PoolHandle"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "PoolHandle type + all function signatures in builtins env"
      contains: "PoolHandle"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Pool module in stdlib_modules + STDLIB_MODULE_NAMES"
      contains: "Pool"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "STDLIB_MODULE_NAMES"
      via: "Pool added to module list"
      pattern: "\"Pool\""
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "map_builtin_name"
      via: "pool_open => snow_pool_open etc."
      pattern: "pool_open.*snow_pool_open"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "known_functions"
      via: "snow_pool_open inserted with correct MirType signature"
      pattern: "snow_pool_open.*MirType"
---

<objective>
Wire all new runtime intrinsics (pool + transactions) through the compiler pipeline: LLVM declarations, MIR lowering, type mapping, and type checker.

Purpose: Makes all Pool.*, Pg.begin/commit/rollback/transaction, and Sqlite.begin/commit/rollback callable from Snow source code. This is the final plan that connects the runtime implementations (Plans 01-02) to the Snow language surface.

Output: Updated compiler pipeline files. Full `cargo test` passes.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-connection-pooling-transactions/57-RESEARCH.md
@.planning/phases/57-connection-pooling-transactions/57-01-SUMMARY.md
@.planning/phases/57-connection-pooling-transactions/57-02-SUMMARY.md
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/types.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LLVM intrinsic declarations and MIR type mapping</name>
  <files>crates/snow-codegen/src/codegen/intrinsics.rs, crates/snow-codegen/src/mir/types.rs</files>
  <action>
**intrinsics.rs -- Add after the Phase 54 PostgreSQL section (~line 517):**

Add LLVM function declarations for all new intrinsics. Follow the exact pattern of existing declarations.

```rust
// ── Phase 57: PostgreSQL Transactions ──────────────────────────────

// snow_pg_begin(conn: i64) -> ptr (SnowResult)
module.add_function("snow_pg_begin",
    ptr_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_pg_commit(conn: i64) -> ptr (SnowResult)
module.add_function("snow_pg_commit",
    ptr_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_pg_rollback(conn: i64) -> ptr (SnowResult)
module.add_function("snow_pg_rollback",
    ptr_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_pg_transaction(conn: i64, fn_ptr: ptr, env_ptr: ptr) -> ptr (SnowResult)
module.add_function("snow_pg_transaction",
    ptr_type.fn_type(&[i64_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));

// ── Phase 57: SQLite Transactions ──────────────────────────────────

// snow_sqlite_begin(conn: i64) -> ptr (SnowResult)
module.add_function("snow_sqlite_begin",
    ptr_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_sqlite_commit(conn: i64) -> ptr (SnowResult)
module.add_function("snow_sqlite_commit",
    ptr_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_sqlite_rollback(conn: i64) -> ptr (SnowResult)
module.add_function("snow_sqlite_rollback",
    ptr_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// ── Phase 57: Connection Pool ──────────────────────────────────────

// snow_pool_open(url: ptr, min: i64, max: i64, timeout: i64) -> ptr (SnowResult)
module.add_function("snow_pool_open",
    ptr_type.fn_type(&[ptr_type.into(), i64_type.into(), i64_type.into(), i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_pool_close(pool: i64) -> void
module.add_function("snow_pool_close",
    void_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_pool_checkout(pool: i64) -> ptr (SnowResult)
module.add_function("snow_pool_checkout",
    ptr_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_pool_checkin(pool: i64, conn: i64) -> void
module.add_function("snow_pool_checkin",
    void_type.fn_type(&[i64_type.into(), i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_pool_query(pool: i64, sql: ptr, params: ptr) -> ptr (SnowResult)
module.add_function("snow_pool_query",
    ptr_type.fn_type(&[i64_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_pool_execute(pool: i64, sql: ptr, params: ptr) -> ptr (SnowResult)
module.add_function("snow_pool_execute",
    ptr_type.fn_type(&[i64_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));
```

**Also add test assertions** in the existing `test_declare_all_intrinsics` test for all new functions (follow the pattern at line ~794).

**types.rs -- Add PoolHandle mapping:**

In the `resolve_type` match on type constructor names (around line 72-82), add:
```rust
// PoolHandle is an opaque u64 handle, lowered to Int for GC safety (same as PgConn/SqliteConn).
"PoolHandle" => MirType::Int,
```

Add it right after the `"PgConn" => MirType::Int` line.
  </action>
  <verify>
    `cargo test -p snow-codegen -- test_declare_all_intrinsics 2>&1 | tail -5` passes.
    Grep for `snow_pool_open` in intrinsics.rs confirms declaration exists.
    Grep for `PoolHandle` in types.rs confirms type mapping.
  </verify>
  <done>
    All 13 new runtime functions declared in LLVM module. PoolHandle maps to MirType::Int. Intrinsics test passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add MIR lowering and type checker entries</name>
  <files>crates/snow-codegen/src/mir/lower.rs, crates/snow-typeck/src/builtins.rs, crates/snow-typeck/src/infer.rs</files>
  <action>
**lower.rs -- known_functions (after PG entries at ~line 687):**

Add known_functions entries for all new intrinsics. Follow the exact pattern of existing PG/SQLite entries.

```rust
// ── Phase 57: PG Transaction functions ──────────────────────────
// snow_pg_begin(conn: i64) -> ptr (Result)
self.known_functions.insert("snow_pg_begin".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_pg_commit".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_pg_rollback".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr)));
// snow_pg_transaction(conn: i64, fn_ptr: ptr, env_ptr: ptr) -> ptr
self.known_functions.insert("snow_pg_transaction".to_string(), MirType::FnPtr(vec![MirType::Int, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));

// ── Phase 57: SQLite Transaction functions ──────────────────────
self.known_functions.insert("snow_sqlite_begin".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_sqlite_commit".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_sqlite_rollback".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr)));

// ── Phase 57: Connection Pool functions ─────────────────────────
// snow_pool_open(url: ptr, min: i64, max: i64, timeout: i64) -> ptr
self.known_functions.insert("snow_pool_open".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Int, MirType::Int, MirType::Int], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_pool_close".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Unit)));
self.known_functions.insert("snow_pool_checkout".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_pool_checkin".to_string(), MirType::FnPtr(vec![MirType::Int, MirType::Int], Box::new(MirType::Unit)));
self.known_functions.insert("snow_pool_query".to_string(), MirType::FnPtr(vec![MirType::Int, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_pool_execute".to_string(), MirType::FnPtr(vec![MirType::Int, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
```

**lower.rs -- map_builtin_name (after PG entries at ~line 9023):**

```rust
// ── Phase 57: PG Transaction functions ──────────────────────────
"pg_begin" => "snow_pg_begin".to_string(),
"pg_commit" => "snow_pg_commit".to_string(),
"pg_rollback" => "snow_pg_rollback".to_string(),
"pg_transaction" => "snow_pg_transaction".to_string(),
// ── Phase 57: SQLite Transaction functions ──────────────────────
"sqlite_begin" => "snow_sqlite_begin".to_string(),
"sqlite_commit" => "snow_sqlite_commit".to_string(),
"sqlite_rollback" => "snow_sqlite_rollback".to_string(),
// ── Phase 57: Connection Pool functions ─────────────────────────
"pool_open" => "snow_pool_open".to_string(),
"pool_close" => "snow_pool_close".to_string(),
"pool_checkout" => "snow_pool_checkout".to_string(),
"pool_checkin" => "snow_pool_checkin".to_string(),
"pool_query" => "snow_pool_query".to_string(),
"pool_execute" => "snow_pool_execute".to_string(),
```

**builtins.rs -- Add type definitions (after Phase 54 PG section, ~line 683):**

```rust
// ── Phase 57: PG Transaction functions ──────────────────────────
// Pg.begin(PgConn) -> Result<Unit, String>
env.insert(
    "pg_begin".into(),
    Scheme::mono(Ty::fun(vec![pg_conn_t.clone()], Ty::result(Ty::Tuple(vec![]), Ty::string()))),
);
// Pg.commit(PgConn) -> Result<Unit, String>
env.insert(
    "pg_commit".into(),
    Scheme::mono(Ty::fun(vec![pg_conn_t.clone()], Ty::result(Ty::Tuple(vec![]), Ty::string()))),
);
// Pg.rollback(PgConn) -> Result<Unit, String>
env.insert(
    "pg_rollback".into(),
    Scheme::mono(Ty::fun(vec![pg_conn_t.clone()], Ty::result(Ty::Tuple(vec![]), Ty::string()))),
);
// Pg.transaction(PgConn, fn(PgConn) -> Result<T, String>) -> Result<T, String>
// For simplicity, use a concrete type: fn(PgConn) -> Result<Unit, String> -> Result<Unit, String>
// Actually, the closure returns a generic result. But Snow's HM inference should handle this.
// Use a type variable:
// For now, use a pragmatic approach -- the closure takes PgConn and returns Result<T, String>.
// Since we can't easily express generic T in the builtins env, use Ptr (opaque) for the inner value.
// Actually, looking at the existing pattern, builtins use concrete types.
// The simplest correct approach: Pg.transaction takes (PgConn, Fun(PgConn) -> Result<a, String>) -> Result<a, String>
// Using Scheme::poly with a type variable:
// However, inspecting the existing builtins, they are all mono. Let's check if we can use a fresh type variable...
// The pragmatic approach matching how Snow closures work at the LLVM level:
// The closure fn_ptr/env_ptr pattern is handled in MIR lowering, not type checking.
// At the type level, Pg.transaction(conn, fn) where fn: Fun(PgConn) -> Result<T, String>
// Since builtins are mono, we need a type variable. Use Scheme with forall:
```

For `Pg.transaction`, define it with a type variable:
```rust
{
    let a = Ty::Var(TyVar::fresh()); // or use the existing TyVar mechanism
    env.insert(
        "pg_transaction".into(),
        Scheme {
            forall: vec![/* the type variable */],
            ty: Ty::fun(
                vec![pg_conn_t.clone(), Ty::fun(vec![pg_conn_t.clone()], Ty::result(a.clone(), Ty::string()))],
                Ty::result(a, Ty::string()),
            ),
        },
    );
}
```

Check how existing polymorphic builtins work in the codebase. If there are no polymorphic builtins (all are mono), simplify to:
- `Pg.transaction(PgConn, Fun(PgConn) -> Result<Unit, String>) -> Result<Unit, String>`
This works because at the runtime level, the closure returns a `*mut u8` (SnowResult) and the transaction function forwards that pointer. The type checker just needs the function signature to type-check.

Actually, after careful consideration: the transaction result's inner type IS generic. If we make it mono with Unit, users can only return Unit from the transaction block. That's too restrictive. Look at how the typeck handles this -- check if `Scheme::poly` exists or if we need fresh `TyVar`s.

If no existing polymorphic builtins pattern exists, use the simple mono approach for now with `Ptr` as the generic stand-in. The MIR layer treats results as Ptr anyway. But ideally, look at how `List.map` or `List.filter` handle generic callback types in builtins. If those use mono Ptr types too, follow that pattern.

```rust
// ── Phase 57: SQLite Transaction functions ──────────────────────
// Sqlite.begin(SqliteConn) -> Result<Unit, String>
env.insert(
    "sqlite_begin".into(),
    Scheme::mono(Ty::fun(vec![sqlite_conn_t.clone()], Ty::result(Ty::Tuple(vec![]), Ty::string()))),
);
// Sqlite.commit(SqliteConn) -> Result<Unit, String>
env.insert(
    "sqlite_commit".into(),
    Scheme::mono(Ty::fun(vec![sqlite_conn_t.clone()], Ty::result(Ty::Tuple(vec![]), Ty::string()))),
);
// Sqlite.rollback(SqliteConn) -> Result<Unit, String>
env.insert(
    "sqlite_rollback".into(),
    Scheme::mono(Ty::fun(vec![sqlite_conn_t.clone()], Ty::result(Ty::Tuple(vec![]), Ty::string()))),
);

// ── Phase 57: Connection Pool ───────────────────────────────────
// PoolHandle opaque type
let pool_handle_t = Ty::Con(TyCon::new("PoolHandle"));
env.insert("PoolHandle".into(), Scheme::mono(pool_handle_t.clone()));

// Pool.open(String, Int, Int, Int) -> Result<PoolHandle, String>
env.insert(
    "pool_open".into(),
    Scheme::mono(Ty::fun(
        vec![Ty::string(), Ty::int(), Ty::int(), Ty::int()],
        Ty::result(pool_handle_t.clone(), Ty::string()),
    )),
);
// Pool.close(PoolHandle) -> Unit
env.insert(
    "pool_close".into(),
    Scheme::mono(Ty::fun(vec![pool_handle_t.clone()], Ty::Tuple(vec![]))),
);
// Pool.checkout(PoolHandle) -> Result<PgConn, String>
env.insert(
    "pool_checkout".into(),
    Scheme::mono(Ty::fun(vec![pool_handle_t.clone()], Ty::result(pg_conn_t.clone(), Ty::string()))),
);
// Pool.checkin(PoolHandle, PgConn) -> Unit
env.insert(
    "pool_checkin".into(),
    Scheme::mono(Ty::fun(vec![pool_handle_t.clone(), pg_conn_t.clone()], Ty::Tuple(vec![]))),
);
// Pool.query(PoolHandle, String, List<String>) -> Result<List<Map<String, String>>, String>
env.insert(
    "pool_query".into(),
    Scheme::mono(Ty::fun(
        vec![pool_handle_t.clone(), Ty::string(), Ty::list(Ty::string())],
        Ty::result(Ty::list(Ty::map(Ty::string(), Ty::string())), Ty::string()),
    )),
);
// Pool.execute(PoolHandle, String, List<String>) -> Result<Int, String>
env.insert(
    "pool_execute".into(),
    Scheme::mono(Ty::fun(
        vec![pool_handle_t.clone(), Ty::string(), Ty::list(Ty::string())],
        Ty::result(Ty::int(), Ty::string()),
    )),
);
```

NOTE: The `pg_conn_t` variable must be in scope where Pool builtins are defined. Since both PG and Pool sections are in the same function, this should work. The `pg_conn_t` is defined at the Phase 54 section.

**infer.rs -- Add Pool module to stdlib_modules (~line 637):**

In the `stdlib_modules()` function, after the `Pg` module definition, add:

```rust
// ── Pool module (Phase 57) ──────────────────────────────────────
let pool_handle_t = Ty::Con(TyCon::new("PoolHandle"));
let pg_conn_t = Ty::Con(TyCon::new("PgConn"));

let mut pool_mod = HashMap::new();
// Pool.open: fn(String, Int, Int, Int) -> Result<PoolHandle, String>
pool_mod.insert("open".to_string(), Scheme::mono(Ty::fun(
    vec![Ty::string(), Ty::int(), Ty::int(), Ty::int()],
    Ty::result(pool_handle_t.clone(), Ty::string()),
)));
// Pool.close: fn(PoolHandle) -> Unit
pool_mod.insert("close".to_string(), Scheme::mono(Ty::fun(
    vec![pool_handle_t.clone()],
    Ty::Tuple(vec![]),
)));
// Pool.checkout: fn(PoolHandle) -> Result<PgConn, String>
pool_mod.insert("checkout".to_string(), Scheme::mono(Ty::fun(
    vec![pool_handle_t.clone()],
    Ty::result(pg_conn_t.clone(), Ty::string()),
)));
// Pool.checkin: fn(PoolHandle, PgConn) -> Unit
pool_mod.insert("checkin".to_string(), Scheme::mono(Ty::fun(
    vec![pool_handle_t.clone(), pg_conn_t.clone()],
    Ty::Tuple(vec![]),
)));
// Pool.query: fn(PoolHandle, String, List<String>) -> Result<List<Map<String, String>>, String>
pool_mod.insert("query".to_string(), Scheme::mono(Ty::fun(
    vec![pool_handle_t.clone(), Ty::string(), Ty::list(Ty::string())],
    Ty::result(Ty::list(Ty::map(Ty::string(), Ty::string())), Ty::string()),
)));
// Pool.execute: fn(PoolHandle, String, List<String>) -> Result<Int, String>
pool_mod.insert("execute".to_string(), Scheme::mono(Ty::fun(
    vec![pool_handle_t.clone(), Ty::string(), Ty::list(Ty::string())],
    Ty::result(Ty::int(), Ty::string()),
)));
modules.insert("Pool".to_string(), pool_mod);
```

Also add Pg.begin/commit/rollback/transaction to the existing `pg_mod` (in the Pg module section around line 642):

```rust
// Pg.begin: fn(PgConn) -> Result<Unit, String>
pg_mod.insert("begin".to_string(), Scheme::mono(Ty::fun(
    vec![pg_conn_t.clone()],
    Ty::result(Ty::Tuple(vec![]), Ty::string()),
)));
// Pg.commit: fn(PgConn) -> Result<Unit, String>
pg_mod.insert("commit".to_string(), Scheme::mono(Ty::fun(
    vec![pg_conn_t.clone()],
    Ty::result(Ty::Tuple(vec![]), Ty::string()),
)));
// Pg.rollback: fn(PgConn) -> Result<Unit, String>
pg_mod.insert("rollback".to_string(), Scheme::mono(Ty::fun(
    vec![pg_conn_t.clone()],
    Ty::result(Ty::Tuple(vec![]), Ty::string()),
)));
// Pg.transaction: fn(PgConn, Fun(PgConn) -> Result<Unit, String>) -> Result<Unit, String>
// Using mono Result<Unit, String> for the callback -- sufficient for most transaction use cases.
// The runtime handles the ptr-level forwarding regardless of inner type.
pg_mod.insert("transaction".to_string(), Scheme::mono(Ty::fun(
    vec![pg_conn_t.clone(), Ty::fun(vec![pg_conn_t.clone()], Ty::result(Ty::Tuple(vec![]), Ty::string()))],
    Ty::result(Ty::Tuple(vec![]), Ty::string()),
)));
```

And add Sqlite.begin/commit/rollback to the existing `sqlite_mod`:

```rust
// Sqlite.begin: fn(SqliteConn) -> Result<Unit, String>
sqlite_mod.insert("begin".to_string(), Scheme::mono(Ty::fun(
    vec![sqlite_conn_t.clone()],
    Ty::result(Ty::Tuple(vec![]), Ty::string()),
)));
// Sqlite.commit: fn(SqliteConn) -> Result<Unit, String>
sqlite_mod.insert("commit".to_string(), Scheme::mono(Ty::fun(
    vec![sqlite_conn_t.clone()],
    Ty::result(Ty::Tuple(vec![]), Ty::string()),
)));
// Sqlite.rollback: fn(SqliteConn) -> Result<Unit, String>
sqlite_mod.insert("rollback".to_string(), Scheme::mono(Ty::fun(
    vec![sqlite_conn_t.clone()],
    Ty::result(Ty::Tuple(vec![]), Ty::string()),
)));
```

**infer.rs -- Add "Pool" to STDLIB_MODULE_NAMES (line ~670):**

Add `"Pool"` to the array:
```rust
const STDLIB_MODULE_NAMES: &[&str] = &[
    "String", "IO", "Env", "File", "List", "Map", "Set", "Tuple", "Range", "Queue", "HTTP", "JSON", "Json", "Request", "Job",
    "Math", "Int", "Float", "Timer", "Sqlite", "Pg", "Pool",
];
```

**Handle Pg.transaction closure lowering in lower.rs:**

The MIR lowerer needs to handle `Pg.transaction(conn, fn)` where the second argument is a closure. The closure will be lowered to (fn_ptr, env_ptr) pair by existing closure infrastructure. At the call site, the MIR will generate a call to `snow_pg_transaction(conn_handle, fn_ptr, env_ptr)` with 3 arguments. The existing closure-to-function-pointer lowering should handle this automatically since the callback argument type is `Fun(PgConn) -> Result<Unit, String>`.

Verify this works by checking how `List.sort` and `List.map` handle callback arguments -- they pass `fn_ptr` and `env_ptr` as separate arguments. If `snow_pg_transaction` follows the same convention (3 args: conn, fn_ptr, env_ptr), it should Just Work with the existing closure lowering.

If there's a mismatch (typeck sees 2 args but runtime expects 3), add special handling in the call lowering to split the closure argument into fn_ptr + env_ptr, similar to how it's done for list operations.
  </action>
  <verify>
    `cargo build 2>&1 | tail -10` -- full workspace build succeeds.
    `cargo test 2>&1 | tail -20` -- all tests pass (or only pre-existing ignores/flakes).
    Grep for `"Pool"` in STDLIB_MODULE_NAMES confirms it's listed.
    Grep for `snow_pool_open` in lower.rs confirms known_functions + map_builtin_name entries.
    Grep for `PoolHandle` in types.rs confirms MirType::Int mapping.
    Grep for `pool_open` in builtins.rs confirms type signature.
  </verify>
  <done>
    All 13 new intrinsics wired through the full compiler pipeline: LLVM declarations in intrinsics.rs, known_functions + map_builtin_name in lower.rs, PoolHandle type mapping in types.rs, all function signatures in builtins.rs, Pool module + Pg/Sqlite transaction methods in infer.rs stdlib_modules, "Pool" in STDLIB_MODULE_NAMES. Full `cargo build` and `cargo test` pass.
  </done>
</task>

</tasks>

<verification>
- `cargo build` -- full workspace compiles
- `cargo test` -- all existing tests pass
- Snow programs can call Pool.open, Pool.query, Pool.close etc.
- Snow programs can call Pg.begin, Pg.commit, Pg.rollback, Pg.transaction
- Snow programs can call Sqlite.begin, Sqlite.commit, Sqlite.rollback
- PoolHandle resolves to i64 at LLVM level
</verification>

<success_criteria>
- All 13 new runtime functions are callable from Snow source code
- Pool module recognized by type checker and MIR lowerer
- Pg module extended with begin/commit/rollback/transaction
- Sqlite module extended with begin/commit/rollback
- PoolHandle is opaque u64 through the full pipeline
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/57-connection-pooling-transactions/57-03-SUMMARY.md`
</output>
