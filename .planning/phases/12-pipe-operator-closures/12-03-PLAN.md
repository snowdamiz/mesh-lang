---
phase: 12-pipe-operator-closures
plan: 03
type: execute
wave: 3
depends_on: [12-02]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/tests/integration.rs
  - tests/e2e/closure_bare_params_pipe.snow
  - tests/e2e/pipe_chain_closures.snow
  - crates/snowc/tests/e2e.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "`list |> map(fn x -> x * 2 end)` parses, type checks, and executes correctly"
    - "Multiple chained pipes with closures work: `list |> map(fn x -> x + 1 end) |> filter(fn x -> x > 3 end)`"
    - "Existing pipe tests still pass (regression-free)"
    - "Existing direct-call closure tests still pass (regression-free)"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Pipe-aware call inference in infer_pipe"
      contains: "CallExpr"
    - path: "tests/e2e/closure_bare_params_pipe.snow"
      provides: "E2E test using actual pipe syntax with closures"
      contains: "|>"
    - path: "tests/e2e/pipe_chain_closures.snow"
      provides: "E2E test for chained pipes with closures"
      contains: "|>"
    - path: "crates/snow-typeck/tests/integration.rs"
      provides: "Type checker unit test for pipe+call arity"
      contains: "pipe"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs (infer_pipe)"
      to: "crates/snow-typeck/src/infer.rs (infer_call)"
      via: "When pipe RHS is CallExpr, infer_pipe does pipe-aware call inference instead of delegating to infer_call"
      pattern: "Expr::CallExpr"
---

<objective>
Fix the type checker so `list |> map(fn x -> x * 2 end)` type checks correctly, closing the two remaining Phase 12 verification gaps.

Purpose: The pipe operator with multi-arg functions is blocked because `infer_pipe` delegates to `infer_expr` which calls `infer_call`, which checks arity before the pipe's LHS is accounted for. The fix makes `infer_pipe` handle `CallExpr` RHS directly by inferring the callee and explicit args, then constructing the expected function type as `Fun([lhs_ty, ...explicit_arg_tys], ret_var)` -- matching the MIR lowering's desugaring approach.

Output: Updated `infer_pipe` function, typeck unit test, updated e2e tests using actual pipe syntax, new chained-pipe e2e test.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pipe-operator-closures/12-02-SUMMARY.md
@.planning/phases/12-pipe-operator-closures/12-VERIFICATION.md

Key source files:
@crates/snow-typeck/src/infer.rs (lines 2399-2437: infer_pipe function; lines 2315-2397: infer_call function)
@crates/snow-codegen/src/mir/lower.rs (lines 1314-1359: lower_pipe_expr showing desugaring pattern)
@crates/snow-parser/src/ast/expr.rs (lines 197-234: CallExpr, ArgList, PipeExpr AST nodes)
@tests/e2e/closure_bare_params_pipe.snow (current: uses direct calls, needs pipe syntax)
@crates/snowc/tests/e2e.rs (e2e test registration)
@crates/snow-typeck/tests/integration.rs (typeck test pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pipe-aware call inference in infer_pipe + typeck unit test</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/tests/integration.rs
  </files>
  <action>
    Modify `infer_pipe` (line ~2399) to handle the case where the pipe RHS is a `CallExpr`. Currently it does:

    ```
    let rhs_ty = infer_expr(ctx, env, &rhs, types, ...)?;
    let expected_fn = Ty::Fun(vec![lhs_ty], Box::new(ret_var.clone()));
    ctx.unify(rhs_ty, expected_fn, ...)?;
    ```

    This fails because `infer_expr` on a `CallExpr` RHS calls `infer_call`, which constructs `Fun([closure_ty], ret)` for `map` -- but `map` is `Fun([List, Fun([Int], Int)], List)` (2 params), causing unification failure.

    **The fix:** When `rhs` is `Expr::CallExpr(call)`, perform pipe-aware inference directly instead of calling `infer_expr` on the whole call:

    1. Extract the callee from the `CallExpr` via `call.callee()`
    2. Infer the callee type via `infer_expr(ctx, env, &callee_expr, ...)`
    3. Collect explicit argument types from `call.arg_list()` via `infer_expr` on each arg
    4. Build the full arg list: `[lhs_ty] ++ explicit_arg_types`
    5. Create `expected_fn_ty = Ty::Fun(full_args, Box::new(ret_var))`
    6. Unify `callee_ty` with `expected_fn_ty`
    7. Store type for the call's text range via `types.insert(call.syntax().text_range(), ret_var.clone())`
    8. Store type for the pipe expression's text range
    9. Also replicate the where-clause constraint checking from `infer_call` (lines 2357-2393) for the pipe-aware path, using the callee expression and the full arg list including the piped argument

    For all other RHS forms (bare name refs, closures, etc.), keep the existing behavior.

    The resulting code structure in `infer_pipe` should be:
    ```rust
    match &rhs {
        Expr::CallExpr(call) => {
            // Pipe-aware: infer callee + explicit args, prepend lhs_ty
            // ... (pipe-aware call inference as described above)
        }
        _ => {
            // Existing behavior: infer rhs as function, unify with Fun([lhs_ty], ret)
            let rhs_ty = infer_expr(ctx, env, &rhs, types, ...)?;
            let expected_fn = Ty::Fun(vec![lhs_ty], Box::new(ret_var.clone()));
            ctx.unify(rhs_ty, expected_fn, ...)?;
        }
    }
    ```

    **Important:** The `rhs` variable is currently `Expr` (from `pipe.rhs().ok_or_else(...)`) -- you can match on it directly.

    **Typeck unit test:** Add a test in `crates/snow-typeck/tests/integration.rs` that verifies pipe+call arity works. The test should:
    - Define a 2-arg function `fn add(x :: Int, y :: Int) -> Int do x + y end`
    - Use pipe: `5 |> add(10)`
    - Assert no type errors and result type is Int
    - Also test pipe with closure: define `fn apply(x :: Int, f :: Fun(Int, Int)) -> Int do f(x) end` and use `5 |> apply(fn x -> x * 2 end)`, assert no errors

    Do NOT change the `infer_call` function itself. The fix is entirely within `infer_pipe`.
  </action>
  <verify>
    Run `cargo test -p snow-typeck` -- all existing tests pass plus the new pipe test(s).
    Run `cargo test -p snow-codegen` -- all 85+ tests pass (no regression).
    Run `cargo test -p snow-parser` -- all 210+ tests pass (no regression).
  </verify>
  <done>
    `infer_pipe` handles `CallExpr` RHS by prepending `lhs_ty` to explicit args before arity check. New typeck test confirms `x |> f(y)` type checks as `f(x, y)`. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E tests with actual pipe+closure syntax</name>
  <files>
    tests/e2e/closure_bare_params_pipe.snow
    tests/e2e/pipe_chain_closures.snow
    crates/snowc/tests/e2e.rs
  </files>
  <action>
    **Update closure_bare_params_pipe.snow** to use actual pipe syntax instead of direct calls:

    ```snow
    fn main() do
      let list = List.new()
      let list = List.append(list, 1)
      let list = List.append(list, 2)
      let list = List.append(list, 3)
      let list = List.append(list, 4)
      let list = List.append(list, 5)

      # Bare single param closure via pipe
      let doubled = list |> map(fn x -> x * 2 end)

      # Bare single param closure with filter via pipe
      let filtered = doubled |> filter(fn x -> x > 4 end)

      # Multi-param bare closure via pipe
      let sum = reduce(filtered, 0, fn acc, x -> acc + x end)

      println("${sum}")
    end
    ```

    Note: `reduce` takes 3 args (list, init, closure), so piping into it would be `list |> reduce(0, fn acc, x -> acc + x end)` -- use this form if the type checker handles it. If reduce with 3 args via pipe is problematic, keep reduce as a direct call (it's testing multi-param closures, not pipe specifically).

    Expected output: `24` (same as before -- [1,2,3,4,5] -> doubled [2,4,6,8,10] -> filtered >4 [6,8,10] -> sum 24)

    **Create tests/e2e/pipe_chain_closures.snow** for chained pipes (Success Criterion #3):

    ```snow
    fn main() do
      let list = List.new()
      let list = List.append(list, 1)
      let list = List.append(list, 2)
      let list = List.append(list, 3)
      let list = List.append(list, 4)
      let list = List.append(list, 5)

      let result = list |> map(fn x -> x + 1 end) |> filter(fn x -> x > 3 end) |> reduce(0, fn acc, x -> acc + x end)

      println("${result}")
    end
    ```

    Expected output: `19` (list [1,2,3,4,5] -> map +1 [2,3,4,5,6] -> filter >3 [4,5,6] -> reduce sum 15)

    Wait -- recalculate: [2,3,4,5,6] filtered >3 = [4,5,6], sum = 15. Use `15` as expected output.

    Actually -- if reduce takes 3 args and the pipe prepends the list as first arg, then `|> reduce(0, fn acc, x -> acc + x end)` would become `reduce(list, 0, fn ...)` which is correct. Verify this works.

    **Register in e2e.rs:** The `e2e_closure_bare_params_pipe` test already exists in `crates/snowc/tests/e2e.rs`. Add a new test for `pipe_chain_closures`:

    ```rust
    /// Chained pipes with closures: Phase 12 gap closure verification.
    #[test]
    fn e2e_pipe_chain_closures() {
        let source = read_fixture("pipe_chain_closures.snow");
        assert_runs_with_output(source, "15\n");
    }
    ```

    The `e2e_closure_bare_params_pipe` test may need its expected output updated if the pipe syntax changes the computation path (it shouldn't -- same logic, just pipe syntax).
  </action>
  <verify>
    Run `cargo test --test e2e` -- all existing e2e tests pass plus the new pipe_chain_closures test.
    Run `cargo build --release` -- compiles successfully.
    Manual test: compile and run `tests/e2e/closure_bare_params_pipe.snow` and verify output is `24`.
    Manual test: compile and run `tests/e2e/pipe_chain_closures.snow` and verify output is `15`.
  </verify>
  <done>
    Both e2e tests use actual pipe syntax with closures. `closure_bare_params_pipe.snow` pipes into `map` and `filter` with closures. `pipe_chain_closures.snow` chains `map |> filter |> reduce` with inline closures. All tests produce correct output.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` -- all tests pass including new pipe+call test
2. `cargo test -p snow-codegen` -- all tests pass (no regression)
3. `cargo test -p snow-parser` -- all tests pass (no regression)
4. `cargo test --test e2e` -- all tests pass including pipe+closure e2e tests
5. `cargo test -p snow-fmt` -- all tests pass (no regression)
6. `cargo build --release` -- compiles successfully
7. Manual verification: `list |> map(fn x -> x * 2 end)` type checks and executes
8. Manual verification: `list |> map(fn x -> x + 1 end) |> filter(fn x -> x > 3 end)` works
</verification>

<success_criteria>
- Phase 12 Success Criterion #1 verified: `list |> Enum.map(fn x -> x * 2 end)` parses AND executes correctly
- Phase 12 Success Criterion #3 verified: Multiple chained pipes with closures work
- Zero test regressions across all crates
- SYN-04 requirement fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/12-pipe-operator-closures/12-03-SUMMARY.md`
</output>
