---
phase: 12-pipe-operator-closures
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - crates/snow-fmt/src/walker.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - tests/e2e/closure_bare_params_pipe.snow
  - tests/e2e/closure_multi_clause.snow
  - tests/e2e/closure_do_end_body.snow
autonomous: true

must_haves:
  truths:
    - "`list |> Enum.map(fn x -> x * 2 end)` compiles and executes correctly (full pipeline)"
    - "`fn 0 -> \"zero\" | n -> to_string(n) end` multi-clause closure compiles and runs correctly"
    - "`fn x do let y = x * 2; y end` do/end closure compiles and runs correctly"
    - "Formatter outputs clean syntax for bare-param closures and do/end closures"
    - "Multiple chained pipes with closures `|> map(fn x -> x + 1 end) |> filter(fn x -> x > 3 end)` compile and execute"
    - "Nested do/end inside closure bodies formats and compiles correctly"
    - "Guard clauses in closures type-check and compile correctly"
  artifacts:
    - path: "crates/snow-fmt/src/walker.rs"
      provides: "Updated walk_closure_expr for bare params, do/end body, multi-clause formatting"
      contains: "walk_closure_expr"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Multi-clause closure type inference via clause desugaring"
      contains: "infer_closure"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Multi-clause closure MIR lowering via clause desugaring"
      contains: "lower_closure_expr"
    - path: "tests/e2e/closure_bare_params_pipe.snow"
      provides: "E2e test: bare params in pipe chain"
      contains: "fn x ->"
    - path: "tests/e2e/closure_multi_clause.snow"
      provides: "E2e test: multi-clause closure"
      contains: "fn 0 ->"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "infer_closure reads ClosureExpr clauses() for multi-clause desugaring"
      pattern: "clauses\\(\\)|is_multi_clause"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "lower_closure_expr reads ClosureExpr clauses() for multi-clause desugaring"
      pattern: "clauses\\(\\)|is_multi_clause"
---

<objective>
Complete the Phase 12 pipeline by updating the formatter for new closure syntax, extending the type checker and MIR lowering to handle multi-clause closures (desugaring to match), and adding end-to-end tests that verify closures in pipe chains compile and execute correctly.

Purpose: Plan 12-01 adds parsing support. This plan ensures the full compiler pipeline works: formatting, type checking, MIR lowering, LLVM codegen, and execution.
Output: Updated formatter, type checker/MIR multi-clause support, passing e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pipe-operator-closures/12-RESEARCH.md
@.planning/phases/12-pipe-operator-closures/12-CONTEXT.md
@.planning/phases/12-pipe-operator-closures/12-01-SUMMARY.md
@crates/snow-fmt/src/walker.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-parser/src/ast/expr.rs
@tests/e2e/stdlib_list_pipe_chain.snow
</context>

<tasks>

<task type="auto">
  <name>Task 1: Formatter + type checker + MIR lowering for new closure forms</name>
  <files>
    crates/snow-fmt/src/walker.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**Formatter updates (walker.rs):**

Update `walk_closure_expr` (line ~864) to handle the new closure syntax forms produced by the rewritten parser:

1. **Bare params (no parens):** The PARAM_LIST child may not have L_PAREN/R_PAREN tokens. Walk the PARAM_LIST node and format params with spaces: `fn x, y -> ...`. If the PARAM_LIST has L_PAREN/R_PAREN tokens, format with parens as before: `fn(x, y) -> ...`.

2. **do/end body:** When a DO_KW token is encountered in the CLOSURE_EXPR, format as:
   - Single-statement: `fn x do body end`
   - Multi-statement: `fn x do\n  stmt1\n  stmt2\nend` (indented block)
   Handle the inner `end` (from do/end) separately from the outer `end` (closure). Actually, with do/end body closures, the `do` block has its own `end`, and the closure has no extra `end` -- the do/end's `end` IS the closure's end. Wait -- re-read the parser: for do/end closures, the parse structure is `fn params do <block_body> end` where `end` closes both the do block and the closure. There is only ONE `end`. Confirm this from Plan 12-01's implementation and format accordingly.

3. **Multi-clause (CLOSURE_CLAUSE children):** If CLOSURE_EXPR has CLOSURE_CLAUSE children, format as:
   ```
   fn clause1_params -> clause1_body | clause2_params -> clause2_body end
   ```
   Use `|` separator with spaces. For multi-line multi-clause closures, format with newlines:
   ```
   fn
     0 -> "zero"
     | n -> to_string(n)
   end
   ```
   But for simple one-liners, keep inline.

4. **Guard clauses:** When a GUARD_CLAUSE child appears, format as `fn x when guard_expr -> body end`. Walk the guard expression normally.

5. **Test formatting:** Run `cargo test -p snow-fmt` to verify formatter tests pass.

**Type checker updates (infer.rs):**

Modify `infer_closure` (line ~2486) to handle multi-clause closures:

1. Check if the closure has CLOSURE_CLAUSE children (via `closure.is_multi_clause()` or `closure.clauses().next().is_some()`).
2. If single-clause (the common case): existing code works unchanged. The bare param / do/end body cases produce the same PARAM_LIST + BLOCK CST shape, so `closure.param_list()` and `closure.body()` work as before.
3. If multi-clause: Desugar to a match during type inference:
   - Count the params in the first clause to determine arity
   - For single-param multi-clause: create a fresh type variable for the param, then type-check each clause as a match arm pattern + body. Unify all clause body types. Return `Ty::Fun(vec![param_ty], body_ty)`.
   - For multi-param multi-clause: similar approach with multiple param type variables
   - Guard expressions: infer guard type and unify with Bool
   - Use the existing pattern matching and guard infrastructure from `infer_case`/`infer_match_arm` to handle clause patterns

   Implementation approach: For each clause, extract the pattern(s) from its param_list and the body expression. Build a synthetic "case" inference: create fresh param type variables, then for each clause, unify the param types with the clause's pattern types and infer the body type. This reuses the pattern matching infrastructure already in the type checker.

   Simpler approach: Since single-param multi-clause closures are the common case, handle them by:
   - Creating a fresh type var for the single param
   - For each clause: push scope, bind pattern variables from the clause's param pattern to fresh vars, infer body, pop scope, collect body type
   - Unify all body types
   - Return Fun([param_ty], unified_body_ty)

**MIR lowering updates (lower.rs):**

Modify `lower_closure_expr` (line ~1611) to handle multi-clause closures:

1. Check if the closure is multi-clause (via AST accessors).
2. If single-clause: existing code works unchanged. Bare params and do/end body produce the same AST shape.
3. If multi-clause: Generate a single-param closure whose body is a MirExpr::Match:
   - The closure param is a synthetic `__arg` (or the first clause's param name if simple ident)
   - Each clause becomes a match arm in the MirExpr::Match
   - Pattern extraction from clause params feeds into MirPattern construction
   - Guard expressions become arm guards
   - This mirrors the Phase 11 multi-clause function approach (see `lower_multi_clause_fn` pattern)

   For single-param multi-clause, use MirExpr::Match on the param. For multi-param multi-clause, use an if-else chain (same as Phase 11 decision for multi-param -- no MirExpr::Tuple exists).

4. Ensure lambda lifting (captured variables) still works correctly for multi-clause closures.
  </action>
  <verify>
Run the following in order:
1. `cargo test -p snow-fmt` -- formatter tests pass
2. `cargo test -p snow-typeck` -- type checker tests pass
3. `cargo test -p snow-codegen` -- codegen tests pass (including MIR lowering)
4. `cargo build` -- full compiler builds
5. `cargo test` -- all tests pass across all crates
  </verify>
  <done>
Formatter correctly handles bare params, do/end body, multi-clause, and guard closures. Type checker infers correct types for all closure forms including multi-clause with pattern matching and guards. MIR lowering produces correct MIR for multi-clause closures via match desugaring. All existing tests continue to pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end tests verifying full compilation and execution</name>
  <files>
    tests/e2e/closure_bare_params_pipe.snow
    tests/e2e/closure_multi_clause.snow
    tests/e2e/closure_do_end_body.snow
  </files>
  <action>
Create end-to-end Snow programs that compile and execute, testing all new closure syntax forms through the full pipeline (parse -> typecheck -> MIR -> LLVM -> execute).

**Test 1: `closure_bare_params_pipe.snow`**
Tests bare param closures in pipe chains -- the primary use case for this phase.
```snow
fn main() do
  let list = List.new()
  let list = List.append(list, 1)
  let list = List.append(list, 2)
  let list = List.append(list, 3)
  let list = List.append(list, 4)
  let list = List.append(list, 5)

  # Bare param closure in direct call
  let doubled = map(list, fn x -> x * 2 end)

  # Bare param closure in pipe chain
  let result = list |> filter(fn x -> x > 2 end) |> map(fn x -> x * 10 end)

  # Multi-param bare closure
  let sum = reduce(list, 0, fn acc, x -> acc + x end)

  println("${sum}")
end
```
Expected output: `15` (sum of 1+2+3+4+5)

**Test 2: `closure_multi_clause.snow`**
Tests multi-clause closures with pattern matching.
```snow
fn main() do
  let list = List.new()
  let list = List.append(list, 0)
  let list = List.append(list, 1)
  let list = List.append(list, 2)
  let list = List.append(list, 3)

  # Multi-clause closure with literal patterns
  let classify = fn 0 -> 0 | n -> 1 end
  let result = map(list, classify)

  # Use reduce to sum the classified values
  let sum = reduce(result, 0, fn acc, x -> acc + x end)
  println("${sum}")
end
```
Expected output: `3` (0 maps to 0, 1/2/3 each map to 1, sum = 3)

**Test 3: `closure_do_end_body.snow`**
Tests do/end body closures with multi-statement bodies.
```snow
fn main() do
  let list = List.new()
  let list = List.append(list, 1)
  let list = List.append(list, 2)
  let list = List.append(list, 3)

  let result = map(list, fn x do
    let doubled = x * 2
    let incremented = doubled + 1
    incremented
  end)

  let sum = reduce(result, 0, fn acc, x -> acc + x end)
  println("${sum}")
end
```
Expected output: `15` ((1*2+1) + (2*2+1) + (3*2+1) = 3 + 5 + 7 = 15)

**Running e2e tests:**
Use the existing e2e test runner. Check how `stdlib_list_pipe_chain.snow` is executed:
```bash
# Build compiler
cargo build --release
# Compile and run each test
./target/release/snowc tests/e2e/closure_bare_params_pipe.snow -o /tmp/test_bare && /tmp/test_bare
./target/release/snowc tests/e2e/closure_multi_clause.snow -o /tmp/test_multi && /tmp/test_multi
./target/release/snowc tests/e2e/closure_do_end_body.snow -o /tmp/test_doend && /tmp/test_doend
```

Verify each produces the expected output. If the e2e test infrastructure uses a different runner (e.g., `cargo test --test e2e`), use that instead.

**Note on List functions:** The e2e tests use `map`, `filter`, `reduce` which are stdlib functions. Check how `stdlib_list_pipe_chain.snow` uses them (it uses `map(list, fn(x) -> x * 2 end)` style, not `Enum.map`). Follow the same pattern -- the phase success criteria mentions `Enum.map` but the actual Snow stdlib may use `map` directly. Adapt test code to match what's actually available.

**Additional edge case tests (if time allows):**
- Pipe inside closure body: `map(list, fn x -> x |> to_string() end)`
- Nested closures: `map(list, fn x -> map(other, fn y -> x + y end) end)`
- Guard clause e2e: `fn x when x > 0 -> x | x -> 0 - x end`
  </action>
  <verify>
Each e2e test compiles without errors and produces the expected output:
1. `closure_bare_params_pipe.snow` -> prints `15`
2. `closure_multi_clause.snow` -> prints `3`
3. `closure_do_end_body.snow` -> prints `15`
Also run `cargo test` to ensure no regressions across the full test suite.
  </verify>
  <done>
Three e2e tests demonstrate the full pipeline works for bare-param closures in pipe chains, multi-clause closures, and do/end body closures. All compile and execute with correct output. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- ALL tests pass across all crates
2. `cargo build --release` -- release build succeeds
3. E2e tests compile and produce expected output
4. Formatter produces clean output for all new closure forms
5. Phase success criteria verified:
   - `list |> Enum.map(fn x -> x * 2 end)` (or `map(list, fn x -> x * 2 end)`) parses and executes correctly
   - Nested do/end blocks inside closures work
   - Multiple chained pipes with closures work
</verification>

<success_criteria>
- Formatter handles bare params, do/end body, multi-clause, and guard closures
- Type checker infers correct types for multi-clause closures
- MIR lowering desugars multi-clause closures to match expressions
- Three e2e tests compile and execute with correct output
- Full `cargo test` suite passes with zero failures
- Phase 12 success criteria from ROADMAP.md all verified
</success_criteria>

<output>
After completion, create `.planning/phases/12-pipe-operator-closures/12-02-SUMMARY.md`
</output>
