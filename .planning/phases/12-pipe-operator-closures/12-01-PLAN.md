---
phase: 12-pipe-operator-closures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/tests/parser_tests.rs
autonomous: true

must_haves:
  truths:
    - "`fn x -> x * 2 end` (bare single param) parses into a valid CLOSURE_EXPR"
    - "`fn x, y -> x + y end` (bare multi-param) parses into a valid CLOSURE_EXPR with 2-param PARAM_LIST"
    - "`fn x do let y = x * 2; y end` (do/end body) parses into a valid CLOSURE_EXPR"
    - "`fn 0 -> \"zero\" | n -> to_string(n) end` (multi-clause) parses into CLOSURE_EXPR wrapping a CASE_EXPR"
    - "`fn x when x > 0 -> x | x -> -x end` (guard clause in closure) parses correctly"
    - "Existing parenthesized closure syntax `fn(x) -> x + 1 end` still works unchanged"
    - "Missing `end` error message references the opening `fn` token span"
    - "Bare closure as pipe target `|> fn x -> x end` produces helpful error suggesting wrapping in a function call"
  artifacts:
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "Rewritten parse_closure with bare params, do/end body, multi-clause, guards"
      contains: "parse_closure"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "ClosureExpr AST accessors for case_expr (multi-clause desugaring)"
      contains: "ClosureExpr"
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "CLOSURE_CLAUSE syntax kind if needed for multi-clause"
      contains: "CLOSURE"
    - path: "crates/snow-parser/tests/parser_tests.rs"
      provides: "Parser snapshot tests for all new closure syntax forms"
      contains: "closure_bare_param"
  key_links:
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "parse_closure produces CLOSURE_EXPR nodes consumed by ClosureExpr accessors"
      pattern: "CLOSURE_EXPR"
---

<objective>
Rewrite the Snow parser's `parse_closure` function to support all specified closure syntax forms: bare parameters (no parens), `do/end` block bodies, multi-clause closures with `|` separator, guard clauses, and full pattern matching in parameters. Multi-clause closures are desugared into a single-clause closure wrapping a case expression, so type checker and MIR lowering need no changes.

Purpose: This is the core parser work for Phase 12 -- enabling `fn x -> x * 2 end` syntax and multi-clause closures inside pipe chains.
Output: Rewritten parse_closure, updated AST accessors, snapshot tests for all new forms.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pipe-operator-closures/12-RESEARCH.md
@.planning/phases/12-pipe-operator-closures/12-CONTEXT.md
@crates/snow-parser/src/parser/expressions.rs
@crates/snow-parser/src/ast/expr.rs
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/items.rs
@crates/snow-parser/tests/parser_tests.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite parse_closure for all syntax forms + AST/syntax updates</name>
  <files>
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-parser/src/ast/expr.rs
    crates/snow-parser/src/syntax_kind.rs
  </files>
  <action>
Rewrite the `parse_closure` function in `expressions.rs` (currently at line ~605) to support all new closure syntax forms. The current implementation only handles `fn (params) -> body end`. The new implementation must handle:

**1. Bare parameters (no parens required):**
After `fn`, detect whether params are bare or parenthesized:
- `fn(` or `fn (` with L_PAREN -> parenthesized params, use `parse_fn_clause_param_list(p)` (reuse Phase 11 infrastructure for pattern matching support)
- `fn IDENT` followed by `,`, `->`, `when`, or `do` -> bare params
- `fn LITERAL` followed by `->`, `when`, `|` -> pattern param (multi-clause start)
- `fn _` -> wildcard param
- `fn (IDENT, IDENT)` where L_PAREN present -> parenthesized (handled above)

For bare params, create a new `parse_bare_closure_params(p)` helper that opens a PARAM_LIST marker, calls `parse_fn_clause_param(p)` for each comma-separated param, and closes with PARAM_LIST. Stop parsing params when hitting `->`, `when`, or `do`.

**2. Two body forms:**
- `-> body end`: Arrow body. For single-clause closures, use `parse_block_body(p)` (same as current). For multi-clause `-> expr` bodies where expr must terminate at `|` (BAR), use `expr(p)` instead since BAR is not an infix operator and the Pratt loop exits at BAR.
- `do ... end`: Block body. Call `parse_block_body(p)` then `expect(END_KW)` for the do/end's own end. The outer closure's `end` is separate.

**3. Multi-clause closures (`|` separator):**
Desugar multi-clause closures into a single-clause closure wrapping a case/match expression. The approach:
- Parse the first clause (params + optional guard + body expression)
- If `|` (BAR) follows, this is multi-clause. Generate a synthetic single-param closure wrapping a CASE_EXPR:
  - The closure gets a single generated param (the param list from the first clause becomes the first match arm's pattern)
  - Each `|`-separated clause becomes a MATCH_ARM in the CASE_EXPR
  - The final `end` closes the entire closure

Implementation strategy for multi-clause desugaring: Rather than literally generating synthetic AST nodes during parsing (complex), parse multi-clause closures into a distinct CST shape that downstream code can recognize. Add a `CLOSURE_CLAUSE` syntax kind. Each clause becomes a CLOSURE_CLAUSE child of CLOSURE_EXPR. Then in the AST accessor layer (`expr.rs`), add a `clauses()` method that returns clause children, and a `is_multi_clause()` method. The type checker (`infer_closure`) and MIR lowerer (`lower_closure_expr`) will need minor updates in Plan 12-02 to handle multi-clause closures by desugaring to a match at that stage.

**REVISED approach (simpler):** Actually, after re-reading the research recommendation -- desugar in the parser by producing a CLOSURE_EXPR that wraps a CASE_EXPR for multi-clause closures. This way the type checker and MIR see a normal single-clause closure with a case body. Here's the approach:

For a multi-clause closure like `fn 0 -> "zero" | n -> to_string(n) end`:
1. Detect multi-clause: parse first clause params, then peek for `|` after body expr
2. When multi-clause detected, the parse_closure function produces:
   - CLOSURE_EXPR with a PARAM_LIST of one param (synthetic `__arg` or reuse the first clause's param if it's a simple ident)
   - Body is a CASE_EXPR node where each clause becomes a MATCH_ARM

Actually, generating synthetic tokens/nodes in a CST parser is fragile. The cleaner approach: **Use CLOSURE_CLAUSE children and handle desugaring in type checker/MIR.** This means:

**Final approach:** Parse multi-clause closures as CLOSURE_EXPR with CLOSURE_CLAUSE children. Add CLOSURE_CLAUSE to syntax_kind.rs. Each clause has its own params (as patterns), optional guard, and body. The AST accessor layer exposes `clauses()`. Type checker and MIR lowering already need trivial changes (they read param_list + body; for multi-clause, they desugar to a match on the clauses). This is addressed in Plan 12-02.

For single-clause closures (the common case including bare params and do/end body), the existing CLOSURE_EXPR shape is preserved: PARAM_LIST child + BLOCK child. No downstream changes needed.

**4. Guard clauses:**
After params and before body, check for `WHEN_KW`. If present, open a GUARD_CLAUSE marker, advance past `when`, call `expr(p)` to parse the guard expression, and close the marker. Use the same pattern as `items.rs` line ~77-81.

**5. Error messages (CRITICAL -- locked user decisions):**
- Save the `fn` token span at the start of `parse_closure` using `p.current_span()`.
- When `END_KW` is expected but not found, use `p.error_with_related("unclosed closure -- expected `end`", current_span, "closure started here", fn_span)`.
- After parsing a PIPE_EXPR where the RHS is a CLOSURE_EXPR (bare closure as pipe target), emit: "unexpected closure as pipe target -- did you mean `|> Func(fn x -> x end)`?". This check goes in `expr_bp` after the pipe infix handling. Look at the PIPE case in `expr_bp` and add a post-check: after closing the PIPE_EXPR, if the RHS child is a CLOSURE_EXPR, emit the diagnostic.

**Syntax kind changes (syntax_kind.rs):**
Add `CLOSURE_CLAUSE` variant for multi-clause closure children. Place it near `CLOSURE_EXPR` (line ~186).

**AST accessor changes (expr.rs):**
Add to ClosureExpr impl:
- `fn clauses(&self) -> impl Iterator<Item = ClosureClause>` -- returns CLOSURE_CLAUSE children (empty for single-clause)
- `fn is_multi_clause(&self) -> bool` -- checks for any CLOSURE_CLAUSE children
- `fn guard(&self) -> Option<GuardClause>` -- returns guard clause if present (single-clause closures with guard)

Add a new `ClosureClause` AST node type:
```rust
ast_node!(ClosureClause, CLOSURE_CLAUSE);
impl ClosureClause {
    pub fn param_list(&self) -> Option<ParamList> { child_node(&self.syntax) }
    pub fn guard(&self) -> Option<GuardClause> { child_node(&self.syntax) }
    pub fn body(&self) -> Option<Block> { child_node(&self.syntax) }
    // For -> expr body (not do/end), the body is the expression
    pub fn body_expr(&self) -> Option<Expr> { self.syntax.children().find_map(Expr::cast) }
}
```

**Backward compatibility:** The existing `fn(x) -> x + 1 end` syntax MUST continue to work. The rewritten parse_closure dispatches to `parse_fn_clause_param_list(p)` when `L_PAREN` is seen (replacing the old `parse_param_list(p)` call). Since `parse_fn_clause_param_list` is a superset of `parse_param_list` (handles both regular params and pattern params), this is fully backward compatible. Verify by running existing parser tests.

**Discretion decisions:**
- Pipes inside closure bodies: YES, allowed. The parser already handles this naturally -- `fn x -> x |> transform() end` works because `parse_block_body` calls `expr(p)` which handles pipe via Pratt parsing, and `end` exits the Pratt loop.
- Closures as pipe source (LHS): YES syntactically. Type checker catches nonsensical types.
- Error terminology: Use "closure" (not "anonymous function") in all error messages.
  </action>
  <verify>
Run `cargo test -p snow-parser` -- all existing parser tests must pass (backward compatibility). The rewritten parse_closure must not break any existing snapshot tests. Check that:
1. `closure_single_param` snapshot is unchanged (fn(x) -> x + 1 end)
2. `closure_two_params` snapshot is unchanged
3. `closure_no_params` snapshot is unchanged
4. `full_program_with_imports_pipes_closures` snapshot is unchanged
5. `lossless_closure` roundtrip test passes
  </verify>
  <done>
parse_closure handles bare params, do/end body, multi-clause with |, guard clauses, and pattern params. All existing closure tests pass unchanged. AST accessors for ClosureClause and multi-clause detection exist. CLOSURE_CLAUSE added to syntax_kind.rs. Error messages use related spans pointing to fn token.
  </done>
</task>

<task type="auto">
  <name>Task 2: Parser snapshot tests for all new closure syntax forms</name>
  <files>
    crates/snow-parser/tests/parser_tests.rs
  </files>
  <action>
Add comprehensive parser snapshot tests for all new closure syntax forms. Place them in the existing "Closures" section of parser_tests.rs (after line ~362). Use `assert_snapshot!(parse_and_debug(...))` for expression-level tests and `assert_snapshot!(source_and_debug(...))` for full-program tests.

**Tests to add:**

1. `closure_bare_single_param` -- `fn x -> x + 1 end`
2. `closure_bare_two_params` -- `fn x, y -> x + y end`
3. `closure_bare_param_pattern_matching` -- `fn 0 -> "zero" end` (literal pattern)
4. `closure_bare_param_with_type` -- `fn x :: Int -> x + 1 end`
5. `closure_do_end_body` -- `fn x do\n  let y = x * 2\n  y + 1\nend` (use source_and_debug for multi-line)
6. `closure_do_end_no_params` -- `fn do\n  42\nend`
7. `closure_multi_clause` -- `fn 0 -> "zero" | n -> to_string(n) end`
8. `closure_multi_clause_three` -- `fn 0 -> "zero" | 1 -> "one" | n -> to_string(n) end`
9. `closure_guard_clause` -- `fn x when x > 0 -> x end`
10. `closure_multi_clause_with_guards` -- `fn x when x > 0 -> x | x -> -x end` (note: -x may need parens depending on parser -- use `0 - x` if needed)
11. `closure_in_pipe_chain` -- full program: `fn main() do\n  let list = [1, 2, 3]\n  list |> map(fn x -> x * 2 end)\nend` (use source_and_debug)
12. `closure_chained_pipes` -- `list |> map(fn x -> x + 1 end) |> filter(fn x -> x > 3 end)` (parse_and_debug)
13. `closure_nested_do_end_in_body` -- `fn x -> if x > 0 do x else 0 - x end end` (verify nested end matching)
14. `closure_paren_params_still_work` -- `fn(x) -> x + 1 end` (confirm unchanged from existing `closure_single_param` -- can reference the existing test instead)
15. `closure_constructor_pattern` -- `fn Some(x) -> x | None -> 0 end` (multi-clause with constructor patterns)
16. `closure_wildcard_param` -- `fn _ -> 42 end`
17. `closure_tuple_pattern_param` -- `fn (a, b) -> a + b end` (parenthesized tuple pattern)
18. `closure_pipe_inside_closure_body` -- `fn x -> x |> to_string() end` (pipes inside closure body)

Run `cargo test -p snow-parser` and accept snapshots with `cargo insta accept -p snow-parser` (or `UPDATE_EXPECT=1`). All new tests should produce valid CST snapshots showing the expected node structure.

**Error case tests:**
19. `closure_missing_end_error` -- `fn x -> x + 1` (no end -- verify error message references fn token)
20. Test that `fn x -> x end` as pipe RHS (without wrapping call) produces the helpful error -- this might be tricky to test as a snapshot, but verify the parse tree contains an error node.
  </action>
  <verify>
Run `cargo test -p snow-parser` -- all tests pass including new snapshots. Run `cargo insta accept -p snow-parser` to accept new snapshots if using insta. Verify snapshot files exist in `crates/snow-parser/tests/snapshots/` for each new test.
  </verify>
  <done>
At least 15 new parser snapshot tests covering bare params, do/end body, multi-clause, guards, pattern params, pipe chains, nested closures, and error cases. All pass with valid CST snapshots.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-parser` -- ALL tests pass (existing + new)
2. `cargo build` -- full compiler builds without errors
3. Existing closure tests unchanged (backward compatibility)
4. New snapshot tests show correct CST structure for all syntax forms
</verification>

<success_criteria>
- parse_closure handles: bare params, parenthesized params, do/end body, -> expr body, multi-clause with |, guard clauses, pattern matching params
- All existing parser tests pass unchanged
- 15+ new parser snapshot tests for new syntax forms
- Error messages reference fn token span for unclosed closures
- CLOSURE_CLAUSE added to syntax_kind.rs for multi-clause support
- ClosureExpr AST accessors support multi-clause detection
</success_criteria>

<output>
After completion, create `.planning/phases/12-pipe-operator-closures/12-01-SUMMARY.md`
</output>
