---
phase: 105.1-fix-codegen-abi-issues-and-workarounds-from-phase-105
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-codegen/src/codegen/types.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - crates/mesh-codegen/src/codegen/pattern.rs
autonomous: true

must_haves:
  truths:
    - "Result<Struct, String> values can be constructed and destructured without segfault"
    - "Sum type variants with struct payloads use pointer-boxing to fit the {i8, ptr} layout"
    - "All existing tests still pass after the fix"
  artifacts:
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "Pointer-boxing for struct payloads in sum type variant construction"
      contains: "codegen_construct_variant"
    - path: "crates/mesh-codegen/src/codegen/pattern.rs"
      provides: "Pointer-unboxing for struct payloads in sum type variant destructuring"
      contains: "navigate_access_path_ptr"
    - path: "crates/mesh-codegen/src/codegen/types.rs"
      provides: "Sum type layout remains {i8, ptr} for monomorphized types"
      contains: "create_sum_type_layout"
  key_links:
    - from: "codegen_construct_variant"
      to: "create_sum_type_layout"
      via: "Variant overlay must match sum type layout size"
      pattern: "variant_struct_type.*sum_layout"
---

<objective>
Fix the codegen so that Result (and Option) types containing multi-field struct payloads work correctly without segfaulting.

Purpose: Structs inside Result/Option cause memory corruption because the variant overlay is larger than the sum type layout. The generic layout is `{i8, ptr}` (16 bytes) but variant construction writes a full struct overlay like `{i8, i64, i64}` (24 bytes), overflowing the allocation.

Output: Corrected codegen that pointer-boxes struct payloads when constructing sum type variants, and pointer-unboxes them when destructuring.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/105-verify-mesher-runtime/105-02-SUMMARY.md
@crates/mesh-codegen/src/codegen/types.rs
@crates/mesh-codegen/src/codegen/expr.rs
@crates/mesh-codegen/src/codegen/pattern.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pointer-box struct payloads in sum type variant construction and pattern matching</name>
  <files>crates/mesh-codegen/src/codegen/expr.rs, crates/mesh-codegen/src/codegen/pattern.rs</files>
  <action>
The root cause: monomorphized sum types like `Result_Project_String` use the generic `Result` layout from `create_sum_type_layout`. Since Result's generic params are registered as `MirType::Ptr` (line 11012 in lower.rs), the `all_single_ptr` check passes, and the layout is `{i8, ptr}` -- 16 bytes total. But when constructing `Ok(project_struct)` in `codegen_construct_variant`, the variant overlay uses `variant_struct_type(context, &[MirType::Struct("Project")], ...)` which produces `{i8, Struct_Project}`. If Project has 2+ fields, this overlay is larger than 16 bytes, causing a buffer overflow when writing via GEP into the alloca.

**Fix 1 — Construction side in `codegen_construct_variant` (expr.rs, around line 1828):**

After computing the field value with `self.codegen_expr(field_expr)?`, check whether the value is a StructValue whose LLVM type size exceeds 8 bytes (i.e., it won't fit in a single pointer slot). If so:

1. Heap-allocate the struct using `mesh_gc_alloc_actor(struct_size, 8)`
2. Store the struct value into the heap allocation
3. Use the heap pointer as the value to store in the variant's payload slot
4. Use the pointer LLVM type for the GEP instead of the original struct type

The variant overlay for the GEP should be `{i8, ptr}` (matching the sum type layout) instead of `{i8, Struct_type}` when the field is pointer-boxed.

Concretely, in the loop `for (i, field_expr) in fields.iter().enumerate()` (line 1874):

```rust
let val = self.codegen_expr(field_expr)?;

// Check if value needs pointer-boxing for sum type slot
let (store_val, use_ptr_overlay) = if val.is_struct_value() {
    let sv = val.into_struct_value();
    let sv_ty = sv.get_type();
    let target_data = self.target_machine.get_target_data();
    let struct_size = target_data.get_store_size(&sv_ty);
    if struct_size > 8 {
        // Large struct: heap-allocate and store pointer
        let size = sv_ty.size_of().unwrap_or(i64_ty.const_int(struct_size, false));
        let align = i64_ty.const_int(8, false);
        let gc_alloc = get_intrinsic(&self.module, "mesh_gc_alloc_actor");
        let heap_ptr = self.builder
            .build_call(gc_alloc, &[size.into(), align.into()], "variant_box")
            .map_err(|e| e.to_string())?
            .try_as_basic_value().basic()
            .ok_or("mesh_gc_alloc_actor returned void")?
            .into_pointer_value();
        self.builder.build_store(heap_ptr, sv).map_err(|e| e.to_string())?;
        (heap_ptr.into(), true)
    } else {
        (val, false)
    }
} else {
    (val, false)
};
```

Then when doing the GEP to store the value, if `use_ptr_overlay` is true, use a variant overlay of `{i8, ptr}` instead of the original `variant_struct_type` with the concrete field type. This ensures the GEP operates within the bounds of the `{i8, ptr}` sum type layout.

**Fix 2 — Destructuring side in `navigate_access_path_ptr` (pattern.rs, line 661-701):**

In `navigate_access_path_ptr`, the `AccessPath::VariantField` arm (line 661-701) creates a variant overlay via `variant_struct_type(context, &variant_def.fields, ...)` and does `build_struct_gep(variant_ty, parent_ptr, index+1, ...)` to get the field pointer. When the sum type uses `{i8, ptr}` layout but the variant field type is `MirType::Struct(name)`, the GEP overlay must be `{i8, ptr}` (not `{i8, Struct_type}`) and the loaded pointer must be dereferenced after the GEP to produce a pointer to the actual struct data.

Specifically, after line 689 where `variant_ty` is computed:

1. Check if the sum type layout is `{i8, ptr}` (look it up in `self.sum_type_layouts`) AND the variant field at `index` is `MirType::Struct(_)`.
2. If so, override `variant_ty` to be `{i8, ptr}` (a struct type with an i8 and a pointer) for the GEP.
3. The GEP at line 692-700 will then yield a pointer to a `ptr` slot (not a pointer to the struct directly).
4. After the GEP, load the pointer value from that slot: `let heap_ptr = build_load(ptr_ty, field_ptr, "unbox_ptr")`.
5. Return `heap_ptr` as the result -- this is a pointer to the actual struct data, which the caller will use for subsequent field accesses.

The heuristic: if the sum type layout is `{i8, ptr}` (the `all_single_ptr` path) but the variant's declared field type is `MirType::Struct(name)`, then the stored value is a pointer to the struct, and destructuring must use the `{i8, ptr}` overlay for GEP and then dereference the loaded pointer.

**Important constraints:**
- Do NOT change the `create_sum_type_layout` function -- the `{i8, ptr}` layout is correct for the generic case
- Do NOT change how the builtin sum types are registered (the Ptr fields are correct for the generic registration)
- Only change the construction and destructuring codegen to box/unbox struct payloads that exceed 8 bytes
- Pointer-sized types (String, Ptr, Int) should NOT be affected -- only multi-field structs
  </action>
  <verify>
Run `cargo test -p mesh-codegen` to confirm all existing codegen tests pass. Run `cargo test -p mesh-rt` to confirm runtime tests pass. Then compile and run the Mesher test suite or a small test program that constructs `Result<MultiFieldStruct, String>` -- `meshc build` should produce working code.
  </verify>
  <done>
`codegen_construct_variant` heap-allocates struct payloads >8 bytes and stores the pointer in the `{i8, ptr}` sum type slot. Pattern matching on these variants correctly loads through the pointer. All existing tests pass. A program returning `Result<MultiFieldStruct, String>` from a function compiles and runs without segfault.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add codegen tests for struct-in-Result layout and construct+match roundtrip</name>
  <files>crates/mesh-codegen/src/codegen/types.rs</files>
  <action>
Add two tests to the codegen crate:

**Test 1: Layout documentation test (`test_sum_type_layout_struct_payload`)**

Add a test to `types.rs` that verifies:

1. A sum type with a multi-field struct variant (like `Result<{i64, i64}, String>`) uses `{i8, ptr}` layout (since one variant has Ptr field via generic registration)
2. The variant overlay for the struct variant should be `{i8, ptr}` (not `{i8, i64, i64}`) when used with pointer-boxing

Add a test `test_sum_type_layout_struct_payload` that creates a MirSumTypeDef with:
- Variant "Ok" with fields `[MirType::Struct("TestStruct")]` where TestStruct is `{i64, i64}`
- Variant "Err" with fields `[MirType::String]`

Verify the layout is `{i8, [N x i8]}` (the byte-array path since Struct is not Ptr/String). This test documents the current layout behavior.

Also verify that with the variant fields being `[MirType::Ptr]` (generic registration), the layout IS `{i8, ptr}` -- confirming the mismatch between generic and monomorphized paths.

**Test 2: JIT roundtrip test (`test_struct_in_result_construct_and_match`)**

Add a JIT-executed integration test (in the codegen crate's test infrastructure) that:

1. Defines a Mesh struct `TestPair` with two i64 fields (e.g., `{x: Int, y: Int}`)
2. Defines a `Result_TestPair_String` sum type with `Ok(TestPair)` and `Err(String)` variants
3. Generates a function `make_ok() -> Result_TestPair_String` that constructs `Ok(TestPair { x: 42, y: 99 })`
4. Generates a function `roundtrip() -> Int` that calls `make_ok()`, pattern-matches on the result: `case result do Ok(pair) -> pair.x + pair.y | Err(_) -> 0 end`, and returns the sum (expected: 141)
5. JIT-compiles and executes `roundtrip()`, asserting the return value is 141 (not a segfault, not garbage)

This test validates the complete pointer-boxing (construction) and pointer-unboxing (pattern match destructuring) pipeline at runtime, catching regressions that a layout-only test would miss.

Use the existing mesh-codegen test infrastructure for JIT execution (look at how other codegen integration tests compile and run small programs). If no JIT test infrastructure exists yet, create a minimal one using inkwell's ExecutionEngine.
  </action>
  <verify>
`cargo test -p mesh-codegen test_sum_type_layout_struct_payload` passes.
`cargo test -p mesh-codegen test_struct_in_result_construct_and_match` passes (returns 141, does not segfault).
  </verify>
  <done>
Two tests exist: one documenting the sum type layout behavior for struct-payload variants (confirming the generic vs monomorphized layout difference), and one JIT-executing a construct+match roundtrip on `Result<MultiFieldStruct, String>` that confirms no segfault and correct value extraction (141).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p mesh-codegen` -- all tests pass including new ones
2. `cargo test -p mesh-rt` -- no regressions in runtime
3. Write a Mesh test program that does: define a struct with 2+ fields, return it wrapped in Ok() from a function, pattern match on the result -- verify no segfault
</verification>

<success_criteria>
- Result<MultiFieldStruct, String> can be constructed, returned from functions, and pattern-matched without segfault
- The fix uses pointer-boxing (heap-allocate struct, store pointer) on the construction side and pointer-unboxing (load through pointer) on the destructuring side
- All existing cargo tests pass
- New test documents the layout behavior
</success_criteria>

<output>
After completion, create `.planning/phases/105.1-fix-codegen-abi-issues-and-workarounds-from-phase-105/105.1-01-SUMMARY.md`
</output>
