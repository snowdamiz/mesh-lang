---
phase: 105.1-fix-codegen-abi-issues-and-workarounds-from-phase-105
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-codegen/src/codegen/types.rs
  - crates/mesh-codegen/src/codegen/expr.rs
autonomous: true

must_haves:
  truths:
    - "Result<Struct, String> values can be constructed and destructured without segfault"
    - "Sum type variants with struct payloads use pointer-boxing to fit the {i8, ptr} layout"
    - "All existing tests still pass after the fix"
  artifacts:
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "Pointer-boxing for struct payloads in sum type variant construction"
      contains: "codegen_construct_variant"
    - path: "crates/mesh-codegen/src/codegen/types.rs"
      provides: "Sum type layout remains {i8, ptr} for monomorphized types"
      contains: "create_sum_type_layout"
  key_links:
    - from: "codegen_construct_variant"
      to: "create_sum_type_layout"
      via: "Variant overlay must match sum type layout size"
      pattern: "variant_struct_type.*sum_layout"
---

<objective>
Fix the codegen so that Result (and Option) types containing multi-field struct payloads work correctly without segfaulting.

Purpose: Structs inside Result/Option cause memory corruption because the variant overlay is larger than the sum type layout. The generic layout is `{i8, ptr}` (16 bytes) but variant construction writes a full struct overlay like `{i8, i64, i64}` (24 bytes), overflowing the allocation.

Output: Corrected codegen that pointer-boxes struct payloads when constructing sum type variants, and pointer-unboxes them when destructuring.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/105-verify-mesher-runtime/105-02-SUMMARY.md
@crates/mesh-codegen/src/codegen/types.rs
@crates/mesh-codegen/src/codegen/expr.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pointer-box struct payloads in sum type variant construction and pattern matching</name>
  <files>crates/mesh-codegen/src/codegen/expr.rs</files>
  <action>
The root cause: monomorphized sum types like `Result_Project_String` use the generic `Result` layout from `create_sum_type_layout`. Since Result's generic params are registered as `MirType::Ptr` (line 11012 in lower.rs), the `all_single_ptr` check passes, and the layout is `{i8, ptr}` -- 16 bytes total. But when constructing `Ok(project_struct)` in `codegen_construct_variant`, the variant overlay uses `variant_struct_type(context, &[MirType::Struct("Project")], ...)` which produces `{i8, Struct_Project}`. If Project has 2+ fields, this overlay is larger than 16 bytes, causing a buffer overflow when writing via GEP into the alloca.

**Fix in `codegen_construct_variant` (around line 1828):**

After computing the field value with `self.codegen_expr(field_expr)?`, check whether the value is a StructValue whose LLVM type size exceeds 8 bytes (i.e., it won't fit in a single pointer slot). If so:

1. Heap-allocate the struct using `mesh_gc_alloc_actor(struct_size, 8)`
2. Store the struct value into the heap allocation
3. Use the heap pointer as the value to store in the variant's payload slot
4. Use the pointer LLVM type for the GEP instead of the original struct type

The variant overlay for the GEP should be `{i8, ptr}` (matching the sum type layout) instead of `{i8, Struct_type}` when the field is pointer-boxed.

Concretely, in the loop `for (i, field_expr) in fields.iter().enumerate()` (line 1874):

```rust
let val = self.codegen_expr(field_expr)?;

// Check if value needs pointer-boxing for sum type slot
let (store_val, use_ptr_overlay) = if val.is_struct_value() {
    let sv = val.into_struct_value();
    let sv_ty = sv.get_type();
    let target_data = self.target_machine.get_target_data();
    let struct_size = target_data.get_store_size(&sv_ty);
    if struct_size > 8 {
        // Large struct: heap-allocate and store pointer
        let size = sv_ty.size_of().unwrap_or(i64_ty.const_int(struct_size, false));
        let align = i64_ty.const_int(8, false);
        let gc_alloc = get_intrinsic(&self.module, "mesh_gc_alloc_actor");
        let heap_ptr = self.builder
            .build_call(gc_alloc, &[size.into(), align.into()], "variant_box")
            .map_err(|e| e.to_string())?
            .try_as_basic_value().basic()
            .ok_or("mesh_gc_alloc_actor returned void")?
            .into_pointer_value();
        self.builder.build_store(heap_ptr, sv).map_err(|e| e.to_string())?;
        (heap_ptr.into(), true)
    } else {
        (val, false)
    }
} else {
    (val, false)
};
```

Then when doing the GEP to store the value, if `use_ptr_overlay` is true, use a variant overlay of `{i8, ptr}` instead of the original `variant_struct_type` with the concrete field type. This ensures the GEP operates within the bounds of the `{i8, ptr}` sum type layout.

**Also fix the pattern matching / destructuring side in `codegen/pattern.rs` or the match codegen in `expr.rs`:**

When extracting a struct from a Result variant, the code uses GEP to load the payload field. If the field was pointer-boxed, the loaded value will be a pointer, which needs to be dereferenced to get the actual struct.

Search for where variant destructuring loads the payload (in the pattern match codegen -- look for `build_struct_gep` with variant overlay access during match arm binding). When the loaded value is a pointer but the expected MIR type is `MirType::Struct`, add a `build_load` of the struct type through the pointer.

The heuristic: if the sum type layout is `{i8, ptr}` (the `all_single_ptr` path) but the variant's declared field type is `MirType::Struct(name)`, then the stored value is a pointer to the struct, and destructuring must load through that pointer.

This requires checking in the pattern match codegen whether the current variant field type is a struct and the sum type uses `{i8, ptr}` layout. Look in `crates/mesh-codegen/src/codegen/pattern.rs` for where variant field bindings are created -- the `extract_payload` or equivalent function that loads fields from a matched variant.

**Important constraints:**
- Do NOT change the `create_sum_type_layout` function -- the `{i8, ptr}` layout is correct for the generic case
- Do NOT change how the builtin sum types are registered (the Ptr fields are correct for the generic registration)
- Only change the construction and destructuring codegen to box/unbox struct payloads that exceed 8 bytes
- Pointer-sized types (String, Ptr, Int) should NOT be affected -- only multi-field structs
  </action>
  <verify>
Run `cargo test -p mesh-codegen` to confirm all existing codegen tests pass. Run `cargo test -p mesh-rt` to confirm runtime tests pass. Then compile and run the Mesher test suite or a small test program that constructs `Result<MultiFieldStruct, String>` -- `meshc build` should produce working code.
  </verify>
  <done>
`codegen_construct_variant` heap-allocates struct payloads >8 bytes and stores the pointer in the `{i8, ptr}` sum type slot. Pattern matching on these variants correctly loads through the pointer. All existing tests pass. A program returning `Result<MultiFieldStruct, String>` from a function compiles and runs without segfault.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add codegen test for struct-in-Result construction and matching</name>
  <files>crates/mesh-codegen/src/codegen/types.rs</files>
  <action>
Add a test to `types.rs` (or a new integration test in the codegen crate) that verifies:

1. A sum type with a multi-field struct variant (like `Result<{i64, i64}, String>`) uses `{i8, ptr}` layout (since one variant has Ptr field)
2. The variant overlay for the struct variant should be `{i8, ptr}` (not `{i8, i64, i64}`) when used with pointer-boxing

Add a test `test_sum_type_layout_struct_payload` that creates a MirSumTypeDef with:
- Variant "Ok" with fields `[MirType::Struct("TestStruct")]` where TestStruct is `{i64, i64}`
- Variant "Err" with fields `[MirType::String]`

Verify the layout is `{i8, [N x i8]}` (the byte-array path since Struct is not Ptr/String). This test documents the current layout behavior.

Also verify that with the variant fields being `[MirType::Ptr]` (generic registration), the layout IS `{i8, ptr}` -- confirming the mismatch between generic and monomorphized paths.
  </action>
  <verify>
`cargo test -p mesh-codegen test_sum_type_layout_struct_payload` passes.
  </verify>
  <done>
Test exists documenting the sum type layout behavior for struct-payload variants, confirming the generic vs monomorphized layout difference that causes the ABI issue.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p mesh-codegen` -- all tests pass including new ones
2. `cargo test -p mesh-rt` -- no regressions in runtime
3. Write a Mesh test program that does: define a struct with 2+ fields, return it wrapped in Ok() from a function, pattern match on the result -- verify no segfault
</verification>

<success_criteria>
- Result<MultiFieldStruct, String> can be constructed, returned from functions, and pattern-matched without segfault
- The fix uses pointer-boxing (heap-allocate struct, store pointer) on the construction side and pointer-unboxing (load through pointer) on the destructuring side
- All existing cargo tests pass
- New test documents the layout behavior
</success_criteria>

<output>
After completion, create `.planning/phases/105.1-fix-codegen-abi-issues-and-workarounds-from-phase-105/105.1-01-SUMMARY.md`
</output>
