---
phase: 105.1-fix-codegen-abi-issues-and-workarounds-from-phase-105
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-codegen/src/codegen/expr.rs
autonomous: true

must_haves:
  truths:
    - "Service call handlers returning tuples with complex types (structs, sum types) serialize and deserialize correctly"
    - "The service loop reply mechanism handles >8-byte reply values via pointer indirection"
    - "The service call caller correctly recovers complex reply types from the reply message"
  artifacts:
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "Fixed service loop reply serialization and caller-side deserialization"
      contains: "codegen_service_loop"
  key_links:
    - from: "codegen_service_loop (reply send)"
      to: "codegen_service_call_helper (reply receive)"
      via: "mesh_service_reply/mesh_service_call message buffer"
      pattern: "mesh_service_reply.*reply_size"
---

<objective>
Fix the service call reply serialization so that complex return types (tuples containing structs and sum types) are correctly transmitted between the service actor and the caller.

Purpose: The current service loop always sends the reply as 8 bytes (a single i64 extracted from the handler tuple via `mesh_tuple_second`). The caller always reads 8 bytes. But when the reply is a complex type (struct >8 bytes, or sum type like `String!String` which is `{i8, ptr}` = up to 16 bytes), the tuple stores it as a pointer-as-i64 (heap-boxed). The service loop extracts this pointer-as-i64 and sends it as the "reply". The caller receives this pointer-as-i64 but has no way to know it needs to dereference it -- it treats the raw i64 as the reply value itself. Additionally, the pointer may point to memory in the service actor's heap, which the caller cannot access.

Output: Corrected service loop and service call helper that properly handle complex reply types through the message passing boundary.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/105-verify-mesher-runtime/105-02-SUMMARY.md
@crates/mesh-codegen/src/codegen/expr.rs
@crates/mesh-rt/src/actor/service.rs
@crates/mesh-rt/src/collections/tuple.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix service loop reply to send actual reply data, not just a pointer-as-i64</name>
  <files>crates/mesh-codegen/src/codegen/expr.rs</files>
  <action>
**Problem analysis:**

The service call handler body returns a tuple `(new_state, reply_value)`. The tuple is heap-allocated with each element stored as a u64. For complex types (structs, sum types), the tuple codegen in `codegen_make_tuple` either:
- Bitcasts small structs (<=8 bytes) to i64 directly
- Heap-allocates large structs (>8 bytes) and stores the pointer as i64

The service loop then does:
1. `reply_val = mesh_tuple_second(result_ptr)` -> gets u64 (which may be a pointer to a heap struct)
2. Stores `reply_val` in a single i64 alloca
3. Calls `mesh_service_reply(caller_pid, &reply_alloca, 8)` -> sends 8 bytes

The caller does:
1. Receives reply message
2. Loads i64 from message data at offset 16

**This is actually correct IF the caller knows to interpret the i64 as a pointer.** The problem is that on the caller side, the reply is loaded as a bare i64 and returned directly as the function result. The caller then uses this i64 as the raw value -- not knowing it's a pointer to heap data.

**The fix must work at both ends:**

**Service loop side (codegen_service_loop, around line 3605-3631):**

The current code extracts reply_val as i64 and sends 8 bytes. This is actually fine -- 8 bytes can hold a pointer. The key change is: the tuple stores complex types as pointer-as-i64, and we send that pointer-as-i64. The caller will receive it. The problem is entirely on the caller side.

**Caller side (codegen_service_call_helper, around line 3972-3983):**

Currently:
```rust
let reply_val = self.builder
    .build_load(i64_ty, reply_data_ptr, "reply_val")
    .map_err(|e| e.to_string())?;
Ok(reply_val)
```

This always returns the reply as a bare i64. But the calling code expects the reply to be the actual value type. For `String!String` (a Result sum type), the calling code expects a struct value `{i8, ptr}`, not a pointer to one.

**The fix:** In `codegen_service_call_helper`, after loading the raw i64 reply:

1. Determine the EXPECTED return type of the service call. The service call function (`__service_{name}_call_{snake}`) has a declared return type in the MIR. This is currently `MirType::Int` (or similar) -- check what it actually resolves to. Look at the function's MIR return type.

Actually, looking at the MIR lowerer more carefully (line 9791-9835), the service call stubs are generated with a body that calls `mesh_service_call` which returns `MirType::Ptr`. The stub function's return type needs to be checked.

**Simpler approach -- fix the tuple encoding to not use pointers for sum types:**

The real issue is that sum types like `{i8, ptr}` are 16 bytes but the tuple stores them via the StructValue path. Since `{i8, ptr}` has store_size = 16 > 8, the tuple heap-allocates and stores a pointer.

But `{i8, ptr}` for a Result like `String!String` contains a tag (i8) and a string pointer (ptr). What we actually want is for the tuple to store the Result value inline as an i64 -- which means we need to encode the Result as a single i64 value.

**Best approach -- keep pointer-as-i64 encoding, but fix the service call helper to recognize it:**

The service call helper function's return type is `MirType::Ptr` or `MirType::Int` in the MIR. The calling code at the Mesh level treats the return as the reply type (e.g., `String!String`).

Let me trace through more carefully. In `lower_service_def` (line 9791+), the call stub function body calls `mesh_service_call(pid, tag, args...)`. The codegen intercepts this call and uses `codegen_service_call_helper`. The reply is loaded as i64 and returned.

The call stub function's return type should match the service handler's reply type. But looking at line 9799-9804, the body is:
```
MirExpr::Call("mesh_service_call", [pid, tag, ...args])
```
And `mesh_service_call` is registered as returning `MirType::Ptr` (line 984).

The fix is straightforward:

**In `codegen_service_call_helper` (line 3910-3983):**

After loading the reply i64, the value is the raw tuple-encoded representation of the reply. For scalar types (Int, Bool, pointers), this i64 IS the value. For sum types and structs stored via the "large struct" path in `codegen_make_tuple`, this i64 is a pointer to the heap-allocated value.

Since the caller doesn't know the reply type at this point (it's generic `mesh_service_call -> Ptr`), the reply is returned as-is. The problem is that the CALLER of the call stub then treats this value as the concrete type.

**The actual fix needs to be in the service loop's reply code.** Instead of sending the raw tuple element (which may be a pointer to actor-local heap data), the service loop should:

1. Check if the reply value from the tuple is a pointer to a complex type
2. If so, copy the pointed-to data into the reply buffer (send the actual bytes, not just the pointer)

BUT the service loop is generated code that doesn't know the reply type at codegen time... it just knows it's an i64 from the tuple.

**Pragmatic fix -- redesign the reply as pointer-based:**

Change the reply mechanism:
1. The service loop stores the reply i64 (which may be a pointer or direct value) into the reply buffer as-is (current behavior -- keep it)
2. The service call helper returns the reply i64 as a `ptr` value (using `inttoptr` if needed)
3. The call stub function returns this pointer
4. The calling code at the Mesh level receives a pointer and handles it based on context

HOWEVER, this still doesn't fix the fundamental issue that the reply i64 may be a pointer into the SERVICE ACTOR's heap, which the caller can't access (different actor context).

**THE ACTUAL ROOT FIX -- copy reply data across actor boundary:**

The tuple in the service handler is allocated on the service actor's heap. When `mesh_tuple_second` returns a pointer-as-i64 for a large struct, that pointer points into the service actor's heap memory. The reply sends 8 bytes (the pointer value). The caller receives these 8 bytes and has a pointer to the service actor's memory -- which may or may not still be valid.

Actually, looking at the runtime code more carefully: `mesh_gc_alloc_actor` allocates from the CURRENT actor's heap (via `get_current_pid`). The service handler runs as the service actor. So any heap allocations are in the service actor's heap. The caller is a different actor. The pointer is in the service actor's address space. BUT -- all actors share the same process address space, so the pointer IS valid. The GC issue is that the service actor might GC the allocation later, but during the synchronous call the service is blocked in its receive loop, so it won't GC.

So the pointer IS valid. The issue is purely on the caller side: the caller gets an i64 that happens to be a pointer but treats it as a raw value.

**THE SIMPLEST CORRECT FIX:**

In `codegen_service_call_helper`, the reply_val (i64) IS the value as stored in the tuple. For the calling code to work correctly:

- If the actual reply type is a scalar (Int, Bool, Float), the i64 IS the value. Return as i64. Already works.
- If the actual reply type is a pointer (String, Ptr), the i64 IS the pointer (ptrtoint). Return as i64, caller will inttoptr. Already works.
- If the actual reply type is a SumType (e.g., String!String), the i64 is EITHER:
  - The struct value bitcast to i64 (if struct size <= 8) -- return as i64, caller will bitcast back
  - A pointer to a heap-allocated struct (if struct size > 8) -- return as i64 (pointer-as-i64)

For the sum type case with > 8 bytes: the calling code receives the pointer-as-i64. But the calling code expects a struct value `{i8, ptr}`, not a pointer to one.

**FIX: Return the reply as a pointer value, and let the caller load through it if needed.**

Change `codegen_service_call_helper` to:
1. Load reply_val as i64 (current)
2. Convert to pointer: `inttoptr i64 reply_val to ptr`
3. Return the pointer value

Then the calling code will have a pointer, and if it needs the actual struct value, it will load through the pointer. This is consistent with how the handler function's return type is `MirType::Ptr`.

Wait -- but the service call stub's return type IS `MirType::Ptr` (since `mesh_service_call` returns Ptr). So the stub already returns a Ptr. The issue is that the codegen for the stub function does `Ok(reply_val)` where `reply_val` is an i64, but the function signature says it returns Ptr. This causes an LLVM type mismatch.

**Check how the stub function handles the return value.** The stub function body is `MirExpr::Call("mesh_service_call", ...)`. The codegen_expr intercepts calls to "mesh_service_call" and routes to `codegen_service_call_helper`. This returns `reply_val` as i64. But the stub function has return type Ptr. The function codegen will try to return this i64 where Ptr is expected.

Actually, in the codegen, return value coercion happens at the function level. Let me check...

The fix is simple: in `codegen_service_call_helper`, convert the reply i64 to a pointer before returning it, since the function's return type is `MirType::Ptr`:

```rust
// Convert reply i64 to pointer (tuple stores values as i64, but service calls return Ptr)
let reply_ptr = self.builder
    .build_int_to_ptr(reply_val.into_int_value(), ptr_ty, "reply_ptr")
    .map_err(|e| e.to_string())?;
Ok(reply_ptr.into())
```

Then in the Mesh code that uses the service call result, when it does:
```mesh
let result = EventProcessor.process_event(pid, project_id, writer_pid, body)
```
The `result` will be a pointer. Pattern matching on `result` will need to handle the fact that the value is a pointer to the sum type struct, not the struct itself.

**Actually, I think the deeper issue is different.** Let me reconsider.

The service call stub function (`__service_eventprocessor_call_process_event`) has this body:
- Call `mesh_service_call(pid, tag, args)` -> returns Ptr
- The Ptr is returned as the function result

The calling Mesh code calls `EventProcessor.process_event(pid, args)` which resolves to calling this stub. The stub returns Ptr. But the Mesh code expects the result to be `String!String` (a Result). The MIR lowerer generates a call to the stub and uses the result as the reply type.

**The problem**: The Mesh type system says `process_event` returns `String!String`. But the stub function returns `Ptr` (raw pointer). The type checker resolves this, and the calling code treats the return value as `String!String`. If the result is a pointer and the code tries to extract the tag byte via struct_gep on a pointer, it will work -- but only if the pointer points to a valid `{i8, ptr}` struct.

So the chain is:
1. Service handler body creates `(state, Ok(issue_id))` -- a tuple
2. Tuple stores: `state` as i64 (or heap-boxed ptr-as-i64 if >8 bytes), `Ok(issue_id)` as i64 (or heap-boxed ptr-as-i64)
3. Service loop extracts reply via `mesh_tuple_second` -> gets i64
4. Service loop sends 8 bytes (the i64 reply)
5. Caller loads 8 bytes as i64
6. Caller returns i64 from stub (as Ptr via inttoptr)
7. Mesh code pattern-matches on the "Ptr" as if it's a `String!String` struct

Step 7 is where it fails. The code does `case result do Ok(id) -> ... end`. The pattern match codegen tries to load the tag byte from the value. If the value is a Ptr (pointer to a heap-allocated `{i8, ptr}` struct), then loading the tag from the pointer WOULD work. But if the value is the struct value bitcast to i64 (small struct path), then interpreting i64 as `{i8, ptr}` will give garbage.

For `String!String`:
- Layout: `{i8, ptr}` = 16 bytes
- Tuple storage: 16 > 8 bytes, so heap-allocated, stored as pointer-as-i64
- `mesh_tuple_second` returns the pointer-as-i64
- Service reply sends this pointer-as-i64
- Caller loads i64 = pointer value
- If caller does inttoptr, gets valid pointer to the `{i8, ptr}` struct in service actor's heap
- Pattern matching on this pointer: works because pointer is valid in shared address space

For `ProcessorState` (the state part):
- Layout: `{i64 pool, i64 count}` = 16 bytes (two i64 fields)
- Tuple storage: 16 > 8 bytes, so heap-allocated, stored as pointer-as-i64
- `mesh_tuple_first` returns the pointer-as-i64
- Service loop does `inttoptr(new_state_val) -> load(state_llvm_ty, ptr)` which loads the struct from the heap pointer
- This SHOULD work if the heap pointer is valid

**So what's actually causing the segfault?** Let me re-examine.

The service stub returns Ptr. But wait -- looking at the code more carefully:

In `codegen_service_call_helper` (line 3979-3983):
```rust
let reply_val = self.builder
    .build_load(i64_ty, reply_data_ptr, "reply_val")
    .map_err(|e| e.to_string())?;
Ok(reply_val)  // Returns BasicValueEnum which is an IntValue (i64)
```

The stub function has return type `MirType::Ptr` (because mesh_service_call returns Ptr). But `reply_val` is an `IntValue(i64)`. The function codegen will try to `build_return(Some(&reply_val))` where the function signature expects a Ptr return type. This is an LLVM type mismatch (returning i64 where ptr is expected), which may cause undefined behavior or crashes.

**FIX: Convert reply_val to ptr before returning:**

In `codegen_service_call_helper`, change the return from:
```rust
Ok(reply_val)
```
to:
```rust
let reply_as_ptr = self.builder
    .build_int_to_ptr(reply_val.into_int_value(), ptr_ty, "reply_as_ptr")
    .map_err(|e| e.to_string())?;
Ok(reply_as_ptr.into())
```

This gives the caller a valid pointer. The calling Mesh code receives this pointer and uses it as `String!String`. The pattern match codegen will load the tag byte from the pointer (via struct_gep on the `{i8, ptr}` layout), which works because the pointer points to valid data in the shared address space.

**BUT ALSO:** The value stored in the tuple for the reply is a POINTER to a heap-allocated `{i8, ptr}` struct. So the caller gets a valid pointer to the actual Result struct.

However, the caller code expects the value to be a STRUCT VALUE, not a pointer. When codegen does pattern matching on a SumType value, it allocates the struct on the stack and does struct_gep. If the value is a pointer, it needs to load through the pointer first.

**This is where Plan 01's fix interacts with Plan 02.** Once Plan 01 fixes the codegen to use pointer-boxing for struct payloads in sum types, and fixes the pattern matching to handle pointer-boxed variants, then the service call reply will work naturally because:
1. The reply value is a pointer to the heap-allocated sum type struct
2. The caller receives this pointer
3. The code that destructures the sum type knows to handle pointer-boxed values (from Plan 01's fix)

**Actually, the interaction is different.** Plan 01 fixes ConstructVariant for struct-inside-Result. Plan 02 needs to fix the service call path specifically.

Let me think about this differently. The real issue for the EventProcessor case:

The handler body returns `(state, Ok(issue_id))`. This is a tuple. The Ok(issue_id) is a `String!String` Result. In the tuple:
- `Ok(issue_id)` is a `{i8, ptr}` struct (16 bytes).
- Since 16 > 8, tuple codegen heap-allocates it and stores the pointer as i64.
- `mesh_tuple_second` returns the pointer-as-i64.
- Service loop sends 8 bytes (the pointer-as-i64).
- Caller loads 8 bytes as i64.
- `codegen_service_call_helper` returns this i64.
- The calling code expects a `String!String` value.

The i64 is a pointer to the `{i8, ptr}` struct. The calling code needs to know this is a pointer and load through it.

**FIX in `codegen_service_call_helper`:**

Return the i64 as a pointer (`inttoptr`). Then where the calling Mesh code uses this value as a SumType, the pattern match codegen needs to handle the pointer-to-struct case. This is standard -- when a variable holds a pointer and the code needs the struct value, do `build_load(struct_type, ptr, name)`.

Actually, looking at how pattern matching works on SumType values in expr.rs:

```rust
let scrutinee_alloca = if matches!(scrutinee_ty, MirType::SumType(_))
```

It allocates, stores the scrutinee value, and then does struct_gep on the alloca. If the scrutinee value IS a pointer (not a struct value), storing it into an alloca and then doing struct_gep won't work -- you'd be interpreting the pointer bits as a struct.

**THE COMPLETE FIX:**

1. In `codegen_service_call_helper`: convert reply i64 to ptr
2. In the code that uses the service call result: when the expected type is a SumType or Struct, and the actual LLVM value is a pointer, load the struct value through the pointer before using it

This second part is a general "pointer coercion" fix. When a value is a pointer but the expected type is a by-value struct/sum, load through the pointer.

**Implementation:**

In `codegen_service_call_helper` (line 3972-3983):

Replace:
```rust
let reply_val = self.builder
    .build_load(i64_ty, reply_data_ptr, "reply_val")
    .map_err(|e| e.to_string())?;
Ok(reply_val)
```

With:
```rust
// Load reply as i64 (raw tuple-encoded value)
let reply_i64 = self.builder
    .build_load(i64_ty, reply_data_ptr, "reply_i64")
    .map_err(|e| e.to_string())?
    .into_int_value();

// The reply is a tuple-encoded i64. For complex types (structs, sum types > 8 bytes),
// the tuple stores a heap pointer as i64. Convert to pointer so callers can
// load through it when needed. For scalar types (Int, Bool), this creates an
// invalid pointer, but the caller will ptrtoint it back to i64 when using as Int.
let reply_ptr = self.builder
    .build_int_to_ptr(reply_i64, ptr_ty, "reply_ptr")
    .map_err(|e| e.to_string())?;
Ok(reply_ptr.into())
```

**Note on pointer-to-struct coercion:** The let-binding codegen in `codegen_expr` (around line 1502-1517) already handles this case. When a call returns a PointerValue but the variable type is `MirType::SumType(_) | MirType::Struct(_)` and the LLVM type is not a pointer type, the existing code does `build_load(llvm_ty, pointer_val, "deref_sum")` to dereference the pointer into the by-value struct. This means once `codegen_service_call_helper` returns a pointer (via the `inttoptr` fix above), the let-binding path will automatically load the actual struct value through it. No additional coercion code is needed.

**Verify this during implementation:** After applying the `inttoptr` fix in `codegen_service_call_helper`, confirm that a let-binding like `let result = EventProcessor.process_event(...)` hits the existing coercion path at line 1508-1514. If the coercion does NOT fire (e.g., because the return type resolves to `MirType::Ptr` instead of `MirType::SumType`), then you will need to also fix the MIR type resolution for service call stubs so the let-binding knows the actual expected type is a SumType. But based on the current code, the MIR type system tracks the user-declared return type (`String!String` -> `MirType::SumType`), not the stub's `MirType::Ptr`, so the coercion should fire.

**ALSO fix the state extraction in `codegen_service_loop` (line 3633-3654):**

For struct state types, the current code does:
```rust
} else if state_llvm_ty.is_struct_type() {
    let state_ptr = self.builder
        .build_int_to_ptr(new_state_val, ptr_ty, "new_state_struct_ptr")?;
    self.builder
        .build_load(state_llvm_ty, state_ptr, "new_state_struct")?
}
```

This is correct for the large struct path (tuple stores pointer-as-i64). However, verify that this works for ALL struct state types, not just large ones. If the struct state has exactly 8 bytes (e.g., a single-field struct), the tuple stores it as a bitcast i64, and `inttoptr` + `load` would crash because the i64 is NOT a valid pointer.

To fix: check the state struct size. If <= 8 bytes, bitcast from i64. If > 8 bytes, use the inttoptr+load path. Apply the same logic as the tuple codegen uses to determine storage strategy.
  </action>
  <verify>
1. `cargo test -p mesh-codegen` -- all tests pass
2. `cargo test -p mesh-rt` -- all tests pass
3. `cargo build -p meshc` -- compiler builds successfully
4. Compile a Mesh program that has a service returning `String!String`, calls it, and pattern-matches: `meshc build` succeeds without errors (validates inttoptr + let-binding coercion end-to-end)
  </verify>
  <done>
Service call reply value is returned as a pointer from `codegen_service_call_helper`. Calling code that expects SumType/Struct values loads through the pointer. Service loop state extraction handles both small (bitcast) and large (pointer) struct encoding. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- full test suite passes
2. `cargo build -p meshc` -- compiler builds
3. Compile the Mesher: `meshc build mesher` -- compiles without errors
4. Write a small Mesh test program (or use an existing test fixture) that defines a service returning a complex type (e.g., `String!String` or a struct), calls the service, and pattern-matches the reply. Compile it with `meshc build` and verify it compiles without errors. This validates the `inttoptr` fix and the let-binding coercion interact correctly BEFORE Plan 03's live endpoint test depends on it.
</verification>

<success_criteria>
- Service call handlers returning complex types (tuples with structs and sum types) work across the actor message boundary
- The reply value is properly typed as a pointer and callers dereference it when expecting struct/sum-type values
- State extraction in the service loop handles both small and large struct states correctly
- All cargo tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/105.1-fix-codegen-abi-issues-and-workarounds-from-phase-105/105.1-02-SUMMARY.md`
</output>
