---
phase: 101-migration-system
plan: 03
type: execute
wave: 2
depends_on: ["101-01"]
files_modified:
  - crates/meshc/src/migrate.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "meshc migrate generate <name> creates migrations/ directory if not exists and writes a timestamped .mpl scaffold file with up/down function stubs"
    - "Generated scaffold file has correct format: pub fn up(pool :: PoolHandle) -> Int!String and pub fn down(pool :: PoolHandle) -> Int!String with commented guidance"
    - "Timestamp prefix is YYYYMMDDHHMMSS format derived from current UTC time"
    - "Generated filename follows convention: {timestamp}_{name}.mpl in migrations/ directory"
  artifacts:
    - path: "crates/meshc/src/migrate.rs"
      provides: "generate_migration function + format_timestamp helper"
      contains: "generate_migration"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "E2e test for scaffold generation"
      contains: "test_migrate_generate"
  key_links:
    - from: "crates/meshc/src/main.rs"
      to: "crates/meshc/src/migrate.rs"
      via: "MigrateAction::Generate dispatches to migrate::generate_migration"
      pattern: "generate_migration"
---

<objective>
Implement `meshc migrate generate <name>` scaffold generation that creates timestamped migration files with up/down stubs, and add e2e tests for the migration CLI.

Purpose: Developers need a convenient way to create new migration files with the correct naming convention and function signatures, following the same scaffold pattern as `meshc init`.

Output: Working `meshc migrate generate` command + e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/101-migration-system/101-RESEARCH.md
@.planning/phases/101-migration-system/101-01-SUMMARY.md
@.planning/phases/101-migration-system/101-02-SUMMARY.md

# Reference for scaffold pattern:
@crates/mesh-pkg/src/scaffold.rs
@crates/meshc/src/migrate.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement scaffold generation and e2e tests</name>
  <files>
    crates/meshc/src/migrate.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
**Part A: Implement generate_migration in migrate.rs**

Replace the placeholder `generate_migration` function with a full implementation:

```rust
pub fn generate_migration(project_dir: &Path, name: &str) -> Result<(), String> {
    // Validate name: must be non-empty, only lowercase letters, digits, underscores
    if name.is_empty() {
        return Err("Migration name cannot be empty".to_string());
    }
    if !name.chars().all(|c| c.is_ascii_lowercase() || c.is_ascii_digit() || c == '_') {
        return Err("Migration name must contain only lowercase letters, digits, and underscores".to_string());
    }

    let migrations_dir = project_dir.join("migrations");
    std::fs::create_dir_all(&migrations_dir)
        .map_err(|e| format!("Failed to create migrations directory: {}", e))?;

    let timestamp = format_timestamp_now();
    let filename = format!("{}_{}.mpl", timestamp, name);
    let filepath = migrations_dir.join(&filename);

    let content = format!(
r#"# Migration: {name}
# Generated: {timestamp}

pub fn up(pool :: PoolHandle) -> Int!String do
  # Add your migration code here
  # Examples:
  #   Migration.create_table(pool, "users", [
  #     "id:UUID:PRIMARY KEY DEFAULT gen_random_uuid()",
  #     "name:TEXT:NOT NULL",
  #     "email:TEXT:NOT NULL UNIQUE",
  #     "inserted_at:TIMESTAMPTZ:NOT NULL DEFAULT now()",
  #     "updated_at:TIMESTAMPTZ:NOT NULL DEFAULT now()"
  #   ])?
  #
  #   Migration.create_index(pool, "users", ["email"], "unique:true")?
  #
  #   Migration.add_column(pool, "users", "age:BIGINT")?
  #
  #   Migration.execute(pool, "CREATE EXTENSION IF NOT EXISTS pgcrypto")?
  Ok(0)
end

pub fn down(pool :: PoolHandle) -> Int!String do
  # Add your rollback code here
  # Examples:
  #   Migration.drop_table(pool, "users")?
  #   Migration.drop_column(pool, "users", "age")?
  #   Migration.drop_index(pool, "users", ["email"])?
  Ok(0)
end
"#, name = name, timestamp = timestamp);

    std::fs::write(&filepath, content)
        .map_err(|e| format!("Failed to write migration file: {}", e))?;

    eprintln!("Created migration: migrations/{}", filename);
    Ok(())
}
```

**Implement format_timestamp_now():**

Generate a `YYYYMMDDHHMMSS` timestamp string from the current UTC time. Use only `std::time::SystemTime` -- no external chrono dependency:

```rust
fn format_timestamp_now() -> String {
    let secs = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs();
    format_timestamp(secs)
}

fn format_timestamp(secs: u64) -> String {
    // Convert Unix timestamp to UTC date/time components
    // Algorithm: days since epoch -> Gregorian calendar date
    let days = (secs / 86400) as i64;
    let time_of_day = secs % 86400;
    let hours = time_of_day / 3600;
    let minutes = (time_of_day % 3600) / 60;
    let seconds = time_of_day % 60;

    // Civil date from days since 1970-01-01 (Howard Hinnant algorithm)
    let (year, month, day) = civil_from_days(days);

    format!("{:04}{:02}{:02}{:02}{:02}{:02}",
        year, month, day, hours, minutes, seconds)
}

/// Convert days since 1970-01-01 to (year, month, day).
/// Uses the Howard Hinnant algorithm from chrono-free date calculations.
fn civil_from_days(days: i64) -> (i64, u64, u64) {
    let z = days + 719468;
    let era = if z >= 0 { z } else { z - 146096 } / 146097;
    let doe = (z - era * 146097) as u64; // day of era [0, 146096]
    let yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365; // year of era [0, 399]
    let y = yoe as i64 + era * 400;
    let doy = doe - (365 * yoe + yoe / 4 - yoe / 100); // day of year [0, 365]
    let mp = (5 * doy + 2) / 153; // [0, 11]
    let d = doy - (153 * mp + 2) / 5 + 1; // day [1, 31]
    let m = if mp < 10 { mp + 3 } else { mp - 9 }; // month [1, 12]
    let y = if m <= 2 { y + 1 } else { y };
    (y, m as u64, d as u64)
}
```

**Part B: Add e2e tests**

Add tests in `crates/meshc/tests/e2e.rs`:

1. `test_migrate_generate_creates_file` -- Run `meshc migrate generate create_users` in a temp directory. Verify:
   - `migrations/` directory was created
   - A file matching `*_create_users.mpl` exists in `migrations/`
   - File contains `pub fn up(pool :: PoolHandle) -> Int!String do`
   - File contains `pub fn down(pool :: PoolHandle) -> Int!String do`
   - Filename starts with 14-digit timestamp

2. `test_migrate_generate_invalid_name` -- Run `meshc migrate generate "Create Users"` (contains uppercase and space). Verify it returns an error about invalid name characters.

3. `test_migrate_generate_scaffold_compiles` -- Generate a scaffold, then verify the generated file compiles successfully as part of a migration project (create a temp main.mpl that imports and uses it). This validates the scaffold template produces syntactically valid Mesh code.

For the e2e tests, use `std::process::Command::new(meshc_binary_path).arg("migrate").arg("generate").arg(name).current_dir(tmp_dir)` pattern. Build the meshc binary first using `cargo build -p meshc` and locate it in the target directory.

Alternatively, if e2e tests in this project call `build()` directly as a library function rather than spawning a process, follow the existing test pattern in e2e.rs.
  </action>
  <verify>
Run `cargo test -p meshc --test e2e` -- all tests pass including new migrate generate tests. Run `cargo build --workspace` -- clean build.
  </verify>
  <done>
`meshc migrate generate <name>` creates timestamped scaffold files with correct up/down stubs. Timestamp is UTC YYYYMMDDHHMMSS. migrations/ directory created automatically. E2e tests verify file creation, content format, and compilation of generated scaffold.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p meshc --test e2e` -- all tests pass including migrate generate tests
2. `cargo build --workspace` -- full workspace compiles
3. Manual test: `meshc migrate generate create_users` creates `migrations/YYYYMMDDHHMMSS_create_users.mpl` with valid Mesh syntax
</verification>

<success_criteria>
- `meshc migrate generate <name>` creates a properly formatted migration scaffold
- Timestamp prefix is YYYYMMDDHHMMSS in UTC
- Scaffold contains documented up/down stubs with example DSL usage
- Name validation rejects invalid characters
- migrations/ directory created if not exists
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/101-migration-system/101-03-SUMMARY.md`
</output>
