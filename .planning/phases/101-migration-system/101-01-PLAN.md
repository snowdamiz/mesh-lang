---
phase: 101-migration-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-rt/src/db/migration.rs
  - crates/mesh-rt/src/db/mod.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-repl/src/jit.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Migration.create_table(pool, table, columns) generates CREATE TABLE IF NOT EXISTS DDL with quoted identifiers and executes it"
    - "Migration.drop_table(pool, table) generates DROP TABLE IF EXISTS DDL and executes it"
    - "Migration.add_column, drop_column, rename_column generate correct ALTER TABLE DDL and execute"
    - "Migration.create_index with unique option generates CREATE UNIQUE INDEX DDL; Migration.drop_index generates DROP INDEX DDL"
    - "Migration.execute(pool, sql) executes arbitrary raw SQL as an escape hatch"
    - "All 8 Migration module functions are callable from Mesh code via Module.function() syntax"
  artifacts:
    - path: "crates/mesh-rt/src/db/migration.rs"
      provides: "DDL SQL builder functions + extern C wrappers"
      contains: "build_create_table_sql"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Migration module type signatures"
      contains: "Migration"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Migration known_functions registration"
      contains: "Migration"
    - path: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM intrinsic declarations for 8 Migration functions"
      contains: "mesh_migration_create_table"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "Migration module registered in both typeck and lowerer"
      pattern: "Migration"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      via: "known_functions map to LLVM intrinsic names"
      pattern: "mesh_migration_"
    - from: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      to: "crates/mesh-rt/src/db/migration.rs"
      via: "LLVM intrinsics resolve to extern C functions at link time"
      pattern: "mesh_migration_"
---

<objective>
Implement the Migration DSL as runtime Rust functions that build DDL SQL and execute it via Pool.execute, registered across the full compiler pipeline (typeck, MIR lowerer, LLVM intrinsics, JIT).

Purpose: Migration files need DDL helper functions (create_table, drop_table, add_column, drop_column, rename_column, create_index, drop_index, execute) callable from Mesh code. This follows the exact same pattern as the Orm module (Phase 97-02) and Repo module (Phase 98).

Output: 8 Migration module functions callable from Mesh, with pure Rust DDL builder helpers + extern C wrappers + unit tests + e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/101-migration-system/101-RESEARCH.md

# Prior art -- follow the EXACT same pattern:
@crates/mesh-rt/src/db/orm.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/codegen/intrinsics.rs
@crates/mesh-repl/src/jit.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Migration DDL builder functions in mesh-rt</name>
  <files>
    crates/mesh-rt/src/db/migration.rs
    crates/mesh-rt/src/db/mod.rs
    crates/mesh-rt/src/lib.rs
  </files>
  <action>
Create `crates/mesh-rt/src/db/migration.rs` with pure Rust DDL builder helpers and extern C wrappers. Follow the exact same pattern as `orm.rs`: pure Rust `pub(crate) fn build_*_sql()` helpers for unit testability, plus `#[no_mangle] pub extern "C" fn mesh_migration_*()` wrappers that parse Mesh values and call the helpers.

**Pure Rust helpers (8 functions):**

1. `build_create_table_sql(table: &str, columns: &[String]) -> String` -- Generates `CREATE TABLE IF NOT EXISTS "table" (col_defs)`. Each column entry is colon-separated: `"name:TYPE:CONSTRAINTS"` (3 parts) or `"name:TYPE"` (2 parts). Use `quote_ident()` from orm.rs for table and column name quoting.

2. `build_drop_table_sql(table: &str) -> String` -- Generates `DROP TABLE IF EXISTS "table"`.

3. `build_add_column_sql(table: &str, column_def: &str) -> String` -- Generates `ALTER TABLE "table" ADD COLUMN IF NOT EXISTS "col" TYPE CONSTRAINTS`. Column def uses same colon encoding as create_table.

4. `build_drop_column_sql(table: &str, column: &str) -> String` -- Generates `ALTER TABLE "table" DROP COLUMN IF EXISTS "col"`.

5. `build_rename_column_sql(table: &str, old_name: &str, new_name: &str) -> String` -- Generates `ALTER TABLE "table" RENAME COLUMN "old" TO "new"`.

6. `build_create_index_sql(table: &str, columns: &[String], options: &str) -> String` -- Generates `CREATE [UNIQUE] INDEX IF NOT EXISTS "idx_table_col1_col2" ON "table" ("col1", "col2")`. Parse `unique:true` from options string. Support `where:` for partial index WHERE clause.

7. `build_drop_index_sql(table: &str, columns: &[String]) -> String` -- Generates `DROP INDEX IF EXISTS "idx_table_col1_col2"`.

8. No pure helper needed for `execute` -- it is a passthrough to Pool.execute.

**Extern C wrappers (8 functions):**

Each wrapper follows the orm.rs pattern: receives `pool: u64`, Mesh string pointers, and Mesh list pointers. Converts Mesh values to Rust, calls the pure helper to build SQL, then calls `mesh_pool_execute(pool, sql_ptr, empty_params)` to execute the DDL.

- `mesh_migration_create_table(pool: u64, table: *const MeshString, columns: *mut u8) -> *mut u8` -- columns is List<String>
- `mesh_migration_drop_table(pool: u64, table: *const MeshString) -> *mut u8`
- `mesh_migration_add_column(pool: u64, table: *const MeshString, column_def: *const MeshString) -> *mut u8`
- `mesh_migration_drop_column(pool: u64, table: *const MeshString, column: *const MeshString) -> *mut u8`
- `mesh_migration_rename_column(pool: u64, table: *const MeshString, old_name: *const MeshString, new_name: *const MeshString) -> *mut u8`
- `mesh_migration_create_index(pool: u64, table: *const MeshString, columns: *mut u8, options: *const MeshString) -> *mut u8`
- `mesh_migration_drop_index(pool: u64, table: *const MeshString, columns: *mut u8) -> *mut u8`
- `mesh_migration_execute(pool: u64, sql: *const MeshString) -> *mut u8` -- thin wrapper that calls `mesh_pool_execute(pool, sql, mesh_list_new())`

**Reuse from orm.rs:** Import `quote_ident` from `super::orm` (or make it `pub(crate)` if not already). Reuse `MeshString`, `rust_str_to_mesh`, `mesh_list_new`, `mesh_pool_execute` from existing db modules.

**List-to-strings helper:** Create a `list_to_strings(list_ptr: *mut u8) -> Vec<String>` helper that iterates a Mesh List<String>, extracting each element as a Rust String. Use the same list introspection pattern as repo.rs (mesh_list_length + mesh_list_get or direct struct access).

**Unit tests:** Add a `#[cfg(test)] mod tests` block with tests for each pure SQL helper:
- `test_build_create_table_sql` -- verify columns with 2 and 3 parts, quoting
- `test_build_drop_table_sql` -- verify IF EXISTS
- `test_build_add_column_sql` -- verify ALTER TABLE format
- `test_build_drop_column_sql` -- verify column name quoting
- `test_build_rename_column_sql` -- verify old and new names
- `test_build_create_index_sql` -- verify regular and UNIQUE index
- `test_build_create_index_sql_partial` -- verify WHERE clause from options
- `test_build_drop_index_sql` -- verify index name format

**Module registration:** Add `pub mod migration;` in `crates/mesh-rt/src/db/mod.rs`. Add re-exports of all 8 `mesh_migration_*` functions in `crates/mesh-rt/src/lib.rs` (follow the pattern of existing `mesh_orm_*` and `mesh_repo_*` re-exports).
  </action>
  <verify>
Run `cargo test -p mesh-rt --lib` -- all unit tests in migration.rs pass. Run `cargo build -p mesh-rt` -- compiles cleanly with no warnings.
  </verify>
  <done>
8 pure Rust DDL builder helpers produce correct SQL strings verified by unit tests. 8 extern C wrappers are compiled and linked. migration.rs is registered in db/mod.rs and lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Migration module across compiler pipeline + e2e tests</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-repl/src/jit.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
Register the Migration module across all 4 compiler pipeline stages, following the EXACT pattern used by Orm (Phase 97-02). The pattern is: typeck signatures -> MIR known_functions -> LLVM intrinsic declarations -> JIT symbol mappings.

**1. Type checker (infer.rs):**

In the stdlib module registration section (where Pool, Orm, Repo, Changeset, Query modules are registered), add a Migration module block:

```
// ── Migration module (Phase 101) ─────────────────────────
let mut migration_mod = FxHashMap::default();
```

Register 8 function signatures using existing type constructors (pool_handle_t, Ty::string(), Ty::list(), Ty::result(), Ty::int()):

- `create_table`: `fn(PoolHandle, String, List<String>) -> Result<Int, String>`
- `drop_table`: `fn(PoolHandle, String) -> Result<Int, String>`
- `add_column`: `fn(PoolHandle, String, String) -> Result<Int, String>`
- `drop_column`: `fn(PoolHandle, String, String) -> Result<Int, String>`
- `rename_column`: `fn(PoolHandle, String, String, String) -> Result<Int, String>`
- `create_index`: `fn(PoolHandle, String, List<String>, String) -> Result<Int, String>`
- `drop_index`: `fn(PoolHandle, String, List<String>) -> Result<Int, String>`
- `execute`: `fn(PoolHandle, String) -> Result<Int, String>`

Insert into `modules.insert("Migration".to_string(), migration_mod);`
Add `"Migration"` to `STDLIB_MODULE_NAMES` array.

**2. MIR lowerer (lower.rs):**

In `known_functions` HashMap, add 8 entries mapping Mesh function names to extern C names:
- `"Migration.create_table"` -> `"mesh_migration_create_table"`
- `"Migration.drop_table"` -> `"mesh_migration_drop_table"`
- `"Migration.add_column"` -> `"mesh_migration_add_column"`
- `"Migration.drop_column"` -> `"mesh_migration_drop_column"`
- `"Migration.rename_column"` -> `"mesh_migration_rename_column"`
- `"Migration.create_index"` -> `"mesh_migration_create_index"`
- `"Migration.drop_index"` -> `"mesh_migration_drop_index"`
- `"Migration.execute"` -> `"mesh_migration_execute"`

Add `"Migration"` to `STDLIB_MODULES` array.
Add entries in `map_builtin_name` match for `"Migration"` module (same pattern as Orm/Repo).

**3. LLVM intrinsics (intrinsics.rs):**

Declare 8 LLVM function intrinsics. Follow the exact pattern from Orm module:

- `mesh_migration_create_table(pool: i64, table: ptr, columns: ptr) -> ptr` -- 3 params (i64, ptr, ptr)
- `mesh_migration_drop_table(pool: i64, table: ptr) -> ptr` -- 2 params (i64, ptr)
- `mesh_migration_add_column(pool: i64, table: ptr, col_def: ptr) -> ptr` -- 3 params (i64, ptr, ptr)
- `mesh_migration_drop_column(pool: i64, table: ptr, col: ptr) -> ptr` -- 3 params (i64, ptr, ptr)
- `mesh_migration_rename_column(pool: i64, table: ptr, old: ptr, new: ptr) -> ptr` -- 4 params (i64, ptr, ptr, ptr)
- `mesh_migration_create_index(pool: i64, table: ptr, cols: ptr, opts: ptr) -> ptr` -- 4 params (i64, ptr, ptr, ptr)
- `mesh_migration_drop_index(pool: i64, table: ptr, cols: ptr) -> ptr` -- 3 params (i64, ptr, ptr)
- `mesh_migration_execute(pool: i64, sql: ptr) -> ptr` -- 2 params (i64, ptr)

All return ptr (Result encoding as tagged pointer). Use `declare_function` with the appropriate `FunctionType` for each parameter count.

**4. JIT symbol mappings (jit.rs):**

Add 8 entries mapping function names to function pointers in the JIT symbol resolution section:
```
"mesh_migration_create_table" => mesh_rt::mesh_migration_create_table as *const u8,
// ... etc for all 8
```

**5. E2e tests (e2e.rs):**

Add e2e tests that verify the Migration module functions compile and generate correct SQL. Since these functions require a live database connection, the tests should verify compilation success and type checking, not runtime execution:

- `test_migration_create_table_compiles` -- Verify that `Migration.create_table(pool, "users", ["id:UUID:PRIMARY KEY", "name:TEXT:NOT NULL"])` type-checks and compiles
- `test_migration_drop_table_compiles` -- Verify `Migration.drop_table(pool, "users")` compiles
- `test_migration_add_column_compiles` -- Verify `Migration.add_column(pool, "users", "age:BIGINT")` compiles
- `test_migration_create_index_compiles` -- Verify `Migration.create_index(pool, "users", ["email"], "unique:true")` compiles
- `test_migration_execute_compiles` -- Verify `Migration.execute(pool, "CREATE EXTENSION IF NOT EXISTS pgcrypto")` compiles

Use the compile-only test pattern: write a Mesh program to a temp file, compile it, verify compilation succeeds (exit code 0, no error output). The test programs should use a dummy pool value since they won't actually execute.
  </action>
  <verify>
Run `cargo test -p meshc --test e2e` -- all existing tests pass (zero regressions) plus new Migration tests pass. Run `cargo build --workspace` -- full workspace compiles with no errors.
  </verify>
  <done>
Migration module is registered in typeck (8 type signatures), MIR lowerer (8 known_functions), LLVM codegen (8 intrinsics), and JIT (8 symbol mappings). E2e tests verify Migration DSL functions compile from Mesh code. All existing tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p mesh-rt --lib` -- migration.rs unit tests pass (8+ tests for DDL SQL builders)
2. `cargo test -p meshc --test e2e` -- all e2e tests pass including new Migration module tests
3. `cargo build --workspace` -- full workspace compiles cleanly
4. Migration SQL builders produce correctly quoted identifiers and IF NOT EXISTS/IF EXISTS clauses
</verification>

<success_criteria>
- 8 Migration module functions are callable from Mesh code
- Pure Rust DDL builders produce correct PostgreSQL DDL SQL
- Column definition colon-encoding works for 2-part and 3-part entries
- CREATE INDEX supports unique option and partial index WHERE clause
- Migration.execute provides raw SQL escape hatch
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/101-migration-system/101-01-SUMMARY.md`
</output>
