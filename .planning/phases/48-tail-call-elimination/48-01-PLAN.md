---
phase: 48-tail-call-elimination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "MirExpr::TailCall variant exists and can represent a self-recursive tail call with args and ty"
    - "MirFunction has a has_tail_calls bool flag that is true when the body contains TailCall nodes"
    - "rewrite_tail_calls correctly rewrites self-recursive Call nodes in tail position to TailCall nodes"
    - "Tail position is correctly propagated through Block (last), Let (body), If (both branches), Match (all arms), ActorReceive (all arms + timeout), and Return (inner)"
    - "Non-tail positions (call args, conditions, scrutinees, let values, earlier block exprs) are NOT rewritten"
    - "The rewrite pass runs after lowering every function body (lower_fn_def, lower_impl_method, lower_actor_def)"
  artifacts:
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "MirExpr::TailCall variant and has_tail_calls field on MirFunction"
      contains: "TailCall"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "rewrite_tail_calls function and integration into all function lowering paths"
      contains: "rewrite_tail_calls"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "rewrite_tail_calls creates MirExpr::TailCall nodes and sets MirFunction.has_tail_calls"
      pattern: "MirExpr::TailCall"
---

<objective>
Add the MIR-level infrastructure for tail-call elimination: a new `MirExpr::TailCall` variant, a `has_tail_calls` flag on `MirFunction`, and a post-lowering rewrite pass that detects self-recursive calls in tail position and rewrites them to `TailCall` nodes.

Purpose: This is the analysis/transformation half of TCE. Without it, codegen has no way to distinguish tail-recursive calls from normal calls. The rewrite pass is where tail position detection happens -- the core algorithmic challenge of TCE.

Output: Modified `mir/mod.rs` with new variant/field, modified `lower.rs` with rewrite pass integrated into all function lowering paths.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-tail-call-elimination/48-RESEARCH.md
@crates/snow-codegen/src/mir/mod.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MirExpr::TailCall variant and MirFunction.has_tail_calls field</name>
  <files>crates/snow-codegen/src/mir/mod.rs</files>
  <action>
1. Add a new variant to the `MirExpr` enum:
```rust
/// Self-recursive tail call (rewritten from Call during TCE pass).
/// Codegen compiles this as parameter reassignment + branch to loop header.
TailCall {
    /// Arguments for the recursive call (assigned to function parameters).
    args: Vec<MirExpr>,
    /// Result type (function return type, but ty() returns Never since it branches).
    ty: MirType,
},
```
Place it after the `Continue` variant (in the loop primitives section), or create a new "TCE primitives" section comment.

2. Add `has_tail_calls: bool` field to `MirFunction` struct, after the `captures` field:
```rust
/// Whether the function body contains TailCall nodes (set by TCE rewrite pass).
/// When true, codegen wraps the function body in a loop.
pub has_tail_calls: bool,
```

3. Add the `ty()` match arm for `TailCall` in the `impl MirExpr` block. It must return `&MirType::Never` (same as Break/Continue/Return -- TailCall never produces a value, it branches):
```rust
MirExpr::TailCall { .. } => &MirType::Never,
```

4. Verify the project still compiles with `cargo check -p snow-codegen`. There will be non-exhaustive pattern warnings in codegen/expr.rs since the new variant has no codegen handler yet -- that is expected and will be addressed in Plan 02.
  </action>
  <verify>
Run `cargo check -p snow-codegen 2>&1`. It should compile (possibly with warnings about non-exhaustive patterns in expr.rs for the new TailCall variant, but NO errors). Verify the new variant appears in mod.rs with `grep "TailCall" crates/snow-codegen/src/mir/mod.rs`.
  </verify>
  <done>
MirExpr::TailCall variant exists with args and ty fields. MirFunction has has_tail_calls: bool. ty() returns Never for TailCall. Crate compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement rewrite_tail_calls pass and integrate into all function lowering paths</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
1. Add a standalone function `rewrite_tail_calls(expr: &mut MirExpr, current_fn_name: &str) -> bool` at module level (outside the `Lowerer` impl, after the `resolve_type` helper function area, or at the bottom of the file). It returns `true` if any TailCall was created. Implementation:

```rust
/// Post-lowering rewrite pass: detect self-recursive calls in tail position
/// and rewrite them to TailCall nodes. Returns true if any rewrites were made.
fn rewrite_tail_calls(expr: &mut MirExpr, current_fn_name: &str) -> bool {
    match expr {
        MirExpr::Call { func, args, ty } => {
            // Check if this is a self-recursive call by name
            if let MirExpr::Var(name, _) = func.as_ref() {
                if name == current_fn_name {
                    let taken_args = std::mem::take(args);
                    let taken_ty = ty.clone();
                    *expr = MirExpr::TailCall { args: taken_args, ty: taken_ty };
                    return true;
                }
            }
            false
        }
        MirExpr::Block(exprs, _) => {
            // Only the LAST expression in a block is in tail position
            if let Some(last) = exprs.last_mut() {
                rewrite_tail_calls(last, current_fn_name)
            } else {
                false
            }
        }
        MirExpr::Let { body, .. } => {
            // The body (continuation) of a let is in tail position; the value is NOT
            rewrite_tail_calls(body, current_fn_name)
        }
        MirExpr::If { then_body, else_body, .. } => {
            // BOTH branches are in tail position; the condition is NOT
            let a = rewrite_tail_calls(then_body, current_fn_name);
            let b = rewrite_tail_calls(else_body, current_fn_name);
            a || b
        }
        MirExpr::Match { arms, .. } => {
            // All arm bodies are in tail position; the scrutinee is NOT
            let mut any = false;
            for arm in arms.iter_mut() {
                if rewrite_tail_calls(&mut arm.body, current_fn_name) {
                    any = true;
                }
            }
            any
        }
        MirExpr::ActorReceive { arms, timeout_body, .. } => {
            // All receive arm bodies and timeout body are in tail position
            let mut any = false;
            for arm in arms.iter_mut() {
                if rewrite_tail_calls(&mut arm.body, current_fn_name) {
                    any = true;
                }
            }
            if let Some(tb) = timeout_body.as_deref_mut() {
                if rewrite_tail_calls(tb, current_fn_name) {
                    any = true;
                }
            }
            any
        }
        MirExpr::Return(inner) => {
            // The inner expression of Return IS in tail position
            // (if inner is a self-call, the return just passes through the value)
            rewrite_tail_calls(inner, current_fn_name)
        }
        // Everything else is NOT a tail context -- do NOT recurse.
        // This includes: BinOp, UnaryOp, Call (non-self), ClosureCall, StructLit,
        // FieldAccess, ConstructVariant, MakeClosure, ListLit, While, ForIn*, etc.
        _ => false,
    }
}
```

CRITICAL: The `_ => false` default is correct. Do NOT recurse into non-tail positions (function call arguments, conditions, loop bodies, etc.) -- those are not tail contexts and self-calls there should remain as normal calls.

2. Integrate the rewrite pass into `lower_fn_def` (around line 870). After the body is lowered and before `self.functions.push(...)`, call the rewrite pass:

```rust
// TCE: Rewrite self-recursive tail calls to TailCall nodes (Phase 48).
let has_tail_calls = rewrite_tail_calls(&mut body, &fn_name);
```

Then update the `MirFunction` push to include the new field:
```rust
self.functions.push(MirFunction {
    name: fn_name,
    params,
    return_type,
    body,
    is_closure_fn: false,
    captures: Vec::new(),
    has_tail_calls,
});
```

NOTE on `fn_name`: The variable holding the qualified function name is computed BEFORE the body is lowered (around line 853-858 where `fn_name` is assigned). The rewrite pass must use this same qualified name because MIR Call nodes contain the qualified name (resolved through `map_builtin_name` / `qualify_name` during lowering). Make sure `body` is declared as `let mut body = ...` so it can be mutated by the rewrite pass.

3. Integrate into `lower_impl_method` (around line 997). Same pattern -- after body lowering, before the push:

```rust
let has_tail_calls = rewrite_tail_calls(&mut body, mangled_name);
```

Update the push to include `has_tail_calls`.

4. Integrate into `lower_actor_def` (around line 6491). Same pattern. The actor function name is the plain `name` variable. Apply the rewrite pass and include `has_tail_calls` in the push.

5. Also update ALL other places where `MirFunction` is constructed in `lower.rs` to include `has_tail_calls: false`. Search for all occurrences of `MirFunction {` in lower.rs and add the field. These include:
   - Lifted closure functions (search for `is_closure_fn: true`)
   - Terminate callback functions (around line 6473)
   - Monomorphized trait functions
   - Default method bodies
   - Any other MirFunction construction

For these non-user-facing functions (closures, callbacks), set `has_tail_calls: false` since they don't need TCE rewriting.

6. Ensure `body` is `let mut body = ...` in lower_fn_def, lower_impl_method, and lower_actor_def so the rewrite pass can mutate it.
  </action>
  <verify>
Run `cargo build -p snow-codegen 2>&1` -- must compile without errors. Then run `cargo test -p snow-codegen 2>&1` to verify existing tests still pass. Search for all `MirFunction {` constructors: `grep -n "MirFunction {" crates/snow-codegen/src/mir/lower.rs` and confirm each one includes `has_tail_calls`.
  </verify>
  <done>
rewrite_tail_calls function exists and correctly detects tail position through Block, Let, If, Match, ActorReceive, and Return. The rewrite pass is called after lowering in lower_fn_def, lower_impl_method, and lower_actor_def. All MirFunction constructors include has_tail_calls. The entire project compiles and existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-codegen` succeeds with no errors
2. `cargo test -p snow-codegen` passes all existing tests
3. `grep -c "TailCall" crates/snow-codegen/src/mir/mod.rs` returns at least 3 (variant def, ty match, has_tail_calls)
4. `grep -c "rewrite_tail_calls" crates/snow-codegen/src/mir/lower.rs` returns at least 4 (function def + 3 call sites)
5. `grep -c "has_tail_calls" crates/snow-codegen/src/mir/lower.rs` returns matches for all MirFunction constructors
6. Full e2e test suite still passes: `cargo test -p snowc --test e2e` (TCE is transparent -- no existing program behavior changes)
</verification>

<success_criteria>
- MirExpr::TailCall variant is defined with args: Vec<MirExpr> and ty: MirType
- MirExpr::TailCall.ty() returns &MirType::Never
- MirFunction.has_tail_calls: bool field exists
- rewrite_tail_calls function handles all 7 tail position contexts (Call, Block, Let, If, Match, ActorReceive, Return)
- The rewrite pass is integrated into lower_fn_def, lower_impl_method, and lower_actor_def
- All MirFunction constructors include has_tail_calls field
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/48-tail-call-elimination/48-01-SUMMARY.md`
</output>
