---
phase: 48-tail-call-elimination
plan: 02
type: execute
wave: 2
depends_on: ["48-01"]
files_modified:
  - crates/snow-codegen/src/codegen/mod.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - tests/e2e/tce_countdown.snow
  - tests/e2e/tce_param_swap.snow
  - tests/e2e/tce_case_arms.snow
  - tests/e2e/tce_actor_loop.snow
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "A self-recursive function counting down from 1,000,000 completes without stack overflow"
    - "A self-recursive function that swaps parameters produces correct results (args evaluated before storing)"
    - "Self-recursive tail calls through case/match arms are correctly eliminated"
    - "Actor receive loops using self-recursive tail calls run without growing the stack"
    - "Non-tail-recursive functions and normal calls are completely unaffected by TCE"
    - "Reduction checks are emitted before loop-back branches for proper actor scheduling"
  artifacts:
    - path: "crates/snow-codegen/src/codegen/mod.rs"
      provides: "Loop wrapping in compile_function when has_tail_calls is true"
      contains: "tce_loop"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "TailCall codegen: evaluate args, store to param allocas, branch to loop header"
      contains: "TailCall"
    - path: "tests/e2e/tce_countdown.snow"
      provides: "E2e test for 1M iteration countdown"
    - path: "tests/e2e/tce_param_swap.snow"
      provides: "E2e test for parameter swap correctness"
    - path: "tests/e2e/tce_case_arms.snow"
      provides: "E2e test for tail calls in case arms"
    - path: "tests/e2e/tce_actor_loop.snow"
      provides: "E2e test for actor receive loop with TCE"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "Rust test functions that run the Snow e2e test programs"
      contains: "tce_countdown"
  key_links:
    - from: "crates/snow-codegen/src/codegen/mod.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "compile_function reads func.has_tail_calls to decide loop wrapping"
      pattern: "has_tail_calls"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/mod.rs"
      via: "TailCall codegen reads tce_loop_header and tce_param_names from CodeGen"
      pattern: "tce_loop_header"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/mod.rs"
      via: "TailCall stores new values into self.locals param allocas and branches to tce_loop_header"
      pattern: "build_unconditional_branch"
---

<objective>
Implement the LLVM codegen for tail-call elimination: wrap tail-recursive function bodies in a loop, and compile TailCall nodes as parameter reassignment + branch to loop header. Validate with comprehensive e2e tests covering the main use cases: deep recursion, parameter swapping, case arm tail calls, and actor receive loops.

Purpose: This completes TCE by making the MIR-level TailCall nodes produce efficient loop-based LLVM IR. Without this, the TailCall nodes from Plan 01 would cause a codegen panic on the unhandled variant.

Output: Modified codegen files, 4 new e2e test programs, and test registrations in e2e.rs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-tail-call-elimination/48-RESEARCH.md
@.planning/phases/48-tail-call-elimination/48-01-SUMMARY.md
@crates/snow-codegen/src/codegen/mod.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-codegen/src/mir/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement loop wrapping in compile_function and TailCall codegen in expr.rs</name>
  <files>crates/snow-codegen/src/codegen/mod.rs, crates/snow-codegen/src/codegen/expr.rs</files>
  <action>
**Part A: Add TCE fields to CodeGen struct (codegen/mod.rs)**

Add two new fields to the `CodeGen` struct after `loop_stack`:

```rust
/// TCE loop header block for the current tail-recursive function.
/// Set during compile_function when has_tail_calls is true. NOT on loop_stack
/// (separate from user while/for loops so break/continue don't interfere).
pub(crate) tce_loop_header: Option<inkwell::basic_block::BasicBlock<'ctx>>,

/// Parameter names for the current tail-recursive function, in order.
/// Used by TailCall codegen to know which allocas to store into.
pub(crate) tce_param_names: Vec<String>,
```

Initialize both in the `CodeGen::new()` constructor: `tce_loop_header: None, tce_param_names: Vec::new()`.

**Part B: Modify compile_function for loop wrapping (codegen/mod.rs)**

In `compile_function`, after the parameter alloca setup (after the closure capture loading section, around line 436) and before the service loop check (line 439), add TCE loop wrapping logic:

```rust
// TCE: If this function has tail calls, wrap body in a loop.
// Create a loop header block that the TailCall codegen will branch back to.
if func.has_tail_calls {
    let tce_loop_bb = self.context.append_basic_block(fn_val, "tce_loop");
    self.builder.build_unconditional_branch(tce_loop_bb).map_err(|e| e.to_string())?;
    self.builder.position_at_end(tce_loop_bb);
    self.tce_loop_header = Some(tce_loop_bb);
    self.tce_param_names = func.params.iter().map(|(name, _)| name.clone()).collect();
}
```

After the function body compilation and return instruction (after the entire compile_function body block, before the `Ok(())`), clear the TCE state:

```rust
// Clear TCE state after function compilation.
self.tce_loop_header = None;
self.tce_param_names.clear();
```

Place the clear BEFORE the final `Ok(())`.

**Part C: Handle MirExpr::TailCall in codegen_expr (codegen/expr.rs)**

Add a new match arm in `codegen_expr` for `MirExpr::TailCall`. Place it near the Break/Continue handling since it has similar semantics (branches, returns Never):

```rust
MirExpr::TailCall { args, .. } => {
    let tce_loop_bb = self.tce_loop_header
        .ok_or("TailCall encountered but no TCE loop header set")?;

    // Step 1: Evaluate ALL arguments to temporary values FIRST.
    // This is critical: if args reference current params (e.g., swap(b, a)),
    // we must read all param values before overwriting any of them.
    let mut new_vals = Vec::with_capacity(args.len());
    for arg in args.iter() {
        new_vals.push(self.codegen_expr(arg)?);
    }

    // Step 2: Store all evaluated values into parameter allocas.
    for (i, param_name) in self.tce_param_names.iter().enumerate() {
        if let Some(&alloca) = self.locals.get(param_name) {
            self.builder
                .build_store(alloca, new_vals[i])
                .map_err(|e| e.to_string())?;
        }
    }

    // Step 3: Emit reduction check for preemptive scheduling.
    // Without this, tight tail-recursive loops would starve other actors.
    self.emit_reduction_check();

    // Step 4: Branch to loop header.
    self.builder
        .build_unconditional_branch(tce_loop_bb)
        .map_err(|e| e.to_string())?;

    // Return a dummy value -- this block is terminated, the value is never used.
    // Use i64 zero as the dummy (same pattern as Break/Continue).
    Ok(self.context.i64_type().const_zero().into())
}
```

CRITICAL DETAIL: The two-phase evaluation (evaluate all args THEN store all values) is essential for correctness. Without it, `swap(b, a)` would break because storing `b` into `a`'s alloca would corrupt `a` before reading it for `b`'s alloca.

Also verify that the codegen_expr function has a match arm covering TailCall. If there is a catch-all `_ =>` arm, the new arm must come before it.
  </action>
  <verify>
Run `cargo build -p snow-codegen 2>&1` -- must compile without errors or warnings about unhandled TailCall variants. Run `cargo test -p snow-codegen 2>&1` to verify existing tests pass.
  </verify>
  <done>
CodeGen has tce_loop_header and tce_param_names fields. compile_function creates a loop header block when has_tail_calls is true. TailCall codegen evaluates all args first, stores to param allocas, emits reduction check, branches to loop header. Crate compiles and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive e2e tests for tail-call elimination</name>
  <files>tests/e2e/tce_countdown.snow, tests/e2e/tce_param_swap.snow, tests/e2e/tce_case_arms.snow, tests/e2e/tce_actor_loop.snow, crates/snowc/tests/e2e.rs</files>
  <action>
Create 4 Snow e2e test programs and register them in the Rust e2e test file.

**Test 1: tce_countdown.snow** -- Deep recursion without stack overflow
```snow
fn countdown(n) do
  if n <= 0 then
    println("done")
  else
    countdown(n - 1)
  end
end

fn main() do
  countdown(1000000)
end
```
Expected output: `done`
This test proves TCE works -- 1,000,000 recursive calls would overflow the stack without it.

**Test 2: tce_param_swap.snow** -- Parameter swap correctness
```snow
fn swap_count(a, b, n) do
  if n <= 0 then
    println(a)
    println(b)
  else
    swap_count(b, a, n - 1)
  end
end

fn main() do
  swap_count(1, 2, 100001)
end
```
Expected output: `2\n1` (odd number of swaps means a and b are swapped from initial).
This test proves the two-phase argument evaluation is correct -- if args were stored sequentially, the swap would produce wrong results.

**Test 3: tce_case_arms.snow** -- Tail calls in case/match arms
```snow
fn process(cmd, acc) do
  case cmd do
    0 -> println(acc)
    1 -> process(0, acc + 10)
    2 -> process(1, acc + 20)
    _ -> process(0, acc)
  end
end

fn main() do
  process(2, 0)
end
```
Expected output: `30`
This test proves tail position detection works through case/match arms. The chain: process(2,0) -> process(1,20) -> process(0,30) -> println(30).

**Test 4: tce_actor_loop.snow** -- Actor receive loop with TCE
```snow
fn counter(n) do
  if n >= 5 then
    println(n)
  else
    receive do
      msg ->
        counter(n + 1)
    end
  end
end

fn main() do
  let pid = spawn counter(0)
  pid <- "tick"
  pid <- "tick"
  pid <- "tick"
  pid <- "tick"
  pid <- "tick"
  Timer.sleep(100)
end
```
Expected output: `5`
This test proves TCE works in actor receive loops -- the primary motivation for this feature.

**Register tests in crates/snowc/tests/e2e.rs:**

Add 4 new test functions following the existing pattern. Look at an existing test like `stdlib_list_sort` for the pattern:
```rust
#[test]
fn tce_countdown() {
    let source = std::fs::read_to_string("tests/e2e/tce_countdown.snow").unwrap();
    let output = compile_and_run(&source);
    assert_eq!(output.trim(), "done");
}

#[test]
fn tce_param_swap() {
    let source = std::fs::read_to_string("tests/e2e/tce_param_swap.snow").unwrap();
    let output = compile_and_run(&source);
    assert_eq!(output.trim(), "2\n1");
}

#[test]
fn tce_case_arms() {
    let source = std::fs::read_to_string("tests/e2e/tce_case_arms.snow").unwrap();
    let output = compile_and_run(&source);
    assert_eq!(output.trim(), "30");
}

#[test]
fn tce_actor_loop() {
    let source = std::fs::read_to_string("tests/e2e/tce_actor_loop.snow").unwrap();
    let output = compile_and_run(&source);
    assert_eq!(output.trim(), "5");
}
```

Place these test functions at the end of the test file, grouped together with a `// TCE tests` section comment.

NOTE: The Timer.sleep in the actor test requires `Timer` to be in scope. If the existing e2e test infrastructure handles stdlib imports automatically, great. If not, check how other actor tests (e.g., `actors_basic.snow`) handle timing and follow the same pattern. You may need to adjust the sleep mechanism -- look at existing actor e2e tests for patterns.
  </action>
  <verify>
Run all 4 new tests individually:
- `cargo test -p snowc --test e2e tce_countdown -- --nocapture`
- `cargo test -p snowc --test e2e tce_param_swap -- --nocapture`
- `cargo test -p snowc --test e2e tce_case_arms -- --nocapture`
- `cargo test -p snowc --test e2e tce_actor_loop -- --nocapture`

Then run the full e2e suite: `cargo test -p snowc --test e2e`

All tests must pass. The countdown test specifically validates no stack overflow at 1M iterations. The param_swap test validates correct two-phase argument evaluation. The case_arms test validates tail position through match. The actor_loop test validates the primary TCE use case.
  </verify>
  <done>
All 4 e2e test programs exist and produce correct output. All 4 test functions registered in e2e.rs. The full e2e test suite passes including all pre-existing tests (TCE is transparent to non-recursive programs).
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds (full project, not just snow-codegen)
2. `cargo test -p snowc --test e2e tce_countdown` passes -- proves 1M iteration recursion works
3. `cargo test -p snowc --test e2e tce_param_swap` passes -- proves arg evaluation order is correct
4. `cargo test -p snowc --test e2e tce_case_arms` passes -- proves tail position through case/match
5. `cargo test -p snowc --test e2e tce_actor_loop` passes -- proves actor receive loop TCE
6. `cargo test -p snowc --test e2e` passes -- ALL e2e tests pass (no regressions)
7. `grep -c "tce_loop_header" crates/snow-codegen/src/codegen/mod.rs` returns at least 2
8. `grep -c "TailCall" crates/snow-codegen/src/codegen/expr.rs` returns at least 2
</verification>

<success_criteria>
- A self-recursive countdown(1000000) completes without stack overflow (Phase success criterion 1)
- Tail position correctly detected through if/else, case, receive, blocks, and let-chains (Phase success criterion 2)
- Actor receive loop using self-recursive tail call runs correctly (Phase success criterion 3)
- Parameter swap recursion produces correct results (arg eval order)
- No existing test regressions
- Reduction checks emitted in TCE loop for actor scheduling safety
</success_criteria>

<output>
After completion, create `.planning/phases/48-tail-call-elimination/48-02-SUMMARY.md`
</output>
