---
phase: 61-production-hardening
plan: 02
type: execute
wave: 2
depends_on: ["61-01"]
files_modified:
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "LLVM intrinsic declaration for snow_ws_serve_tls exists with correct 9-argument signature (6 ptr + 1 i64 + 2 ptr)"
    - "known_functions entry for snow_ws_serve_tls has correct MIR type signature"
    - "map_builtin_name maps ws_serve_tls to snow_ws_serve_tls"
    - "Full workspace builds and all tests pass"
  artifacts:
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM external function declaration for snow_ws_serve_tls"
      contains: "snow_ws_serve_tls"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "known_functions entry and map_builtin_name mapping for snow_ws_serve_tls"
      contains: "snow_ws_serve_tls"
  key_links:
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/ws/server.rs"
      via: "LLVM external function declaration matching extern C signature"
      pattern: "snow_ws_serve_tls"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "known_functions type signature matches LLVM declaration"
      pattern: "snow_ws_serve_tls"
---

<objective>
Wire the snow_ws_serve_tls runtime function into the codegen pipeline so Snow programs can call Ws.serve_tls(handler, port, cert_path, key_path).

Purpose: Without codegen wiring, the runtime function exists but Snow programs cannot call it. This plan adds the LLVM declaration, MIR type signature, and builtin name mapping, following the exact pattern established for snow_ws_serve (Phase 60-02) and snow_http_serve_tls (Phase 56).

Output: Ws.serve_tls is callable from Snow source, full workspace compiles.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-production-hardening/61-RESEARCH.md
@.planning/phases/60-actor-integration/60-02-SUMMARY.md
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LLVM intrinsic declaration and MIR wiring for snow_ws_serve_tls</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
Follow the exact pattern from Phase 60-02 (Ws functions) and Phase 56 (http_serve_tls).

**1. Add LLVM declaration in intrinsics.rs:**
After the existing snow_ws_send_binary declaration (around line 437), add:

```rust
// snow_ws_serve_tls(on_connect_fn: ptr, on_connect_env: ptr, on_message_fn: ptr, on_message_env: ptr, on_close_fn: ptr, on_close_env: ptr, port: i64, cert_path: ptr, key_path: ptr) -> void
module.add_function("snow_ws_serve_tls", void_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), i64_type.into(), ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
```

This matches the extern "C" signature: 6 fn/env ptr pairs + 1 i64 port + 2 ptr for cert/key SnowString pointers = 9 arguments, void return.

**2. Add test assertion in intrinsics.rs:**
In the existing test function that asserts WS functions exist, add:
```rust
assert!(module.get_function("snow_ws_serve_tls").is_some());
```

**3. Add known_functions entry in lower.rs:**
After the existing snow_ws_send_binary entry (around line 682), add:

```rust
// snow_ws_serve_tls(on_connect_fn: ptr, on_connect_env: ptr, on_message_fn: ptr, on_message_env: ptr, on_close_fn: ptr, on_close_env: ptr, port: i64, cert_path: ptr, key_path: ptr) -> void
self.known_functions.insert("snow_ws_serve_tls".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr, MirType::Ptr, MirType::Ptr, MirType::Ptr, MirType::Int, MirType::Ptr, MirType::Ptr], Box::new(MirType::Unit)));
```

**IMPORTANT:** Use `MirType::Ptr` for the cert_path and key_path arguments, NOT `MirType::String`. This follows the convention from Phase 60-02 decision: the extern C signature takes `*const SnowString` (a raw pointer), and the codegen emits pointer-typed arguments. This is consistent with snow_ws_send which also uses Ptr for its SnowString argument.

Note: The snow_http_serve_tls known_functions entry uses `MirType::String` for cert/key args (line 659). However, the WS functions established the `MirType::Ptr` convention for SnowString pointer arguments in Phase 60-02. Follow the WS convention (Ptr) for consistency within the WS function family.

**4. Add map_builtin_name mapping in lower.rs:**
After the existing ws_send_binary mapping (around line 9510), add:

```rust
"ws_serve_tls" => "snow_ws_serve_tls".to_string(),
```

This maps `Ws.serve_tls(...)` in Snow source to `snow_ws_serve_tls(...)` in LLVM IR.
  </action>
  <verify>
    - `cargo check -p snow-codegen` compiles with no errors
    - `cargo test -p snow-codegen` -- all codegen tests pass (including new intrinsic assertion)
    - `cargo test --workspace` -- full workspace passes
    - Grep for `snow_ws_serve_tls` in intrinsics.rs -- declaration + test assertion present
    - Grep for `snow_ws_serve_tls` in lower.rs -- known_functions entry + map_builtin_name mapping present
  </verify>
  <done>
    LLVM external function declaration for snow_ws_serve_tls with 9-argument signature exists in intrinsics.rs. known_functions entry with matching MIR type signature exists in lower.rs. map_builtin_name maps ws_serve_tls to snow_ws_serve_tls. Full workspace builds and all tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify full workspace build and run complete test suite</name>
  <files></files>
  <action>
Run the complete workspace build and test suite to ensure no regressions from Phase 61 changes.

**1. Build the full workspace:**
```bash
cargo build --workspace
```
Must complete with no errors. Warnings about dead_code on unused fields are acceptable (e.g., shutdown field on WsConnection may warn if only accessed through the Arc).

**2. Run full test suite:**
```bash
cargo test --workspace
```
All tests must pass. Expected test counts:
- snow-rt ws:: tests: 30+ (existing Phase 59-60 tests)
- snow-rt actor:: tests: 120+
- snow-codegen tests: including new snow_ws_serve_tls intrinsic assertion
- Total: 1500+ tests

**3. Verify the runtime function and codegen declaration signatures match:**
Cross-reference the extern "C" signature in server.rs with the LLVM declaration in intrinsics.rs:
- server.rs: `pub extern "C" fn snow_ws_serve_tls(on_connect_fn: *mut u8, on_connect_env: *mut u8, on_message_fn: *mut u8, on_message_env: *mut u8, on_close_fn: *mut u8, on_close_env: *mut u8, port: i64, cert_path: *const SnowString, key_path: *const SnowString)`
- intrinsics.rs: 6 ptr + 1 i64 + 2 ptr = 9 args, void return
- Must match exactly.
  </action>
  <verify>
    - `cargo build --workspace` succeeds
    - `cargo test --workspace` -- all tests pass
    - Argument count in server.rs extern "C" matches intrinsics.rs LLVM declaration (9 args, void return)
  </verify>
  <done>
    Full workspace builds with no errors. All tests pass with zero regressions. Runtime and codegen signatures match exactly. Phase 61 is complete.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` -- compiles
2. `cargo test --workspace` -- all tests pass
3. Grep for `snow_ws_serve_tls` across codebase -- present in server.rs, intrinsics.rs, lower.rs
4. LLVM declaration argument count matches extern "C" signature (9 args)
</verification>

<success_criteria>
- Snow programs can reference Ws.serve_tls and it compiles to snow_ws_serve_tls call
- Full workspace builds and all tests pass
- Codegen signatures match runtime signatures exactly
</success_criteria>

<output>
After completion, create `.planning/phases/61-production-hardening/61-02-SUMMARY.md`
</output>
