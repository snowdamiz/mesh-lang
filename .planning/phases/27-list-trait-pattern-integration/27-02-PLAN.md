---
phase: 27-list-trait-pattern-integration
plan: 02
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/patterns.rs
  - crates/snow-parser/src/ast/pat.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/exhaustiveness.rs
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/pattern/compile.rs
  - crates/snow-codegen/src/codegen/pattern.rs
  - crates/snowc/tests/e2e_stdlib.rs
  - tests/e2e/list_cons_int.snow
  - tests/e2e/list_cons_string.snow
autonomous: true

must_haves:
  truths:
    - "case [1, 2, 3] do head :: tail -> head end returns 1"
    - "case ['a', 'b'] do h :: t -> h end returns 'a'"
    - "head :: tail pattern binds tail as List<T> with remaining elements"
    - "Empty list pattern ([] or matching via else/wildcard) handles the base case"
    - "Cons pattern works in recursive functions over lists"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "CONS_PAT SyntaxKind variant"
      contains: "CONS_PAT"
    - path: "crates/snow-parser/src/parser/patterns.rs"
      provides: ":: pattern parsing in pattern position"
      contains: "CONS_PAT"
    - path: "crates/snow-parser/src/ast/pat.rs"
      provides: "ConsPat AST node with head() and tail() accessors"
      contains: "ConsPat"
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "MirPattern::ListCons variant"
      contains: "ListCons"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Cons pattern lowering from AST to MIR"
      contains: "ListCons"
    - path: "crates/snow-codegen/src/pattern/compile.rs"
      provides: "Decision tree compilation for ListCons patterns"
      contains: "ListCons"
  key_links:
    - from: "crates/snow-parser/src/parser/patterns.rs"
      to: "crates/snow-parser/src/ast/pat.rs"
      via: "CONS_PAT SyntaxKind connects parser output to AST node"
      pattern: "CONS_PAT"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/pat.rs"
      via: "ConsPat type inference extracts T from List<T>"
      pattern: "ConsPat|cons"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "Lowering ConsPat AST to MirPattern::ListCons"
      pattern: "ListCons"
    - from: "crates/snow-codegen/src/pattern/compile.rs"
      to: "crates/snow-codegen/src/codegen/pattern.rs"
      via: "Decision tree with ListCons nodes compiled to LLVM IR"
      pattern: "ListCons"
---

<objective>
Add `head :: tail` cons pattern destructuring for List<T> in case expressions.

Purpose: LIST-08 requirement -- users can pattern match on lists using `head :: tail` syntax to destructure into first element and remaining list, enabling recursive list processing in the functional style.

Output: Full pipeline from parser (CONS_PAT syntax) through typeck (type inference) through MIR (ListCons pattern) through pattern compilation (decision tree) through LLVM codegen (runtime calls to snow_list_head/snow_list_tail/snow_list_length).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-list-trait-pattern-integration/27-RESEARCH.md
@.planning/phases/27-list-trait-pattern-integration/27-01-SUMMARY.md
@.planning/phases/26-polymorphic-list-foundation/26-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parser + AST + Typeck for cons patterns</name>
  <files>
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/parser/patterns.rs
    crates/snow-parser/src/ast/pat.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/exhaustiveness.rs
  </files>
  <action>
**Part A: Add CONS_PAT to syntax_kind.rs**

Add `CONS_PAT` variant to the `SyntaxKind` enum. Place it near the other pattern kinds (after `AS_PAT` or `CONSTRUCTOR_PAT`). Also add it to any display/debug match arms and to the `is_pat` or similar helper if one exists.

**Part B: Parse `head :: tail` in patterns.rs**

The `::` token already exists as `SyntaxKind::COLON_COLON`. Cons patterns should be parsed at a new precedence level between `or_pattern` and `as_pattern` (or equivalently, after parsing a primary pattern, check for `::` as an infix operator in pattern position).

Modify the pattern parsing to support cons as an infix operator. The cleanest approach: after `parse_primary_pattern` returns, check if the next token is `COLON_COLON`. If so, wrap the left pattern and parse the right pattern into a `CONS_PAT` node.

Update the grammar hierarchy:
```
pattern       = as_pattern
as_pattern    = cons_pattern ["as" IDENT]
cons_pattern  = or_pattern ("::" or_pattern)?
or_pattern    = primary_pattern ("|" primary_pattern)*
```

Implementation:
1. Rename the call chain: `parse_as_pattern` calls new `parse_cons_pattern` instead of `parse_or_pattern`
2. `parse_cons_pattern` calls `parse_or_pattern`, then checks for `COLON_COLON`:
```rust
fn parse_cons_pattern(p: &mut Parser) -> Option<MarkClosed> {
    let head = parse_or_pattern(p)?;

    if p.at(SyntaxKind::COLON_COLON) {
        let m = p.open_before(head);
        p.advance(); // ::
        parse_or_pattern(p); // tail pattern (could be another cons for h1 :: h2 :: rest)
        Some(p.close(m, SyntaxKind::CONS_PAT))
    } else {
        Some(head)
    }
}
```

Wait -- cons should be right-associative (`h :: t` where t can itself be `h2 :: rest`). So the recursive call should be to `parse_cons_pattern` not `parse_or_pattern`:

```rust
fn parse_cons_pattern(p: &mut Parser) -> Option<MarkClosed> {
    let head = parse_or_pattern(p)?;

    if p.at(SyntaxKind::COLON_COLON) {
        let m = p.open_before(head);
        p.advance(); // ::
        parse_cons_pattern(p); // right-associative: tail can be another cons
        Some(p.close(m, SyntaxKind::CONS_PAT))
    } else {
        Some(head)
    }
}
```

IMPORTANT: Only parse `::` in PATTERN position. The expression parser does NOT use `::` (it uses `++` for concat). No ambiguity.

**Part C: Add ConsPat AST node in pat.rs**

1. Add `Cons(ConsPat)` variant to the `Pattern` enum
2. Add `SyntaxKind::CONS_PAT => Some(Pattern::Cons(ConsPat { syntax: node }))` to `Pattern::cast`
3. Add `Pattern::Cons(n) => &n.syntax` to `Pattern::syntax()`
4. Define the `ConsPat` struct and accessors:

```rust
ast_node!(ConsPat, CONS_PAT);

impl ConsPat {
    /// The head pattern (first child pattern).
    pub fn head(&self) -> Option<Pattern> {
        self.syntax.children().find_map(Pattern::cast)
    }

    /// The tail pattern (second child pattern).
    pub fn tail(&self) -> Option<Pattern> {
        self.syntax.children().filter_map(Pattern::cast).nth(1)
    }
}
```

**Part D: Type inference for cons patterns in infer.rs**

Find the pattern type inference code in the type checker (search for where `Pattern::Ident`, `Pattern::Constructor`, `Pattern::Tuple` are handled during type inference in case arms).

When a `Pattern::Cons(cons_pat)` is encountered with expected type `List<T>`:
1. The head pattern gets type `T` (the element type extracted from `List<T>`)
2. The tail pattern gets type `List<T>` (same as the scrutinee type)

If the expected type is not a List, emit a type error: "cons pattern (::) can only match on List types".

To extract T from List<T>: match `Ty::App(Con("List"), [elem_ty])` -> `elem_ty`.

Look for how `Pattern::Tuple` handles sub-pattern inference for the implementation pattern.

**Part E: Exhaustiveness checking in exhaustiveness.rs**

The exhaustiveness checker needs to know about cons patterns. For lists, the "constructors" are conceptually:
- `[]` (empty list -- matched by wildcard or empty list literal)
- `head :: tail` (non-empty list -- matched by cons pattern)

For now, a CONSERVATIVE approach: treat cons patterns as non-exhaustive (warn that not all cases may be covered unless a wildcard/else arm exists). This avoids the complexity of proving list exhaustiveness. The exhaustiveness checker likely already handles unknown patterns by treating them as partial -- verify and follow the existing fallback behavior.

If the exhaustiveness checker would crash on an unknown pattern type, add a `Pattern::Cons(_)` arm that returns the equivalent of "partial coverage" (same as what the wildcard does, but without marking full coverage).
  </action>
  <verify>
    `cargo test -p snow-parser` passes (all existing + verify new cons pattern parsing).
    `cargo test -p snow-typeck` passes (type inference for cons patterns in case arms).
    `cargo build` succeeds.

    Write a quick parser unit test: parse `case xs do h :: t -> h end` and verify the CST contains a CONS_PAT node.
  </verify>
  <done>
    `head :: tail` parses as CONS_PAT in pattern position.
    ConsPat AST node provides head() and tail() accessors.
    Type checker infers head as T and tail as List<T> for cons patterns on List<T>.
    Exhaustiveness checker does not crash on cons patterns.
    All existing parser/typeck tests pass with 0 regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: MIR lowering + pattern compilation + codegen + e2e tests for cons patterns</name>
  <files>
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/pattern/compile.rs
    crates/snow-codegen/src/codegen/pattern.rs
    crates/snowc/tests/e2e_stdlib.rs
    tests/e2e/list_cons_int.snow
    tests/e2e/list_cons_string.snow
  </files>
  <action>
**Part A: Add MirPattern::ListCons to mod.rs**

Add a new variant to the `MirPattern` enum:

```rust
/// Matches a non-empty list: head :: tail
ListCons {
    head: Box<MirPattern>,
    tail: Box<MirPattern>,
    elem_ty: MirType,  // The element type T in List<T>
},
```

**Part B: Lower ConsPat to MirPattern::ListCons in lower.rs**

Find where patterns are lowered from AST to MIR (search for `Pattern::Constructor`, `Pattern::Tuple` handling in the lowerer). Add a new arm for `Pattern::Cons(cons_pat)`:

```rust
Pattern::Cons(cons_pat) => {
    let head_pat = cons_pat.head()
        .map(|p| self.lower_pattern(&p, /* head type: elem_ty */))
        .unwrap_or(MirPattern::Wildcard);
    let tail_pat = cons_pat.tail()
        .map(|p| self.lower_pattern(&p, /* tail type: list_ty */))
        .unwrap_or(MirPattern::Wildcard);
    MirPattern::ListCons {
        head: Box::new(head_pat),
        tail: Box::new(tail_pat),
        elem_ty: /* element MIR type */,
    }
}
```

The element type should come from the typeck type. Look at how the existing `lower_pattern` gets the expected type for sub-patterns.

For head/tail sub-patterns: if they are `Pattern::Ident`, they should produce `MirPattern::Binding`. The lowerer already handles this -- just pass the correct expected type.

**Part C: Pattern compilation for ListCons in compile.rs**

The pattern compiler builds decision trees from MIR patterns. Find where `MirPattern::Constructor` and `MirPattern::Tuple` are handled and add ListCons support.

ListCons pattern compilation strategy (similar to a 2-field constructor):
1. **Test:** Check if the list is non-empty: `snow_list_length(scrutinee) > 0`
2. **Extract fields:** If non-empty, extract head = `snow_list_head(scrutinee)`, tail = `snow_list_tail(scrutinee)`
3. **Bind sub-patterns:** Recursively compile head_pat against the head value, tail_pat against the tail value

The decision tree should have:
- A conditional check for length > 0
- If true: extract head and tail, continue matching sub-patterns
- If false: fall through to next arm (or fail)

Look at how `MirPattern::Constructor` handles its `fields` to understand the extraction pattern. ListCons is essentially a binary constructor with two sub-patterns.

Add `MirPattern::ListCons { .. }` match arms wherever `MirPattern::Constructor`, `MirPattern::Tuple`, `MirPattern::Or` are handled (likely in `is_wildcard`, `specialize`, `constructors_in_column`, etc.).

**Part D: LLVM codegen for ListCons in pattern.rs (codegen)**

Find the pattern codegen file (likely `crates/snow-codegen/src/codegen/pattern.rs` or wherever decision trees are translated to LLVM IR).

For ListCons nodes in the decision tree:
1. Emit length check: `snow_list_length(scrutinee) > 0` using the existing intrinsic
2. Create conditional branch: if true -> extract block, if false -> fallthrough block
3. In extract block: call `snow_list_head(scrutinee)` for head binding, `snow_list_tail(scrutinee)` for tail binding
4. Apply type conversion on head: the `snow_list_head` returns u64 (i64 at LLVM level). Convert to the actual element type using the same conversion logic from Phase 26 (Bool: trunc to i1, Float: bitcast to f64, Ptr/String/Struct: inttoptr).
5. Tail is already a Ptr (List), no conversion needed.
6. Store extracted values and continue with sub-pattern matching.

IMPORTANT: `snow_list_head` returns `u64` at runtime level. The codegen must apply the type conversion based on `elem_ty` just like the existing list_get/list_head return value conversion in `expr.rs`.

**Part E: E2e tests**

`tests/e2e/list_cons_int.snow`:
```snow
fn sum_list(xs: List<Int>) -> Int do
  case xs do
    head :: tail -> head + sum_list(tail)
    _ -> 0
  end
end

fn main() do
  let result = sum_list([1, 2, 3, 4, 5])
  IO.puts(to_string(result))
end
```
Expected output: `15`

`tests/e2e/list_cons_string.snow`:
```snow
fn first_or_default(xs : List<String>) -> String do
  case xs do
    head :: _ -> head
    _ -> "empty"
  end
end

fn main() do
  IO.puts(first_or_default(["hello", "world"]))
  IO.puts(first_or_default([]))
end
```
Expected output:
```
hello
empty
```

Register both tests in `crates/snowc/tests/e2e_stdlib.rs`.

NOTE: The empty list `[]` will match the wildcard `_` arm. We do NOT need a dedicated empty list pattern -- the wildcard handles the base case. The cons pattern only matches non-empty lists.

Type annotations on function parameters (like `xs: List<Int>`) should already work from Phase 26's polymorphic list types. If the type annotation syntax causes issues, use `let xs = [1, 2, 3, 4, 5]` inline instead.
  </action>
  <verify>
    `cargo test -p snow-codegen` passes (MIR lowering + pattern compilation tests).
    `cargo test -p snowc -- list_cons_int` passes with output "15".
    `cargo test -p snowc -- list_cons_string` passes with correct output.
    `cargo test` full suite passes with 0 regressions.
  </verify>
  <done>
    case xs do head :: tail -> ... end works for List<Int>, List<String>, and any List<T>.
    Recursive list functions via cons patterns compile and run correctly.
    Empty list falls through to wildcard arm.
    LIST-08 requirement satisfied.
    All existing tests pass with 0 regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- full test suite passes with 0 regressions
2. E2e tests: list_cons_int outputs "15", list_cons_string outputs "hello\nempty"
3. Cons pattern type inference: head gets element type T, tail gets List<T>
4. Parser does not confuse `::` in pattern position with any expression operator
5. Recursive list processing via cons patterns works end-to-end
</verification>

<success_criteria>
- `case [1, 2, 3] do h :: t -> h end` returns 1
- `case ["a", "b"] do h :: _ -> h end` returns "a"
- Recursive sum_list using cons pattern produces correct result (15 for [1..5])
- Empty list matches wildcard arm correctly
- No regressions in existing test suite (1,212+ tests)
</success_criteria>

<output>
After completion, create `.planning/phases/27-list-trait-pattern-integration/27-02-SUMMARY.md`
</output>
