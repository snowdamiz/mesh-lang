---
phase: 27-list-trait-pattern-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/collections/list.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snowc/tests/e2e_stdlib.rs
  - tests/e2e/list_display_string.snow
  - tests/e2e/list_eq.snow
  - tests/e2e/list_ord.snow
autonomous: true

must_haves:
  truths:
    - "to_string([1, 2, 3]) produces '[1, 2, 3]' as a direct function call"
    - "to_string(['a', 'b']) produces correct Display output for List<String>"
    - "debug(my_list) renders each element using its Debug implementation"
    - "[1, 2] == [1, 2] returns true via element-wise comparison"
    - "[1, 3] > [1, 2] returns true via lexicographic comparison"
    - "[1, 2] != [1, 3] returns true"
  artifacts:
    - path: "crates/snow-rt/src/collections/list.rs"
      provides: "snow_list_eq and snow_list_compare runtime functions"
      contains: "snow_list_eq"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Binary op dispatch for Ptr types when typeck type is List"
      contains: "snow_list_eq"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for snow_list_eq and snow_list_compare"
      contains: "snow_list_eq"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "MIR Call to snow_list_eq/snow_list_compare with callback fn ptr"
      pattern: "snow_list_eq|snow_list_compare"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "known_functions registration matches LLVM extern declaration"
      pattern: "snow_list_eq|snow_list_compare"
---

<objective>
Make Display/Debug and Eq/Ord trait protocols work correctly with polymorphic List<T>.

Purpose: LIST-06 and LIST-07 requirements -- users can call to_string/debug on any List<T> and use == / < / > operators to compare lists element-wise.

Output: Runtime functions snow_list_eq and snow_list_compare with callback-based element comparison, MIR dispatch for binary operators on Ptr-typed list expressions, and correct to_string/debug dispatch for List<T> via direct function calls.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-list-trait-pattern-integration/27-RESEARCH.md
@.planning/phases/26-polymorphic-list-foundation/26-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add snow_list_eq and snow_list_compare runtime functions + LLVM declarations</name>
  <files>
    crates/snow-rt/src/collections/list.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
**In `crates/snow-rt/src/collections/list.rs`:**

Add two new `#[no_mangle] pub extern "C" fn` functions following the `snow_list_to_string` callback pattern:

1. `snow_list_eq(list_a: *mut u8, list_b: *mut u8, elem_eq: *mut u8) -> i8`
   - `elem_eq` is a function pointer `fn(u64, u64) -> i8` that compares two elements for equality
   - Algorithm: if lengths differ, return 0 (false). Otherwise iterate pairwise, calling elem_eq on each pair. If any returns 0, return 0. If all match, return 1.
   - Type alias: `type ElemEq = unsafe extern "C" fn(u64, u64) -> i8;`
   - Use `std::mem::transmute` on elem_eq to get the typed function pointer (same pattern as snow_list_to_string)

2. `snow_list_compare(list_a: *mut u8, list_b: *mut u8, elem_cmp: *mut u8) -> i64`
   - `elem_cmp` is a function pointer `fn(u64, u64) -> i64` that returns negative/0/positive for ordering
   - Algorithm: iterate pairwise up to min(len_a, len_b). For each pair, call elem_cmp. If result != 0, return it immediately. After loop, compare lengths: if len_a < len_b return -1, if len_a > len_b return 1, else return 0.
   - Type alias: `type ElemCmp = unsafe extern "C" fn(u64, u64) -> i64;`

Add unit tests for both functions in the existing `mod tests` block:
- `test_list_eq_same` -- equal lists return 1
- `test_list_eq_different` -- different lists return 0
- `test_list_eq_different_length` -- different length lists return 0
- `test_list_compare_less` -- [1, 2] < [1, 3] returns negative
- `test_list_compare_equal` -- [1, 2] vs [1, 2] returns 0
- `test_list_compare_length` -- [1, 2] vs [1, 2, 3] returns negative

For tests, create simple comparison callbacks as `extern "C" fn` that compare i64 values directly.

**In `crates/snow-codegen/src/codegen/intrinsics.rs`:**

Add LLVM extern declarations in the `register_intrinsics` function, near the existing collection Display declarations (after line ~378):

```rust
// snow_list_eq(list_a: ptr, list_b: ptr, elem_eq: ptr) -> i8
module.add_function("snow_list_eq", i8_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));

// snow_list_compare(list_a: ptr, list_b: ptr, elem_cmp: ptr) -> i64
module.add_function("snow_list_compare", i64_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
```

Note: Check what integer types are available in the intrinsics function. The return type for snow_list_eq should be i8 (same as Bool at LLVM level). If i8_type is not declared, use the context to create it: `context.i8_type()`.
  </action>
  <verify>
    `cargo test -p snow-rt -- list` passes (including new tests).
    `cargo test -p snow-codegen -- intrinsic` passes (existing intrinsics test verifies declarations).
    `cargo build` succeeds with no errors.
  </verify>
  <done>
    snow_list_eq and snow_list_compare exist as #[no_mangle] extern "C" functions in snow-rt with correct callback signatures.
    LLVM extern declarations registered in intrinsics.rs.
    All existing tests pass with 0 regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: MIR dispatch for List Display/Debug and Eq/Ord binary operators + e2e tests</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snowc/tests/e2e_stdlib.rs
    tests/e2e/list_display_string.snow
    tests/e2e/list_eq.snow
    tests/e2e/list_ord.snow
  </files>
  <action>
**Part A: Register runtime functions in known_functions (lower.rs)**

In the `Lowerer::new` known_functions section, after the existing `snow_list_to_string` registration (~line 429), add:

```rust
// List Eq/Ord (Phase 27)
self.known_functions.insert("snow_list_eq".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::Bool)));
self.known_functions.insert("snow_list_compare".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
```

Note: snow_list_eq returns i8 at LLVM level but MirType::Bool is correct at MIR level. snow_list_compare returns i64 at LLVM level but use MirType::Int at MIR level (to match Ordering convention).

**Part B: Binary operator dispatch for List Eq/Ord (lower.rs)**

In `lower_binary` (~line 3176), after the `is_user_type` check for `MirType::Struct | MirType::SumType`, add a NEW branch for `MirType::Ptr` when the typeck type is a List:

```rust
// After the is_user_type block (around line 3228):
// List Eq/Ord dispatch: if lhs is Ptr and typeck type is List<T>,
// emit snow_list_eq / snow_list_compare with element callback.
if matches!(lhs_ty, MirType::Ptr) {
    if let Some(typeck_ty) = self.get_ty(bin.syntax().text_range()).cloned() {
        // Also need the LHS typeck type to extract element type
        if let Some(lhs_ast) = bin.lhs() {
            if let Some(lhs_typeck) = self.get_ty(lhs_ast.syntax().text_range()).cloned() {
                if let Some(elem_ty) = extract_list_elem_type(&lhs_typeck) {
                    // Determine operation
                    match op {
                        BinOp::Eq | BinOp::NotEq => {
                            let eq_callback = self.resolve_eq_callback(&elem_ty);
                            let fn_ptr_ty = MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Bool));
                            let eq_callback_expr = MirExpr::Var(eq_callback, MirType::FnPtr(vec![MirType::Int, MirType::Int], Box::new(MirType::Bool)));
                            let call = MirExpr::Call {
                                func: Box::new(MirExpr::Var("snow_list_eq".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::Bool)))),
                                args: vec![lhs, rhs, eq_callback_expr],
                                ty: MirType::Bool,
                            };
                            if op == BinOp::NotEq {
                                return MirExpr::BinOp {
                                    op: BinOp::Eq,
                                    lhs: Box::new(call),
                                    rhs: Box::new(MirExpr::BoolLit(false, MirType::Bool)),
                                    ty,
                                };
                            }
                            return call;
                        }
                        BinOp::Lt | BinOp::Gt | BinOp::LtEq | BinOp::GtEq => {
                            let cmp_callback = self.resolve_compare_callback(&elem_ty);
                            let cmp_callback_expr = MirExpr::Var(cmp_callback, MirType::FnPtr(vec![MirType::Int, MirType::Int], Box::new(MirType::Int)));
                            let compare_call = MirExpr::Call {
                                func: Box::new(MirExpr::Var("snow_list_compare".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::Int)))),
                                args: vec![lhs, rhs, cmp_callback_expr],
                                ty: MirType::Int,
                            };
                            // Convert compare result to boolean:
                            // Lt: compare < 0, Gt: compare > 0, LtEq: compare <= 0, GtEq: compare >= 0
                            let compare_op = match op {
                                BinOp::Lt => BinOp::Lt,
                                BinOp::Gt => BinOp::Gt,
                                BinOp::LtEq => BinOp::LtEq,
                                BinOp::GtEq => BinOp::GtEq,
                                _ => unreachable!(),
                            };
                            return MirExpr::BinOp {
                                op: compare_op,
                                lhs: Box::new(compare_call),
                                rhs: Box::new(MirExpr::IntLit(0, MirType::Int)),
                                ty,
                            };
                        }
                        _ => {}
                    }
                }
            }
        }
    }
}
```

**Part C: Add helper functions for Eq/Ord callbacks (lower.rs)**

Add these methods to the `Lowerer` impl, near `resolve_to_string_callback`:

1. `fn extract_list_elem_type(ty: &Ty) -> Option<Ty>` -- a free function that extracts the element type T from `Ty::App(Con("List"), [T])`. Returns None if not a List type.

2. `fn resolve_eq_callback(&mut self, elem_ty: &Ty) -> String` -- follows the same pattern as `resolve_to_string_callback`:
   - For `Ty::Con("Int")`: return `"snow_int_eq"` (a new synthetic wrapper, see below)
   - For `Ty::Con("Float")`: return `"snow_float_eq"`
   - For `Ty::Con("Bool")`: return `"snow_bool_eq"`
   - For `Ty::Con("String")`: return `"snow_string_eq"` (already exists)
   - For `Ty::Con(user_type)` with Eq impl: return `"Eq__eq__{user_type}"`
   - For nested `Ty::App(Con("List"), [inner])`: generate a synthetic wrapper `__eq_list_{inner}_callback` that calls `snow_list_eq` with a recursive inner callback

3. `fn resolve_compare_callback(&mut self, elem_ty: &Ty) -> String` -- similar pattern:
   - For `Ty::Con("Int")`: return a wrapper function name that compares two i64 values
   - For `Ty::Con("String")`: return a wrapper that calls `snow_string_compare`
   - For user types with Ord impl: return `"Ord__compare__{type}"`
   - For nested lists: recursive wrapper

For primitive comparison, generate synthetic MIR wrapper functions following the same pattern as `generate_display_collection_wrapper`:

- `__eq_int_callback(a: i64, b: i64) -> i8` -- `a == b`
- `__cmp_int_callback(a: i64, b: i64) -> i64` -- `if a < b { -1 } else if a > b { 1 } else { 0 }`
- `__eq_string_callback(a: Ptr, b: Ptr) -> i8` -- calls `snow_string_eq(a, b)`
- `__cmp_string_callback(a: Ptr, b: Ptr) -> i64` -- calls `snow_string_compare(a, b)`

Register these wrappers as MIR functions (push to `self.functions`) and add to `self.known_functions`, same as `generate_display_collection_wrapper` does.

IMPORTANT: The runtime expects callbacks with signature `fn(u64, u64) -> i8` for eq and `fn(u64, u64) -> i64` for compare. The MIR wrapper functions take the appropriate MIR types and the codegen will handle the type conversion (u64 -> actual type) at call sites. Keep the MIR types semantically correct (Int, String, Bool, etc.) -- the LLVM codegen's existing argument coercion logic handles conversion.

Actually, looking at how `snow_list_to_string` works: the runtime expects `fn(u64) -> *mut u8` and the MIR declares callbacks using semantic types. The LLVM codegen already handles the conversion between semantic types and u64 for runtime callbacks. Follow the EXACT same pattern for eq/compare callbacks.

**Part D: Display/Debug dispatch for to_string() and debug() calls on List<T> (lower.rs)**

The `wrap_collection_to_string` function already handles Display for List<T> when the expression is a `MirType::Ptr` with a typeck type of List. This works for string interpolation (`"${my_list}"`).

Check that `to_string(my_list)` as a direct function call also dispatches correctly. Looking at the code around line 3411-3420, the `to_string` call dispatch already checks for Ptr args and calls `wrap_collection_to_string`. This should already work.

For `debug(my_list)`, check if there's similar dispatch. If not, add it: when callee is "debug" or "inspect" and arg is Ptr, look up typeck type and if it's a List, emit the same `wrap_collection_to_string` call (Debug for List uses the same format as Display).

If `to_string` and `debug` already work for List<T> Ptr types via the existing collection dispatch, just verify with e2e tests.

**Part E: E2e tests**

Create test files:

`tests/e2e/list_display_string.snow`:
```snow
fn main() do
  let xs = ["hello", "world"]
  let result = to_string(xs)
  IO.puts(result)
end
```
Expected output: `[hello, world]`

`tests/e2e/list_eq.snow`:
```snow
fn main() do
  let a = [1, 2, 3]
  let b = [1, 2, 3]
  let c = [1, 2, 4]
  if a == b do
    IO.puts("equal")
  end
  if a != c do
    IO.puts("not equal")
  end
end
```
Expected output:
```
equal
not equal
```

`tests/e2e/list_ord.snow`:
```snow
fn main() do
  let a = [1, 2]
  let b = [1, 3]
  if a < b do
    IO.puts("less")
  end
  if b > a do
    IO.puts("greater")
  end
end
```
Expected output:
```
less
greater
```

Register all three tests in `crates/snowc/tests/e2e_stdlib.rs` following the existing test function pattern (compile + run + assert output).
  </action>
  <verify>
    `cargo test -p snow-codegen` passes (all existing tests + any new MIR tests).
    `cargo test -p snowc -- list_display_string` passes.
    `cargo test -p snowc -- list_eq` passes.
    `cargo test -p snowc -- list_ord` passes.
    `cargo test` full suite passes with 0 regressions.
  </verify>
  <done>
    to_string([1, 2, 3]) and to_string(["a", "b"]) produce correct Display output.
    [1, 2] == [1, 2] returns true. [1, 3] > [1, 2] returns true.
    All comparison operators (==, !=, <, >, <=, >=) work for List<T>.
    LIST-06 (Display/Debug) and LIST-07 (Eq/Ord) requirements satisfied.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- full test suite passes with 0 regressions
2. E2e tests compile and run: list_display_string, list_eq, list_ord
3. String interpolation still works: `"${[1, 2, 3]}"` produces `[1, 2, 3]`
4. Existing list operations (append, get, head, tail, concat) still work
</verification>

<success_criteria>
- to_string([1, 2, 3]) returns "[1, 2, 3]" as a direct function call
- to_string(["hello", "world"]) returns "[hello, world]"
- [1, 2] == [1, 2] returns true
- [1, 3] > [1, 2] returns true
- All 6 comparison operators work for lists
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/27-list-trait-pattern-integration/27-01-SUMMARY.md`
</output>
