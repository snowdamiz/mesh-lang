---
phase: 69-cross-node-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/dist/node.rs
  - crates/snow-rt/src/ws/rooms.rs
autonomous: true

must_haves:
  truths:
    - "snow_ws_broadcast sends to local room members AND forwards to all connected nodes"
    - "snow_ws_broadcast_except sends to local members (minus excluded) AND forwards to all connected nodes"
    - "A node receiving DIST_ROOM_BROADCAST delivers to its own local room members only (no re-forwarding)"
    - "DIST_ROOM_BROADCAST wire format encodes/decodes room name and message text correctly"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "DIST_ROOM_BROADCAST wire tag (0x1E) and reader loop handler"
      contains: "DIST_ROOM_BROADCAST"
    - path: "crates/snow-rt/src/ws/rooms.rs"
      provides: "broadcast_room_to_cluster function and local_room_broadcast helper"
      contains: "broadcast_room_to_cluster"
  key_links:
    - from: "crates/snow-rt/src/ws/rooms.rs"
      to: "crates/snow-rt/src/dist/node.rs"
      via: "broadcast_room_to_cluster calls node_state(), write_msg() to forward to all sessions"
      pattern: "broadcast_room_to_cluster"
    - from: "crates/snow-rt/src/dist/node.rs"
      to: "crates/snow-rt/src/ws/rooms.rs"
      via: "reader loop DIST_ROOM_BROADCAST handler calls local_room_broadcast"
      pattern: "local_room_broadcast"
---

<objective>
Make WebSocket room broadcasts cluster-wide by adding a DIST_ROOM_BROADCAST wire message that forwards room broadcasts to all connected nodes.

Purpose: Satisfies CLUST-04 -- WebSocket rooms broadcast messages across connected nodes transparently. A message broadcast to a room on one node reaches room members on all nodes.
Output: Modified rooms.rs with cluster-aware broadcast, modified node.rs with new wire tag and reader handler.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/69-cross-node-integration/69-RESEARCH.md
@crates/snow-rt/src/ws/rooms.rs
@crates/snow-rt/src/dist/node.rs
@crates/snow-rt/src/dist/global.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DIST_ROOM_BROADCAST wire tag, broadcast function, and reader handler</name>
  <files>crates/snow-rt/src/dist/node.rs, crates/snow-rt/src/ws/rooms.rs</files>
  <action>
**In `crates/snow-rt/src/dist/node.rs`:**

1. Add wire tag constant after `DIST_GLOBAL_SYNC`:
   ```rust
   pub(crate) const DIST_ROOM_BROADCAST: u8 = 0x1E;
   ```

2. In `reader_loop_session`, add a match arm for `DIST_ROOM_BROADCAST` after the `DIST_GLOBAL_SYNC` handler. Wire format: `[tag 0x1E][u16 room_name_len][room_name bytes][u32 msg_len][msg bytes]`. Decode room_name and msg text, then call `crate::ws::rooms::local_room_broadcast(room_name, text)` for local-only delivery. Do NOT re-forward to other nodes (prevents infinite broadcast storms -- see Pitfall 1 in RESEARCH.md). Follow the same defensive length/UTF-8 validation pattern used by `DIST_GLOBAL_REGISTER` handler.

**In `crates/snow-rt/src/ws/rooms.rs`:**

3. Add a `pub(crate) fn local_room_broadcast(room: &str, msg: &str)` function. This extracts the local delivery logic from `snow_ws_broadcast` into a reusable helper: snapshot members from `global_room_registry().members(room)`, iterate, skip shutdown connections, write text frame via `write_frame`. Returns number of write failures as `i64`.

4. Add a `pub(crate) fn broadcast_room_to_cluster(room: &str, msg: &str)` function. This follows the exact broadcast pattern from `global.rs::broadcast_global_register`: call `crate::dist::node::node_state()` (return early if None -- distribution not started), build DIST_ROOM_BROADCAST payload bytes, collect `Arc<NodeSession>` references under sessions read lock, drop lock, then iterate and `write_msg` to each session. Wire format: `[0x1E][u16 room_name_len][room_name][u32 msg_len][msg]`. Use `crate::dist::node::DIST_ROOM_BROADCAST` for the tag and `crate::dist::node::write_msg` for writing.

5. Modify `snow_ws_broadcast` to call `local_room_broadcast(room, text)` for local delivery, then call `broadcast_room_to_cluster(room, text)` for cluster forwarding. The return value is the local failure count from `local_room_broadcast`.

6. Modify `snow_ws_broadcast_except` similarly: keep the existing except_conn logic for LOCAL delivery only (the excluded connection is always on the originating node), then call `broadcast_room_to_cluster(room, text)` to forward the full message to all peers. Remote nodes will deliver to ALL their local members, which is correct since the excluded connection is not on those nodes.
  </action>
  <verify>
Run `cargo build -p snow-rt` -- must compile with no errors. Run `cargo test -p snow-rt -- rooms` -- all existing room registry tests must pass. Run `cargo test -p snow-rt` -- full test suite must pass (no regressions).
  </verify>
  <done>
DIST_ROOM_BROADCAST (0x1E) wire tag exists. `snow_ws_broadcast` and `snow_ws_broadcast_except` both perform local delivery AND forward to connected nodes. Reader loop decodes DIST_ROOM_BROADCAST and calls local_room_broadcast for local-only delivery. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DIST_ROOM_BROADCAST wire format and broadcast unit tests</name>
  <files>crates/snow-rt/src/ws/rooms.rs, crates/snow-rt/src/dist/node.rs</files>
  <action>
**In `crates/snow-rt/src/ws/rooms.rs` tests module:**

1. Add test `test_local_room_broadcast_empty_room`: Call `local_room_broadcast("empty_room", "hello")` -- should return 0 failures and not panic. Verifies the function handles non-existent rooms gracefully.

2. Add test `test_broadcast_room_to_cluster_no_distribution`: Call `broadcast_room_to_cluster("lobby", "hello")` when node distribution is not started (`node_state()` returns None). Should return immediately without panic. This tests the early-return guard.

**In `crates/snow-rt/src/dist/node.rs` tests (or a new test in rooms.rs):**

3. Add test `test_dist_room_broadcast_wire_format`: Manually construct a DIST_ROOM_BROADCAST payload with a known room name ("lobby") and message ("hello world"), then parse it back using the same byte-offset logic from the reader handler. Verify room_name and msg are correctly extracted. This follows the pattern from Phase 68's wire format tests that use direct payload byte verification.

4. Add test `test_dist_room_broadcast_wire_roundtrip`: Build a payload via the same logic `broadcast_room_to_cluster` uses (tag + u16 room_len + room + u32 msg_len + msg), then decode using the reader loop logic. Verify decoded values match originals. Test with: empty message, ASCII room name, multi-byte UTF-8 room name.
  </action>
  <verify>
Run `cargo test -p snow-rt -- rooms` -- all new and existing tests pass. Run `cargo test -p snow-rt -- dist_room_broadcast` -- wire format tests pass.
  </verify>
  <done>
Unit tests verify: local_room_broadcast handles empty rooms, broadcast_room_to_cluster handles no distribution, DIST_ROOM_BROADCAST wire format encodes/decodes correctly for various inputs. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles cleanly
2. `cargo test -p snow-rt` -- all tests pass (existing + new)
3. DIST_ROOM_BROADCAST constant 0x1E exists in node.rs
4. Reader loop has DIST_ROOM_BROADCAST match arm that calls local_room_broadcast
5. snow_ws_broadcast calls broadcast_room_to_cluster after local delivery
6. snow_ws_broadcast_except calls broadcast_room_to_cluster after local delivery
</verification>

<success_criteria>
- snow_ws_broadcast delivers locally AND forwards DIST_ROOM_BROADCAST to all connected node sessions
- snow_ws_broadcast_except delivers locally (with exclusion) AND forwards to all connected node sessions
- Receiving DIST_ROOM_BROADCAST delivers to local room members only (no re-forwarding)
- Wire format tests verify encode/decode correctness
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/69-cross-node-integration/69-01-SUMMARY.md`
</output>
