---
phase: 69-cross-node-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/actor/child_spec.rs
  - crates/snow-rt/src/actor/supervisor.rs
  - crates/snow-rt/src/actor/mod.rs
autonomous: true

must_haves:
  truths:
    - "A supervisor can spawn a child on a remote node when target_node is set in the child spec"
    - "A remote child crash triggers the supervisor's existing handle_child_exit restart logic"
    - "A remote child is restarted on the same remote node (target_node persists across restarts)"
    - "Terminating a remote child sends DIST_EXIT shutdown signal via distribution"
    - "Local-only supervisors are completely unaffected by these changes"
  artifacts:
    - path: "crates/snow-rt/src/actor/child_spec.rs"
      provides: "ChildSpec with optional target_node and start_fn_name fields"
      contains: "target_node"
    - path: "crates/snow-rt/src/actor/supervisor.rs"
      provides: "start_single_child routing to remote spawn, terminate_single_child handling remote PIDs"
      contains: "start_single_child_remote"
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "parse_supervisor_config reading optional target_node field"
      contains: "target_node"
  key_links:
    - from: "crates/snow-rt/src/actor/supervisor.rs"
      to: "crates/snow-rt/src/dist/node.rs"
      via: "start_single_child_remote calls snow_node_spawn with link_flag=1"
      pattern: "snow_node_spawn"
    - from: "crates/snow-rt/src/actor/supervisor.rs"
      to: "crates/snow-rt/src/dist/node.rs"
      via: "terminate_single_child sends DIST_EXIT for remote children via send_dist_exit"
      pattern: "send_dist_exit"
    - from: "crates/snow-rt/src/actor/mod.rs"
      to: "crates/snow-rt/src/actor/child_spec.rs"
      via: "parse_supervisor_config populates target_node/start_fn_name from wire format"
      pattern: "target_node"
---

<objective>
Extend the supervisor to spawn, monitor, and restart children on remote nodes, using existing distribution primitives (snow_node_spawn, remote links, DIST_EXIT).

Purpose: Satisfies CLUST-05 -- Supervision trees can monitor and restart child actors running on remote nodes, treating remote crashes the same as local ones.
Output: Extended ChildSpec with target_node/start_fn_name, remote-aware start_single_child and terminate_single_child, updated config parser.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/69-cross-node-integration/69-RESEARCH.md
@crates/snow-rt/src/actor/child_spec.rs
@crates/snow-rt/src/actor/supervisor.rs
@crates/snow-rt/src/actor/mod.rs
@crates/snow-rt/src/dist/node.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ChildSpec and add remote spawn/terminate to supervisor</name>
  <files>crates/snow-rt/src/actor/child_spec.rs, crates/snow-rt/src/actor/supervisor.rs</files>
  <action>
**In `crates/snow-rt/src/actor/child_spec.rs`:**

1. Add two new fields to `ChildSpec`:
   ```rust
   /// Optional target node name for remote spawning (e.g., "worker@192.168.1.2:9000").
   /// When set, the supervisor spawns this child on the remote node via snow_node_spawn.
   /// When None, the supervisor spawns locally (existing behavior unchanged).
   pub target_node: Option<String>,
   /// Function name for remote spawning (required when target_node is Some).
   /// Used by snow_node_spawn to look up the function on the remote node.
   pub start_fn_name: Option<String>,
   ```

2. Update ALL existing `ChildSpec` construction sites in child_spec.rs tests to include `target_node: None, start_fn_name: None` so tests compile.

**In `crates/snow-rt/src/actor/supervisor.rs`:**

3. Add `start_single_child_remote` function:
   ```rust
   fn start_single_child_remote(
       child: &mut ChildState,
       sup_pid: ProcessId,
       target_node: &str,
       fn_name: &str,
   ) -> Result<ProcessId, String> {
   ```
   This function:
   - Calls `crate::dist::node::snow_node_spawn(node_ptr, node_len, fn_name_ptr, fn_name_len, args_ptr, args_size, 1)` with `link_flag=1` (spawn + bidirectional link). The link ensures the supervisor receives DIST_EXIT when the remote child crashes, which the supervisor's existing `trap_exit + handle_child_exit` handles automatically.
   - IMPORTANT: `snow_node_spawn` must be called from within an actor coroutine context (it reads `stack::get_current_pid()`). The supervisor IS an actor, so this works. But we need to call the underlying function correctly. Since snow_node_spawn is an `extern "C"` function expecting raw pointers, convert `target_node` and `fn_name` to `(ptr, len)` pairs.
   - If `snow_node_spawn` returns 0, return `Err("remote spawn failed: node not connected or function not found")`.
   - Otherwise, construct `ProcessId(returned_u64)`, set `child.pid = Some(remote_pid)`, `child.running = true`, return `Ok(remote_pid)`.
   - The returned PID from `snow_node_spawn` is already a fully-qualified remote PID with correct node_id/creation/local_id (Phase 67 handles this).

4. Modify `start_single_child` to check `child.spec.target_node` first:
   ```rust
   pub fn start_single_child(
       child: &mut ChildState,
       scheduler: &Scheduler,
       sup_pid: ProcessId,
   ) -> Result<ProcessId, String> {
       // Route to remote spawn if target_node is set
       if let Some(ref node) = child.spec.target_node {
           let fn_name = child.spec.start_fn_name.as_deref()
               .ok_or("remote child requires start_fn_name")?;
           return start_single_child_remote(child, sup_pid, node, fn_name);
       }
       // ... existing local spawn code unchanged ...
   }
   ```
   This ensures target_node persists across restarts -- when `apply_strategy` calls `start_single_child` again for a restarted child, the ChildSpec still has `target_node` set, so it routes to remote spawn again (Pitfall 4 from RESEARCH.md).

5. Modify `terminate_single_child` to handle remote children:
   After the existing `let child_pid = match child.pid { ... }` but before the `match child.spec.shutdown` block, add a remote child early-return path:
   ```rust
   // Remote children: send exit signal via distribution, don't access local process table
   if !child_pid.is_local() {
       crate::dist::node::send_dist_exit(sup_pid, child_pid, &ExitReason::Shutdown);
       // The bidirectional link will deliver the child's exit back to the supervisor's
       // mailbox. We mark as not running immediately -- the supervisor's receive loop
       // handles the actual exit signal. This matches OTP semantics where termination
       // is asynchronous for remote children.
       child.running = false;
       child.pid = None;
       return;
   }
   ```
   The existing local termination code (BrutalKill/Timeout) remains unchanged for local children.

6. Update ALL existing `ChildSpec` construction sites in supervisor.rs tests (the `test_child_spec` helper function) to include `target_node: None, start_fn_name: None`.
  </action>
  <verify>
Run `cargo build -p snow-rt` -- must compile with no errors. Run `cargo test -p snow-rt -- supervisor` -- all existing supervisor tests pass. Run `cargo test -p snow-rt -- child_spec` -- all existing child_spec tests pass. Run `cargo test -p snow-rt` -- full test suite passes.
  </verify>
  <done>
ChildSpec has target_node and start_fn_name fields. start_single_child routes to start_single_child_remote when target_node is set. terminate_single_child sends DIST_EXIT for remote children. All existing tests pass (local supervisors completely unaffected).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update supervisor config parser and add remote supervisor tests</name>
  <files>crates/snow-rt/src/actor/mod.rs, crates/snow-rt/src/actor/supervisor.rs</files>
  <action>
**In `crates/snow-rt/src/actor/mod.rs`:**

1. Extend `parse_supervisor_config` to read optional `target_node` and `start_fn_name` fields after the existing `child_type` byte. Wire format extension per child spec:
   ```
   [existing fields...][child_type (1 byte)]
   [has_target_node (1 byte): 0=local, 1=remote]
   IF has_target_node == 1:
     [u16 node_name_len][node_name bytes]
     [u16 fn_name_len][fn_name bytes]
   ```
   When `has_target_node == 0`: set `target_node: None, start_fn_name: None` (backward compatible -- existing compiled programs emit 0 here, or we default to 0 if the byte is missing for backward compat).
   When `has_target_node == 1`: read node_name_len (u16 LE), node_name (UTF-8), fn_name_len (u16 LE), fn_name (UTF-8), and populate the ChildSpec fields.

   IMPORTANT for backward compatibility: If the data ends right after `child_type` (no more bytes for this spec), treat as `has_target_node = 0`. This keeps existing compiled programs working without recompilation. Check `pos < data.len()` before reading the has_target_node byte.

2. Update the `ChildSpec` construction in `parse_supervisor_config` to include the new fields:
   ```rust
   child_specs.push(child_spec::ChildSpec {
       id,
       start_fn,
       start_args_ptr,
       start_args_size,
       restart_type,
       shutdown,
       child_type,
       target_node,
       start_fn_name,
   });
   ```

3. Update the `snow_supervisor_start` function's ChildState construction to pass through the new fields (they're already in the ChildSpec from parsing, so the existing `.map(|spec| child_spec::ChildState { spec, pid: None, running: false })` works unchanged).

4. Update ALL existing test helpers in `mod.rs` tests that construct ChildSpec directly to include `target_node: None, start_fn_name: None`.

**In `crates/snow-rt/src/actor/supervisor.rs` tests:**

5. Add test `test_remote_child_spec_fields`: Create a ChildSpec with `target_node: Some("worker@host:9000".to_string())` and `start_fn_name: Some("my_worker".to_string())`. Verify the fields are set correctly. Create a ChildState from it. Verify `spec.target_node` is `Some(...)` and `spec.start_fn_name` is `Some(...)`.

6. Add test `test_find_child_index_with_remote_pid`: Create a SupervisorState with children. Set one child's PID to a remote PID (use `ProcessId::from_remote(5, 1, 42)` or similar). Call `find_child_index` with that PID. Verify it returns the correct index.

7. Add test `test_terminate_remote_child_marks_not_running`: Create a ChildState with a remote PID (node_id != 0). Call `terminate_single_child`. Verify `child.running = false` and `child.pid = None`. The `send_dist_exit` call will silently return (no node_state in test), which is fine -- we're testing the control flow, not the network.

**In `crates/snow-rt/src/actor/mod.rs` tests:**

8. Add test `test_parse_supervisor_config_with_target_node`: Build a config byte buffer that includes a child spec with `has_target_node = 1`, a node name, and a function name. Parse it with `parse_supervisor_config`. Verify the returned config has `target_node = Some(...)` and `start_fn_name = Some(...)`.

9. Add test `test_parse_supervisor_config_backward_compat`: Build a config byte buffer WITHOUT the `has_target_node` byte (simulating old compiled programs). Parse it. Verify it succeeds and `target_node = None`.
  </action>
  <verify>
Run `cargo build -p snow-rt` -- must compile with no errors. Run `cargo test -p snow-rt -- supervisor` -- all tests pass (existing + new). Run `cargo test -p snow-rt -- parse_supervisor_config` -- config parser tests pass. Run `cargo test -p snow-rt` -- full test suite passes.
  </verify>
  <done>
parse_supervisor_config reads optional target_node/start_fn_name from wire format with backward compatibility. Tests verify: remote child spec field storage, find_child_index with remote PIDs, terminate_single_child for remote children, config parsing with and without target_node. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles cleanly
2. `cargo test -p snow-rt` -- all tests pass (existing + new)
3. ChildSpec has target_node and start_fn_name fields
4. start_single_child routes to remote spawn when target_node is set
5. terminate_single_child sends DIST_EXIT for remote PIDs (is_local() == false)
6. parse_supervisor_config handles target_node wire format with backward compat
7. Existing local supervisors are completely unaffected (target_node: None path)
</verification>

<success_criteria>
- ChildSpec extended with target_node and start_fn_name (Option<String>)
- start_single_child routes to start_single_child_remote when target_node is Some
- start_single_child_remote calls snow_node_spawn with link_flag=1
- terminate_single_child sends DIST_EXIT for remote children (no local process table access)
- parse_supervisor_config reads target_node from wire format, backward compatible
- Remote child restarts go to the same remote node (target_node persists in ChildSpec)
- All existing supervisor tests pass unchanged
- Zero regressions in full test suite
</success_criteria>

<output>
After completion, create `.planning/phases/69-cross-node-integration/69-02-SUMMARY.md`
</output>
