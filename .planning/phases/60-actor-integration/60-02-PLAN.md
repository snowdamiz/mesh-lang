---
phase: 60-actor-integration
plan: 02
type: execute
wave: 2
depends_on: ["60-01"]
files_modified:
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "Ws.serve(on_connect, on_message, on_close, port) compiles to a call to snow_ws_serve with 7 arguments"
    - "Ws.send(conn, message) compiles to a call to snow_ws_send with conn pointer and SnowString"
    - "Ws.send_binary(conn, data, len) compiles to a call to snow_ws_send_binary with conn pointer, data pointer, and length"
    - "The full workspace builds without errors including both snow-rt and snow-codegen"
  artifacts:
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM function declarations for snow_ws_serve, snow_ws_send, snow_ws_send_binary"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Ws module in STDLIB_MODULES, known_functions entries, map_builtin_name entries"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/ws/server.rs"
      via: "map_builtin_name maps ws_serve -> snow_ws_serve"
      pattern: "ws_serve.*snow_ws_serve"
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/ws/server.rs"
      via: "LLVM External linkage declarations match #[no_mangle] extern C functions"
      pattern: "snow_ws_serve|snow_ws_send"
---

<objective>
Wire the WebSocket runtime functions into the Snow compiler's codegen pipeline so that `Ws.serve(...)`, `Ws.send(...)`, and `Ws.send_binary(...)` are recognized as stdlib module calls and lowered to the correct LLVM IR function calls.

Purpose: Without codegen wiring, the runtime functions from Plan 01 exist but cannot be called from Snow programs. This plan connects the Snow language surface (Ws.serve, Ws.send) to the Rust runtime (snow_ws_serve, snow_ws_send).

Output: Updated `intrinsics.rs` and `lower.rs` with WebSocket function declarations and mappings.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-actor-integration/60-RESEARCH.md
@.planning/phases/60-actor-integration/60-01-SUMMARY.md
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-rt/src/ws/server.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LLVM intrinsic declarations and known_functions for WebSocket runtime</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**1. Add LLVM function declarations in `intrinsics.rs`:**

Add after the HTTP function declarations (after the `snow_http_serve_tls` line):

```rust
// ── WebSocket functions (Phase 60) ──────────────────────────────────
// snow_ws_serve(on_connect_fn: ptr, on_connect_env: ptr, on_message_fn: ptr, on_message_env: ptr, on_close_fn: ptr, on_close_env: ptr, port: i64) -> void
module.add_function("snow_ws_serve", void_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), i64_type.into()], false), Some(inkwell::module::Linkage::External));

// snow_ws_send(conn: ptr, msg: ptr) -> i64
module.add_function("snow_ws_send", i64_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));

// snow_ws_send_binary(conn: ptr, data: ptr, len: i64) -> i64
module.add_function("snow_ws_send_binary", i64_type.fn_type(&[ptr_type.into(), ptr_type.into(), i64_type.into()], false), Some(inkwell::module::Linkage::External));
```

Add assertions in the test at the bottom of intrinsics.rs (find the test that checks for `snow_http_serve` and add):
```rust
assert!(module.get_function("snow_ws_serve").is_some());
assert!(module.get_function("snow_ws_send").is_some());
assert!(module.get_function("snow_ws_send_binary").is_some());
```

**2. Add known_functions entries in `lower.rs`:**

Find the `register_known_functions` method (or equivalent) where `snow_http_serve` is registered. Add after the HTTP entries:

```rust
// WebSocket functions (Phase 60)
self.known_functions.insert("snow_ws_serve".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr, MirType::Ptr, MirType::Ptr, MirType::Ptr, MirType::Int], Box::new(MirType::Unit)));
self.known_functions.insert("snow_ws_send".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::String], Box::new(MirType::Int)));
self.known_functions.insert("snow_ws_send_binary".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Int], Box::new(MirType::Int)));
```

**3. Add "Ws" to STDLIB_MODULES:**

Find the `STDLIB_MODULES` constant array. Add `"Ws"` to the list:

```rust
const STDLIB_MODULES: &[&str] = &[
    "String", "IO", "Env", "File", "List", "Map", "Set", "Tuple", "Range", "Queue", "HTTP", "JSON", "Json", "Request", "Job",
    "Math", "Int", "Float", "Timer", "Sqlite", "Pg", "Ws",
];
```

**4. Add map_builtin_name entries:**

Find the `map_builtin_name` function and add entries after the HTTP section:

```rust
// ── WebSocket functions (Phase 60) ────────────────────────────
"ws_serve" => "snow_ws_serve".to_string(),
"ws_send" => "snow_ws_send".to_string(),
"ws_send_binary" => "snow_ws_send_binary".to_string(),
```

These are the prefixed forms: when the compiler sees `Ws.serve(...)`, it converts the module+method to `ws_serve` (lowercase module + underscore + method), then `map_builtin_name` maps that to the runtime function name.
  </action>
  <verify>
`cargo check -p snow-codegen 2>&1 | tail -5` compiles without errors.
`cargo test -p snow-codegen intrinsics 2>&1 | tail -10` passes the intrinsics test.
`cargo build 2>&1 | tail -5` -- full workspace builds.
  </verify>
  <done>
`snow_ws_serve`, `snow_ws_send`, and `snow_ws_send_binary` are declared as LLVM external functions in intrinsics.rs.
`Ws` is recognized as a stdlib module in STDLIB_MODULES.
`ws_serve`, `ws_send`, `ws_send_binary` map to their runtime function names.
Known function types match the runtime function signatures.
Full workspace builds without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify full workspace build and run complete test suite</name>
  <files></files>
  <action>
Run the full workspace build and test suite to verify end-to-end integration:

1. `cargo build` -- full workspace must compile with the new WebSocket codegen wiring linked to the runtime functions
2. `cargo test` -- full test suite must pass
3. Verify that the LLVM declarations in intrinsics.rs match the actual `#[no_mangle] pub extern "C"` signatures in server.rs:
   - `snow_ws_serve` takes 7 args: 6 ptrs (3 closure pairs) + 1 i64 (port)
   - `snow_ws_send` takes 2 args: 1 ptr (conn) + 1 ptr (SnowString msg)
   - `snow_ws_send_binary` takes 3 args: 1 ptr (conn) + 1 ptr (data) + 1 i64 (len)

If any compilation errors occur from mismatched function signatures between codegen and runtime, fix them. Common issues:
- Argument count mismatch between intrinsics.rs declaration and actual extern "C" function
- Type mismatch (ptr vs i64) between known_functions and actual parameter types
- Missing or misspelled map_builtin_name entry causing "unknown function" errors

4. Run `cargo test -p snow-rt ws::` specifically to verify all 30 WebSocket protocol tests still pass
5. Run `cargo test -p snow-codegen` to verify all codegen tests pass
  </action>
  <verify>
`cargo build 2>&1 | tail -5` shows no errors.
`cargo test 2>&1 | grep "test result"` shows all test suites passing.
`cargo test -p snow-rt ws:: 2>&1 | tail -5` shows WS tests passing.
`cargo test -p snow-codegen 2>&1 | tail -5` shows codegen tests passing.
  </verify>
  <done>
Full workspace builds cleanly with WebSocket codegen wired to runtime.
All tests pass across snow-rt and snow-codegen.
No regressions in any existing functionality.
The WebSocket actor integration is complete and ready for Phase 61 (Production Hardening).
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds for the full workspace
2. `cargo test` passes all tests across all crates
3. `snow_ws_serve` is callable from LLVM IR with correct argument types
4. `Ws.serve`, `Ws.send`, `Ws.send_binary` are recognized during MIR lowering
5. No regressions in HTTP server, actor system, or WebSocket protocol tests
</verification>

<success_criteria>
- Snow programs can reference `Ws.serve`, `Ws.send`, `Ws.send_binary` without compilation errors
- LLVM IR function declarations match runtime extern "C" signatures exactly
- Full workspace builds and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/60-actor-integration/60-02-SUMMARY.md`
</output>
