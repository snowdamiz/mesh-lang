---
phase: 60-actor-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/ws/handshake.rs
  - crates/snow-rt/src/ws/server.rs
  - crates/snow-rt/src/ws/mod.rs
autonomous: true

must_haves:
  truths:
    - "snow_ws_serve binds a TCP listener and spawns one actor per accepted WebSocket connection"
    - "The reader thread reads frames from the TCP stream and pushes them into the actor mailbox with reserved type tags"
    - "Ws.send and Ws.send_binary write text/binary frames to the client through a shared Arc<Mutex<TcpStream>>"
    - "Actor crash sends close frame 1011 before dropping the connection"
    - "Client disconnect pushes a WS_DISCONNECT_TAG message to the actor mailbox causing the actor to exit"
    - "on_connect callback receives request headers and can reject connections with close 1008"
    - "on_message callback fires for each text and binary frame"
    - "on_close callback fires when the connection ends"
  artifacts:
    - path: "crates/snow-rt/src/ws/server.rs"
      provides: "WebSocket server runtime: accept loop, reader thread bridge, connection handle, lifecycle callbacks"
    - path: "crates/snow-rt/src/ws/handshake.rs"
      provides: "perform_upgrade returns request path and headers on success"
    - path: "crates/snow-rt/src/ws/mod.rs"
      provides: "Re-exports server module items"
  key_links:
    - from: "crates/snow-rt/src/ws/server.rs"
      to: "crates/snow-rt/src/ws/handshake.rs"
      via: "perform_upgrade call in ws_connection_entry"
      pattern: "perform_upgrade"
    - from: "crates/snow-rt/src/ws/server.rs"
      to: "crates/snow-rt/src/ws/frame.rs"
      via: "read_frame in reader thread, write_frame in Ws.send"
      pattern: "read_frame|write_frame"
    - from: "crates/snow-rt/src/ws/server.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "global_scheduler, sched.spawn, Mailbox push, wake_process"
      pattern: "global_scheduler|sched\\.spawn|mailbox\\.push|wake_process"
---

<objective>
Implement the WebSocket server runtime: accept loop, actor-per-connection, reader thread bridge, connection handle, Ws.send/Ws.send_binary, lifecycle callbacks (on_connect, on_message, on_close), crash isolation, and client disconnect handling.

Purpose: This is the core runtime layer that integrates Phase 59's WebSocket protocol with Snow's actor system. The reader thread bridge is the novel component -- it reads frames on a dedicated OS thread and pushes them into the actor's mailbox without blocking the M:N scheduler.

Output: `crates/snow-rt/src/ws/server.rs` with all runtime functions, modified `handshake.rs` returning headers.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-actor-integration/60-RESEARCH.md
@.planning/phases/59-protocol-core/59-01-SUMMARY.md
@.planning/phases/59-protocol-core/59-02-SUMMARY.md
@crates/snow-rt/src/ws/mod.rs
@crates/snow-rt/src/ws/frame.rs
@crates/snow-rt/src/ws/handshake.rs
@crates/snow-rt/src/ws/close.rs
@crates/snow-rt/src/http/server.rs
@crates/snow-rt/src/actor/mod.rs
@crates/snow-rt/src/actor/mailbox.rs
@crates/snow-rt/src/actor/process.rs
@crates/snow-rt/src/actor/link.rs
@crates/snow-rt/src/actor/scheduler.rs
@crates/snow-rt/src/actor/heap.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify perform_upgrade to return headers and create server.rs skeleton with reserved tags, WsHandler, WsConnection, and accept loop</name>
  <files>
    crates/snow-rt/src/ws/handshake.rs
    crates/snow-rt/src/ws/server.rs
    crates/snow-rt/src/ws/mod.rs
  </files>
  <action>
**1. Modify `perform_upgrade` in `handshake.rs` (LIFE-01 prerequisite):**
Change the return type from `Result<(), String>` to `Result<(String, Vec<(String, String)>), String>`.
On success, return `Ok((path, headers))` where `path` is from the request line (e.g., "/ws") and `headers` is the parsed `Vec<(String, String)>`. The request path is `parts[1].to_string()`.
Update the existing tests to expect the new return type -- `assert!(result.is_ok())` still works, but any test that destructures the result needs updating.

**2. Create `crates/snow-rt/src/ws/server.rs`** with the following items:

**Reserved type tags (from research, extending EXIT_SIGNAL_TAG pattern in link.rs):**
```rust
pub const WS_TEXT_TAG: u64 = u64::MAX - 1;
pub const WS_BINARY_TAG: u64 = u64::MAX - 2;
pub const WS_DISCONNECT_TAG: u64 = u64::MAX - 3;
pub const WS_CONNECT_TAG: u64 = u64::MAX - 4;
```

**WsHandler struct** (3 Snow closure pairs = 6 pointers):
```rust
#[repr(C)]
struct WsHandler {
    on_connect_fn: *mut u8,
    on_connect_env: *mut u8,
    on_message_fn: *mut u8,
    on_message_env: *mut u8,
    on_close_fn: *mut u8,
    on_close_env: *mut u8,
}
```
WsHandler contains raw pointers -- mark it `unsafe impl Send for WsHandler {}` since it's transferred between threads.

**WsConnection struct** (connection handle for Ws.send):
```rust
struct WsConnection {
    write_stream: Arc<Mutex<TcpStream>>,
    shutdown: Arc<AtomicBool>,
}
```
The `actor_pid` is not needed in the connection handle because the actor calls Ws.send on itself -- it already knows its own PID.

**WsConnectionArgs** (args passed to the spawned actor, following HTTP's ConnectionArgs pattern):
```rust
#[repr(C)]
struct WsConnectionArgs {
    handler: WsHandler,
    stream_ptr: usize,
}
```

**`snow_ws_serve` function** (extern "C", #[no_mangle]):
- Signature: `snow_ws_serve(on_connect_fn: *mut u8, on_connect_env: *mut u8, on_message_fn: *mut u8, on_message_env: *mut u8, on_close_fn: *mut u8, on_close_env: *mut u8, port: i64)`
- Call `crate::actor::snow_rt_init_actor(0)` (idempotent)
- Bind `TcpListener` on `0.0.0.0:{port}`
- Print `[snow-rt] WebSocket server listening on {addr}` to stderr
- For each accepted TCP stream:
  - `tcp_stream.set_read_timeout(Some(Duration::from_secs(30))).ok()`
  - Pack into `WsConnectionArgs` with handler cloned (copy the 6 pointers) and `Box::into_raw(Box::new(tcp_stream)) as usize`
  - Call `sched.spawn(ws_connection_entry as *const u8, args_ptr, args_size, 1)`
- On accept error: `eprintln!("[snow-rt] accept error: {}", e)` and continue

**`snow_ws_send` function** (extern "C", #[no_mangle]):
- Signature: `snow_ws_send(conn: *mut u8, msg_ptr: *const u8, msg_len: i64) -> i64`
- Cast `conn` to `&WsConnection`
- Extract the string bytes from `msg_ptr` and `msg_len` (these are raw bytes, not SnowString -- the codegen will pass the string data pointer and length)
- Lock `write_stream`, call `write_frame(&mut *stream, WsOpcode::Text, bytes, true)`
- Return 0 on success, -1 on error

IMPORTANT: The Snow-level API is `Ws.send(conn, message)` where message is a SnowString. The codegen maps this to `snow_ws_send(conn_ptr, str_ptr, str_len)`. The runtime function receives the raw pointer to SnowString. Read the string data via `(*msg).as_str()` like the HTTP server does. So the actual signature should be:
```rust
pub extern "C" fn snow_ws_send(conn: *mut u8, msg: *const SnowString) -> i64
```
Extract text via `unsafe { (*msg).as_str() }`, then `write_frame` with `text.as_bytes()`.

**`snow_ws_send_binary` function** (extern "C", #[no_mangle]):
- Signature: `snow_ws_send_binary(conn: *mut u8, data: *const u8, len: i64) -> i64`
- Cast `conn` to `&WsConnection`
- Construct slice from `data` and `len`
- Lock `write_stream`, call `write_frame(&mut *stream, WsOpcode::Binary, bytes, true)`
- Return 0 on success, -1 on error

**3. Update `mod.rs`:**
Add `pub mod server;` and re-export key items: `pub use server::{WS_TEXT_TAG, WS_BINARY_TAG, WS_DISCONNECT_TAG, WS_CONNECT_TAG};`

**Imports needed in server.rs:**
```rust
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::Duration;
use parking_lot::Mutex;
use crate::actor::{self, global_scheduler, MessageBuffer, Message, ProcessId, ProcessState, Mailbox};
use crate::actor::stack;
use crate::string::SnowString;
use super::frame::{read_frame, write_frame, WsOpcode};
use super::handshake::perform_upgrade;
use super::close::{process_frame, send_close, WsCloseCode};
```
  </action>
  <verify>
`cargo check -p snow-rt 2>&1 | tail -5` compiles without errors.
Existing WS tests still pass: `cargo test -p snow-rt ws:: 2>&1 | tail -20`.
The `perform_upgrade` tests in `handshake.rs` pass with the updated return type.
  </verify>
  <done>
`perform_upgrade` returns `Result<(String, Vec<(String, String)>), String>` with path and headers.
`server.rs` exists with `snow_ws_serve`, `snow_ws_send`, `snow_ws_send_binary`, reserved type tags, WsHandler, WsConnection, WsConnectionArgs.
`mod.rs` re-exports the server module.
All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement reader thread bridge, actor message loop with lifecycle callbacks, crash isolation, and disconnect handling</name>
  <files>
    crates/snow-rt/src/ws/server.rs
  </files>
  <action>
Implement the remaining runtime functions in `server.rs`. This is the novel part of Phase 60 -- the reader thread bridge and actor lifecycle management.

**1. `ws_connection_entry` function** (actor entry point):

```rust
extern "C" fn ws_connection_entry(args: *const u8) {
    if args.is_null() { return; }
    let args = unsafe { Box::from_raw(args as *mut WsConnectionArgs) };
    let handler = args.handler;
    let mut stream = unsafe { *Box::from_raw(args.stream_ptr as *mut TcpStream) };

    // 1. Perform WebSocket upgrade handshake
    let (path, headers) = match perform_upgrade(&mut stream) {
        Ok(ph) => ph,
        Err(e) => {
            eprintln!("[snow-rt] WS upgrade failed: {}", e);
            return;
        }
    };

    // 2. Split stream: clone for reading, original for writing via Arc<Mutex>
    let read_stream = match stream.try_clone() {
        Ok(s) => s,
        Err(e) => {
            eprintln!("[snow-rt] WS stream clone failed: {}", e);
            return;
        }
    };
    let write_stream = Arc::new(Mutex::new(stream));
    let shutdown = Arc::new(AtomicBool::new(false));

    // 3. Create WsConnection handle (Rust heap, not GC heap)
    let conn = Box::into_raw(Box::new(WsConnection {
        write_stream: write_stream.clone(),
        shutdown: shutdown.clone(),
    }));
    let conn_ptr = conn as *mut u8;

    // 4. Get current actor's PID and mailbox for reader thread
    let my_pid = stack::get_current_pid().expect("ws_connection_entry: no PID");
    let sched = global_scheduler();
    let mailbox_arc = {
        let proc = sched.get_process(my_pid).expect("ws_connection_entry: no process");
        let p = proc.lock();
        // We need the mailbox as Arc -- but Mailbox is inside Process behind Arc<Mutex<Process>>.
        // Instead, we'll store a reference to the process itself for pushing.
        // Actually, looking at the Mailbox type, it's inside the Process struct, not separately Arc'd.
        // So we need to keep the Arc<Mutex<Process>> for the reader thread to push messages.
        drop(p);
        proc
    };

    // 5. Call on_connect callback (LIFE-01, LIFE-02)
    //    Build a Snow-level headers map and path string, pass to on_connect
    //    If on_connect returns a rejection signal, send close 1008 and exit
    let accepted = call_on_connect(&handler, conn_ptr, &path, &headers);
    if !accepted {
        // on_connect rejected -- send close 1008 (Policy Violation)
        let _ = send_close(&mut *write_stream.lock(), WsCloseCode::PROTOCOL_ERROR, "rejected");
        shutdown.store(true, Ordering::SeqCst);
        // Clean up connection handle
        unsafe { drop(Box::from_raw(conn)); }
        return;
    }

    // 6. Set read timeout on the read stream clone for the reader thread (5 seconds for periodic shutdown check)
    read_stream.set_read_timeout(Some(Duration::from_secs(5))).ok();

    // 7. Spawn reader thread
    let reader_shutdown = shutdown.clone();
    let reader_write = write_stream.clone();
    let reader_proc = mailbox_arc.clone();
    let reader_pid = my_pid;
    std::thread::spawn(move || {
        reader_thread_loop(read_stream, reader_write, reader_proc, reader_pid, reader_shutdown);
    });

    // 8. Actor message loop with catch_unwind (ACTOR-01, ACTOR-05)
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        actor_message_loop(&handler, conn_ptr, &mailbox_arc, my_pid);
    }));

    // 9. Cleanup
    shutdown.store(true, Ordering::SeqCst);

    // Determine close code and call on_close
    let (close_code, close_reason) = if result.is_err() {
        // Actor crashed (ACTOR-05): send close 1011
        let _ = send_close(&mut *write_stream.lock(), WsCloseCode::INTERNAL_ERROR, "internal error");
        (WsCloseCode::INTERNAL_ERROR, "internal error")
    } else {
        (WsCloseCode::NORMAL, "")
    };

    // Call on_close callback (LIFE-04)
    call_on_close(&handler, conn_ptr, close_code, close_reason);

    // Clean up connection handle
    unsafe { drop(Box::from_raw(conn)); }
}
```

IMPORTANT CORRECTION on close code for on_connect rejection: Use 1008 (Policy Violation) as specified in the research, not PROTOCOL_ERROR (1002). Define a new constant in the server:
```rust
const WS_POLICY_VIOLATION: u16 = 1008;
```

**2. `reader_thread_loop` function:**

```rust
fn reader_thread_loop(
    mut read_stream: TcpStream,
    write_stream: Arc<Mutex<TcpStream>>,
    proc_arc: Arc<Mutex<Process>>,
    actor_pid: ProcessId,
    shutdown: Arc<AtomicBool>,
) {
    loop {
        if shutdown.load(Ordering::SeqCst) { break; }

        match read_frame(&mut read_stream) {
            Ok(frame) => {
                let mut writer = write_stream.lock();
                match process_frame(&mut *writer, frame) {
                    Ok(Some(data_frame)) => {
                        drop(writer); // Release lock before mailbox push
                        let tag = match data_frame.opcode {
                            WsOpcode::Text => WS_TEXT_TAG,
                            WsOpcode::Binary => WS_BINARY_TAG,
                            _ => WS_TEXT_TAG, // Continuation treated as text for now
                        };
                        let buffer = MessageBuffer::new(data_frame.payload, tag);
                        let msg = Message { buffer };

                        // Push to mailbox and wake actor if Waiting (Pitfall 7)
                        {
                            let mut proc = proc_arc.lock();
                            proc.mailbox.push(msg);
                            if matches!(proc.state, ProcessState::Waiting) {
                                proc.state = ProcessState::Ready;
                                drop(proc);
                                let sched = global_scheduler();
                                sched.wake_process(actor_pid);
                            }
                        }
                    }
                    Ok(None) => { /* Control frame handled (ping->pong) */ }
                    Err(_) => {
                        drop(writer);
                        // Close or protocol error -- push disconnect
                        push_disconnect(&proc_arc, actor_pid);
                        break;
                    }
                }
            }
            Err(e) => {
                if shutdown.load(Ordering::SeqCst) { break; }
                // Check if it's a timeout (not a real error)
                let err_str = e.to_string();
                if err_str.contains("timed out") || err_str.contains("WouldBlock") {
                    continue; // Just a read timeout, check shutdown and loop
                }
                // Real I/O error -- push disconnect
                push_disconnect(&proc_arc, actor_pid);
                break;
            }
        }
    }
}
```

NOTE: `read_frame` returns `Result<WsFrame, String>`. Check the actual error type. The `e` is a `String`, so `e.contains("timed out")` works directly.

**3. `push_disconnect` helper:**

```rust
fn push_disconnect(proc_arc: &Arc<Mutex<Process>>, actor_pid: ProcessId) {
    let buffer = MessageBuffer::new(Vec::new(), WS_DISCONNECT_TAG);
    let msg = Message { buffer };
    let mut proc = proc_arc.lock();
    proc.mailbox.push(msg);
    if matches!(proc.state, ProcessState::Waiting) {
        proc.state = ProcessState::Ready;
        drop(proc);
        let sched = global_scheduler();
        sched.wake_process(actor_pid);
    }
}
```

**4. `actor_message_loop` function:**

The actor loops calling `snow_actor_receive(-1)` (blocking receive). When a message arrives, check the type_tag in the returned heap layout `[u64 type_tag, u64 data_len, u8... data]`:

```rust
fn actor_message_loop(
    handler: &WsHandler,
    conn_ptr: *mut u8,
    proc_arc: &Arc<Mutex<Process>>,
    my_pid: ProcessId,
) {
    use crate::actor::snow_actor_receive;

    loop {
        let msg_ptr = snow_actor_receive(-1);
        if msg_ptr.is_null() { break; }

        // Read type_tag from heap layout
        let type_tag = unsafe {
            let mut tag_bytes = [0u8; 8];
            std::ptr::copy_nonoverlapping(msg_ptr, tag_bytes.as_mut_ptr(), 8);
            u64::from_le_bytes(tag_bytes)
        };

        match type_tag {
            WS_TEXT_TAG | WS_BINARY_TAG => {
                // Read data_len and data
                let (data_len, data_ptr) = unsafe {
                    let mut len_bytes = [0u8; 8];
                    std::ptr::copy_nonoverlapping(msg_ptr.add(8), len_bytes.as_mut_ptr(), 8);
                    let len = u64::from_le_bytes(len_bytes) as usize;
                    (len, msg_ptr.add(16))
                };
                // Call on_message (LIFE-03)
                call_on_message(handler, conn_ptr, data_ptr, data_len, type_tag == WS_TEXT_TAG);
            }
            WS_DISCONNECT_TAG => {
                // Client disconnected (ACTOR-06)
                break;
            }
            tag if tag == crate::actor::EXIT_SIGNAL_TAG => {
                // Exit signal from linked actor
                break;
            }
            _ => {
                // Regular actor-to-actor message -- ignore for now
                // (future: could be handled by user code)
            }
        }
    }
}
```

**5. Callback calling helpers:**

For calling Snow closures, follow the HTTP server pattern in `call_handler`. Each callback is a `{fn_ptr, env_ptr}` pair.

```rust
fn call_on_connect(handler: &WsHandler, conn_ptr: *mut u8, path: &str, headers: &[(String, String)]) -> bool {
    if handler.on_connect_fn.is_null() { return true; } // No callback = accept

    // Build Snow-level path string and headers map
    // Use snow_string_new for the path, snow_map for headers
    // Then call the closure
    unsafe {
        let path_snow = crate::string::snow_string_new(path.as_ptr(), path.len() as u64) as *mut u8;
        let mut headers_map = crate::collections::map::snow_map_new_typed(1);
        for (name, value) in headers {
            let key = crate::string::snow_string_new(name.as_ptr(), name.len() as u64);
            let val = crate::string::snow_string_new(value.as_ptr(), value.len() as u64);
            headers_map = crate::collections::map::snow_map_put(headers_map, key as u64, val as u64);
        }

        let result = if handler.on_connect_env.is_null() {
            let f: fn(*mut u8, *mut u8, *mut u8) -> *mut u8 = std::mem::transmute(handler.on_connect_fn);
            f(conn_ptr, path_snow, headers_map)
        } else {
            let f: fn(*mut u8, *mut u8, *mut u8, *mut u8) -> *mut u8 = std::mem::transmute(handler.on_connect_fn);
            f(handler.on_connect_env, conn_ptr, path_snow, headers_map)
        };

        // Interpret result: if it equals the atom :reject (or is null/error), reject.
        // Convention: non-null = accepted, null = rejected
        // Simpler: return value is an i64 atom tag. :ok = 0, :reject = 1.
        // Actually: Snow returns an atom. The simplest convention is:
        // if result is null -> reject, otherwise -> accept
        !result.is_null()
    }
}
```

NOTE on GC safety: `call_on_connect` calls `snow_string_new` and `snow_map_*` which allocate on the current actor's GC heap. This is safe because `ws_connection_entry` runs inside an actor coroutine. `snow_gc_alloc_actor` uses the thread-local actor heap.

```rust
fn call_on_message(handler: &WsHandler, conn_ptr: *mut u8, data_ptr: *const u8, data_len: usize, is_text: bool) {
    if handler.on_message_fn.is_null() { return; }

    unsafe {
        // Build a Snow string from the frame payload
        let msg_snow = crate::string::snow_string_new(data_ptr, data_len as u64) as *mut u8;

        if handler.on_message_env.is_null() {
            let f: fn(*mut u8, *mut u8) -> *mut u8 = std::mem::transmute(handler.on_message_fn);
            f(conn_ptr, msg_snow);
        } else {
            let f: fn(*mut u8, *mut u8, *mut u8) -> *mut u8 = std::mem::transmute(handler.on_message_fn);
            f(handler.on_message_env, conn_ptr, msg_snow);
        }
    }
}
```

```rust
fn call_on_close(handler: &WsHandler, conn_ptr: *mut u8, code: u16, reason: &str) {
    if handler.on_close_fn.is_null() { return; }

    unsafe {
        let code_i64 = code as i64;
        let reason_snow = crate::string::snow_string_new(reason.as_ptr(), reason.len() as u64) as *mut u8;

        if handler.on_close_env.is_null() {
            let f: fn(*mut u8, i64, *mut u8) -> *mut u8 = std::mem::transmute(handler.on_close_fn);
            f(conn_ptr, code_i64, reason_snow);
        } else {
            let f: fn(*mut u8, *mut u8, i64, *mut u8) -> *mut u8 = std::mem::transmute(handler.on_close_fn);
            f(handler.on_close_env, conn_ptr, code_i64, reason_snow);
        }
    }
}
```

**6. Handle Process import:**

The `reader_thread_loop` needs `Arc<Mutex<Process>>`. Import `Process` from `crate::actor::process::Process`. Also import `use parking_lot::Mutex;` -- make sure to use `parking_lot::Mutex` NOT `std::sync::Mutex` since that's what the rest of the actor system uses.

**CRITICAL: Thread-safety of proc_arc in reader thread:**

The reader thread holds `Arc<parking_lot::Mutex<Process>>`. This works because `parking_lot::Mutex` is `Send + Sync`, and `Process` is behind the mutex. However, `Process` contains raw pointers (coroutine handle, heap, etc.) which are NOT Send. The Arc<Mutex<Process>> is already used across threads in the scheduler (worker threads share the process table). The reader thread only accesses `proc.mailbox.push()` and `proc.state` -- both are safe through the mutex.

To make this compile, the reader thread needs the same `Arc<Mutex<Process>>` type used by `sched.get_process()`. This returns `Option<Arc<Mutex<Process>>>` already, so just pass it to the reader thread.

**CRITICAL: `on_close` must be called inside the actor coroutine context**, not after the coroutine returns. Move the `call_on_close` into the end of `actor_message_loop` (before it returns) for the normal-disconnect case. For the crash case, call it in the catch_unwind error handler (but GC allocations may not be safe after a panic -- use a minimal implementation that doesn't allocate on the actor heap if possible, or just skip on_close on crash and only send the 1011 close frame).

Revised approach: Call `on_close` at the end of the actor_message_loop for the normal case. For crashes, only send the 1011 frame (on_close is best-effort and may not be safe to call after a panic).

**Exit signal propagation (ACTOR-06):**

When the actor's entry function returns (either normally from disconnect or via catch_unwind from crash), the scheduler's normal process exit handling runs. This propagates exit signals to linked actors via `propagate_exit`. No additional code needed -- the existing scheduler infrastructure handles this.
  </action>
  <verify>
`cargo check -p snow-rt 2>&1 | tail -5` compiles without errors.
`cargo test -p snow-rt ws:: 2>&1 | tail -20` -- all 30 existing WebSocket tests pass.
`cargo test -p snow-rt 2>&1 | grep "test result"` -- full runtime test suite passes.
  </verify>
  <done>
`ws_connection_entry` performs handshake, splits stream, spawns reader thread, runs actor message loop with catch_unwind.
Reader thread reads frames via `read_frame`, dispatches via `process_frame`, pushes to mailbox with reserved tags, wakes actor.
`actor_message_loop` dispatches WS_TEXT_TAG/WS_BINARY_TAG to on_message, WS_DISCONNECT_TAG exits loop.
`call_on_connect` invokes the on_connect callback and supports rejection (close 1008).
`call_on_message` invokes the on_message callback with the frame payload as a SnowString.
`call_on_close` invokes the on_close callback with close code and reason.
Actor crash sends close frame 1011 via catch_unwind handler (ACTOR-05).
Actor exit propagates to linked actors via existing scheduler exit handling (ACTOR-06).
Shutdown flag stops reader thread when actor exits (Pitfall 4).
All existing tests pass (no regressions).
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p snow-rt` compiles without errors
2. `cargo test -p snow-rt ws::` passes all WebSocket tests (30 existing + any new)
3. `cargo test -p snow-rt` passes the full runtime test suite
4. `perform_upgrade` returns `(String, Vec<(String, String)>)` on success
5. `snow_ws_serve` is `#[no_mangle] pub extern "C"` and callable from LLVM IR
6. `snow_ws_send` and `snow_ws_send_binary` are `#[no_mangle] pub extern "C"`
7. Reserved type tags use u64::MAX - {1,2,3,4} range (no collision with EXIT_SIGNAL_TAG = u64::MAX)
</verification>

<success_criteria>
- server.rs implements the complete actor-per-connection WebSocket runtime
- Reader thread bridge pushes frames to actor mailbox without blocking scheduler
- Lifecycle callbacks (on_connect, on_message, on_close) fire at correct points
- Actor crash isolation via catch_unwind sends 1011 close frame
- Client disconnect causes actor exit with signal propagation
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/60-actor-integration/60-01-SUMMARY.md`
</output>
