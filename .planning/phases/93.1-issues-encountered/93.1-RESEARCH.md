# Phase 93.1: Issues Encountered - Research

**Researched:** 2026-02-15
**Domain:** Mesh application-level compilation errors in Mesher REST API modules
**Confidence:** HIGH

## Summary

Phase 93.1 addresses 7 compilation errors across 3 Mesher source files (`api/detail.mpl`, `api/team.mpl`, `main.mpl`). Unlike Phase 87.1 which fixed compiler bugs in the Mesh toolchain itself, all errors here are application-level Mesh code bugs caused by violating Mesh language constraints (define-before-use, module expression typing) or by type mismatches from incorrect function signatures.

The errors break into three categories: **(A) Define-before-use violations** in `detail.mpl` and `team.mpl` where functions call other functions defined later in the file, **(B) Module expression type mismatch** in `detail.mpl` where the module body evaluates to `Response` instead of `()`, and **(C) Cross-module type mismatch** in `main.mpl` where `handle_top_issues` is inferred with a return type of `Result<List<Map<String, String>>, String>` instead of `Response`, likely caused by error propagation from the Dashboard module's compilation.

All fixes are purely Mesh source code reordering and edits -- no compiler changes needed. The fixes are low-risk and well-understood from established patterns in the working modules (`api/search.mpl`, `api/alerts.mpl`, `api/settings.mpl`).

**Primary recommendation:** Fix define-before-use ordering in detail.mpl and team.mpl first (most errors), then address the module expression issue, then verify the main.mpl type error resolves as a cascading fix.

## Standard Stack

Not applicable -- this phase edits existing Mesh application code only. No new libraries, dependencies, or compiler changes required.

## Architecture Patterns

### Pattern 1: Define-Before-Use Function Ordering (Leaf-First)

**What:** In Mesh, functions must be defined before they are called. Helper function chains must be ordered so that "leaf" functions (those calling no other local functions) appear first, and "root" functions (those called by the framework, like `pub fn handle_*`) appear last.

**When to use:** Every `.mpl` module with internal helper functions.

**Correct order (from working `api/search.mpl`):**
```
1. Leaf helpers (pure transforms, no internal calls):  cap_limit, parse_limit, row_to_issue_json
2. Mid-level helpers (call leaf helpers):              serialize_issue_rows, build_paginated_response
3. Handler helpers (call mid-level):                   handle_issue_result_ok, dispatch_event_search
4. Pub handlers (call handler helpers):                pub fn handle_search_issues
```

**Anti-pattern (current `api/detail.mpl`):**
```
line 62: fn add_navigation calls build_nav_response (line 71) -- FORWARD REFERENCE
line 65: fn build_nav_response defined AFTER add_navigation -- TOO LATE
```

### Pattern 2: Module Expression Must Be Unit `()`

**What:** In Mesh, a module body is treated as a sequence of items (fn defs, imports). The "expression" the module evaluates to determines its type. Modules containing only function definitions evaluate to `()`. If the last item in a module is a `pub fn` returning `Response`, the compiler may infer the module expression as `Response` instead of `()`.

**When to use:** Understanding why `detail.mpl` gets `expected (), found Response`.

**Analysis of detail.mpl:**
The error spans lines 1-109 (the entire module), saying `expected (), found Response`. This is a cascading error -- because `build_nav_response` is undefined at line 65, the type checker cannot determine the type of `add_navigation`, which cascades upward. The `expected Result<...>, found Response` error on lines 77-82 is also cascading. Once the define-before-use error is fixed, the module expression should correctly resolve to `()`.

### Pattern 3: Router Handler Type Inference

**What:** Each handler registered with `HTTP.on_get`/`HTTP.on_post` must have the signature `(Request) -> Response`. If a handler's inferred return type is not `Response` (e.g., it returns `Result<...>` because the case expression is incomplete or has type inference issues), the router pipe chain fails with a type mismatch.

**When to use:** The `main.mpl` error on lines 78-79 where `handle_top_issues` has type `Result<List<Map<String, String>>, String>` instead of `Response`.

**Root cause analysis:** Looking at `handle_top_issues` in `dashboard.mpl` (lines 105-115), the function is structurally correct -- it wraps the `top_issues_by_frequency` call in a `case` that returns `HTTP.response(...)` in both arms. The type mismatch in `main.mpl` is almost certainly a cascading error from the errors in `detail.mpl` or `team.mpl` -- when those modules fail to type-check, cross-module type resolution may produce incorrect types for other modules. **This error should resolve once detail.mpl and team.mpl are fixed.**

If the error persists after fixing the other modules, the fallback fix is to add an explicit return type annotation: `pub fn handle_top_issues(request) -> Response do`.

### Anti-Patterns to Avoid

- **Adding functions at the end of a chain without checking call order:** When adding helper functions to an existing module, always trace the call graph and ensure callees appear before callers.
- **Assuming cascading errors are independent bugs:** Many errors in this batch are cascading. Fix root causes first, recompile, then assess remaining errors.
- **Adding explicit type annotations as a first resort:** The type inference is generally correct when the code structure is right. Annotations should only be added if the underlying structural issue cannot be resolved.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Function ordering | Manual topological sort | Follow existing module patterns | Working modules (search, alerts, settings) demonstrate the correct pattern |
| Module type errors | Compiler fixes | Correct source code ordering | These are application bugs, not compiler bugs |

**Key insight:** All errors in this phase are solvable by reordering existing Mesh code and/or adding minor fixes. No compiler changes are needed.

## Common Pitfalls

### Pitfall 1: Forward References in Helper Chains

**What goes wrong:** A function calls another function that is defined later in the file. Mesh uses define-before-use semantics (like C without forward declarations).
**Why it happens:** When writing mutually-dependent or chain-like helper functions, it's natural to write the "entry point" first and the "implementation" second. This is backwards for Mesh.
**How to avoid:** Draw the call graph. Place leaf functions (no internal calls) first, then their callers, then their callers' callers. Pub handlers go last.
**Warning signs:** `undefined variable: <function_name>` error where the function IS defined in the same file, just later.

### Pitfall 2: Cascading Type Errors Across Modules

**What goes wrong:** An error in one module (e.g., `detail.mpl`) causes type inference failures in other modules (e.g., `main.mpl`) that import from the broken module.
**Why it happens:** The Mesh compiler processes modules in dependency order. If module A fails to type-check, exported symbols from A may have incorrect or placeholder types, causing downstream type mismatches.
**How to avoid:** Fix errors in leaf modules first, recompile, then check if downstream errors resolve.
**Warning signs:** Type errors in `main.mpl` that reference types belonging to functions defined in other modules.

### Pitfall 3: Module Expression Type for Modules with Only Function Definitions

**What goes wrong:** The compiler reports `expected (), found <type>` for the entire module span.
**Why it happens:** When type inference fails for internal functions, the module's expression type can be inferred incorrectly. This is almost always a symptom of another error, not a standalone bug.
**How to avoid:** Fix all `undefined variable` errors in the module first. The module expression type should resolve to `()` once all functions type-check correctly.
**Warning signs:** Error span covering the entire module (line 1 to last line).

## Code Examples

Verified patterns from working Mesher modules.

### Correct Helper Chain Ordering (from api/alerts.mpl)

```mesh
# 1. Leaf helper (no internal calls)
fn format_nullable_ts(ts :: String) -> String do
  if String.length(ts) > 0 do
    "\"" <> ts <> "\""
  else
    "null"
  end
end

# 2. Mid-level helper (calls leaf helper)
fn alert_row_to_json(row) -> String do
  # ... uses format_nullable_ts ...
end

# 3. Handler helper (calls mid-level)
fn toggle_from_rows(pool :: PoolHandle, rule_id :: String, rows) do
  # ... calls toggle_alert_rule then HTTP.response ...
end

# 4. Pub handler (calls handler helper) -- LAST
pub fn handle_toggle_alert_rule(request) do
  # ... calls toggle_from_rows ...
end
```

### Correct Helper Chain for Two-Query Pattern (fix for detail.mpl)

The current broken order in detail.mpl:
```
line 62: fn add_navigation  -->  calls build_nav_response (FORWARD REF!)
line 71: fn build_nav_response
line 83: fn build_event_response_from_rows  -->  calls add_navigation
line 100: pub fn handle_event_detail  -->  calls build_event_response_from_rows
```

The correct order should be:
```
fn build_nav_response           (leaf -- calls only HTTP.response, build_detail_response)
fn add_navigation               (calls build_nav_response)
fn build_event_response_from_rows  (calls add_navigation)
pub fn handle_event_detail      (calls build_event_response_from_rows)
```

### Correct Helper Chain for team.mpl

The current broken order:
```
line 84: fn do_add_member
line 93: fn add_member_with_role  -->  calls do_add_member (OK, defined above)
line 102: fn validate_add_member  -->  calls check_user_id (FORWARD REF to line 111!)
line 110: fn check_user_id  -->  calls add_member_with_role (OK)
line 122: fn do_update_role  -->  calls perform_role_update (FORWARD REF to line 131!)
line 131: fn perform_role_update
line 142: fn do_create_key  -->  calls perform_create_key (FORWARD REF to line 151!)
line 151: fn perform_create_key
```

The correct order:
```
fn do_add_member                (calls add_member)
fn add_member_with_role         (calls do_add_member)
fn check_user_id                (calls add_member_with_role)
fn validate_add_member          (calls check_user_id)
fn perform_role_update          (calls update_member_role)
fn do_update_role               (calls perform_role_update)
fn perform_create_key           (calls create_api_key)
fn do_create_key                (calls perform_create_key)
```

## Issue Catalog

### Issue 1: detail.mpl -- `build_nav_response` Forward Reference (ROOT CAUSE)

**Error:** `undefined variable: build_nav_response` at line 61 (inside comment parsed as identifier in `add_navigation`)
**Actual error location:** Line 65 in `add_navigation` function calls `build_nav_response` which is defined at line 71.
**Fix:** Move `build_nav_response` (lines 71-79) above `add_navigation` (lines 62-68).
**Cascading errors this fixes:**
- `expected Result<...>, found Response` on lines 77-82 (type inference cascade)
- `expected (), found Response` on lines 1-109 (module expression cascade)

### Issue 2: team.mpl -- `check_user_id` Forward Reference

**Error:** `undefined variable: check_user_id` at line 96 (inside `validate_add_member`)
**Fix:** Move `check_user_id` (lines 111-117) above `validate_add_member` (lines 102-108).

### Issue 3: team.mpl -- `perform_role_update` Forward Reference

**Error:** `undefined variable: perform_role_update` at line 125 (inside `do_update_role`)
**Fix:** Move `perform_role_update` (lines 131-137) above `do_update_role` (lines 122-128).

### Issue 4: team.mpl -- `perform_create_key` Forward Reference

**Error:** `undefined variable: perform_create_key` at line 145 (inside `do_create_key`)
**Fix:** Move `perform_create_key` (lines 151-157) above `do_create_key` (lines 142-148).

### Issue 5: main.mpl -- `handle_top_issues` Type Mismatch (LIKELY CASCADING)

**Error:** `expected Response, found Result<List<Map<String, String>>, String>` at lines 78-79
**Analysis:** `handle_top_issues` in `dashboard.mpl` is structurally correct. The type mismatch is likely caused by cascading inference failures from the broken `detail.mpl` module. Both are in the `Api.*` module namespace and compiled in the same dependency resolution pass.
**Fix:** Fix Issues 1-4 first, recompile. If error persists, add explicit return type: `pub fn handle_top_issues(request) -> Response do`.

## Priority and Fix Order

| Issue | File | Error Type | Complexity | Cascading? |
|-------|------|-----------|------------|------------|
| 1 | detail.mpl | Forward reference | LOW | ROOT CAUSE of 2 more errors |
| 2 | team.mpl | Forward reference | LOW | Independent |
| 3 | team.mpl | Forward reference | LOW | Independent |
| 4 | team.mpl | Forward reference | LOW | Independent |
| 5 | main.mpl | Type mismatch | LOW | Likely cascading from Issue 1 |

**Recommended approach:**
1. Fix detail.mpl (reorder functions) -- resolves 3 of 7 errors
2. Fix team.mpl (reorder functions) -- resolves 3 more errors
3. Recompile and verify main.mpl error resolves (expected)
4. If main.mpl error persists, add explicit return type annotation

**Total files to modify:** 2 (detail.mpl, team.mpl), possibly 3 (main.mpl if cascading fix doesn't work)

## Verification Approach

1. After fixes, run `cargo run --release -- build mesher/` and verify 0 compilation errors
2. Compare error count: before = 7 errors, after = 0 errors
3. No runtime testing needed -- these are all type-checking/name-resolution errors that don't affect runtime behavior once compilation succeeds

## Open Questions

1. **Will the main.mpl error resolve as a cascading fix?**
   - What we know: `handle_top_issues` in dashboard.mpl looks structurally correct. The inferred type `Result<List<Map<String, String>>, String>` matches the return type of `top_issues_by_frequency`, suggesting the type checker is seeing through the `case` expression. This could be a genuine inference issue OR a cascade from broken Api.Detail.
   - What's unclear: Whether the Mesh compiler's type resolution truly cascades across modules in the Api namespace.
   - Recommendation: Fix the definitive issues first, recompile, and assess. HIGH probability this resolves automatically.

## Sources

### Primary (HIGH confidence)
- Direct analysis of `mesher/api/detail.mpl` (110 lines) -- forward reference confirmed
- Direct analysis of `mesher/api/team.mpl` (244 lines) -- 3 forward references confirmed
- Direct analysis of `mesher/main.mpl` (116 lines) -- type error confirmed at router registration
- Direct analysis of `mesher/api/dashboard.mpl` (191 lines) -- handle_top_issues structure verified correct
- Compilation output from `cargo run --release -- build mesher/` -- all 7 errors captured
- Working module patterns from `mesher/api/search.mpl`, `mesher/api/alerts.mpl`, `mesher/api/settings.mpl`
- Phase 87.1 research (prior issues-encountered phase) for pattern reference

### Secondary (HIGH confidence)
- STATE.md decisions [90-03], [91.1-02] -- define-before-use and parser constraints documented
- Phase 87.1 RESEARCH.md -- establishes precedent for issues-encountered phase structure

## Metadata

**Confidence breakdown:**
- Issue analysis: HIGH -- all errors directly examined in source, compilation output verified
- Fix approach: HIGH -- reordering pattern proven in 6+ working modules
- Cascading fix (main.mpl): MEDIUM -- structurally likely but unverified until recompile

**Research date:** 2026-02-15
**Valid until:** Until fixes are applied (no external dependencies that could change)
