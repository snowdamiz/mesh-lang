---
phase: 96-compiler-additions
plan: 04
type: execute
wave: 4
depends_on: ["96-03"]
files_modified:
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/mir/mod.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-parser/src/parser/items.rs
  - crates/mesh-parser/src/syntax_kind.rs
  - crates/mesh-parser/src/ast/item.rs
  - crates/mesh-rt/src/lib.rs
  - crates/meshc/tests/e2e.rs
  - crates/mesh-repl/src/jit.rs
autonomous: true

must_haves:
  truths:
    - "A struct with deriving(Schema) generates callable __table__(), __fields__(), and __primary_key__() metadata functions"
    - "Relationship declarations (belongs_to, has_many, has_one) inside struct bodies produce queryable relationship metadata via __relationships__()"
    - "__table__() returns a pluralized, lowercased version of the struct name (User -> \"users\")"
    - "__fields__() returns a List of field name strings"
    - "__primary_key__() returns the primary key field name (default: \"id\")"
  artifacts:
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Schema derive validation and metadata function type registration"
      contains: "Schema"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "MIR function generation for __table__, __fields__, __primary_key__, __relationships__"
      contains: "__table__"
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "LLVM codegen for Schema metadata functions"
      contains: "__table__"
    - path: "crates/mesh-parser/src/parser/items.rs"
      provides: "Parser support for belongs_to/has_many/has_one declarations in struct bodies"
      contains: "belongs_to"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "Schema derive trait registered -> MIR generates synthetic metadata functions"
      pattern: "Schema"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/expr.rs"
      via: "MIR metadata functions are standard MirFunction entries codegen handles normally"
      pattern: "__table__"
    - from: "crates/mesh-parser/src/parser/items.rs"
      to: "crates/mesh-typeck/src/infer.rs"
      via: "Relationship declarations parsed as AST nodes, typeck extracts metadata"
      pattern: "RELATIONSHIP_DECL"
---

<objective>
Add `deriving(Schema)` infrastructure and relationship declarations (belongs_to, has_many, has_one) to the Mesh compiler.

Purpose: Schema metadata functions are the foundation for the entire ORM -- they provide compile-time table names, field lists, and primary key information that the query builder and repo use at runtime. Relationship declarations enable `Repo.preload` to know which tables are associated and through what foreign keys.

Output: `deriving(Schema)` generates `__table__()`, `__fields__()`, `__primary_key__()`, and `__relationships__()` metadata functions. `belongs_to`, `has_many`, `has_one` declarations in struct bodies are parsed and included in relationship metadata.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/096-compiler-additions/96-RESEARCH.md
@.planning/phases/096-compiler-additions/96-03-SUMMARY.md

@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/mir/mod.rs
@crates/mesh-codegen/src/codegen/expr.rs
@crates/mesh-parser/src/parser/items.rs
@crates/mesh-parser/src/ast/item.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parse relationship declarations and register deriving(Schema) in type checker</name>
  <files>
    crates/mesh-parser/src/syntax_kind.rs
    crates/mesh-parser/src/parser/items.rs
    crates/mesh-parser/src/ast/item.rs
    crates/mesh-typeck/src/infer.rs
  </files>
  <action>
1. In `crates/mesh-parser/src/syntax_kind.rs`:
   - Add `RELATIONSHIP_DECL` composite node kind for `belongs_to :name, Type` / `has_many :name, Type` / `has_one :name, Type` declarations.
   - Update variant count tests as needed.

2. In `crates/mesh-parser/src/parser/items.rs`:
   - In the struct body parser (where struct fields are parsed), add detection for relationship declarations. After parsing regular fields (with `::` type annotations), check for the pattern `IDENT(belongs_to|has_many|has_one) ATOM_LITERAL COMMA IDENT`:
     - `belongs_to :user, User` -- open RELATIONSHIP_DECL marker, bump `belongs_to` ident, bump `:user` atom, bump comma, bump `User` type ident, close marker.
     - `has_many :posts, Post` -- same pattern with `has_many`.
     - `has_one :profile, Profile` -- same pattern with `has_one`.
   - These declarations appear AFTER all field definitions in the struct body, BEFORE `end` and optional `deriving(...)`.
   - The identifier text `belongs_to`, `has_many`, `has_one` are NOT keywords -- they are contextual identifiers recognized only inside struct bodies. Use text comparison on IDENT tokens.
   - Relationship declarations are metadata-only -- they do NOT add fields to the struct.

3. In `crates/mesh-parser/src/ast/item.rs`:
   - Add `ast_node!(RelationshipDecl, RELATIONSHIP_DECL);`
   - Implement accessors:
     - `pub fn kind_text(&self) -> Option<String>` -- "belongs_to", "has_many", or "has_one"
     - `pub fn assoc_name(&self) -> Option<String>` -- the atom name (e.g., "user" from `:user`)
     - `pub fn target_type(&self) -> Option<String>` -- the type name (e.g., "User")
   - On `StructDef`, add accessor: `pub fn relationships(&self) -> Vec<RelationshipDecl>` that finds all RELATIONSHIP_DECL children.

4. In `crates/mesh-typeck/src/infer.rs`:
   - Add "Schema" to the `valid_derives` array (currently: `["Eq", "Ord", "Display", "Debug", "Hash", "Json", "Row"]`, becomes `["Eq", "Ord", "Display", "Debug", "Hash", "Json", "Row", "Schema"]`).
   - Do this in BOTH the struct derive validation AND the sum type derive validation. However, Schema should only be valid for structs (not sum types). Add a check: if `derive_list` contains "Schema" and we're in sum type context, emit an error "deriving(Schema) is only supported on structs".
   - When `derive_list.iter().any(|t| t == "Schema")` for a struct:
     a. Register `__table__` as a function in the environment: `fn() -> String`. Mangled name: `{StructName}____table__`.
     b. Register `__fields__` as a function in the environment: `fn() -> List<String>`. Mangled name: `{StructName}____fields__`.
     c. Register `__primary_key__` as a function in the environment: `fn() -> String`. Mangled name: `{StructName}____primary_key__`.
     d. Register `__relationships__` as a function in the environment: `fn() -> List<Map<String, String>>`. Mangled name: `{StructName}____relationships__`. Each relationship is a map with keys "kind", "name", "target".
   - These are registered as module-level functions callable via `User.__table__()` (dot syntax on the type name). They follow the same pattern as `User.from_row()` which is already callable via `StructName.method()` syntax.
   - Extract relationship declarations from the struct AST and store them for use during MIR lowering. Store in a side table or pass through the TypeRegistry.
  </action>
  <verify>
    `cargo test -p mesh-parser` passes (relationship declarations parse).
    `cargo test -p mesh-typeck` passes (Schema in valid_derives, functions registered).
    `deriving(Schema)` on a struct does not produce "unknown derive trait" error.
  </verify>
  <done>
    `belongs_to :user, User` parses as RELATIONSHIP_DECL inside struct bodies. `deriving(Schema)` is accepted without error. Type checker registers `__table__`, `__fields__`, `__primary_key__`, `__relationships__` functions with correct signatures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate Schema metadata functions in MIR and codegen, with e2e tests</name>
  <files>
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/mir/mod.rs
    crates/mesh-codegen/src/codegen/expr.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-rt/src/lib.rs
    crates/mesh-repl/src/jit.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
1. In `crates/mesh-codegen/src/mir/lower.rs`:
   - When processing a struct with `deriving(Schema)` (check the derive_list already extracted during struct lowering), generate synthetic MIR functions:

   a. `{StructName}____table__()` function:
      - Body: return `MirExpr::StringLit(pluralized_name, MirType::String)`
      - Pluralization: lowercase the struct name, then append "s" (simple English pluralization). Examples: `User -> "users"`, `Post -> "posts"`, `Address -> "addresss"`. For now, use naive `lowercase + "s"` -- proper pluralization is a Phase 97 concern with configurable table names.
      - Actually, based on the roadmap, Phase 97 handles "configurable table name". For this plan, use the simple `lowercase + "s"` approach.

   b. `{StructName}____fields__()` function:
      - Body: return a `MirExpr::ListLit` containing `MirExpr::StringLit` for each field name in the struct.
      - Example: struct with fields `id`, `name`, `email` -> `["id", "name", "email"]`

   c. `{StructName}____primary_key__()` function:
      - Body: return `MirExpr::StringLit("id", MirType::String)` (default primary key).
      - If the struct has no `id` field, still return `"id"` as the default -- this can be overridden in Phase 97 with schema options.

   d. `{StructName}____relationships__()` function:
      - Body: return a `MirExpr::ListLit` of maps, where each map represents a relationship.
      - For each relationship declaration: create a map with `"kind"` -> `"belongs_to"/"has_many"/"has_one"`, `"name"` -> relationship name (e.g., `"user"`), `"target"` -> target type name (e.g., `"User"`).
      - If no relationships, return empty list.
      - Use the existing `MirExpr::MapLit` or construct the maps using runtime calls. Since MIR doesn't have a MapLit, use a sequence of `mesh_map_new` + `mesh_map_put` calls to construct each relationship map. Alternatively, if this is too complex, return a simple list of strings with a structured format (e.g., `["belongs_to:user:User", "has_many:posts:Post"]`) and parse at runtime. The simpler string format avoids complex MIR for map construction.
      - Decision: Use the string format `"kind:name:target"` for simplicity. Return `List<String>`.

   - These functions are added as `MirFunction` entries in `self.functions` during struct lowering, alongside the existing `from_row`/`from_json` generation pattern.

2. In `crates/mesh-codegen/src/codegen/expr.rs`:
   - No special codegen needed -- the metadata functions use existing MirExpr types (StringLit, ListLit) that codegen already handles. The functions are regular MirFunctions.

3. In `crates/mesh-codegen/src/codegen/intrinsics.rs` and `crates/mesh-rt/src/lib.rs`:
   - No new runtime functions needed. Schema metadata functions use existing string and list infrastructure.

4. In `crates/mesh-repl/src/jit.rs`:
   - No changes needed unless JIT needs specific symbols for Schema functions.

5. In `crates/meshc/tests/e2e.rs`:
   - Add `e2e_deriving_schema_table` test:
     ```
     struct User do
       id :: String
       name :: String
       email :: String
     end deriving(Schema)

     IO.puts(User.__table__())
     ```
     Expected output: `users`

   - Add `e2e_deriving_schema_fields` test:
     ```
     struct Post do
       id :: String
       title :: String
       body :: String
     end deriving(Schema)

     let fields = Post.__fields__()
     IO.puts(List.to_string(fields))
     ```
     Expected output: `["id", "title", "body"]` (or however List<String> prints)

   - Add `e2e_deriving_schema_primary_key` test:
     ```
     struct Comment do
       id :: String
       text :: String
     end deriving(Schema)

     IO.puts(Comment.__primary_key__())
     ```
     Expected output: `id`

   - Add `e2e_deriving_schema_relationships` test:
     ```
     struct Post do
       id :: String
       title :: String
       user_id :: String
       belongs_to :user, User
     end deriving(Schema)

     struct User do
       id :: String
       name :: String
       has_many :posts, Post
     end deriving(Schema)

     let rels = Post.__relationships__()
     IO.puts(List.to_string(rels))
     ```
     Expected output should contain the belongs_to relationship info.

   - Add `e2e_deriving_schema_with_other_derives` test verifying Schema works alongside other derives:
     ```
     struct Item do
       id :: String
       name :: String
     end deriving(Schema, Eq, Json)

     IO.puts(Item.__table__())
     ```
     Expected output: `items`
  </action>
  <verify>
    `cargo test -p mesh-codegen` passes.
    `cargo test -p meshc --test e2e -- e2e_deriving_schema` passes.
    `cargo build` succeeds with no new warnings.
  </verify>
  <done>
    `deriving(Schema)` generates working `__table__()`, `__fields__()`, `__primary_key__()`, and `__relationships__()` functions. Relationship declarations (`belongs_to`, `has_many`, `has_one`) are parsed and included in metadata. Functions are callable via `StructName.__table__()` syntax. All e2e tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with no regressions
2. `deriving(Schema)` generates all four metadata functions
3. `User.__table__()` returns `"users"` (pluralized, lowercased)
4. `User.__fields__()` returns list of field name strings
5. `User.__primary_key__()` returns `"id"` (default)
6. Relationship declarations are parsed and queryable
7. Schema derives work alongside other derives (Eq, Json, Row)
8. All existing deriving tests pass unchanged
</verification>

<success_criteria>
- `deriving(Schema)` is in valid_derives and does not error
- `__table__()` returns lowercased, pluralized struct name
- `__fields__()` returns list of all field names as strings
- `__primary_key__()` returns "id" by default
- `__relationships__()` returns list of relationship metadata
- `belongs_to`, `has_many`, `has_one` parse inside struct bodies
- Existing deriving(Eq), deriving(Json), deriving(Row) unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/096-compiler-additions/96-04-SUMMARY.md`
</output>
