---
phase: 96-compiler-additions
plan: 02
type: execute
wave: 2
depends_on: ["96-01"]
files_modified:
  - crates/mesh-parser/src/parser/expressions.rs
  - crates/mesh-parser/src/parser/mod.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Developer can write keyword arguments at call sites like where(name: \"Alice\", age: 30) and they compile to a Map parameter"
    - "Developer can write multi-line pipe chains where |> at line start continues the previous expression"
    - "Keyword args and multi-line pipes work together: multi-line pipe chains with keyword arg calls compile correctly"
  artifacts:
    - path: "crates/mesh-parser/src/parser/expressions.rs"
      provides: "Keyword argument desugaring in parse_arg_list and multi-line pipe continuation"
      contains: "keyword"
    - path: "crates/mesh-parser/src/parser/mod.rs"
      provides: "Multi-line pipe lookahead logic"
      contains: "PIPE"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "E2e tests for keyword args and multi-line pipes"
      contains: "e2e_keyword_args"
  key_links:
    - from: "crates/mesh-parser/src/parser/expressions.rs"
      to: "crates/mesh-typeck/src/infer.rs"
      via: "Parser desugars keyword args to MAP_LITERAL nodes which typeck already handles"
      pattern: "MAP_LITERAL"
    - from: "crates/mesh-parser/src/parser/mod.rs"
      to: "crates/mesh-parser/src/parser/expressions.rs"
      via: "Parser lookahead for |> after newlines feeds into Pratt parser pipe handling"
      pattern: "PIPE"
---

<objective>
Add keyword argument syntax and multi-line pipe chain support to the Mesh parser.

Purpose: Keyword arguments enable ergonomic ORM DSL syntax (`where(name: "Alice")` instead of `where(%{"name" => "Alice"})`). Multi-line pipes make query chains readable across multiple lines instead of cramming everything onto one line.

Output: Working keyword arguments that desugar to Map literals at the parser level, and multi-line pipe chains that parse correctly when `|>` appears at the start of a new line.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/096-compiler-additions/96-RESEARCH.md
@.planning/phases/096-compiler-additions/96-01-SUMMARY.md

@crates/mesh-parser/src/parser/expressions.rs
@crates/mesh-parser/src/parser/mod.rs
@crates/mesh-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement keyword argument desugaring in parser</name>
  <files>
    crates/mesh-parser/src/parser/expressions.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
1. In `crates/mesh-parser/src/parser/expressions.rs`, modify `parse_arg_list`:
   - After parsing each positional argument expression, check if the next token pattern is `IDENT COLON` (an identifier immediately followed by a colon, but NOT `COLON_COLON` which is a type annotation). This is the keyword argument pattern: `name: value`.
   - When keyword arguments are detected, collect all remaining `ident: expr` pairs. For each pair:
     a. Open a `MAP_ENTRY` marker
     b. Create a synthetic string literal node from the identifier text (the key becomes `"name"` string)
     c. Parse the value expression after the colon
     d. Close the `MAP_ENTRY` marker
   - Wrap all keyword entries in a `MAP_LITERAL` node. This makes the keyword args a single Map argument appended after all positional arguments.
   - Detection logic: Inside the argument list, after parsing an expression, if the parser sees `COMMA` followed by `IDENT` followed by `COLON` (and NOT `COLON_COLON`), the IDENT+COLON starts keyword arguments. Also handle the case where the VERY FIRST argument starts as `IDENT COLON` -- this means the entire argument list is keyword arguments (zero positional args, one map arg).
   - Key ambiguity to handle: `f(x, name: "Alice")` -- `x` is positional, `name: "Alice"` starts kwargs. `f(name: "Alice")` -- no positional args, just kwargs. `f(x)` -- just positional, no kwargs.
   - The parser should look ahead 2 tokens to distinguish `f(name: "Alice")` (kwarg) from `f(name)` (positional ident).
   - Keyword arguments MUST be at the end of the argument list (after all positional args). Once a keyword arg is seen, all remaining args must be keyword args.

2. In `crates/meshc/tests/e2e.rs`:
   - Add `e2e_keyword_arguments` test that compiles a program calling a function with keyword args:
     ```
     def greet(opts :: Map<String, String>) do
       IO.puts(Map.get(opts, "name"))
     end
     greet(name: "Alice")
     ```
   - Add `e2e_keyword_args_mixed` test mixing positional and keyword args:
     ```
     def query(table :: String, opts :: Map<String, String>) do
       IO.puts(table)
       IO.puts(Map.get(opts, "name"))
     end
     query("users", name: "Alice")
     ```
   - Verify both compile and produce correct output.
  </action>
  <verify>
    `cargo test -p mesh-parser` passes.
    `cargo test -p meshc --test e2e -- e2e_keyword_arg` passes.
  </verify>
  <done>
    `f(name: "Alice", age: 30)` parses as `f(%{"name" => "Alice", "age" => 30})`. Mixed positional+keyword works: `f(x, name: "Alice")` parses as `f(x, %{"name" => "Alice"})`. Keyword-only calls work. E2e tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement multi-line pipe chain continuation</name>
  <files>
    crates/mesh-parser/src/parser/expressions.rs
    crates/mesh-parser/src/parser/mod.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
1. In `crates/mesh-parser/src/parser/mod.rs` or `crates/mesh-parser/src/parser/expressions.rs`:
   - The core issue: at top-level (outside delimiters), newlines are significant statement terminators. When the parser sees `expr NEWLINE`, it ends the statement. But for multi-line pipes like:
     ```
     users
       |> Enum.filter(fn u -> u.active end)
       |> Enum.map(fn u -> u.name end)
     ```
     The NEWLINE after `users` should NOT terminate the statement because `|>` follows on the next line.

   - Implementation approach (parser-level peek): In the Pratt parser loop inside `expr_bp` (or in the statement parsing level), after parsing a complete expression, when the next token is `NEWLINE`:
     a. Save the current position
     b. Peek past all NEWLINE/WHITESPACE/COMMENT tokens
     c. If the next non-trivia token is `PIPE` (`|>`), skip the newlines and continue the Pratt parser loop -- the `|>` becomes the infix operator continuing the expression
     d. If the next non-trivia token is NOT `|>`, treat the newline as normal (statement terminator)

   - The peek must not consume tokens. Use the parser's existing `nth()` or `peek_past_trivia()` mechanism. If no such mechanism exists, implement a helper `peek_past_newlines(n)` that returns the SyntaxKind of the nth non-newline token ahead.

   - Important: This lookahead should ONLY activate at the top-level expression parsing (where newlines are significant). Inside parentheses/brackets/braces, newlines are already insignificant, so multi-line pipes already work there.

   - The parser's `should_skip` method treats newlines as skippable inside delimiters. For multi-line pipes at top-level, we need a different mechanism: NOT making all newlines insignificant, but specifically recognizing `NEWLINE ... PIPE` as a continuation.

2. In `crates/meshc/tests/e2e.rs`:
   - Add `e2e_multiline_pipe` test:
     ```
     let result = [1, 2, 3, 4, 5]
       |> List.filter(fn x -> x > 2 end)
       |> List.map(fn x -> x * 10 end)
     IO.puts(List.to_string(result))
     ```
     Expected output: `[30, 40, 50]`

   - Add `e2e_multiline_pipe_complex` test with more than 2 pipe stages to verify chaining works:
     ```
     let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
       |> List.filter(fn x -> x > 3 end)
       |> List.take(4)
       |> List.map(fn x -> x * 2 end)
     IO.puts(List.to_string(result))
     ```

   - Add `e2e_multiline_pipe_with_keyword_args` test combining both features:
     ```
     # This test validates that multi-line pipes work with keyword arg calls
     # For now just test the pipe chain works -- actual ORM usage comes later
     let nums = [3, 1, 4, 1, 5]
       |> List.sort()
       |> List.map(fn x -> x * 2 end)
     IO.puts(List.to_string(nums))
     ```
  </action>
  <verify>
    `cargo test -p mesh-parser` passes.
    `cargo test -p meshc --test e2e -- e2e_multiline_pipe` passes.
    Existing single-line pipe tests still pass (no regressions).
  </verify>
  <done>
    Multi-line pipe chains where `|>` at line start continues the previous expression parse and execute correctly. Single-line pipes continue to work. E2e tests confirm multi-line pipe chains with multiple stages work.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with no regressions
2. Keyword arguments: `f(name: "Alice")` compiles as `f(%{"name" => "Alice"})`
3. Multi-line pipes: expressions split across lines with `|>` at line start compile correctly
4. Both features work together in combined test
5. Existing pipe and function call tests pass unchanged
</verification>

<success_criteria>
- `f(name: "Alice", age: 30)` desugars to `f(%{"name" => "Alice", "age" => 30})`
- `f(x, name: "Alice")` desugars to `f(x, %{"name" => "Alice"})`
- Multi-line `|>` at line start continues expression, not new statement
- Single-line pipes unchanged
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/096-compiler-additions/96-02-SUMMARY.md`
</output>
