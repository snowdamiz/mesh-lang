---
phase: 20-essential-stdlib-protocols
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "String interpolation '${my_struct}' calls Display__to_string__TypeName for struct types"
    - "String interpolation '${my_sum}' calls Display__to_string__TypeName for sum types"
    - "Primitive string interpolation ('${42}', '${true}') still uses direct runtime functions"
    - "to_string(x) call on struct/sum type resolves to Display__to_string__TypeName via trait dispatch"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Display-aware wrap_to_string with Struct/SumType cases"
      contains: "Display__to_string"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs wrap_to_string"
      to: "crates/snow-typeck/src/traits.rs find_method_traits"
      via: "trait_registry.find_method_traits('to_string', &ty) lookup"
      pattern: "find_method_traits.*to_string"
    - from: "crates/snow-codegen/src/mir/lower.rs wrap_to_string"
      to: "crates/snow-codegen/src/mir/types.rs mir_type_to_ty"
      via: "type conversion for trait registry lookup"
      pattern: "mir_type_to_ty"
---

<objective>
Wire string interpolation to dispatch through Display trait for non-primitive types.

Purpose: Currently, `"value is ${my_struct}"` emits a bare `to_string` call that doesn't resolve. After this plan, string interpolation automatically calls the correct `Display__to_string__TypeName` mangled function for any struct or sum type with a Display impl.

Output: Updated wrap_to_string() that dispatches through Display trait for Struct/SumType, plus the existing trait call rewriting in lower_call_expr() handles explicit to_string(x) calls on user types.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-essential-stdlib-protocols/20-RESEARCH.md
@.planning/phases/20-essential-stdlib-protocols/20-01-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update wrap_to_string for Display trait dispatch on user types</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Modify the `wrap_to_string()` method (currently at line ~2494) to handle `MirType::Struct(name)` and `MirType::SumType(name)` before the catch-all `_ =>` case. The new cases should:

1. Use `mir_type_to_ty()` (already imported from types.rs) to convert the MirType to a Ty for trait registry lookup.
2. Call `self.trait_registry.find_method_traits("to_string", &ty)` to check if the type has a Display impl.
3. If a Display impl exists, construct a `MirExpr::Call` with the mangled name `Display__to_string__TypeName` (using `mir_type_to_impl_name()` for the type name).
4. If no Display impl exists, fall through to the existing catch-all behavior (bare `to_string` call) -- this preserves error recovery.

Replace the current catch-all `_ =>` block with three cases:

```rust
MirType::Struct(ref name) | MirType::SumType(ref name) => {
    let ty_for_lookup = mir_type_to_ty(expr.ty());
    let matching = self.trait_registry.find_method_traits("to_string", &ty_for_lookup);
    if !matching.is_empty() {
        let trait_name = &matching[0];
        let type_name = mir_type_to_impl_name(expr.ty());
        let mangled = format!("{}__{}__{}", trait_name, "to_string", type_name);
        MirExpr::Call {
            func: Box::new(MirExpr::Var(
                mangled,
                MirType::FnPtr(vec![expr.ty().clone()], Box::new(MirType::String)),
            )),
            args: vec![expr],
            ty: MirType::String,
        }
    } else {
        // No Display impl -- fall through to generic to_string
        MirExpr::Call {
            func: Box::new(MirExpr::Var(
                "to_string".to_string(),
                MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::String)),
            )),
            args: vec![expr],
            ty: MirType::String,
        }
    }
}
_ => {
    // For other types, attempt a generic to_string call.
    MirExpr::Call {
        func: Box::new(MirExpr::Var(
            "to_string".to_string(),
            MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::String)),
        )),
        args: vec![expr],
        ty: MirType::String,
    }
}
```

Note: The `_ =>` `ref name` binding is needed for the pattern but will trigger an unused variable warning -- use `ref _name` or just match `MirType::Struct(_) | MirType::SumType(_)` since `name` is obtained via `mir_type_to_impl_name`.

Also add a MIR-level integration test in the existing test module for lower.rs (or in the codegen integration tests) that verifies wrap_to_string produces the correct mangled call name for a struct type. If there's no existing test infrastructure for wrap_to_string specifically, add a comment-level verification and rely on the cargo test --workspace passing.

Important: Ensure `mir_type_to_ty` and `mir_type_to_impl_name` are imported at the top of lower.rs (they should already be from Phase 19 work -- verify before adding).
  </action>
  <verify>Run `cargo test --workspace` to confirm compilation and all tests pass. Grep for `Display__to_string` in the lowering output by examining the MIR test infrastructure if available. At minimum, verify the code compiles and doesn't break existing string interpolation for primitives.</verify>
  <done>wrap_to_string() emits `Display__to_string__TypeName` for Struct/SumType types with Display impls. Primitive types (Int, Float, Bool, String) still use direct runtime functions. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Verify to_string() explicit call dispatch works for Display impls</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Verify that the existing trait call rewriting in `lower_call_expr()` (around line 1564) already handles explicit `to_string(my_struct)` calls correctly. The logic already:
1. Checks if callee "to_string" is not in known_functions
2. Gets the first arg's type
3. Calls `find_method_traits("to_string", &ty)`
4. Rewrites to `Display__to_string__TypeName`

This should work automatically with the Display impls registered in 20-01. Verify by:

1. Adding or extending a MIR integration test that creates a scenario where `to_string` is called on a non-primitive type. If the existing test framework doesn't easily support this, add a focused test using the lower.rs test harness.

2. For primitive types, the existing runtime functions should still be preferred in wrap_to_string. But when `to_string(42)` is called explicitly (not through interpolation), it goes through lower_call_expr -> trait rewriting -> `Display__to_string__Int`. This mangled name won't have a MIR function body (the actual implementation is `snow_int_to_string` in the runtime).

   To handle this: In lower_call_expr or in the codegen layer, when encountering `Display__to_string__Int` (or Float/Bool/String), map it to the corresponding runtime function. The simplest approach: in the `known_functions` pre-registration during lowering setup, register `Display__to_string__Int` -> maps to `snow_int_to_string`, etc. OR: in the codegen layer, when a function name starts with `Display__to_string__` and the type is primitive, redirect to the runtime function.

   Recommended approach: During the lowering initialization (where known_functions is populated), register the primitive Display mangled names as aliases for the runtime functions. Add entries like:
   ```rust
   self.known_functions.insert("Display__to_string__Int".to_string(), ...);
   self.known_functions.insert("Display__to_string__Float".to_string(), ...);
   self.known_functions.insert("Display__to_string__Bool".to_string(), ...);
   self.known_functions.insert("Display__to_string__String".to_string(), ...);
   ```

   These entries ensure the mangled name is recognized. In codegen, when these functions are called, they should be declared as extern functions mapping to the snow_*_to_string runtime functions. The simplest way: in intrinsics.rs or the codegen function resolution, add a mapping from `Display__to_string__Int` to `snow_int_to_string` (and similarly for Float, Bool). For String, Display__to_string__String is just the identity function -- return the input string.

   If this mapping is complex, an alternative: in wrap_to_string and lower_call_expr, detect primitive Display calls and emit the runtime function name directly instead of the mangled name. This keeps codegen simple.
  </action>
  <verify>Run `cargo test --workspace` to confirm all tests pass. If possible, add a test that compiles a Snow program calling `to_string(42)` and verify it produces valid MIR with either `snow_int_to_string` or `Display__to_string__Int` (either is acceptable as long as codegen handles it).</verify>
  <done>Explicit `to_string(x)` calls resolve correctly for both primitive and user-defined types. Primitive Display calls map to the existing runtime functions without requiring new MIR function bodies. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. `cargo build --workspace` -- clean compilation
3. String interpolation with primitives still works (no regression)
4. wrap_to_string produces mangled Display call for Struct/SumType types
5. Explicit to_string() on primitives still works (maps to runtime functions)
</verification>

<success_criteria>
- wrap_to_string("${point_var}") produces MirExpr::Call with func "Display__to_string__Point"
- wrap_to_string("${42}") still produces MirExpr::Call with func "snow_int_to_string"
- to_string(my_struct) in Snow code resolves through trait dispatch to Display__to_string__TypeName
- to_string(42) works end-to-end (either via direct runtime call or Display dispatch)
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-essential-stdlib-protocols/20-02-SUMMARY.md`
</output>
