---
phase: 20-essential-stdlib-protocols
plan: 03
type: execute
wave: 3
depends_on: ["20-02"]
files_modified:
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "Debug trait is registered in TraitRegistry with inspect method"
    - "Debug impls are auto-registered for all struct types at typeck time"
    - "inspect(my_struct) produces developer-readable output like 'Point { x: 1, y: 2 }'"
    - "Debug impls are auto-registered for all sum types at typeck time"
  artifacts:
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Debug trait definition and primitive impls"
      contains: "Debug"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Auto-generated Debug__inspect__TypeName MIR function bodies for structs and sum types"
      contains: "Debug__inspect"
  key_links:
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "crates/snow-typeck/src/traits.rs"
      via: "register_trait and register_impl for Debug"
      pattern: "Debug.*inspect"
    - from: "crates/snow-codegen/src/mir/lower.rs lower_struct_def"
      to: "crates/snow-codegen/src/mir/lower.rs functions (MirFunction output)"
      via: "generate Debug MIR function body during struct lowering"
      pattern: "Debug__inspect"
---

<objective>
Add the Debug protocol with auto-generated inspect functions for all struct and sum types.

Purpose: The Debug protocol enables developer-readable output for debugging. `inspect(my_point)` should produce "Point { x: 1, y: 2 }". Unlike Display (which users write), Debug is auto-generated by the compiler since it knows all fields and types.

Output: Debug trait registered with primitive impls, auto-generated Debug__inspect__TypeName MIR functions for every struct and sum type.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-essential-stdlib-protocols/20-RESEARCH.md
@.planning/phases/20-essential-stdlib-protocols/20-01-SUMMARY.md
@.planning/phases/20-essential-stdlib-protocols/20-02-SUMMARY.md
@crates/snow-typeck/src/builtins.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Debug trait with primitive impls and auto-register for structs/sum types</name>
  <files>crates/snow-typeck/src/builtins.rs, crates/snow-typeck/src/infer.rs</files>
  <action>
**Part A: Register Debug trait in builtins.rs**

In `register_compiler_known_traits()`, add the Debug trait registration after the Display block:

```rust
// ── Debug trait ───────────────────────────────────────────────
registry.register_trait(TraitDef {
    name: "Debug".to_string(),
    methods: vec![TraitMethodSig {
        name: "inspect".to_string(),
        has_self: true,
        param_count: 0,
        return_type: Some(Ty::string()),
    }],
});

// Debug impls for primitives (Int, Float, String, Bool).
// For primitives, inspect produces the same output as to_string.
for (ty, ty_name) in &[
    (Ty::int(), "Int"),
    (Ty::float(), "Float"),
    (Ty::string(), "String"),
    (Ty::bool(), "Bool"),
] {
    let mut methods = FxHashMap::default();
    methods.insert(
        "inspect".to_string(),
        ImplMethodSig {
            has_self: true,
            param_count: 0,
            return_type: Some(Ty::string()),
        },
    );
    let _ = registry.register_impl(ImplDef {
        trait_name: "Debug".to_string(),
        impl_type: ty.clone(),
        impl_type_name: ty_name.to_string(),
        methods,
    });
}
```

**Part B: Auto-register Debug impls for struct and sum types in typeck**

In `infer.rs`, find where struct definitions are processed (in `infer_struct_def` or the equivalent). After the struct is registered in the type registry, also register a Debug impl for it in the TraitRegistry:

```rust
// Auto-register Debug impl for this struct type
let struct_ty = Ty::Con(TyCon::new(&struct_name));
let mut debug_methods = FxHashMap::default();
debug_methods.insert(
    "inspect".to_string(),
    ImplMethodSig {
        has_self: true,
        param_count: 0,
        return_type: Some(Ty::string()),
    },
);
let _ = self.trait_registry.register_impl(ImplDef {
    trait_name: "Debug".to_string(),
    impl_type: struct_ty,
    impl_type_name: struct_name.clone(),
    methods: debug_methods,
});
```

Do the same in `infer_sum_type_def` (or equivalent) for sum types.

Note: The trait_registry is accessible in the inference context as `self.trait_registry`. Verify the exact field name by checking how the TraitRegistry is accessed in infer.rs (it was threaded through in Phase 18-03).

**Part C: Add tests in builtins.rs**

```rust
#[test]
fn debug_trait_registered_for_primitives() {
    let mut ctx = InferCtx::new();
    let mut env = TypeEnv::new();
    let mut trait_registry = TraitRegistry::new();
    register_builtins(&mut ctx, &mut env, &mut trait_registry);

    assert!(trait_registry.has_impl("Debug", &Ty::int()));
    assert!(trait_registry.has_impl("Debug", &Ty::float()));
    assert!(trait_registry.has_impl("Debug", &Ty::string()));
    assert!(trait_registry.has_impl("Debug", &Ty::bool()));

    let traits = trait_registry.find_method_traits("inspect", &Ty::int());
    assert!(traits.contains(&"Debug".to_string()));
}
```
  </action>
  <verify>Run `cargo test -p snow-typeck -- debug_trait` and confirm the new test passes. Run `cargo test --workspace` for full suite.</verify>
  <done>Debug trait registered with inspect(self) -> String. All primitive types have Debug impls. Struct and sum type definitions auto-register Debug impls in typeck. find_method_traits("inspect", &struct_ty) returns ["Debug"].</done>
</task>

<task type="auto">
  <name>Task 2: Generate Debug__inspect__TypeName MIR function bodies for structs and sum types</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
In `lower_struct_def()` (around line 1109), after pushing the `MirStructDef` to `self.structs`, generate a synthetic `Debug__inspect__StructName` MIR function. This function:

1. Takes one parameter `self` of the struct type
2. Returns a String
3. Body: builds a string like `"StructName { field1: <field1_value>, field2: <field2_value> }"` by:
   - Starting with a string literal of the struct name + " { "
   - For each field: concatenate field name + ": " + wrap_to_string(field_access) + ", "
   - End with " }"
   - Chain all parts with `snow_string_concat` calls

The MIR should look like:
```
fn Debug__inspect__Point(self: Point) -> String {
    let s0 = "Point { "
    let f0 = self.x           // FieldAccess
    let f0s = snow_int_to_string(f0)  // or wrap_to_string equivalent
    let s1 = concat(s0, "x: ")
    let s2 = concat(s1, f0s)
    let s3 = concat(s2, ", ")
    let f1 = self.y
    let f1s = snow_int_to_string(f1)
    let s4 = concat(s3, "y: ")
    let s5 = concat(s4, f1s)
    let s6 = concat(s5, " }")
    return s6
}
```

Implementation approach:
- Create a new helper method `generate_debug_inspect_struct(&mut self, name: &str, fields: &[(String, MirType)])`
- Build the MirExpr tree by iterating over fields
- For each field, create a `MirExpr::FieldAccess` on the self parameter, then call `self.wrap_to_string()` on the field value (this reuses the Display dispatch for nested types)
- Use `MirExpr::Call` with `snow_string_concat` to chain string segments
- Push the resulting `MirFunction` to `self.functions`
- Register the mangled name in `self.known_functions`

For the last field, omit the trailing ", " to get clean output like `Point { x: 1, y: 2 }`.

For **primitive Debug impls**: The generated function body should just call the corresponding `snow_*_to_string` function (same as Display for primitives). Register these during the lowering initialization alongside known_functions:
- `Debug__inspect__Int` -> calls `snow_int_to_string`
- `Debug__inspect__Float` -> calls `snow_float_to_string`
- `Debug__inspect__Bool` -> calls `snow_bool_to_string`
- `Debug__inspect__String` -> wraps value in quotes: concat `"\""`, value, `"\""`

For **sum types**: In `lower_sum_type_def()`, generate a similar function but with a match on the tag value. For each variant:
- If no fields: return just the variant name string (e.g., "None")
- If fields: return "VariantName(field1_str, field2_str)" format

The sum type inspect is more complex -- if time/context is a concern, generate a simplified version that just returns the variant name without payload details, and mark payload inspection as a follow-up.

Register all generated functions in `self.known_functions` so codegen can find them.
  </action>
  <verify>Run `cargo test --workspace` to confirm compilation and all tests pass. Verify that `Debug__inspect__` function names appear in the generated MIR by checking test output or adding a targeted test.</verify>
  <done>Debug__inspect__TypeName MIR functions are auto-generated for all struct and sum types during lowering. Struct inspect produces "TypeName { field: value, ... }" format. Sum type inspect produces at minimum the variant name. Functions registered in known_functions. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. Debug trait is registered and has_impl returns true for primitives AND user-defined structs
3. MIR lowering produces Debug__inspect__X functions for struct/sum types
4. Generated inspect functions use field access and string concatenation
</verification>

<success_criteria>
- inspect(point) where point is Point { x: 1, y: 2 } produces a string containing "Point", "x", "y" and the field values
- Debug impls auto-registered for all struct definitions (no manual impl required)
- Debug impls auto-registered for all sum type definitions
- Primitive inspect works (inspect(42) -> "42", inspect("hello") -> "\"hello\"")
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-essential-stdlib-protocols/20-03-SUMMARY.md`
</output>
