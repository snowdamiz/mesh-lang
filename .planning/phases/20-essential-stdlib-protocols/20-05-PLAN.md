---
phase: 20-essential-stdlib-protocols
plan: 05
type: execute
wave: 5
depends_on: ["20-04"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "== on sum types compares variant tag and then payload fields"
    - "!= on sum types returns the negation of =="
    - "< on sum types compares variant tag first, then payload fields lexicographically"
    - "> on sum types works (reverse of <)"
    - "<= and >= on sum types work correctly"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Auto-registered Eq and Ord impls for sum types"
      contains: "Eq.*register_impl"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Auto-generated Eq__eq__SumTypeName and Ord__lt__SumTypeName MIR functions"
      contains: "Eq__eq__|Ord__lt__"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs infer_sum_type_def"
      to: "crates/snow-typeck/src/traits.rs register_impl"
      via: "auto-register Eq/Ord impls for each sum type definition"
      pattern: "register_impl.*Eq|register_impl.*Ord"
    - from: "crates/snow-codegen/src/mir/lower.rs lower_sum_type_def"
      to: "crates/snow-codegen/src/mir/lower.rs functions"
      via: "auto-generate Eq__eq and Ord__lt MIR functions during sum type lowering"
      pattern: "Eq__eq__|Ord__lt__"
    - from: "crates/snow-codegen/src/mir/lower.rs lower_binary_expr"
      to: "Eq__eq__SumTypeName / Ord__lt__SumTypeName"
      via: "operator dispatch (built in 20-04) routes sum type comparisons to generated functions"
      pattern: "has_impl.*Eq|has_impl.*Ord"
---

<objective>
Add Eq and Ord support for user-defined sum types with auto-generated variant-aware comparison.

Purpose: Success criteria 4 and 5 require == and comparison operators to work on sum types (variant + payload equality/ordering). Plan 20-04 delivered struct Eq/Ord and the operator dispatch infrastructure. This plan extends that to sum types by auto-registering impls and generating comparison function bodies that handle tag comparison and per-variant payload comparison.

Output: Sum types support all 6 comparison operators (==, !=, <, >, <=, >=) via auto-derived variant-tag-then-payload comparison. Combined with Plan 20-04, all user-defined types now support full comparison semantics.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-essential-stdlib-protocols/20-RESEARCH.md
@.planning/phases/20-essential-stdlib-protocols/20-04-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auto-register Eq/Ord impls for sum types in typeck</name>
  <files>crates/snow-typeck/src/infer.rs</files>
  <action>
In `infer_sum_type_def` (or the sum type definition inference path), after registering the Debug impl (added in 20-03), also register Eq and Ord impls. Follow the same pattern used for structs in Plan 20-04 Task 1 Part B:

```rust
// Auto-register Eq impl for this sum type
let sum_ty = Ty::Con(TyCon::new(&sum_type_name));
let mut eq_methods = FxHashMap::default();
eq_methods.insert("eq".to_string(), ImplMethodSig {
    has_self: true,
    param_count: 1,
    return_type: Some(Ty::bool()),
});
let _ = self.trait_registry.register_impl(ImplDef {
    trait_name: "Eq".to_string(),
    impl_type: sum_ty.clone(),
    impl_type_name: sum_type_name.clone(),
    methods: eq_methods,
});

// Auto-register Ord impl for this sum type
let mut ord_methods = FxHashMap::default();
ord_methods.insert("lt".to_string(), ImplMethodSig {
    has_self: true,
    param_count: 1,
    return_type: Some(Ty::bool()),
});
let _ = self.trait_registry.register_impl(ImplDef {
    trait_name: "Ord".to_string(),
    impl_type: sum_ty,
    impl_type_name: sum_type_name.clone(),
    methods: ord_methods,
});
```

The operator dispatch infrastructure from Plan 20-04 already handles all 6 comparison operators generically. Once Eq/Ord impls are registered for sum types, the dispatch will automatically route `sum1 == sum2` to `Eq__eq__SumTypeName` etc.
  </action>
  <verify>Run `cargo test --workspace` to confirm compilation and all tests pass. Verify `has_impl("Eq", &sum_ty)` and `has_impl("Ord", &sum_ty)` return true for sum types.</verify>
  <done>Eq and Ord impls auto-registered for all sum type definitions in typeck. Operator dispatch (from 20-04) can now route sum type comparisons to the appropriate generated functions. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Generate Eq__eq and Ord__lt MIR function bodies for sum types</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
In `lower_sum_type_def()`, after generating the Debug__inspect function (from 20-03), generate two synthetic MIR functions for sum type comparison.

**Eq__eq__SumTypeName:**
Takes `(self: SumType, other: SumType) -> Bool`. Logic:

1. Extract tags from both self and other (using `MirExpr::FieldAccess` on the tag field, or however tags are accessed in the MIR -- check how Debug__inspect accesses the tag from 20-03)
2. If tags differ, return false: `if self.tag != other.tag then false`
3. If same tag, compare payload fields for that variant:
   - For each variant (by tag value), check if `self.tag == variant_tag_value`
   - If match, compare each payload field recursively (same field-by-field AND as struct Eq)
   - If variant has no payload fields, return true (same tag = equal)

Pseudocode:
```
fn Eq__eq__Option(self: Option, other: Option) -> Bool {
    if self.tag != other.tag then false
    else if self.tag == 0 then   // Some variant
        self.field0 == other.field0
    else                          // None variant
        true
}
```

Implementation:
1. Create helper `generate_eq_sum(&mut self, name: &str, variants: &[SumVariant])`
2. Start with tag inequality check: `if self.tag != other.tag { return false }`
3. Then chain if/else for each variant's tag value, comparing payload fields
4. For each payload field, use `BinOp::Eq` for primitives, `Eq__eq__FieldType` call for nested types
5. Last variant can be the else branch (no tag check needed)

**Ord__lt__SumTypeName:**
Takes `(self: SumType, other: SumType) -> Bool`. Logic:

1. Compare tags first: if `self.tag < other.tag`, return true
2. If `self.tag > other.tag`, return false (earlier-defined variants are "less than" later ones)
3. If same tag, lexicographic compare on payload fields (same logic as struct Ord)

Pseudocode:
```
fn Ord__lt__Option(self: Option, other: Option) -> Bool {
    if self.tag < other.tag then true
    else if self.tag > other.tag then false
    else if self.tag == 0 then   // Some variant, compare payload
        self.field0 < other.field0
    else                          // None variant, no fields
        false                     // equal, not less-than
}
```

Implementation:
1. Create helper `generate_ord_sum(&mut self, name: &str, variants: &[SumVariant])`
2. First: `if self.tag < other.tag { return true }`
3. Then: `if self.tag != other.tag { return false }` (covers self.tag > other.tag)
4. Then: chain if/else for each variant's tag, doing lexicographic payload comparison
5. For variants with no payload: return false (same tag, no fields = equal = not less-than)
6. For variants with payload: use the same lexicographic if/else chain as struct Ord

Use the same approach for accessing tag and payload fields as the Debug__inspect sum type generator from 20-03. Look at how 20-03's `lower_sum_type_def` accesses `self.tag` and variant payloads to stay consistent.

Register all generated function names in `self.known_functions`.
  </action>
  <verify>Run `cargo test --workspace` to confirm compilation and all tests pass. Verify a Snow program with sum type equality/comparison compiles and the MIR contains `Eq__eq__SumTypeName` and `Ord__lt__SumTypeName` function calls.</verify>
  <done>Eq__eq__SumTypeName and Ord__lt__SumTypeName MIR functions auto-generated for all sum types. Eq compares tag then payload fields. Ord compares tag ordering then payload lexicographically. Functions registered in known_functions. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. Eq/Ord impls registered for sum types (has_impl returns true)
3. Generated Eq function compares tag first, then payload fields per variant
4. Generated Ord function orders by variant tag, then lexicographic payload
5. All 6 comparison operators work on sum types via dispatch from 20-04
</verification>

<success_criteria>
- `some_val == none_val` compiles and correctly returns false (different tags)
- `Some(1) == Some(1)` compiles and returns true (same tag, same payload)
- `Some(1) == Some(2)` compiles and returns false (same tag, different payload)
- `Some(1) != Some(2)` compiles and returns true
- `None < Some(1)` compiles (variant ordering by definition order)
- `Some(1) < Some(2)` compiles (same variant, payload comparison)
- `>, <=, >=` all work on sum types
- Auto-derived impls require no user-written impl blocks
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-essential-stdlib-protocols/20-05-SUMMARY.md`
</output>
