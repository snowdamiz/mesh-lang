---
phase: 20-essential-stdlib-protocols
plan: 04
type: execute
wave: 4
depends_on: ["20-03"]
files_modified:
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "== on user-defined structs performs field-by-field equality comparison"
    - "!= on user-defined structs returns the negation of =="
    - "< on user-defined structs performs lexicographic field comparison"
    - "> on user-defined structs works (reverse of <)"
    - "<= and >= on user-defined structs work correctly"
  artifacts:
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Ord trait method name fixed to 'lt', String Ord impl added"
      contains: "Ord"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Auto-registered Eq and Ord impls for struct types"
      contains: "Eq.*register_impl"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Auto-generated Eq__eq__StructName and Ord__lt__StructName MIR functions, extended operator dispatch for NotEq/Gt/LtEq/GtEq"
      contains: "Eq__eq__|Ord__lt__"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs lower_binary_expr"
      to: "crates/snow-typeck/src/traits.rs has_impl"
      via: "operator dispatch checks has_impl before emitting trait call"
      pattern: "has_impl.*Eq|has_impl.*Ord"
    - from: "crates/snow-codegen/src/mir/lower.rs lower_struct_def"
      to: "crates/snow-codegen/src/mir/lower.rs functions"
      via: "auto-generate Eq__eq and Ord__lt MIR functions during struct lowering"
      pattern: "Eq__eq__|Ord__lt__"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/traits.rs register_impl"
      via: "auto-register Eq/Ord impls for each struct type definition"
      pattern: "register_impl.*Eq|register_impl.*Ord"
---

<objective>
Add Eq and Ord support for user-defined struct types with auto-generated field-by-field comparison, and extend operator dispatch to handle all 6 comparison operators.

Purpose: Success criteria 4 and 5 require == and comparison operators on user-defined types. This plan delivers struct support: auto-registering Eq/Ord impls, fixing the Ord method name inconsistency, extending operator dispatch for !=, >, <=, >=, and generating Eq__eq and Ord__lt MIR function bodies for structs.

Output: Struct types support all 6 comparison operators (==, !=, <, >, <=, >=) via auto-derived field-by-field (Eq) and lexicographic (Ord) comparison. Operator dispatch infrastructure shared by sum types in Plan 20-05.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-essential-stdlib-protocols/20-RESEARCH.md
@.planning/phases/20-essential-stdlib-protocols/20-01-SUMMARY.md
@.planning/phases/20-essential-stdlib-protocols/20-03-SUMMARY.md
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Ord method name, add missing impls, auto-register Eq/Ord for structs, extend operator dispatch</name>
  <files>crates/snow-typeck/src/builtins.rs, crates/snow-typeck/src/infer.rs, crates/snow-codegen/src/mir/lower.rs</files>
  <action>
**Part A: Fix Ord trait method name and add missing impls (builtins.rs)**

The Ord trait's method is currently registered as "cmp" in builtins.rs (line ~636), but the operator dispatch in lower_binary_expr uses "lt" (line ~1446). Fix the inconsistency:

1. In `register_compiler_known_traits`, update the Ord trait's `TraitMethodSig` to use method name "lt" instead of "cmp":
```rust
registry.register_trait(TraitDef {
    name: "Ord".to_string(),
    methods: vec![TraitMethodSig {
        name: "lt".to_string(),  // was "cmp" -- changed to match operator dispatch
        has_self: true,
        param_count: 1,
        return_type: Some(Ty::bool()),
    }],
});
```

2. Update the existing Ord impls for Int and Float to use "lt" as the method key:
```rust
methods.insert("lt".to_string(), ImplMethodSig { ... });
```

3. Add missing Ord impl for String (string comparison -- register the impl, codegen will route to a string comparison helper):
```rust
let mut methods = FxHashMap::default();
methods.insert("lt".to_string(), ImplMethodSig {
    has_self: true,
    param_count: 1,
    return_type: Some(Ty::bool()),
});
let _ = registry.register_impl(ImplDef {
    trait_name: "Ord".to_string(),
    impl_type: Ty::string(),
    impl_type_name: "String".to_string(),
    methods,
});
```

**Part B: Auto-register Eq and Ord impls for struct types (infer.rs)**

In `infer_struct_def` (or the struct definition inference path), after registering the Debug impl (added in 20-03), also register Eq and Ord impls:

```rust
// Auto-register Eq impl for this struct type
let struct_ty = Ty::Con(TyCon::new(&struct_name));
let mut eq_methods = FxHashMap::default();
eq_methods.insert("eq".to_string(), ImplMethodSig {
    has_self: true,
    param_count: 1,
    return_type: Some(Ty::bool()),
});
let _ = self.trait_registry.register_impl(ImplDef {
    trait_name: "Eq".to_string(),
    impl_type: struct_ty.clone(),
    impl_type_name: struct_name.clone(),
    methods: eq_methods,
});

// Auto-register Ord impl for this struct type
let mut ord_methods = FxHashMap::default();
ord_methods.insert("lt".to_string(), ImplMethodSig {
    has_self: true,
    param_count: 1,
    return_type: Some(Ty::bool()),
});
let _ = self.trait_registry.register_impl(ImplDef {
    trait_name: "Ord".to_string(),
    impl_type: struct_ty,
    impl_type_name: struct_name.clone(),
    methods: ord_methods,
});
```

NOTE: Only register for struct types in this task. Sum type registration is handled in Plan 20-05.

**Part C: Extend operator dispatch in lower_binary_expr (lower.rs)**

Update the operator dispatch map (around line 1441-1448) to handle all comparison operators via a unified (trait_name, method_name, negate, swap_args) tuple:

```rust
let (trait_name, method_name, negate, swap_args) = match op {
    BinOp::Add => (Some("Add"), "add", false, false),
    BinOp::Sub => (Some("Sub"), "sub", false, false),
    BinOp::Mul => (Some("Mul"), "mul", false, false),
    BinOp::Eq => (Some("Eq"), "eq", false, false),
    BinOp::NotEq => (Some("Eq"), "eq", true, false),   // negate eq result
    BinOp::Lt => (Some("Ord"), "lt", false, false),
    BinOp::Gt => (Some("Ord"), "lt", false, true),      // swap: b < a
    BinOp::LtEq => (Some("Ord"), "lt", true, true),     // negate(b < a) = a <= b
    BinOp::GtEq => (Some("Ord"), "lt", true, false),    // negate(a < b) = a >= b
    _ => (None, "", false, false),
};
```

Then update the trait dispatch block to apply transformations:
- If `swap_args`: swap lhs and rhs in the call arguments
- If `negate`: wrap result in a NOT operation. Check if `UnaryOp::Not` exists in MIR; if not, use `MirExpr::BinOp { op: BinOp::Eq, lhs: call_result, rhs: MirExpr::Bool(false) }` to negate (comparing with false is equivalent to NOT for booleans).

```rust
if let Some(trait_name) = trait_name {
    let ty_for_lookup = mir_type_to_ty(&lhs_ty);
    if self.trait_registry.has_impl(trait_name, &ty_for_lookup) {
        let type_name = mir_type_to_impl_name(&lhs_ty);
        let mangled = format!("{}__{}__{}", trait_name, method_name, type_name);
        let rhs_ty = rhs.ty().clone();
        let fn_ty = MirType::FnPtr(
            vec![lhs_ty.clone(), rhs_ty],
            Box::new(MirType::Bool),
        );
        let (call_lhs, call_rhs) = if swap_args { (rhs, lhs) } else { (lhs, rhs) };
        let call = MirExpr::Call {
            func: Box::new(MirExpr::Var(mangled, fn_ty)),
            args: vec![call_lhs, call_rhs],
            ty: MirType::Bool,
        };
        if negate {
            return MirExpr::BinOp {
                op: BinOp::Eq,
                lhs: Box::new(call),
                rhs: Box::new(MirExpr::Bool(false)),
                ty: MirType::Bool,
            };
        } else {
            return call;
        }
    }
}
```

This dispatch infrastructure is generic -- it works for both struct and sum types. Plan 20-05 will leverage this same dispatch path.
  </action>
  <verify>Run `cargo test --workspace` to confirm compilation and all tests pass. Verify the Ord method name is consistently "lt" by checking builtins.rs and lower.rs match.</verify>
  <done>Ord trait method name is consistently "lt" in registration and dispatch. String Ord impl registered. Eq/Ord impls auto-registered for all struct types in typeck. Operator dispatch handles all 6 comparison operators (==, !=, <, >, <=, >=) for any type with Eq/Ord impls. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Generate Eq__eq and Ord__lt MIR function bodies for struct types</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
In `lower_struct_def()`, after generating the Debug__inspect function (from 20-03), generate two more synthetic MIR functions:

**Eq__eq__StructName:**
Takes `(self: Struct, other: Struct) -> Bool`. Body: AND together field-by-field equality checks.

```
fn Eq__eq__Point(self: Point, other: Point) -> Bool {
    self.x == other.x && self.y == other.y
}
```

Implementation:
1. Create a helper `generate_eq_struct(&mut self, name: &str, fields: &[(String, MirType)])`
2. For each field, create two `MirExpr::FieldAccess` nodes (one on self, one on other)
3. Compare with `MirExpr::BinOp { op: BinOp::Eq }` for primitive fields
4. For struct-typed fields: use `MirExpr::Call` to `Eq__eq__FieldType` (recursive dispatch)
5. Chain all comparisons with `BinOp::And` (or logical AND -- check what exists in BinOp)
6. If zero fields: return `MirExpr::Bool(true)` (empty structs are always equal)

The self/other parameters are represented as `MirExpr::Var` with the struct `MirType`. Field access uses whatever field access MIR node exists (check `MirExpr` variants -- likely `MirExpr::FieldAccess { object, field_name, ty }` or similar).

**Ord__lt__StructName:**
Takes `(self: Struct, other: Struct) -> Bool`. Body: lexicographic less-than comparison.

```
fn Ord__lt__Point(self: Point, other: Point) -> Bool {
    if self.x < other.x then true
    else if self.x == other.x then self.y < other.y
    else false
}
```

Implementation:
1. Create helper `generate_ord_struct(&mut self, name: &str, fields: &[(String, MirType)])`
2. For each field except the last: if self.field < other.field, return true; if self.field == other.field, continue to next field; else return false
3. For the last field: return self.field < other.field
4. If zero fields: return `MirExpr::Bool(false)` (empty structs are never less-than)
5. Use nested `MirExpr::If` expressions to build the lexicographic chain
6. For primitive fields, use direct `BinOp::Lt` and `BinOp::Eq`
7. For struct-typed fields, use `Ord__lt__FieldType` and `Eq__eq__FieldType` calls (recursive)

Register all generated function names in `self.known_functions` so codegen can resolve them.
  </action>
  <verify>Run `cargo test --workspace` to confirm compilation and all tests pass. Write or verify a Snow program with struct equality/comparison compiles correctly and the MIR contains `Eq__eq__StructName` and `Ord__lt__StructName` function calls.</verify>
  <done>Eq__eq__StructName and Ord__lt__StructName MIR functions auto-generated for all struct types during lowering. Eq uses field-by-field AND comparison. Ord uses lexicographic if/else chain. Recursive dispatch works for nested struct fields. Functions registered in known_functions. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. Eq/Ord impls registered for struct types (has_impl returns true)
3. Operator dispatch handles all 6 comparison operators for user types
4. Generated Eq function uses field-by-field AND comparison
5. Generated Ord function uses lexicographic comparison
6. Ord trait method name is consistently "lt" in registration and dispatch
</verification>

<success_criteria>
- `point1 == point2` compiles and produces correct field-by-field comparison MIR
- `point1 != point2` compiles and negates the equality check
- `point1 < point2` compiles with lexicographic field comparison
- `point1 > point2`, `point1 <= point2`, `point1 >= point2` all compile correctly
- Auto-derived impls require no user-written impl blocks
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-essential-stdlib-protocols/20-04-SUMMARY.md`
</output>
