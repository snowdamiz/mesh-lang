---
phase: 20-essential-stdlib-protocols
plan: 04
type: execute
wave: 4
depends_on: ["20-03"]
files_modified:
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "== on user-defined structs performs field-by-field equality comparison"
    - "!= on user-defined structs returns the negation of =="
    - "< on user-defined structs performs lexicographic field comparison"
    - "> on user-defined structs works (reverse of <)"
    - "<= and >= on user-defined structs work correctly"
    - "== on sum types compares variant tag and then payload fields"
  artifacts:
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Eq/Ord String impls extended (if not already present)"
      contains: "Eq"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Auto-registered Eq and Ord impls for struct and sum types"
      contains: "Eq.*register_impl"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Auto-generated Eq__eq__TypeName and Ord__lt__TypeName MIR functions, extended operator dispatch for NotEq/Gt/LtEq/GtEq"
      contains: "Eq__eq__|Ord__lt__"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs lower_binary_expr"
      to: "crates/snow-typeck/src/traits.rs has_impl"
      via: "operator dispatch checks has_impl before emitting trait call"
      pattern: "has_impl.*Eq|has_impl.*Ord"
    - from: "crates/snow-codegen/src/mir/lower.rs lower_struct_def"
      to: "crates/snow-codegen/src/mir/lower.rs functions"
      via: "auto-generate Eq__eq and Ord__lt MIR functions during struct lowering"
      pattern: "Eq__eq__|Ord__lt__"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/traits.rs register_impl"
      via: "auto-register Eq/Ord impls for each struct/sum type definition"
      pattern: "register_impl.*Eq|register_impl.*Ord"
---

<objective>
Extend Eq and Ord to work on user-defined struct and sum types with auto-generated field-by-field comparison.

Purpose: The success criteria require == and comparison operators to work on user-defined structs and sum types. This plan auto-derives structural equality and lexicographic ordering for all struct/sum types, and extends the operator dispatch to handle NotEq, Gt, LtEq, GtEq.

Output: Auto-registered Eq/Ord impls for all struct/sum types, auto-generated comparison MIR function bodies, complete operator dispatch for all 6 comparison operators.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-essential-stdlib-protocols/20-RESEARCH.md
@.planning/phases/20-essential-stdlib-protocols/20-01-SUMMARY.md
@.planning/phases/20-essential-stdlib-protocols/20-03-SUMMARY.md
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auto-register Eq/Ord impls for structs/sum types and extend operator dispatch</name>
  <files>crates/snow-typeck/src/infer.rs, crates/snow-typeck/src/builtins.rs, crates/snow-codegen/src/mir/lower.rs</files>
  <action>
**Part A: Auto-register Eq and Ord impls for struct/sum types in typeck (infer.rs)**

In `infer_struct_def` (or the struct definition inference path), after registering the Debug impl (from 20-03), also register Eq and Ord impls:

```rust
// Auto-register Eq impl for this struct type
let struct_ty = Ty::Con(TyCon::new(&struct_name));
let mut eq_methods = FxHashMap::default();
eq_methods.insert("eq".to_string(), ImplMethodSig {
    has_self: true,
    param_count: 1,
    return_type: Some(Ty::bool()),
});
let _ = self.trait_registry.register_impl(ImplDef {
    trait_name: "Eq".to_string(),
    impl_type: struct_ty.clone(),
    impl_type_name: struct_name.clone(),
    methods: eq_methods,
});

// Auto-register Ord impl for this struct type
let mut ord_methods = FxHashMap::default();
ord_methods.insert("lt".to_string(), ImplMethodSig {
    has_self: true,
    param_count: 1,
    return_type: Some(Ty::bool()),
});
let _ = self.trait_registry.register_impl(ImplDef {
    trait_name: "Ord".to_string(),
    impl_type: struct_ty,
    impl_type_name: struct_name.clone(),
    methods: ord_methods,
});
```

Do the same in `infer_sum_type_def` for sum types.

IMPORTANT: The Ord trait's method is currently registered as "cmp" in builtins.rs (line 636), but the operator dispatch in lower_binary_expr uses "lt" (line 1446). These MUST be consistent. Update the Ord trait registration in builtins.rs to use method name "lt" instead of "cmp":

```rust
// In register_compiler_known_traits, update Ord trait:
registry.register_trait(TraitDef {
    name: "Ord".to_string(),
    methods: vec![TraitMethodSig {
        name: "lt".to_string(),  // was "cmp" -- changed to match operator dispatch
        has_self: true,
        param_count: 1,
        return_type: Some(Ty::bool()),
    }],
});

// And update Ord impls for Int/Float to use "lt" as well:
methods.insert("lt".to_string(), ImplMethodSig { ... });
```

Also add Eq impl for String and Ord impls for String and Bool in builtins.rs if not already present. Currently String has Eq (line 611) but NOT Ord. Bool has Eq but NOT Ord. Add:
- Ord impl for String (string comparison via `snow_string_eq` or lexicographic -- for now, string ordering isn't strictly needed but register for completeness)

**Part B: Extend operator dispatch in lower_binary_expr (lower.rs)**

Update the operator dispatch map (around line 1441-1448) to handle all comparison operators:

```rust
let (trait_name, method_name, negate, swap_args) = match op {
    BinOp::Add => (Some("Add"), "add", false, false),
    BinOp::Sub => (Some("Sub"), "sub", false, false),
    BinOp::Mul => (Some("Mul"), "mul", false, false),
    BinOp::Eq => (Some("Eq"), "eq", false, false),
    BinOp::NotEq => (Some("Eq"), "eq", true, false),   // negate eq result
    BinOp::Lt => (Some("Ord"), "lt", false, false),
    BinOp::Gt => (Some("Ord"), "lt", false, true),      // swap: b < a
    BinOp::LtEq => (Some("Ord"), "lt", true, true),     // negate(b < a) = a <= b
    BinOp::GtEq => (Some("Ord"), "lt", true, false),    // negate(a < b) = a >= b
    _ => (None, "", false, false),
};
```

Then after the trait method call is constructed, apply the transformations:
- If `swap_args`: swap lhs and rhs in the call arguments
- If `negate`: wrap the result in `MirExpr::UnaryOp { op: UnaryOp::Not, expr: call_result, ty: Bool }`

Check if `UnaryOp::Not` exists in the MIR. If not, use `MirExpr::BinOp { op: BinOp::Eq, lhs: call_result, rhs: MirExpr::Bool(false) }` to negate (comparing with false is equivalent to NOT for booleans). Or check if there's an existing NOT operation pattern in the lowerer.

The updated dispatch block should look like:
```rust
if let Some(trait_name) = trait_name {
    let ty_for_lookup = mir_type_to_ty(&lhs_ty);
    if self.trait_registry.has_impl(trait_name, &ty_for_lookup) {
        let type_name = mir_type_to_impl_name(&lhs_ty);
        let mangled = format!("{}__{}__{}", trait_name, method_name, type_name);
        let rhs_ty = rhs.ty().clone();
        let fn_ty = MirType::FnPtr(
            vec![lhs_ty.clone(), rhs_ty],
            Box::new(MirType::Bool),
        );
        let (call_lhs, call_rhs) = if swap_args {
            (rhs, lhs)
        } else {
            (lhs, rhs)
        };
        let call = MirExpr::Call {
            func: Box::new(MirExpr::Var(mangled, fn_ty)),
            args: vec![call_lhs, call_rhs],
            ty: MirType::Bool,
        };
        if negate {
            return MirExpr::BinOp {
                op: BinOp::Eq,
                lhs: Box::new(call),
                rhs: Box::new(MirExpr::Bool(false)),
                ty: MirType::Bool,
            };
        } else {
            return call;
        }
    }
}
```
  </action>
  <verify>Run `cargo test --workspace` to confirm compilation and all tests pass. Verify operator dispatch by checking that the match arm coverage is complete (no uncovered BinOp variants for user types).</verify>
  <done>Eq and Ord impls auto-registered for all struct/sum types in typeck. Operator dispatch handles ==, !=, <, >, <=, >= for user types. Ord trait method name is "lt" consistently between registration and dispatch. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Generate Eq__eq and Ord__lt MIR function bodies for structs and sum types</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
In `lower_struct_def()`, after generating the Debug__inspect function (from 20-03), generate two more synthetic MIR functions:

**Eq__eq__StructName:**
Takes `(self: Struct, other: Struct) -> Bool`. Body: AND together field-by-field equality checks.

```
fn Eq__eq__Point(self: Point, other: Point) -> Bool {
    self.x == other.x && self.y == other.y
}
```

Implementation:
1. Create a helper `generate_eq_struct(&mut self, name: &str, fields: &[(String, MirType)])`
2. For each field, create two `MirExpr::FieldAccess` nodes (one on self, one on other)
3. Compare with `MirExpr::BinOp { op: BinOp::Eq }` for primitive fields
4. For struct-typed fields: use `MirExpr::Call` to `Eq__eq__FieldType` (recursive dispatch)
5. Chain all comparisons with `BinOp::And`
6. If zero fields: return `MirExpr::Bool(true)` (empty structs are always equal)

The self/other parameters are represented as MirExpr::Var with the struct MirType. Field access uses `MirExpr::FieldAccess { object, field_name, ty }` (check the exact variant name in the MIR definition -- it may be `MirExpr::FieldAccess` or similar).

**Ord__lt__StructName:**
Takes `(self: Struct, other: Struct) -> Bool`. Body: lexicographic less-than comparison.

```
fn Ord__lt__Point(self: Point, other: Point) -> Bool {
    if self.x < other.x then true
    else if self.x == other.x then self.y < other.y
    else false
}
```

Implementation:
1. Create helper `generate_ord_struct(&mut self, name: &str, fields: &[(String, MirType)])`
2. For each field except the last: if self.field < other.field, return true; if self.field == other.field, continue to next field; else return false
3. For the last field: return self.field < other.field
4. If zero fields: return `MirExpr::Bool(false)` (empty structs are never less-than)
5. Use nested `MirExpr::If` expressions to build the lexicographic chain
6. For primitive fields, use direct `BinOp::Lt` and `BinOp::Eq`
7. For struct-typed fields, use `Ord__lt__FieldType` and `Eq__eq__FieldType` calls

**For sum types** in `lower_sum_type_def()`:

**Eq__eq__SumTypeName:**
1. Compare tags first: if tags differ, return false
2. If same tag, compare payload fields for that variant
3. The tag comparison uses `MirExpr::BinOp { op: BinOp::Eq }` on the tag values
4. Payload comparison: for each variant, if tag matches, compare fields recursively
5. Implementation: a chain of if-else for each variant tag value

**Ord__lt__SumTypeName:**
1. Compare tags first: if self.tag < other.tag, return true; if different, return false
2. If same tag, lexicographic compare on payload fields
3. This gives ordering: first variant < second variant < ... (by definition order)

If sum type comparison is too complex for the context budget, implement Eq for sum types (tag + field comparison) and defer Ord for sum types to Phase 21 (noting in the summary). Eq is the higher-priority success criterion.

Register all generated function names in `self.known_functions`.

Add tests that verify the generated functions exist in the MIR output.
  </action>
  <verify>Run `cargo test --workspace` to confirm compilation and all tests pass. If possible, write a Snow program with struct equality and compile it to verify the MIR contains `Eq__eq__StructName` function calls. At minimum, verify compilation succeeds and no panics occur during lowering of struct-containing programs.</verify>
  <done>Eq__eq__TypeName and Ord__lt__TypeName MIR functions auto-generated for all struct types. Sum type Eq (at minimum) auto-generated. Functions use field-by-field comparison with correct recursive dispatch for nested types. Functions registered in known_functions. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. Eq/Ord impls registered for struct types (has_impl returns true)
3. Operator dispatch handles all 6 comparison operators for user types
4. Generated Eq function uses field-by-field AND comparison
5. Generated Ord function uses lexicographic comparison
6. Ord trait method name is consistently "lt" in registration and dispatch
</verification>

<success_criteria>
- `point1 == point2` compiles and produces correct field-by-field comparison MIR
- `point1 != point2` compiles and negates the equality check
- `point1 < point2` compiles with lexicographic field comparison
- `point1 > point2`, `point1 <= point2`, `point1 >= point2` all compile correctly
- Sum type `variant1 == variant2` compares tag and payload
- Auto-derived impls require no user-written impl blocks
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-essential-stdlib-protocols/20-04-SUMMARY.md`
</output>
