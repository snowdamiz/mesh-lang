---
phase: 20-essential-stdlib-protocols
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/unify.rs
  - crates/snow-typeck/src/builtins.rs
autonomous: true

must_haves:
  truths:
    - "Ty::Con('Point') unifies with Ty::App(Con('Point'), []) without error"
    - "Display trait is registered in TraitRegistry with to_string method"
    - "Display impls exist for Int, Float, String, Bool primitives"
    - "to_string(42) resolves via Display trait dispatch to mangled name"
  artifacts:
    - path: "crates/snow-typeck/src/unify.rs"
      provides: "Con vs App(Con, []) unification case"
      contains: "args.is_empty"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Display trait definition and primitive impls"
      contains: "Display"
  key_links:
    - from: "crates/snow-typeck/src/unify.rs"
      to: "crates/snow-typeck/src/infer.rs"
      via: "unify called during infer_call for trait method argument matching"
      pattern: "Con.*App.*args.*is_empty"
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "crates/snow-typeck/src/traits.rs"
      via: "register_trait and register_impl calls for Display"
      pattern: "Display.*to_string"
---

<objective>
Fix the critical typeck type identity gap and register the Display protocol with primitive implementations.

Purpose: The typeck identity gap (Ty::Con vs Ty::App(Con, [])) blocks ALL user-defined trait impls from working at call sites. Fixing this unblocks everything in Phase 20. The Display trait registration enables to_string() to dispatch through the trait system for any type with a Display impl.

Output: Working type unification for non-generic struct types, Display trait registered with primitive impls.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-essential-stdlib-protocols/20-RESEARCH.md
@crates/snow-typeck/src/unify.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/traits.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix typeck Ty::Con vs Ty::App(Con, []) unification gap</name>
  <files>crates/snow-typeck/src/unify.rs</files>
  <action>
In `InferCtx::unify()` in unify.rs, add a new match arm BEFORE the existing `(Ty::App, Ty::App)` case (around line 222) and AFTER the existing Pid escape hatch (around line 213-219). The new case handles non-generic struct type identity:

```rust
// Non-generic type identity: Con("Point") == App(Con("Point"), [])
// This arises because infer_struct_literal returns App(Con(name), []) for
// non-generic structs, while name_to_type returns Con(name). Both represent
// the same type.
(Ty::Con(ref c), Ty::App(ref con, ref args))
| (Ty::App(ref con, ref args), Ty::Con(ref c))
    if args.is_empty()
        && matches!(con.as_ref(), Ty::Con(ref ac) if ac.name == c.name) =>
{
    Ok(())
}
```

This is strictly more permissive -- it allows unification that previously failed. It does NOT affect any existing passing unification (primitives use Con-Con, generics use App-App).

Also add a unit test in the existing `mod tests` block at the bottom of unify.rs:

```rust
#[test]
fn con_unifies_with_app_con_empty_args() {
    let mut ctx = InferCtx::new();
    let con = Ty::Con(TyCon::new("Point"));
    let app = Ty::App(Box::new(Ty::Con(TyCon::new("Point"))), vec![]);
    // Con("Point") should unify with App(Con("Point"), [])
    assert!(ctx.unify(con.clone(), app.clone(), ConstraintOrigin::Assignment).is_ok());
    // Symmetric: App should also unify with Con
    assert!(ctx.unify(app, con, ConstraintOrigin::Assignment).is_ok());
}

#[test]
fn con_does_not_unify_with_app_con_nonempty_args() {
    let mut ctx = InferCtx::new();
    let con = Ty::Con(TyCon::new("List"));
    let app = Ty::App(Box::new(Ty::Con(TyCon::new("List"))), vec![Ty::int()]);
    // Con("List") should NOT unify with App(Con("List"), [Int]) -- different arities
    assert!(ctx.unify(con, app, ConstraintOrigin::Assignment).is_err());
}
```
  </action>
  <verify>Run `cargo test -p snow-typeck -- unify` and confirm all tests pass, including the two new tests. Run full test suite `cargo test --workspace` to confirm no regressions.</verify>
  <done>Ty::Con("Point") unifies with Ty::App(Con("Point"), []) bidirectionally. Ty::Con("List") does NOT unify with Ty::App(Con("List"), [Int]). All 1,018+ existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Register Display trait and primitive impls in builtins</name>
  <files>crates/snow-typeck/src/builtins.rs</files>
  <action>
In `register_compiler_known_traits()` in builtins.rs, add the Display trait registration AFTER the existing Not trait block (after line 688, before the closing brace). Follow the exact pattern used by Eq:

1. Register the Display trait definition:
```rust
// ── Display trait ──────────────────────────────────────────────
registry.register_trait(TraitDef {
    name: "Display".to_string(),
    methods: vec![TraitMethodSig {
        name: "to_string".to_string(),
        has_self: true,
        param_count: 0,  // no params besides self
        return_type: Some(Ty::string()),
    }],
});
```

2. Register Display impls for Int, Float, String, Bool:
```rust
for (ty, ty_name) in &[
    (Ty::int(), "Int"),
    (Ty::float(), "Float"),
    (Ty::string(), "String"),
    (Ty::bool(), "Bool"),
] {
    let mut methods = FxHashMap::default();
    methods.insert(
        "to_string".to_string(),
        ImplMethodSig {
            has_self: true,
            param_count: 0,
            return_type: Some(Ty::string()),
        },
    );
    let _ = registry.register_impl(ImplDef {
        trait_name: "Display".to_string(),
        impl_type: ty.clone(),
        impl_type_name: ty_name.to_string(),
        methods,
    });
}
```

3. Add a test in the existing `mod tests` block to verify Display is registered:
```rust
#[test]
fn display_trait_registered_for_primitives() {
    let mut ctx = InferCtx::new();
    let mut env = TypeEnv::new();
    let mut trait_registry = TraitRegistry::new();
    register_builtins(&mut ctx, &mut env, &mut trait_registry);

    // Display trait exists
    assert!(trait_registry.has_impl("Display", &Ty::int()));
    assert!(trait_registry.has_impl("Display", &Ty::float()));
    assert!(trait_registry.has_impl("Display", &Ty::string()));
    assert!(trait_registry.has_impl("Display", &Ty::bool()));

    // find_method_traits should find Display for to_string
    let traits = trait_registry.find_method_traits("to_string", &Ty::int());
    assert!(traits.contains(&"Display".to_string()));
}
```
  </action>
  <verify>Run `cargo test -p snow-typeck -- builtins` and confirm all tests pass including the new display test. Run `cargo test --workspace` for full suite.</verify>
  <done>Display trait registered with to_string(self) -> String method signature. All four primitive types have Display impls. find_method_traits("to_string", &Ty::int()) returns ["Display"]. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all existing tests pass (no regressions from unify fix)
2. `cargo test -p snow-typeck -- con_unifies_with_app` -- new unification test passes
3. `cargo test -p snow-typeck -- display_trait_registered` -- new Display test passes
4. The typeck identity gap documented in STATE.md blockers is resolved
</verification>

<success_criteria>
- Ty::Con("X") unifies with Ty::App(Con("X"), []) for any non-generic type X
- Display trait is registered as compiler-known trait
- Int, Float, String, Bool all have Display impls
- find_method_traits("to_string", &ty) returns ["Display"] for primitives
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/20-essential-stdlib-protocols/20-01-SUMMARY.md`
</output>
