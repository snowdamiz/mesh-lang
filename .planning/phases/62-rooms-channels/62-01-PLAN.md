---
phase: 62-rooms-channels
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/ws/rooms.rs
  - crates/snow-rt/src/ws/server.rs
  - crates/snow-rt/src/ws/mod.rs
autonomous: true

must_haves:
  truths:
    - "Ws.join(conn, room) subscribes a connection to a named room"
    - "Ws.leave(conn, room) unsubscribes a connection from a room"
    - "Ws.broadcast(room, message) delivers a text frame to all connections in a room"
    - "Ws.broadcast_except(room, message, conn) delivers to all except the specified connection"
    - "Connections are automatically removed from all rooms on disconnect"
    - "Room registry supports concurrent access from multiple connection actors"
  artifacts:
    - path: "crates/snow-rt/src/ws/rooms.rs"
      provides: "RoomRegistry struct, global instance, snow_ws_join, snow_ws_leave, snow_ws_broadcast, snow_ws_broadcast_except"
      contains: "struct RoomRegistry"
    - path: "crates/snow-rt/src/ws/server.rs"
      provides: "Disconnect cleanup hook calling cleanup_connection before Box::from_raw"
      contains: "cleanup_connection"
    - path: "crates/snow-rt/src/ws/mod.rs"
      provides: "pub mod rooms re-export"
      contains: "pub mod rooms"
  key_links:
    - from: "crates/snow-rt/src/ws/rooms.rs"
      to: "crates/snow-rt/src/ws/server.rs"
      via: "WsConnection struct dereference in broadcast"
      pattern: "WsConnection"
    - from: "crates/snow-rt/src/ws/server.rs"
      to: "crates/snow-rt/src/ws/rooms.rs"
      via: "cleanup_connection call in ws_connection_entry cleanup"
      pattern: "global_room_registry.*cleanup_connection"
    - from: "crates/snow-rt/src/ws/rooms.rs"
      to: "crates/snow-rt/src/ws/frame.rs"
      via: "write_frame for broadcast"
      pattern: "write_frame"
---

<objective>
Create the RoomRegistry data structure and four runtime functions (snow_ws_join, snow_ws_leave, snow_ws_broadcast, snow_ws_broadcast_except) with automatic disconnect cleanup.

Purpose: Enable WebSocket connections to join named rooms for pub/sub broadcast messaging. This is the runtime foundation that the codegen pipeline (Plan 02) will wire into.

Output: `rooms.rs` with complete room registry and extern "C" functions, `server.rs` with cleanup hook, `mod.rs` with module re-export.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-rooms-channels/62-RESEARCH.md
@crates/snow-rt/src/ws/server.rs
@crates/snow-rt/src/ws/mod.rs
@crates/snow-rt/src/ws/frame.rs
@crates/snow-rt/src/actor/registry.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rooms.rs with RoomRegistry and four runtime functions</name>
  <files>crates/snow-rt/src/ws/rooms.rs, crates/snow-rt/src/ws/mod.rs</files>
  <action>
Create `crates/snow-rt/src/ws/rooms.rs` containing:

1. **RoomRegistry struct** modeled on ProcessRegistry (`crates/snow-rt/src/actor/registry.rs`):
   - `rooms: RwLock<FxHashMap<String, HashSet<usize>>>` -- room name to set of connection handles (WsConnection ptr as usize)
   - `conn_rooms: RwLock<FxHashMap<usize, HashSet<String>>>` -- reverse index for O(rooms_per_conn) cleanup
   - Use `parking_lot::RwLock` and `rustc_hash::FxHashMap` (already in dependencies, same as ProcessRegistry)
   - Use `std::collections::HashSet` for membership sets

2. **Lock ordering**: Always acquire `rooms` write lock first, then `conn_rooms` write lock (nested, consistent order to prevent deadlock). This means `join`, `leave`, and `cleanup_connection` all acquire in the same order.

3. **Methods on RoomRegistry**:
   - `new() -> Self` -- empty maps
   - `join(&self, conn: usize, room: String)` -- insert conn into rooms[room], insert room into conn_rooms[conn]. Acquire rooms write, then conn_rooms write.
   - `leave(&self, conn: usize, room: &str)` -- remove conn from rooms[room], remove empty room entry, remove room from conn_rooms[conn], remove empty conn entry. Acquire rooms write, then conn_rooms write.
   - `cleanup_connection(&self, conn: usize)` -- remove conn from conn_rooms, get set of room names, then remove conn from each room in rooms map, remove empty room entries. Acquire rooms write, then conn_rooms write (same order).
   - `members(&self, room: &str) -> Vec<usize>` -- snapshot member list. Acquire rooms read lock only.

4. **Global instance** via `OnceLock<RoomRegistry>`:
   ```rust
   static GLOBAL_ROOM_REGISTRY: OnceLock<RoomRegistry> = OnceLock::new();
   pub fn global_room_registry() -> &'static RoomRegistry {
       GLOBAL_ROOM_REGISTRY.get_or_init(RoomRegistry::new)
   }
   ```

5. **Four extern "C" functions** (all `#[no_mangle] pub extern "C"`):

   a. `snow_ws_join(conn: *mut u8, room_name: *const SnowString) -> i64`
      - Null check both args (return -1)
      - Extract room name as owned Rust String: `unsafe { (*room_name).as_str().to_string() }` (prevents GC dangling reference -- see Research Pitfall 4)
      - Call `global_room_registry().join(conn as usize, room)`
      - Return 0 on success

   b. `snow_ws_leave(conn: *mut u8, room_name: *const SnowString) -> i64`
      - Null check both args (return -1)
      - Extract room name as `&str`: `unsafe { (*room_name).as_str() }`
      - Call `global_room_registry().leave(conn as usize, room)`
      - Return 0 on success

   c. `snow_ws_broadcast(room_name: *const SnowString, msg: *const SnowString) -> i64`
      - Null check both args (return -1)
      - Extract room name and message text as `&str`
      - Snapshot members via `global_room_registry().members(room)` (drops read lock before iterating)
      - Iterate members: for each conn_usize, dereference as `&*(conn_usize as *const WsConnection)`, check `shutdown` flag (skip if set), lock `write_stream`, call `write_frame(&mut *stream, WsOpcode::Text, payload, true)`
      - Count and return failures (0 = all succeeded, N = N failed, -1 = null args)
      - Use `WsConnection` from `super::server::WsConnection` -- NOTE: `WsConnection` is currently private in server.rs. It must be made `pub(crate)` for rooms.rs to access it. Also make its fields `write_stream` and `shutdown` `pub(crate)`.

   d. `snow_ws_broadcast_except(room_name: *const SnowString, msg: *const SnowString, except_conn: *mut u8) -> i64`
      - Same as broadcast but skip `conn_usize == except_conn as usize`
      - Null check room_name and msg (return -1). except_conn can be null (treated as no exclusion).

6. **Imports needed in rooms.rs**:
   - `use parking_lot::RwLock;`
   - `use rustc_hash::FxHashMap;`
   - `use std::collections::HashSet;`
   - `use std::sync::OnceLock;`
   - `use std::sync::atomic::Ordering;`
   - `use crate::string::SnowString;`
   - `use super::server::WsConnection;`
   - `use super::{write_frame, WsOpcode};`

7. **In mod.rs**: Add `pub mod rooms;` after `pub mod server;`. Add re-export: `pub use rooms::global_room_registry;`

8. **In server.rs**: Change `struct WsConnection` to `pub(crate) struct WsConnection` and its fields `write_stream` and `shutdown` to `pub(crate)`.
  </action>
  <verify>
Run `cargo check -p snow-rt` -- must compile with no errors. Warnings about unused functions are acceptable (codegen wiring happens in Plan 02).
  </verify>
  <done>
rooms.rs exists with RoomRegistry struct, 4 methods (join, leave, cleanup_connection, members), global instance, and 4 extern "C" functions (snow_ws_join, snow_ws_leave, snow_ws_broadcast, snow_ws_broadcast_except). mod.rs re-exports rooms module. WsConnection is pub(crate) with pub(crate) fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hook room cleanup into ws_connection_entry disconnect path</name>
  <files>crates/snow-rt/src/ws/server.rs</files>
  <action>
In `ws_connection_entry` (server.rs), add room cleanup to the actor cleanup path. The cleanup must happen BEFORE `drop(Box::from_raw(conn))` to prevent use-after-free in concurrent broadcasts (Research Pitfall 1).

Find the cleanup section (around line 593-613). Current cleanup order:
1. `shutdown.store(true, Ordering::SeqCst)` (line ~594)
2. Send close frame (crash: 1011, normal: 1000)
3. Call on_close callback
4. `drop(Box::from_raw(conn))` (line ~612)

**Revised cleanup order** -- insert room cleanup BEFORE shutdown signal. The new order:
1. **NEW**: `crate::ws::rooms::global_room_registry().cleanup_connection(conn as usize);` -- remove from all rooms first, so no concurrent broadcast can reference this connection
2. `shutdown.store(true, Ordering::SeqCst)` -- signal reader thread
3. Send close frame
4. Call on_close callback
5. `drop(Box::from_raw(conn))` -- free connection handle

Insert the room cleanup line as the FIRST action in the cleanup section (line ~594, before `shutdown.store`). Add a comment: `// ROOM-05: remove from all rooms before signaling shutdown`

Also handle the early-exit rejection path (around line 564-570, where `!accepted`). In that path, the connection was rejected by on_connect, so it was never joined to any rooms. No room cleanup is needed there -- the existing code is fine.
  </action>
  <verify>
Run `cargo check -p snow-rt` -- must compile with no errors. Then run `cargo test -p snow-rt` -- all existing tests must pass (the cleanup call is a no-op for connections not in any rooms).
  </verify>
  <done>
ws_connection_entry cleanup path calls `cleanup_connection` before `shutdown.store` and before `Box::from_raw`. All existing tests pass with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p snow-rt` compiles successfully
2. `cargo test -p snow-rt` -- all tests pass (expect ~323+ tests, 0 failures)
3. `rooms.rs` contains RoomRegistry with RwLock-based concurrent maps
4. Four `#[no_mangle] pub extern "C"` functions exist in rooms.rs
5. `global_room_registry()` provides static singleton access
6. `ws_connection_entry` calls `cleanup_connection` before freeing WsConnection
7. WsConnection and its fields are pub(crate) accessible
</verification>

<success_criteria>
- RoomRegistry struct mirrors ProcessRegistry pattern with rooms + conn_rooms maps
- All four runtime functions handle null pointers gracefully (return -1)
- Broadcast correctly snapshots members, checks shutdown flag, writes frames
- broadcast_except skips the excluded connection
- Disconnect cleanup removes connection from all rooms atomically
- Lock ordering is consistent (rooms first, conn_rooms second) across all methods
- Empty rooms are removed from the map to prevent memory leaks
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/62-rooms-channels/62-01-SUMMARY.md`
</output>
