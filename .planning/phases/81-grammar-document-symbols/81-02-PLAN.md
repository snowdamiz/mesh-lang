---
phase: 81-grammar-document-symbols
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-lsp/src/server.rs
autonomous: true

must_haves:
  truths:
    - "VS Code Outline panel shows hierarchical symbols for Mesh files"
    - "Go-to-symbol (Cmd+Shift+O) lists all fn, struct, module, actor, service, supervisor, interface, impl, and let definitions"
    - "Breadcrumbs navigation shows correct nesting (function inside module)"
    - "Symbol ranges cover entire definitions (fn to end), selection ranges cover just the name"
  artifacts:
    - path: "crates/mesh-lsp/src/server.rs"
      provides: "textDocument/documentSymbol handler with hierarchical symbol response"
      contains: "document_symbol"
  key_links:
    - from: "crates/mesh-lsp/src/server.rs"
      to: "crates/mesh-parser/src/syntax_kind.rs"
      via: "SyntaxKind matching for FN_DEF, STRUCT_DEF, MODULE_DEF, etc."
      pattern: "SyntaxKind::FN_DEF"
    - from: "crates/mesh-lsp/src/server.rs"
      to: "crates/mesh-lsp/src/definition.rs"
      via: "tree_to_source_offset for range conversion"
      pattern: "tree_to_source_offset"
    - from: "crates/mesh-lsp/src/server.rs"
      to: "crates/mesh-lsp/src/analysis.rs"
      via: "offset_to_position for LSP position conversion"
      pattern: "offset_to_position"
---

<objective>
Add textDocument/documentSymbol handler to the Mesh LSP server for VS Code Outline, Breadcrumbs, and Go-to-Symbol.

Purpose: Satisfies SYM-01 through SYM-03. After this plan, opening a Mesh file in VS Code shows a hierarchical symbol tree in the Outline panel, breadcrumb navigation works, and Cmd+Shift+O lists all definitions.

Output: Updated `server.rs` with `document_symbol` handler, capability advertisement, and test coverage.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/81-grammar-document-symbols/81-RESEARCH.md
@crates/mesh-lsp/src/server.rs
@crates/mesh-lsp/src/definition.rs
@crates/mesh-lsp/src/analysis.rs
@crates/mesh-parser/src/ast/item.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement document_symbol handler with hierarchical CST walk</name>
  <files>crates/mesh-lsp/src/server.rs</files>
  <action>
Add the `document_symbol` method to the `LanguageServer` impl for `MeshBackend`, plus helper functions for CST traversal and symbol construction. Follow the exact patterns established in `definition.rs` for CST walking and offset conversion.

**1. Add capability advertisement in `initialize()`:**

Add `document_symbol_provider: Some(OneOf::Left(true)),` to the `ServerCapabilities` struct, alongside the existing `hover_provider` and `definition_provider`.

**2. Add the `document_symbol` method to the `LanguageServer` impl:**

```rust
async fn document_symbol(
    &self,
    params: DocumentSymbolParams,
) -> Result<Option<DocumentSymbolResponse>> {
    let uri_str = params.text_document.uri.to_string();

    let docs = self.documents.lock().unwrap();
    let doc = match docs.get(&uri_str) {
        Some(doc) => doc,
        None => return Ok(None),
    };

    let root = doc.analysis.parse.syntax();
    let symbols = collect_symbols(&doc.source, &root);

    Ok(Some(DocumentSymbolResponse::Nested(symbols)))
}
```

**3. Add helper functions OUTSIDE the impl blocks (module-level):**

`collect_symbols(source: &str, node: &SyntaxNode) -> Vec<DocumentSymbol>`:
Walk `node.children()` and match on `child.kind()`:

| SyntaxKind | SymbolKind | Name extraction | Children |
|------------|-----------|-----------------|----------|
| `FN_DEF` | `SymbolKind::FUNCTION` | NAME child -> IDENT token text | None |
| `STRUCT_DEF` | `SymbolKind::STRUCT` | NAME child -> IDENT token text | None |
| `MODULE_DEF` | `SymbolKind::MODULE` | NAME child -> IDENT token text | Recurse into BLOCK child |
| `ACTOR_DEF` | `SymbolKind::CLASS` | NAME child -> IDENT token text | Recurse into BLOCK child for fn defs |
| `SERVICE_DEF` | `SymbolKind::CLASS` | NAME child -> IDENT token text | Recurse into BLOCK child for fn/call/cast |
| `SUPERVISOR_DEF` | `SymbolKind::CLASS` | NAME child -> IDENT token text | None |
| `INTERFACE_DEF` | `SymbolKind::INTERFACE` | NAME child -> IDENT token text | Recurse into children for INTERFACE_METHOD |
| `IMPL_DEF` | `SymbolKind::OBJECT` | Extract from PATH child (trait name). Use first IDENT from first PATH child. Format as "impl TraitName". If no PATH found, use "impl" as name. | Recurse into BLOCK child for fn defs |
| `LET_BINDING` | `SymbolKind::VARIABLE` | NAME child -> IDENT token text | None |
| `SUM_TYPE_DEF` | `SymbolKind::ENUM` | NAME child -> IDENT token text | None |
| `TYPE_ALIAS_DEF` | `SymbolKind::TYPE_PARAMETER` | NAME child -> IDENT token text | None |

For containers (MODULE_DEF, ACTOR_DEF, SERVICE_DEF, INTERFACE_DEF, IMPL_DEF), recursively call `collect_symbols` on the BLOCK child node, and set `children: Some(child_symbols)` if non-empty.

For INTERFACE_DEF, also iterate over direct children matching `SyntaxKind::INTERFACE_METHOD` and create FUNCTION symbols for each.

`make_symbol(source: &str, node: &SyntaxNode, kind: SymbolKind, name: String) -> Option<DocumentSymbol>`:

Compute ranges using the SAME offset conversion chain as `goto_definition`:
1. Get the node's `text_range()` for the full range
2. Find the NAME child and get its `text_range()` for the selection range
3. Convert rowan offsets to source byte offsets via `crate::definition::tree_to_source_offset()`
4. Convert source byte offsets to LSP Positions via `crate::analysis::offset_to_position()`

CRITICAL: Use `tree_to_source_offset` for BOTH start and end of BOTH ranges. If any conversion returns `None`, return `None` from make_symbol (skip that symbol rather than panic).

For the selection_range, use the NAME node's text_range when available. For IMPL_DEF (which has no NAME child), use the PATH node's text_range for the selection_range.

Construct `DocumentSymbol`:
```rust
#[allow(deprecated)]  // deprecated field must still be set
DocumentSymbol {
    name,
    detail: None,
    kind,
    tags: None,
    deprecated: None,  // deprecated but required by struct
    range,
    selection_range,
    children: None,  // set by caller for containers
}
```

Note: The `deprecated` field on `DocumentSymbol` is deprecated in the LSP spec (replaced by `tags`) but the Rust struct still requires it. Use `#[allow(deprecated)]` to suppress the warning.

**4. Required imports at the top of server.rs:**

Add `use mesh_parser::SyntaxKind;` and ensure `SyntaxNode` is imported (it comes from `mesh_parser` as `mesh_parser::SyntaxNode` or via `mesh_parser::cst::SyntaxNode`). Check what `definition.rs` imports and follow the same pattern. Also import `DocumentSymbolParams`, `DocumentSymbolResponse`, `DocumentSymbol`, `SymbolKind` -- these should already be covered by the `use tower_lsp::lsp_types::*` import.

**5. Add test for document_symbol capability:**

Extend the existing `server_capabilities` test to assert that `caps.document_symbol_provider.is_some()`.
  </action>
  <verify>
Run `cargo build -p mesh-lsp` -- must compile without errors.
Run `cargo test -p mesh-lsp` -- all tests must pass (existing + new capability test).

Verify the handler compiles by checking that:
- `document_symbol_provider` is advertised in capabilities
- `document_symbol` method exists on the LanguageServer impl
- `collect_symbols` and `make_symbol` functions exist
- SyntaxKind matching covers all 11 node types (FN_DEF, STRUCT_DEF, MODULE_DEF, ACTOR_DEF, SERVICE_DEF, SUPERVISOR_DEF, INTERFACE_DEF, IMPL_DEF, LET_BINDING, SUM_TYPE_DEF, TYPE_ALIAS_DEF)
  </verify>
  <done>
LSP server advertises document_symbol_provider capability. The document_symbol handler returns hierarchical DocumentSymbolResponse::Nested with correct SymbolKind mappings for all 11 definition types. Ranges use proper rowan-to-source offset conversion. Selection ranges cover name identifiers only. Container symbols (module, actor, service, interface, impl) include nested children. All existing tests pass plus new capability assertion.
  </done>
</task>

</tasks>

<verification>
- `cargo build -p mesh-lsp` succeeds
- `cargo test -p mesh-lsp` passes all tests
- `document_symbol_provider` capability is advertised
- All 11 CST node kinds are handled in collect_symbols
- SymbolKind mapping matches spec: FN_DEF->FUNCTION, STRUCT_DEF->STRUCT, MODULE_DEF->MODULE, ACTOR_DEF->CLASS, SERVICE_DEF->CLASS, SUPERVISOR_DEF->CLASS, INTERFACE_DEF->INTERFACE, IMPL_DEF->OBJECT, LET_BINDING->VARIABLE, SUM_TYPE_DEF->ENUM, TYPE_ALIAS_DEF->TYPE_PARAMETER
- Offset conversion uses tree_to_source_offset (not raw rowan offsets)
</verification>

<success_criteria>
SYM-01, SYM-02, SYM-03 all satisfied. LSP compiles and tests pass. Document symbol handler returns hierarchical symbols with correct kinds, ranges, and nesting.
</success_criteria>

<output>
After completion, create `.planning/phases/81-grammar-document-symbols/81-02-SUMMARY.md`
</output>
