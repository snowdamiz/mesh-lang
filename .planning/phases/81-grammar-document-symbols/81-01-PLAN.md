---
phase: 81-grammar-document-symbols
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - editors/vscode-mesh/syntaxes/mesh.tmLanguage.json
  - website/docs/.vitepress/theme/shiki/mesh-light.json
  - website/docs/.vitepress/theme/shiki/mesh-dark.json
autonomous: true

must_haves:
  truths:
    - "All Mesh keywords are syntax-highlighted in VS Code and on the website"
    - "Doc comments (## and ##!) appear visually distinct from regular comments"
    - "Hex, binary, and scientific number literals are highlighted as numbers"
    - "Triple-quoted strings with interpolation are highlighted correctly"
    - "Module-qualified calls (List.map) highlight module as type and function as function"
    - "nil is NOT highlighted as a language constant (Mesh uses None)"
  artifacts:
    - path: "editors/vscode-mesh/syntaxes/mesh.tmLanguage.json"
      provides: "Complete TextMate grammar for Mesh language"
      contains: "for|while|cond|break|continue"
    - path: "website/docs/.vitepress/theme/shiki/mesh-light.json"
      provides: "Light theme with doc comment styling"
      contains: "comment.line.documentation"
    - path: "website/docs/.vitepress/theme/shiki/mesh-dark.json"
      provides: "Dark theme with doc comment styling"
      contains: "comment.line.documentation"
  key_links:
    - from: "editors/vscode-mesh/syntaxes/mesh.tmLanguage.json"
      to: "website/docs/.vitepress/config.mts"
      via: "Direct import path for Shiki highlighting"
      pattern: "mesh.tmLanguage.json"
---

<objective>
Complete TextMate grammar covering all Mesh syntax + update Shiki themes for doc comment distinction.

Purpose: Satisfies GRAM-01 through GRAM-10. After this plan, every Mesh keyword, operator, literal form, and construct is syntax-highlighted in both VS Code and the website (website gets it for free via shared grammar architecture).

Output: Updated `mesh.tmLanguage.json` with full coverage, updated Shiki themes with doc comment styling.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/81-grammar-document-symbols/81-RESEARCH.md
@editors/vscode-mesh/syntaxes/mesh.tmLanguage.json
@website/docs/.vitepress/theme/shiki/mesh-light.json
@website/docs/.vitepress/theme/shiki/mesh-dark.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update TextMate grammar with complete Mesh syntax coverage</name>
  <files>editors/vscode-mesh/syntaxes/mesh.tmLanguage.json</files>
  <action>
Rewrite the TextMate grammar to cover all 10 GRAM requirements. The following changes are needed -- pay careful attention to RULE ORDERING (TextMate matches first matching rule):

**Comments repository (GRAM-05) -- replace existing `#.*$` with ordered rules:**
1. `##!.*$` as `comment.line.documentation.module.mesh` (module-level doc comments)
2. `##[^!].*$|##$` as `comment.line.documentation.mesh` (item doc comments)
3. `#[^#=].*$|#$` as `comment.line.hash.mesh` (regular comments)
4. `#=` / `=#` begin/end as `comment.block.mesh` (block comments)

**Strings repository (GRAM-07) -- add triple-quoted strings BEFORE regular strings:**
1. Triple-quoted string: begin `"""`, end `"""`, name `string.quoted.triple.mesh`, with nested patterns for escape chars (`\\\\.`) and interpolation (`\\$\\{` / `\\}`). Interpolation patterns include `source.mesh`.
2. Regular double-quoted string (existing, keep as-is but after triple-quote rule).

**Numbers repository (GRAM-06) -- replace with ordered specific-to-general:**
1. Hex: `\\b0[xX][0-9a-fA-F_]+\\b` as `constant.numeric.hex.mesh`
2. Binary: `\\b0[bB][01_]+\\b` as `constant.numeric.binary.mesh`
3. Octal: `\\b0[oO][0-7_]+\\b` as `constant.numeric.octal.mesh`
4. Scientific float: `\\b[0-9][0-9_]*(?:\\.[0-9][0-9_]*)?[eE][+-]?[0-9_]+\\b` as `constant.numeric.float.mesh`
5. Regular float: `\\b[0-9][0-9_]*\\.[0-9][0-9_]*\\b` as `constant.numeric.float.mesh`
6. Integer: `\\b[0-9][0-9_]*\\b` as `constant.numeric.integer.mesh`

**Keywords repository:**
- **GRAM-01** Control flow: add `for`, `while`, `cond`, `break`, `continue` to keyword.control.mesh.
  New pattern: `\\b(if|else|case|match|when|do|end|return|from|import|for|while|cond|break|continue)\\b`
- **GRAM-02** Declaration: add `trait`, `alias` to keyword.declaration.mesh.
  New pattern: `\\b(fn|let|def|type|struct|module|interface|impl|pub|actor|service|supervisor|call|cast|trait|alias)\\b`
- **GRAM-03** Actor/supervision: add `monitor`, `terminate`, `trap`, `after` to keyword.operator.mesh.
  New pattern: `\\b(and|or|not|in|where|with|as|spawn|send|receive|self|link|monitor|terminate|trap|after)\\b`
- **GRAM-09** Constants: remove `nil` from constant.language.mesh.
  New pattern: `\\b(true|false)\\b`

**Operators repository (GRAM-04) -- add missing operators BEFORE existing ones:**
Add these rules before the existing operator rules:
1. `\\.\\.` as `keyword.operator.range.mesh` (range `..`)
2. `<>` as `keyword.operator.diamond.mesh` (diamond/concat)
3. `\\+\\+` as `keyword.operator.concat.mesh` (list concat) -- must come BEFORE arithmetic `\\+`
4. `=>` as `keyword.operator.arrow.fat.mesh` (fat arrow) -- must come BEFORE comparison
5. `\\?` as `keyword.operator.try.mesh` (try operator)
6. `&&` as `keyword.operator.logical.and.mesh` (logical and)
7. `\\|\\|` as `keyword.operator.logical.or.mesh` (logical or)

Keep existing pipe, arrow, annotation, comparison, arithmetic, assignment rules but ensure the new more-specific rules come BEFORE them.

**Top-level patterns -- add module-qualified calls (GRAM-08):**
Add a new repository section `module-calls` and include it in the top-level patterns BEFORE `types` (so it takes priority over generic uppercase type matching):
```json
{
  "match": "\\b([A-Z][a-zA-Z0-9_]*)(\\.)(\\w+)(?=\\s*\\()",
  "captures": {
    "1": { "name": "entity.name.type.module.mesh" },
    "2": { "name": "punctuation.accessor.mesh" },
    "3": { "name": "entity.name.function.mesh" }
  }
}
```
The `(?=\\s*\\()` lookahead ensures this only matches call patterns like `List.map(...)`, not field access like `point.x`.

**Top-level patterns order should be:**
1. comments
2. strings
3. numbers
4. module-calls (NEW -- before types to take priority)
5. keywords
6. types
7. operators
8. functions
9. variables
  </action>
  <verify>
Validate the JSON is syntactically valid: `python3 -c "import json; json.load(open('editors/vscode-mesh/syntaxes/mesh.tmLanguage.json'))"`.

Verify key patterns are present:
- `for|while|cond|break|continue` in keyword.control
- `trait|alias` in keyword.declaration
- `monitor|terminate|trap|after` in keyword.operator
- `true|false` in constant.language (NOT nil)
- `comment.line.documentation` scope exists
- `string.quoted.triple` scope exists
- `constant.numeric.hex` scope exists
- `0[xX]` pattern exists
- `entity.name.type.module` capture exists
  </verify>
  <done>
Grammar file contains patterns for all GRAM-01 through GRAM-09 requirements. JSON is valid. Rule ordering is correct (specific before general). nil is removed. GRAM-10 is satisfied by existing shared architecture (no separate work needed).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add doc comment styling to Shiki themes</name>
  <files>website/docs/.vitepress/theme/shiki/mesh-light.json, website/docs/.vitepress/theme/shiki/mesh-dark.json</files>
  <action>
Add dedicated doc comment styling entries to both Shiki theme files so doc comments are visually distinct from regular comments. Also add entries for the new operator scopes to ensure they pick up styling.

**mesh-light.json:**
Add a new tokenColors entry AFTER the existing "Comments" entry:
```json
{
  "name": "Doc Comments",
  "scope": ["comment.line.documentation", "comment.line.documentation.module"],
  "settings": {
    "foreground": "#7a9a6a",
    "fontStyle": ""
  }
}
```
This gives doc comments a slightly greener, bolder color compared to regular comments (#9baa90 italic), and removes italic to make them look distinct.

Add entries for new operator scopes to the existing "Operators" tokenColors:
Add these scopes to the existing operators scope array: `"keyword.operator.range"`, `"keyword.operator.diamond"`, `"keyword.operator.concat"`, `"keyword.operator.arrow.fat"`, `"keyword.operator.try"`, `"keyword.operator.logical"`.

**mesh-dark.json:**
Add a new tokenColors entry AFTER the existing "Comments" entry:
```json
{
  "name": "Doc Comments",
  "scope": ["comment.line.documentation", "comment.line.documentation.module"],
  "settings": {
    "foreground": "#8aaa7a",
    "fontStyle": ""
  }
}
```
Similarly brighter/greener than regular dark comments (#6b7b6b italic), non-italic.

Add the same new operator scopes to the dark theme's "Operators" scope array.

Validate both files are valid JSON after editing.
  </action>
  <verify>
Validate JSON: `python3 -c "import json; json.load(open('website/docs/.vitepress/theme/shiki/mesh-light.json'))"` and same for mesh-dark.json.

Verify "Doc Comments" entry exists in both files. Verify the foreground color differs from regular comments in both themes.
  </verify>
  <done>
Both Shiki themes have dedicated doc comment styling distinct from regular comments. New operator scopes are covered by theme rules. Website code blocks will render doc comments differently from regular comments.
  </done>
</task>

</tasks>

<verification>
- JSON validity of all 3 modified files (grammar + 2 themes)
- Grammar covers all GRAM-01 through GRAM-09 keyword/operator/literal patterns
- Rule ordering: doc comments before regular comments, triple-quote before single-quote, hex/binary before decimal
- nil removed from constants
- Module-qualified call pattern has lookahead for `(`
- Shiki themes have distinct doc comment colors
- GRAM-10 satisfied by architecture (grammar file is shared -- verify import path exists in config.mts)
</verification>

<success_criteria>
All 10 GRAM requirements satisfied. Grammar JSON valid. Themes updated. No regressions in existing highlighting.
</success_criteria>

<output>
After completion, create `.planning/phases/81-grammar-document-symbols/81-01-SUMMARY.md`
</output>
