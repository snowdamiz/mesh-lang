---
phase: "47-extended-collection-operations"
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/collections/list.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snowc/tests/e2e_stdlib.rs
  - tests/e2e/stdlib_list_zip.snow
  - tests/e2e/stdlib_list_flat_map.snow
  - tests/e2e/stdlib_list_enumerate.snow
  - tests/e2e/stdlib_list_take_drop.snow
autonomous: true

must_haves:
  truths:
    - "User can call List.zip(a, b) and get a list of 2-tuples truncated to shorter length"
    - "User can call List.flat_map(list, fn) where fn returns a list, and get a flattened result"
    - "User can call List.flatten(nested_list) and get a single flat list"
    - "User can call List.enumerate(list) and get a list of (index, element) tuples"
    - "User can call List.take(list, n) and get the first n elements"
    - "User can call List.drop(list, n) and get all elements after the first n"
  artifacts:
    - path: "crates/snow-rt/src/collections/list.rs"
      provides: "Runtime implementations for zip, flat_map, flatten, enumerate, take, drop + alloc_pair helper"
      contains: "snow_list_zip"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "List module type signatures for zip, flat_map, flatten, enumerate, take, drop"
      contains: "zip"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Flat env entries for list_zip, list_flat_map, etc."
      contains: "list_zip"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "MIR name mapping and known_functions for all 8 List ops"
      contains: "snow_list_zip"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM external declarations for all 8 List ops"
      contains: "snow_list_zip"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "matching type signatures for module-qualified and flat names"
      pattern: "list_zip|list_flat_map|list_flatten|list_enumerate|list_take|list_drop"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "map_builtin_name maps list_zip -> snow_list_zip which links to runtime"
      pattern: "snow_list_zip"
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "LLVM external linkage to #[no_mangle] runtime functions"
      pattern: "snow_list_zip"
---

<objective>
Implement all 8 List operations (zip, flat_map, flatten, enumerate, take, drop) across runtime, typeck, MIR, and codegen layers with e2e tests.

Purpose: Provides functional collection transformations for List (COLL-05, COLL-06, COLL-07, COLL-08), including the `alloc_pair` helper needed by Plan 02's Map.to_list.
Output: 8 working List stdlib functions with full e2e test coverage.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-extended-collection-operations/47-RESEARCH.md
@.planning/phases/46-core-collection-operations/46-01-SUMMARY.md
@.planning/phases/46-core-collection-operations/46-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement alloc_pair helper and 8 List runtime functions</name>
  <files>crates/snow-rt/src/collections/list.rs, crates/snow-rt/src/lib.rs</files>
  <action>
Add a `pub(crate)` alloc_pair helper and 8 new `#[no_mangle] pub extern "C"` functions to `crates/snow-rt/src/collections/list.rs`. Also add re-exports to `crates/snow-rt/src/lib.rs`.

**alloc_pair helper** (add after the existing `alloc_list_from` helper, around line 59):
```rust
/// Allocate a 2-element tuple on the GC heap matching Snow's tuple layout.
/// Layout: { u64 len=2, u64 elem0, u64 elem1 }
pub(crate) unsafe fn alloc_pair(a: u64, b: u64) -> *mut u8 {
    let total = 8 + 2 * 8; // len field + 2 elements
    let p = snow_gc_alloc_actor(total as u64, 8);
    *(p as *mut u64) = 2;           // len = 2
    *((p as *mut u64).add(1)) = a;  // first element
    *((p as *mut u64).add(2)) = b;  // second element
    p
}
```

**snow_list_zip(a, b) -> list of pairs:**
Iterate `min(len_a, len_b)` times, create `alloc_pair(*src_a.add(i), *src_b.add(i))` for each pair, store tuple pointers (cast as u64) in a result list built with `alloc_list` + direct write to `list_data_mut`.

**snow_list_flat_map(list, fn_ptr, env_ptr) -> flattened list:**
Follow the exact same BareFn/ClosureFn pattern from `snow_list_map` and `snow_list_sort`. For each element, call the closure to get a sub-list (the closure returns u64, cast to `*mut u8` to read as a list). Collect ALL sub-list elements into a `Vec<u64>`, then build the final result list from the Vec. The BareFn signature is `unsafe extern "C" fn(u64) -> u64` (element in, list-pointer-as-u64 out). The ClosureFn signature is `unsafe extern "C" fn(*mut u8, u64) -> u64`.

**snow_list_flatten(list) -> flattened list:**
Iterate the outer list. Each element is a list pointer stored as u64. Cast each to `*mut u8`, read its length and data, collect all inner elements into a `Vec<u64>`, then build result list from the Vec.

**snow_list_enumerate(list) -> list of (index, element) pairs:**
Iterate, create `alloc_pair(i as u64, *src.add(i))` for each element, store in result list.

**snow_list_take(list, n: i64) -> list:**
Compute `actual_n = (n.max(0) as u64).min(len)`. Return `alloc_list_from(list_data(list), actual_n, actual_n)`.

**snow_list_drop(list, n: i64) -> list:**
Compute `actual_n = (n.max(0) as u64).min(len)`. Compute `remaining = len - actual_n`. Return `alloc_list_from(list_data(list).add(actual_n as usize), remaining, remaining)`.

Add re-exports for all 8 new functions in `crates/snow-rt/src/lib.rs` following the existing pattern (grep for `snow_list_sort` to find the re-export block).

Verify with: `cargo build -p snow-rt`
  </action>
  <verify>Run `cargo build -p snow-rt` -- must compile with no errors.</verify>
  <done>All 8 new extern "C" functions compile. alloc_pair is pub(crate) and accessible from sibling modules.</done>
</task>

<task type="auto">
  <name>Task 2: Register List ops across typeck/MIR/codegen and add e2e tests</name>
  <files>crates/snow-typeck/src/infer.rs, crates/snow-typeck/src/builtins.rs, crates/snow-codegen/src/mir/lower.rs, crates/snow-codegen/src/codegen/intrinsics.rs, crates/snowc/tests/e2e_stdlib.rs, tests/e2e/stdlib_list_zip.snow, tests/e2e/stdlib_list_flat_map.snow, tests/e2e/stdlib_list_enumerate.snow, tests/e2e/stdlib_list_take_drop.snow</files>
  <action>
Register all 8 List functions across the 4 compiler layers, then add e2e tests. Follow the EXACT patterns from Phase 46 (see 46-01-SUMMARY.md and 46-02-SUMMARY.md).

**Layer 1 -- Typeck Module Map (infer.rs):**
Add to the List module section in `stdlib_modules()`, after the existing Phase 46 entries. Use the existing type variables `t_var=TyVar(91000)`, `u_var=TyVar(91001)`, `t`, `u`, `list_t`, `list_u` that are already defined in the List module block.

- `zip`: `fn(List<T>, List<U>) -> List<(T, U)>` -- vars: `[t_var, u_var]`, return `Ty::list(Ty::Tuple(vec![t.clone(), u.clone()]))`
- `flat_map`: `fn(List<T>, fn(T) -> List<U>) -> List<U>` -- vars: `[t_var, u_var]`, second arg is `Ty::fun(vec![t.clone()], list_u.clone())`
- `flatten`: `fn(List<List<T>>) -> List<T>` -- vars: `[t_var]`, arg is `Ty::list(list_t.clone())`
- `enumerate`: `fn(List<T>) -> List<(Int, T)>` -- vars: `[t_var]`, return `Ty::list(Ty::Tuple(vec![Ty::int(), t.clone()]))`
- `take`: `fn(List<T>, Int) -> List<T>` -- vars: `[t_var]`
- `drop`: `fn(List<T>, Int) -> List<T>` -- vars: `[t_var]`

**Layer 2 -- Typeck Flat Env (builtins.rs):**
Add matching entries: `list_zip`, `list_flat_map`, `list_flatten`, `list_enumerate`, `list_take`, `list_drop` with identical type signatures to Layer 1.

**Layer 3a -- MIR Name Mapping (lower.rs `map_builtin_name`):**
Add 8 entries:
```
"list_zip" => "snow_list_zip"
"list_flat_map" => "snow_list_flat_map"
"list_flatten" => "snow_list_flatten"
"list_enumerate" => "snow_list_enumerate"
"list_take" => "snow_list_take"
"list_drop" => "snow_list_drop"
```
Also add bare name mappings where appropriate (no bare names for take/drop to avoid keyword conflicts):
```
"zip" => "snow_list_zip"
"flat_map" => "snow_list_flat_map"
"flatten" => "snow_list_flatten"
"enumerate" => "snow_list_enumerate"
```

**Layer 3b -- MIR Known Functions (lower.rs `known_functions`):**
Add entries using correct MIR types:
- `snow_list_zip`: `FnPtr(vec![Ptr, Ptr], Ptr)` -- two lists in, list out
- `snow_list_flat_map`: `FnPtr(vec![Ptr, Ptr, Ptr], Ptr)` -- list + fn_ptr + env_ptr in, list out (closure split)
- `snow_list_flatten`: `FnPtr(vec![Ptr], Ptr)` -- list in, list out
- `snow_list_enumerate`: `FnPtr(vec![Ptr], Ptr)` -- list in, list out
- `snow_list_take`: `FnPtr(vec![Ptr, Int], Ptr)` -- list + int in, list out
- `snow_list_drop`: `FnPtr(vec![Ptr, Int], Ptr)` -- list + int in, list out

**Layer 4 -- LLVM Intrinsics (intrinsics.rs):**
Add 8 external function declarations:
- `snow_list_zip`: `ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false)`
- `snow_list_flat_map`: `ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false)`
- `snow_list_flatten`: `ptr_type.fn_type(&[ptr_type.into()], false)`
- `snow_list_enumerate`: `ptr_type.fn_type(&[ptr_type.into()], false)`
- `snow_list_take`: `ptr_type.fn_type(&[ptr_type.into(), i64_type.into()], false)`
- `snow_list_drop`: `ptr_type.fn_type(&[ptr_type.into(), i64_type.into()], false)`

**E2E Tests:**

Create 4 Snow fixture files and add corresponding test functions in `e2e_stdlib.rs`.

`tests/e2e/stdlib_list_zip.snow`:
```snow
fn main() do
  let a = [1, 2, 3]
  let b = [10, 20, 30]
  let zipped = List.zip(a, b)
  let first_pair = List.head(zipped)
  let t_first = Tuple.first(first_pair)
  let t_second = Tuple.second(first_pair)
  println("${t_first}")
  println("${t_second}")
  println("${List.length(zipped)}")

  let short = List.zip([1, 2], [10, 20, 30])
  println("${List.length(short)}")
end
```
Expected output: `1\n10\n3\n2`

`tests/e2e/stdlib_list_flat_map.snow`:
```snow
fn main() do
  let result = List.flat_map([1, 2, 3], fn(x) -> [x, x * 10] end)
  println("${List.length(result)}")
  println("${List.head(result)}")
  println("${List.nth(result, 1)}")
  println("${List.nth(result, 2)}")

  let flat = List.flatten([[1, 2], [3, 4], [5]])
  println("${List.length(flat)}")
  println("${List.head(flat)}")
  println("${List.last(flat)}")
end
```
Expected output: `6\n1\n10\n2\n5\n1\n5`

`tests/e2e/stdlib_list_enumerate.snow`:
```snow
fn main() do
  let pairs = List.enumerate(["a", "b", "c"])
  println("${List.length(pairs)}")
  let first_pair = List.head(pairs)
  let idx = Tuple.first(first_pair)
  let val = Tuple.second(first_pair)
  println("${idx}")
  println("${val}")
end
```
Expected output: `3\n0\na`

`tests/e2e/stdlib_list_take_drop.snow`:
```snow
fn main() do
  let xs = [10, 20, 30, 40, 50]
  let first3 = List.take(xs, 3)
  println("${List.length(first3)}")
  println("${List.head(first3)}")
  println("${List.last(first3)}")

  let last2 = List.drop(xs, 3)
  println("${List.length(last2)}")
  println("${List.head(last2)}")

  let over = List.take(xs, 100)
  println("${List.length(over)}")

  let drop_all = List.drop(xs, 100)
  println("${List.length(drop_all)}")
end
```
Expected output: `3\n10\n30\n2\n40\n5\n0`

Add 4 test functions in `e2e_stdlib.rs` following the existing pattern (compile_and_run with expected output assertion). IMPORTANT: run `touch crates/snow-rt/src/lib.rs && cargo build -p snow-rt` before running tests to ensure the staticlib is fresh (learned from Phase 46).

Use unique variable names across all case arms in Snow test code (learned from Phase 46 -- avoids LLVM alloca naming collision).

Verify with: `cargo test -p snowc --test e2e_stdlib -- stdlib_list_zip stdlib_list_flat_map stdlib_list_enumerate stdlib_list_take_drop`
  </action>
  <verify>Run `touch crates/snow-rt/src/lib.rs && cargo build -p snow-rt && cargo test -p snowc --test e2e_stdlib -- stdlib_list_zip stdlib_list_flat_map stdlib_list_enumerate stdlib_list_take_drop` -- all 4 tests pass.</verify>
  <done>All 8 List functions compile, link, and produce correct output. zip and enumerate return accessible tuples. flat_map/flatten handle nested lists. take/drop handle edge cases (n > length, n = 0).</done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles with no errors (runtime functions exist)
2. `cargo build -p snowc` compiles with no errors (all 4 layers registered)
3. All 4 new e2e tests pass with correct expected output
4. Full test suite shows no regressions: `cargo test -p snowc --test e2e_stdlib` (all ~70 tests pass)
</verification>

<success_criteria>
- List.zip([1,2,3], [10,20,30]) returns a 3-element list of tuples with accessible first/second elements
- List.flat_map with a closure that returns lists produces a correctly flattened result
- List.flatten([[1,2],[3,4]]) produces [1,2,3,4]
- List.enumerate(["a","b"]) returns [(0,"a"),(1,"b")] with correct tuple access
- List.take([1,2,3,4,5], 3) returns [1,2,3]
- List.drop([1,2,3,4,5], 3) returns [4,5]
- Edge cases: zip truncates to shorter, take/drop with n > length, take/drop with n = 0
</success_criteria>

<output>
After completion, create `.planning/phases/47-extended-collection-operations/47-01-SUMMARY.md`
</output>
