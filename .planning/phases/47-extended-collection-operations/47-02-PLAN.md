---
phase: "47-extended-collection-operations"
plan: "02"
type: execute
wave: 2
depends_on: ["47-01"]
files_modified:
  - crates/snow-rt/src/collections/map.rs
  - crates/snow-rt/src/collections/set.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snowc/tests/e2e_stdlib.rs
  - tests/e2e/stdlib_map_conversions.snow
  - tests/e2e/stdlib_set_conversions.snow
autonomous: true

must_haves:
  truths:
    - "User can call Map.merge(a, b) and get a combined map where b's entries overwrite a's duplicates"
    - "User can call Map.to_list(map) and get a list of (key, value) tuples"
    - "User can call Map.from_list(list_of_tuples) and get a map"
    - "User can call Set.difference(a, b) and get elements in a not in b"
    - "User can call Set.to_list(set) and get a List<Int>"
    - "User can call Set.from_list(list) and get a Set with duplicates removed"
  artifacts:
    - path: "crates/snow-rt/src/collections/map.rs"
      provides: "Runtime implementations for merge, to_list, from_list"
      contains: "snow_map_merge"
    - path: "crates/snow-rt/src/collections/set.rs"
      provides: "Runtime implementations for difference, to_list, from_list"
      contains: "snow_set_difference"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Map and Set module type signatures"
      contains: "merge"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Flat env entries for map_merge, set_difference, etc."
      contains: "map_merge"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "MIR name mapping and known_functions for all 6 Map/Set ops"
      contains: "snow_map_merge"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM external declarations for all 6 Map/Set ops"
      contains: "snow_map_merge"
  key_links:
    - from: "crates/snow-rt/src/collections/map.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "imports alloc_pair for Map.to_list tuple creation"
      pattern: "super::list::alloc_pair"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/collections/map.rs"
      via: "map_builtin_name maps map_merge -> snow_map_merge which links to runtime"
      pattern: "snow_map_merge"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/collections/set.rs"
      via: "map_builtin_name maps set_difference -> snow_set_difference which links to runtime"
      pattern: "snow_set_difference"
---

<objective>
Implement 6 Map/Set conversion operations (Map.merge, Map.to_list, Map.from_list, Set.difference, Set.to_list, Set.from_list) across runtime, typeck, MIR, and codegen layers with e2e tests.

Purpose: Enables bidirectional conversion between Map/Set and List types (COLL-11, COLL-12), completing the full collection transformation suite.
Output: 6 working Map/Set stdlib functions with full e2e test coverage.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-extended-collection-operations/47-RESEARCH.md
@.planning/phases/47-extended-collection-operations/47-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 6 Map and Set runtime functions</name>
  <files>crates/snow-rt/src/collections/map.rs, crates/snow-rt/src/collections/set.rs, crates/snow-rt/src/lib.rs</files>
  <action>
Add 3 new `#[no_mangle] pub extern "C"` functions to `map.rs`, 3 to `set.rs`, and re-exports to `lib.rs`.

**Map functions (map.rs):**

Import alloc_pair from list module: `use super::list::alloc_pair;`
Also import list builder: reference via `super::list::snow_list_builder_new` and `super::list::snow_list_builder_push` (they are already `pub extern "C"` so accessible).

**snow_map_merge(a, b) -> merged map:**
1. Get `a_len`, `b_len`, `kt = map_key_type(a)`
2. Allocate result with `alloc_map(a_len + b_len, kt)`
3. Copy all entries from `a` into result: set result len = a_len, copy `a_len * ENTRY_SIZE` bytes from `map_entries(a)` to `map_entries_mut(result)` using `ptr::copy_nonoverlapping`
4. Iterate `b`'s entries: for each, call `snow_map_put(result, key, val)` which handles both insert and overwrite
5. Note: `snow_map_put` may reallocate, so reassign `result = snow_map_put(result, key, val)` in the loop

**snow_map_to_list(map) -> list of (key, value) tuples:**
1. Get `len = map_len(map)`, `entries = map_entries(map)`
2. Create list: `let list = super::list::snow_list_builder_new(len as i64)`
3. For each entry `i in 0..len`: read `key = (*entries.add(i))[0]`, `val = (*entries.add(i))[1]`
4. Create tuple: `let pair = alloc_pair(key, val)` (imported from super::list)
5. Push: `super::list::snow_list_builder_push(list, pair as u64)`
6. Return list

**snow_map_from_list(list) -> map:**
1. Get `len = super::list::snow_list_length(list)` (list is *mut u8 but snow_list_length takes *mut u8)
2. Create map: `let mut map = snow_map_new()`
3. Get list data pointer: `let data = (list as *const u64).add(2)` (skip len + cap header)
4. For each element `i in 0..len as usize`: read `tuple_ptr = *data.add(i) as *mut u8`
5. Extract key: `*((tuple_ptr as *const u64).add(1))` (offset 1 = first tuple element, offset 0 = tuple len)
6. Extract val: `*((tuple_ptr as *const u64).add(2))` (offset 2 = second tuple element)
7. Put: `map = snow_map_put(map, key, val)`
8. Return map
9. NOTE: Map.from_list defaults to KEY_TYPE_INT (0) since runtime cannot detect key type. This is acceptable per research decision.

**Set functions (set.rs):**

**snow_set_difference(a, b) -> set:**
1. Get `a_len = set_len(a)`, `a_data = set_data(a)`
2. Allocate result: `alloc_set(a_len)` with same capacity as a
3. Get `dst = set_data_mut(result)`
4. Iterate a: for each element, check `if !contains_elem(b, elem)` then write to dst and increment count
5. Set result length: `*(result as *mut u64) = count as u64`
6. Return result

**snow_set_to_list(set) -> list:**
1. Get `len = set_len(set)`, `src = set_data(set)`
2. Create list: `let list = super::list::snow_list_builder_new(len as i64)`
3. For each element: `super::list::snow_list_builder_push(list, *src.add(i))`
4. Return list
5. NOTE: Add `use super::list;` or reference via full path. Set module doesn't currently import from list, so add the cross-reference.

**snow_set_from_list(list) -> set:**
1. Get `len = super::list::snow_list_length(list)`
2. Get list data: `let data = (list as *const u64).add(2)` (skip header)
3. Create set: `let mut set = snow_set_new()`
4. For each element: `set = snow_set_add(set, *data.add(i))` -- snow_set_add handles deduplication
5. Return set

Add re-exports for all 6 new functions in `crates/snow-rt/src/lib.rs` following existing map/set re-export patterns.

Verify with: `cargo build -p snow-rt`
  </action>
  <verify>Run `cargo build -p snow-rt` -- must compile with no errors.</verify>
  <done>All 6 new Map/Set extern "C" functions compile. Map.to_list correctly uses alloc_pair from list module. Set functions correctly cross-reference list builder.</done>
</task>

<task type="auto">
  <name>Task 2: Register Map/Set ops across typeck/MIR/codegen and add e2e tests</name>
  <files>crates/snow-typeck/src/infer.rs, crates/snow-typeck/src/builtins.rs, crates/snow-codegen/src/mir/lower.rs, crates/snow-codegen/src/codegen/intrinsics.rs, crates/snowc/tests/e2e_stdlib.rs, tests/e2e/stdlib_map_conversions.snow, tests/e2e/stdlib_set_conversions.snow</files>
  <action>
Register all 6 Map/Set functions across the 4 compiler layers, then add e2e tests. Follow the EXACT patterns from Plan 01 and Phase 46.

**Layer 1 -- Typeck Module Map (infer.rs):**

Map module additions (after existing Map entries). Use existing type variables `k_var=TyVar(90000)`, `v_var=TyVar(90001)`, `k`, `v`, `map_kv`:
- `merge`: `fn(Map<K,V>, Map<K,V>) -> Map<K,V>` -- vars: `[k_var, v_var]`
- `to_list`: `fn(Map<K,V>) -> List<(K,V)>` -- vars: `[k_var, v_var]`, return `Ty::list(Ty::Tuple(vec![k.clone(), v.clone()]))`
- `from_list`: `fn(List<(K,V)>) -> Map<K,V>` -- vars: `[k_var, v_var]`, arg `Ty::list(Ty::Tuple(vec![k.clone(), v.clone()]))`

Set module additions (after existing Set entries). Set is monomorphic (`set_t = Ty::set_untyped()`):
- `difference`: `fn(Set, Set) -> Set` -- `Scheme::mono(...)`
- `to_list`: `fn(Set) -> List<Int>` -- `Scheme::mono(...)`, return `Ty::list(Ty::int())`
- `from_list`: `fn(List<Int>) -> Set` -- `Scheme::mono(...)`, arg `Ty::list(Ty::int())`

**Layer 2 -- Typeck Flat Env (builtins.rs):**
Add matching entries: `map_merge`, `map_to_list`, `map_from_list`, `set_difference`, `set_to_list`, `set_from_list`.

**Layer 3a -- MIR Name Mapping (lower.rs `map_builtin_name`):**
```
"map_merge" => "snow_map_merge"
"map_to_list" => "snow_map_to_list"
"map_from_list" => "snow_map_from_list"
"set_difference" => "snow_set_difference"
"set_to_list" => "snow_set_to_list"
"set_from_list" => "snow_set_from_list"
```
Also add bare name mappings:
```
"merge" => "snow_map_merge"
"difference" => "snow_set_difference"
```
Do NOT add bare name mappings for `to_list` and `from_list` (shared name across Map and Set would collide).

**Layer 3b -- MIR Known Functions (lower.rs `known_functions`):**
All Map/Set functions use Ptr types only (no Int args):
- `snow_map_merge`: `FnPtr(vec![Ptr, Ptr], Ptr)`
- `snow_map_to_list`: `FnPtr(vec![Ptr], Ptr)`
- `snow_map_from_list`: `FnPtr(vec![Ptr], Ptr)`
- `snow_set_difference`: `FnPtr(vec![Ptr, Ptr], Ptr)`
- `snow_set_to_list`: `FnPtr(vec![Ptr], Ptr)`
- `snow_set_from_list`: `FnPtr(vec![Ptr], Ptr)`

**Layer 4 -- LLVM Intrinsics (intrinsics.rs):**
All 6 functions use only ptr_type parameters:
- `snow_map_merge`: `ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false)`
- `snow_map_to_list`: `ptr_type.fn_type(&[ptr_type.into()], false)`
- `snow_map_from_list`: `ptr_type.fn_type(&[ptr_type.into()], false)`
- `snow_set_difference`: `ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false)`
- `snow_set_to_list`: `ptr_type.fn_type(&[ptr_type.into()], false)`
- `snow_set_from_list`: `ptr_type.fn_type(&[ptr_type.into()], false)`

**E2E Tests:**

Create 2 Snow fixture files and add corresponding test functions in `e2e_stdlib.rs`.

`tests/e2e/stdlib_map_conversions.snow`:
```snow
fn main() do
  let m1 = Map.put(Map.put(Map.new(), 1, 10), 2, 20)
  let m2 = Map.put(Map.put(Map.new(), 2, 200), 3, 30)
  let merged = Map.merge(m1, m2)
  println("${Map.size(merged)}")
  println("${Map.get(merged, 1)}")
  println("${Map.get(merged, 2)}")
  println("${Map.get(merged, 3)}")

  let as_list = Map.to_list(m1)
  println("${List.length(as_list)}")

  let rebuilt = Map.from_list(as_list)
  println("${Map.size(rebuilt)}")
  println("${Map.get(rebuilt, 1)}")
  println("${Map.get(rebuilt, 2)}")
end
```
Expected output: `3\n10\n200\n30\n2\n2\n10\n20`

`tests/e2e/stdlib_set_conversions.snow`:
```snow
fn main() do
  let s1 = Set.add(Set.add(Set.add(Set.new(), 1), 2), 3)
  let s2 = Set.add(Set.add(Set.new(), 2), 3)
  let diff = Set.difference(s1, s2)
  println("${Set.size(diff)}")
  println("${Set.contains(diff, 1)}")
  println("${Set.contains(diff, 2)}")

  let as_list = Set.to_list(s1)
  println("${List.length(as_list)}")

  let from = Set.from_list([1, 2, 2, 3, 3, 3])
  println("${Set.size(from)}")
  println("${Set.contains(from, 1)}")
  println("${Set.contains(from, 3)}")
end
```
Expected output: `1\ntrue\nfalse\n3\n3\ntrue\ntrue`

Add 2 test functions in `e2e_stdlib.rs`. IMPORTANT: run `touch crates/snow-rt/src/lib.rs && cargo build -p snow-rt` before running tests.

Use unique variable names across case arms (learned from Phase 46).

Verify with: `cargo test -p snowc --test e2e_stdlib -- stdlib_map_conversions stdlib_set_conversions`
  </action>
  <verify>Run `touch crates/snow-rt/src/lib.rs && cargo build -p snow-rt && cargo test -p snowc --test e2e_stdlib -- stdlib_map_conversions stdlib_set_conversions` -- both tests pass.</verify>
  <done>All 6 Map/Set functions compile, link, and produce correct output. Map.merge correctly overwrites duplicates. Map.to_list returns accessible tuples. Map.from_list reads tuples correctly. Set.difference filters correctly. Set.from_list deduplicates. Set.to_list converts to List<Int>.</done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles with no errors (all 6 Map/Set runtime functions exist)
2. `cargo build -p snowc` compiles with no errors (all 4 layers registered)
3. Both new e2e tests pass with correct expected output
4. Full test suite shows no regressions: `cargo test -p snowc --test e2e_stdlib` (all ~74 tests pass)
</verification>

<success_criteria>
- Map.merge combines two maps, with second map's values winning on key collisions
- Map.to_list returns a list of 2-tuples with correct key/value access
- Map.from_list builds a map from a list of 2-tuples
- Set.difference returns elements in first set not in second
- Set.to_list returns a List<Int> with correct length
- Set.from_list creates a Set with duplicate removal (size 3 from [1,2,2,3,3,3])
</success_criteria>

<output>
After completion, create `.planning/phases/47-extended-collection-operations/47-02-SUMMARY.md`
</output>
