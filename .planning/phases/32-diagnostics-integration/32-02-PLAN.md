---
phase: 32-diagnostics-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snowc/tests/e2e.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "Struct field access (point.x) works in the same program as method dot-syntax (point.to_string())"
    - "Module-qualified calls (String.length(s)) work alongside method dot-syntax (s.length())"
    - "Pipe operator (value |> fn) works in the same program as method dot-syntax"
    - "Sum type variant access (Shape.Circle) works in the same program as method dot-syntax"
    - "Actor self in receive blocks is unaffected by method dot-syntax on local variables"
    - "MIR resolve_trait_callee picks traits deterministically (defense-in-depth sort)"
  artifacts:
    - path: "crates/snowc/tests/e2e.rs"
      provides: "Integration e2e tests for INTG-01 through INTG-05"
      contains: "e2e_phase32"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Defense-in-depth sort in resolve_trait_callee"
      contains: "matching_traits.sort()"
  key_links:
    - from: "crates/snowc/tests/e2e.rs"
      to: "compile_and_run"
      via: "Each INTG test compiles Snow source and asserts stdout"
      pattern: "compile_and_run.*assert"
---

<objective>
Write integration e2e tests proving all existing syntax forms (struct field access, module-qualified calls, pipe operator, sum type variant access, actor self) work unchanged alongside method dot-syntax (INTG-01 through INTG-05), and add defense-in-depth sort in MIR `resolve_trait_callee`.

Purpose: Phase 32 success criteria require that all five integration points "continue to work exactly as before" and that the existing test suite passes with zero regressions. These tests document the v1.6 guarantee by explicitly combining traditional syntax with method dot-syntax in the same programs.

Output: 5 e2e integration tests (one per INTG requirement) and deterministic MIR trait selection.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-diagnostics-integration/32-RESEARCH.md
@.planning/phases/31-extended-method-support/31-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add defense-in-depth sort in MIR resolve_trait_callee</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
In `resolve_trait_callee` (line ~3385), after `find_method_traits` returns but before accessing `matching_traits[0]` (line ~3387), add a sort for defense-in-depth:

```rust
let mut matching_traits = self.trait_registry.find_method_traits(name, &ty_for_lookup);
matching_traits.sort();  // Defense-in-depth: deterministic trait selection
if !matching_traits.is_empty() {
    let trait_name = &matching_traits[0];
    ...
```

Note: The type checker already catches ambiguity before MIR runs, and Plan 01 sorts inside `find_method_traits` itself. This sort is defense-in-depth -- if ambiguity somehow reaches MIR, `matching_traits[0]` will consistently pick the alphabetically-first trait rather than a random one.

The change is minimal: make `matching_traits` mutable and add `.sort()` before the `.is_empty()` check.
  </action>
  <verify>
Run `cargo test -p snow-codegen` -- all MIR tests must pass.

Run `cargo build --workspace` -- full workspace must compile.
  </verify>
  <done>
`resolve_trait_callee` sorts `matching_traits` before selecting `[0]`, ensuring deterministic MIR output regardless of HashMap iteration order.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write e2e integration tests for INTG-01 through INTG-05</name>
  <files>
    crates/snowc/tests/e2e.rs
  </files>
  <action>
Add 5 new compile-and-run e2e tests at the end of the file. Each test combines the traditional syntax form WITH method dot-syntax in the SAME program to prove both coexist.

**INTG-01: Struct field access preserved**
```rust
#[test]
fn e2e_phase32_struct_field_access_preserved() {
    let source = r#"
struct Point do
  x :: Int
  y :: Int
end deriving(Display)

fn main() do
  let p = Point { x: 42, y: 99 }
  println("${p.x}")
  println("${p.y}")
  println(p.to_string())
end
"#;
    let output = compile_and_run(source);
    assert_eq!(output, "42\n99\nPoint(42, 99)\n");
}
```

This test explicitly accesses struct fields (`p.x`, `p.y`) AND calls a method (`p.to_string()`) on the same struct value. If the method resolution guard chain incorrectly intercepts field access, `p.x` would fail.

**INTG-02: Module-qualified calls preserved**
```rust
#[test]
fn e2e_phase32_module_qualified_preserved() {
    let source = r#"
fn main() do
  let s = "hello"
  let len = String.length(s)
  println("${len}")
  println("${String.length("world")}")
end
"#;
    let output = compile_and_run(source);
    assert_eq!(output, "5\n5\n");
}
```

This test uses module-qualified `String.length(s)` syntax. If method resolution incorrectly intercepts `String.length` as a method call on `String`, it would fail.

**INTG-03: Pipe operator preserved**
```rust
#[test]
fn e2e_phase32_pipe_operator_preserved() {
    let source = r#"
fn double(x :: Int) -> Int do
  x * 2
end

fn add_ten(x :: Int) -> Int do
  x + 10
end

fn main() do
  let result = 5 |> double |> add_ten
  println("${result}")
end
"#;
    let output = compile_and_run(source);
    assert_eq!(output.trim(), "20");
}
```

This test uses the pipe operator to chain function calls. The pipe desugars in `lower_pipe_expr` (not `lower_call_expr`), so it should not be affected by method interception, but this test proves it.

**INTG-04: Sum type variant access preserved**
```rust
#[test]
fn e2e_phase32_sum_type_variant_preserved() {
    let source = r#"
type Shape do
  Circle(Int)
  Square(Int)
end

fn area(s :: Shape) -> Int do
  match s do
    Shape.Circle(r) -> r * r * 3
    Shape.Square(side) -> side * side
  end
end

fn main() do
  let c = Shape.Circle(10)
  let sq = Shape.Square(5)
  println("${area(c)}")
  println("${area(sq)}")
end
"#;
    let output = compile_and_run(source);
    assert_eq!(output, "300\n25\n");
}
```

This test uses `Shape.Circle` and `Shape.Square` variant constructors. The guard chain checks sum type names before method resolution, so these should not be intercepted.

**INTG-05: Actor self in receive blocks**
```rust
#[test]
fn e2e_phase32_actor_self_preserved() {
    let source = r#"
actor counter(initial :: Int) :: Int do
  let count = initial
  receive do
    n ->
      let new_count = count + n
      counter(new_count)
  end
end

fn main() do
  let pid = spawn(counter(0))
  send(pid, 1)
  IO.sleep(50)
  println("ok")
end
"#;
    let output = compile_and_run(source);
    assert!(output.contains("ok"));
}
```

This test spawns an actor with a receive block. Inside receive blocks, `self` refers to the actor's PID (handled by `infer_self` / `ACTOR_MSG_TYPE_KEY`). This test verifies that actor self-reference is unaffected by method dot-syntax. The test does not call methods on `self` because actor PID types don't have trait impls -- it simply proves that the actor mechanism still works alongside method dot-syntax infrastructure.

**Naming convention:** All tests use `e2e_phase32_` prefix to clearly identify them as Phase 32 integration tests.

**Important e2e test constraints (from Phase 30/31 lessons):**
- Use `println()` (bare name), not `IO.println()`
- Use `deriving(Display)` for trait impls, not manual `interface + impl` blocks
- Use string interpolation `"${expr}"` for type conversion
- Actor tests need `IO.sleep()` for timing
  </action>
  <verify>
Run `cargo test -p snowc e2e_phase32` -- all 5 new tests must compile, run, and pass.

Run `cargo test --workspace` -- full suite must pass with zero regressions.

Verify each test name maps to its INTG requirement:
- `e2e_phase32_struct_field_access_preserved` -> INTG-01
- `e2e_phase32_module_qualified_preserved` -> INTG-02
- `e2e_phase32_pipe_operator_preserved` -> INTG-03
- `e2e_phase32_sum_type_variant_preserved` -> INTG-04
- `e2e_phase32_actor_self_preserved` -> INTG-05
  </verify>
  <done>
5 e2e integration tests pass, each combining traditional syntax with method dot-syntax infrastructure to prove zero regression. Each test maps to one INTG requirement. Full workspace test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` compiles with zero errors
2. `cargo test --workspace` passes all tests (existing + new) with zero regressions
3. Each INTG requirement (01-05) has a corresponding passing e2e test
4. MIR `resolve_trait_callee` sorts `matching_traits` before selection
5. All 5 e2e tests use `compile_and_run` to prove end-to-end correctness
</verification>

<success_criteria>
- INTG-01: Struct field access works alongside method dot-syntax (e2e test passes)
- INTG-02: Module-qualified calls work alongside method dot-syntax (e2e test passes)
- INTG-03: Pipe operator works alongside method dot-syntax (e2e test passes)
- INTG-04: Sum type variant access works alongside method dot-syntax (e2e test passes)
- INTG-05: Actor self in receive blocks unaffected by method dot-syntax (e2e test passes)
- Existing test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/32-diagnostics-integration/32-02-SUMMARY.md`
</output>
