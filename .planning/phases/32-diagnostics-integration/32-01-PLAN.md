---
phase: 32-diagnostics-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/traits.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-lsp/src/analysis.rs
  - crates/snow-typeck/tests/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "find_method_traits returns trait names in alphabetical order regardless of HashMap insertion order"
    - "AmbiguousMethod error points at the specific method call site, not the entire file"
    - "AmbiguousMethod help text lists each candidate trait's qualified syntax (e.g., Display.to_string(value) or Printable.to_string(value))"
    - "All existing tests pass with zero regressions after adding span field to AmbiguousMethod"
  artifacts:
    - path: "crates/snow-typeck/src/traits.rs"
      provides: "Sorted find_method_traits output"
      contains: "trait_names.sort()"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "AmbiguousMethod with span field"
      contains: "span: TextRange"
    - path: "crates/snow-typeck/tests/diagnostics.rs"
      provides: "Diagnostic snapshot tests for AmbiguousMethod"
      contains: "test_diag_ambiguous_method"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "TypeError::AmbiguousMethod"
      via: "fa.syntax().text_range() passed as span"
      pattern: "span: fa\\.syntax\\(\\)\\.text_range\\(\\)"
    - from: "crates/snow-typeck/src/diagnostics.rs"
      to: "TypeError::AmbiguousMethod"
      via: "Uses actual span for label positioning"
      pattern: "clamp.*text_range_to_range.*span"
    - from: "crates/snow-lsp/src/analysis.rs"
      to: "TypeError::AmbiguousMethod"
      via: "Returns Some(*span) instead of None"
      pattern: "AmbiguousMethod.*Some.*span"
---

<objective>
Fix ambiguous method diagnostics: sort `find_method_traits` for deterministic ordering (DIAG-03), add `span: TextRange` to `AmbiguousMethod` for precise error location (DIAG-02), improve help text to list specific qualified syntax per candidate trait (DIAG-02), and add diagnostic snapshot tests.

Purpose: The final v1.6 phase requires polished diagnostics when multiple traits provide the same method for a type. Currently the candidate list is nondeterministic (FxHashMap iteration order), the error highlights the entire file (no span), and the help text uses a generic placeholder instead of listing actual trait names.

Output: Deterministic, precisely-located ambiguity errors with actionable suggestions; diagnostic snapshot tests proving correctness.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-diagnostics-integration/32-RESEARCH.md
@.planning/phases/30-core-method-resolution/30-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sort find_method_traits, add span to AmbiguousMethod, improve help text</name>
  <files>
    crates/snow-typeck/src/traits.rs
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/diagnostics.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-lsp/src/analysis.rs
  </files>
  <action>
All changes must be done in a single commit since the `AmbiguousMethod` struct change is breaking.

**1. Sort find_method_traits output (traits.rs line ~286)**

In `TraitRegistry::find_method_traits`, add `trait_names.sort();` immediately before the `trait_names` return on line 286. This ensures ALL callers get deterministic alphabetical ordering regardless of FxHashMap iteration order.

**2. Add span field to AmbiguousMethod (error.rs line ~235)**

Add `span: TextRange` field to the `AmbiguousMethod` variant:
```rust
AmbiguousMethod {
    method_name: String,
    candidate_traits: Vec<String>,
    ty: Ty,
    span: TextRange,  // NEW
},
```

Update the `Display` impl (line ~492) to include `span` in the destructuring pattern but do NOT include span in the formatted output (follows existing conventions -- no other Display impls include span info):
```rust
TypeError::AmbiguousMethod {
    method_name,
    candidate_traits,
    ty,
    span: _,  // Not shown in Display
} => { ... }
```

**3. Update AmbiguousMethod construction sites (infer.rs)**

Both construction sites (lines ~4069 and ~4105) need `span: fa.syntax().text_range()` added. The `fa` variable (FieldAccess node) is already in scope at both locations.

Site 1 (inside struct field loop, line ~4069):
```rust
let err = TypeError::AmbiguousMethod {
    method_name: field_name.clone(),
    candidate_traits: matching_traits,
    ty: resolved_base.clone(),
    span: fa.syntax().text_range(),
};
```

Site 2 (non-struct type fallback, line ~4105):
```rust
let err = TypeError::AmbiguousMethod {
    method_name: field_name.clone(),
    candidate_traits: matching_traits,
    ty: resolved_base.clone(),
    span: fa.syntax().text_range(),
};
```

**4. Update diagnostic rendering (diagnostics.rs line ~1310)**

Update the `AmbiguousMethod` rendering to:
- Destructure the new `span` field
- Use `clamp(text_range_to_range(*span))` instead of `clamp(0..source_len.max(1).min(source_len))`
- Build help text that lists each candidate trait's qualified syntax: `"use qualified syntax: Display.to_string(value) or Printable.to_string(value)"`

```rust
TypeError::AmbiguousMethod {
    method_name,
    candidate_traits,
    ty,
    span,
} => {
    let msg = format!(
        "ambiguous method `{}` for type `{}`: candidates from traits [{}]",
        method_name, ty, candidate_traits.join(", ")
    );
    let range = clamp(text_range_to_range(*span));

    let suggestions: Vec<String> = candidate_traits
        .iter()
        .map(|t| format!("{}.{}(value)", t, method_name))
        .collect();
    let help = format!("use qualified syntax: {}", suggestions.join(" or "));

    Report::build(ReportKind::Error, range.clone())
        .with_code(code)
        .with_message(&msg)
        .with_config(config)
        .with_label(
            Label::new(range)
                .with_message(format!("multiple traits provide `{}`", method_name))
                .with_color(Color::Red),
        )
        .with_help(help)
        .finish()
}
```

**5. Update JSON rendering catch-all (diagnostics.rs line ~485)**

The `AmbiguousMethod` currently falls through to the `_ =>` catch-all arm that uses `0..source_len`. Add it to the span-bearing match arm group (line ~464) so JSON diagnostics also get precise spans:

Add `| TypeError::AmbiguousMethod { span, .. }` to the chain at line ~467 (after `NoSuchMethod`).

**6. Update LSP span extraction (analysis.rs line ~202)**

Change `TypeError::AmbiguousMethod { .. } => None,` to:
```rust
TypeError::AmbiguousMethod { span, .. } => Some(*span),
```

**7. Update existing unit test in traits.rs**

The `find_method_traits_multiple` test (line ~710) creates Displayable and Printable traits. After sorting, the returned order should be `["Displayable", "Printable"]` (alphabetical). Verify the test assertion matches this order. If the test was asserting a specific order that was HashMap-dependent, update it to expect alphabetical order.
  </action>
  <verify>
Run `cargo test -p snow-typeck -p snow-lsp` -- all tests must pass with zero regressions. The `find_method_traits_multiple` test should now consistently return traits in alphabetical order.

Run `cargo build --workspace` -- full workspace must compile (verifies all match arms updated).
  </verify>
  <done>
AmbiguousMethod variant has span field, find_method_traits returns sorted Vec, diagnostic rendering uses actual span and lists specific qualified syntax per trait, LSP returns span, JSON rendering uses span, all existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add diagnostic snapshot tests for AmbiguousMethod</name>
  <files>
    crates/snow-typeck/tests/diagnostics.rs
  </files>
  <action>
Add diagnostic snapshot tests using Pattern A (constructed TypeError) since ambiguity requires registering multiple traits for the same type, which is not easily triggered via standard Snow source.

**Test 1: test_diag_ambiguous_method_deterministic_order**

Construct an `AmbiguousMethod` error with candidate_traits in NON-alphabetical order (e.g., `["Printable", "Displayable"]`) and verify the rendered output shows them in alphabetical order. Note: Since `find_method_traits` now sorts, in practice the candidates will arrive sorted. But this test verifies the diagnostic renders whatever order it receives. The real determinism guarantee is tested by the unit test in `traits.rs`.

```rust
#[test]
fn test_diag_ambiguous_method_deterministic_order() {
    use snow_typeck::ty::Ty;
    use rowan::TextRange;

    let src = "x.to_string()";
    let err = TypeError::AmbiguousMethod {
        method_name: "to_string".to_string(),
        candidate_traits: vec!["Displayable".to_string(), "Printable".to_string()],
        ty: Ty::int(),
        span: TextRange::new(0.into(), 13.into()),
    };
    let output = render_diagnostic(&err, src, "test.snow", &opts(), None);
    insta::assert_snapshot!(output);
}
```

**Test 2: test_diag_ambiguous_method_help_text**

Construct an `AmbiguousMethod` with two candidate traits and verify the help text lists BOTH qualified syntax suggestions (e.g., `Display.to_string(value) or Printable.to_string(value)`).

```rust
#[test]
fn test_diag_ambiguous_method_help_text() {
    use snow_typeck::ty::Ty;
    use rowan::TextRange;

    let src = "point.to_string()";
    let err = TypeError::AmbiguousMethod {
        method_name: "to_string".to_string(),
        candidate_traits: vec!["Display".to_string(), "Printable".to_string()],
        ty: Ty::Con("Point".to_string()),
        span: TextRange::new(0.into(), 17.into()),
    };
    let output = render_diagnostic(&err, src, "test.snow", &opts(), None);
    insta::assert_snapshot!(output);
}
```

Both tests use `insta::assert_snapshot!` for deterministic output verification. On first run, accept the snapshots with `cargo insta accept` (or `cargo insta review`).

Note: Import `rowan::TextRange` and `snow_typeck::ty::Ty` at the top of each test function (or in a use block). Check existing test patterns for how `Ty` constructors are accessed -- may need `Ty::int()` or `Ty::Con(...)`.
  </action>
  <verify>
Run `cargo test -p snow-typeck test_diag_ambiguous` -- both new tests must pass.

Run `cargo insta test -p snow-typeck` -- snapshots must be accepted and committed.

Verify snapshot files exist in `crates/snow-typeck/tests/snapshots/` with correct content showing:
1. Alphabetically-ordered trait names in the error message
2. Help text listing specific qualified syntax per trait
3. Error label pointing at the actual span (not 0..source_len)
  </verify>
  <done>
Two diagnostic snapshot tests exist and pass, proving AmbiguousMethod renders with deterministic trait ordering, precise source span highlighting, and actionable qualified syntax suggestions per trait.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` compiles with zero errors
2. `cargo test --workspace` passes all tests (existing + new) with zero regressions
3. `find_method_traits_multiple` unit test in traits.rs returns sorted trait names
4. Diagnostic snapshots show alphabetical trait ordering and per-trait qualified syntax help
5. AmbiguousMethod span points at the method call site, not the entire file
</verification>

<success_criteria>
- DIAG-02: AmbiguousMethod error lists conflicting traits and suggests qualified syntax per trait (e.g., `Display.to_string(value) or Printable.to_string(value)`)
- DIAG-03: Trait names in ambiguity errors are deterministically alphabetically ordered
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/32-diagnostics-integration/32-01-SUMMARY.md`
</output>
