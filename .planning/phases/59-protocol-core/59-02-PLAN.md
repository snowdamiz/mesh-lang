---
phase: 59-protocol-core
plan: 02
type: execute
wave: 2
depends_on: ["59-01"]
files_modified:
  - crates/snow-rt/src/ws/handshake.rs
  - crates/snow-rt/src/ws/close.rs
  - crates/snow-rt/src/ws/mod.rs
autonomous: true

must_haves:
  truths:
    - "A valid WebSocket upgrade request receives a 101 Switching Protocols response with correct Sec-WebSocket-Accept header"
    - "A malformed upgrade request (missing headers, wrong method, wrong version) receives HTTP 400"
    - "Text frames are validated as UTF-8; invalid UTF-8 triggers close code 1007"
    - "A close frame from the client is echoed back and the connection terminates cleanly"
    - "A server-initiated close sends the close frame and waits for the client echo"
    - "Unknown opcodes trigger a close with code 1002 (protocol error)"
    - "Close frame payloads are parsed into status code + reason correctly"
  artifacts:
    - path: "crates/snow-rt/src/ws/handshake.rs"
      provides: "validate_upgrade_request, compute_accept_key, perform_upgrade, write_bad_request"
      contains: "pub fn perform_upgrade"
    - path: "crates/snow-rt/src/ws/close.rs"
      provides: "parse_close_payload, build_close_payload, send_close, handle_close_frame"
      contains: "pub fn build_close_payload"
    - path: "crates/snow-rt/src/ws/mod.rs"
      provides: "Updated module declarations with handshake and close submodules"
      contains: "pub mod handshake"
  key_links:
    - from: "crates/snow-rt/src/ws/handshake.rs"
      to: "sha1::Sha1"
      via: "Digest trait for Sec-WebSocket-Accept computation"
      pattern: "Sha1::new"
    - from: "crates/snow-rt/src/ws/handshake.rs"
      to: "base64::engine::general_purpose::STANDARD"
      via: "Base64 encoding of SHA-1 hash"
      pattern: "BASE64\\.encode"
    - from: "crates/snow-rt/src/ws/close.rs"
      to: "crates/snow-rt/src/ws/frame.rs"
      via: "Uses write_frame with WsOpcode::Close to send close frames"
      pattern: "write_frame.*Close"
    - from: "crates/snow-rt/src/ws/handshake.rs"
      to: "std::io::{BufRead, BufReader, Write}"
      via: "BufReader for HTTP headers, raw Write for 101/400 responses"
      pattern: "BufReader"
---

<objective>
Implement the WebSocket handshake (HTTP upgrade with Sec-WebSocket-Accept), close handshake state machine, text frame UTF-8 validation, and error handling for malformed requests and unknown opcodes.

Purpose: This plan completes the Phase 59 protocol layer. The handshake enables connections to upgrade from HTTP to WebSocket. The close handshake ensures graceful connection teardown. Text validation and error handling ensure RFC 6455 compliance. Together with Plan 01's frame codec, this gives Phase 60 a complete, tested protocol library to wire into the actor system.

Output: handshake.rs with upgrade logic, close.rs with close handshake, updated mod.rs with all re-exports, comprehensive unit tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-protocol-core/59-RESEARCH.md
@.planning/phases/59-protocol-core/59-01-SUMMARY.md

@crates/snow-rt/src/ws/mod.rs
@crates/snow-rt/src/ws/frame.rs
@crates/snow-rt/src/http/server.rs
@crates/snow-rt/src/db/pg.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HTTP upgrade handshake</name>
  <files>crates/snow-rt/src/ws/handshake.rs, crates/snow-rt/src/ws/mod.rs</files>
  <action>
Create `crates/snow-rt/src/ws/handshake.rs` implementing the WebSocket upgrade handshake per RFC 6455 Section 4.2.

**Constants:**
- `const WS_GUID: &str = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";` (RFC 6455 magic GUID)

**compute_accept_key(client_key: &str) -> String:**
- Use `sha1::{Sha1, Digest}` (same Digest trait pattern as sha2 in pg.rs)
- Use `base64::{engine::general_purpose::STANDARD as BASE64, Engine as _}` (same pattern as pg.rs)
- Concatenate client_key + WS_GUID, SHA-1 hash, base64 encode
- This is a pub(crate) function -- needed by handshake, tested directly

**validate_upgrade_request(method: &str, headers: &[(String, String)]) -> Result&lt;String, &str&gt;:**
- Validate: method must be GET
- Required headers (case-insensitive name matching):
  - `Upgrade` must contain "websocket" (case-insensitive value)
  - `Connection` must contain "upgrade" (case-insensitive, may have multiple tokens like "keep-alive, Upgrade")
  - `Sec-WebSocket-Key` must be present (value is an opaque base64 string)
  - `Sec-WebSocket-Version` must be "13"
- Return Ok(client_key) on success, Err(reason) on failure

**write_upgrade_response&lt;W: Write&gt;(stream: &mut W, accept_key: &str) -> io::Result&lt;()&gt;:**
- Write "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: {accept_key}\r\n\r\n"
- Flush the stream

**write_bad_request&lt;W: Write&gt;(stream: &mut W, reason: &str) -> io::Result&lt;()&gt;:**
- Write "HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nContent-Length: {len}\r\nConnection: close\r\n\r\n{body}"
- Body is "Bad Request: {reason}"
- Flush the stream

**perform_upgrade&lt;S: Read + Write&gt;(stream: &mut S) -> Result&lt;(), String&gt;:**
- This is the main entry point Phase 60 will call.
- Read the HTTP request using a BufReader: read request line (method + path), read headers until blank line. Follow the same BufReader pattern as `parse_request` in server.rs but simpler (no body, no Content-Length, no query params).
- IMPORTANT (BufReader pitfall from research): After reading headers, the BufReader may have buffered bytes beyond the headers. Since `perform_upgrade` takes `&mut S` (not ownership), and the BufReader borrows `stream`, the borrow ends when perform_upgrade returns. The caller then uses the raw stream for frame I/O. This is safe IF the client does not send WebSocket frames before receiving the 101 response (which is the normal case per RFC 6455). If paranoid, check `reader.buffer().is_empty()` before returning -- if not empty, log a warning but proceed.
- Call `validate_upgrade_request(method, headers)` -- on error, call `write_bad_request` and return Err
- On success: compute accept key, call `write_upgrade_response`, return Ok(())

**Update ws/mod.rs:** Add `pub mod handshake;` and re-export: `pub use handshake::{perform_upgrade, write_bad_request};`

**Unit tests** in handshake.rs:
1. `test_accept_key_rfc_example` -- Use the RFC 6455 Section 4.2.2 test vector: key "dGhlIHNhbXBsZSBub25jZQ==" should produce "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="
2. `test_validate_valid_upgrade` -- All required headers present with method GET -> Ok(key)
3. `test_validate_missing_upgrade_header` -- Missing "Upgrade: websocket" -> Err
4. `test_validate_missing_connection_header` -- Missing "Connection: Upgrade" -> Err
5. `test_validate_missing_key` -- Missing Sec-WebSocket-Key -> Err
6. `test_validate_wrong_version` -- Sec-WebSocket-Version: "8" -> Err
7. `test_validate_wrong_method` -- POST instead of GET -> Err
8. `test_perform_upgrade_success` -- Simulate a full upgrade by writing a valid HTTP upgrade request into a Vec&lt;u8&gt; buffer, wrapping in Cursor, calling perform_upgrade, checking the written output contains "101 Switching Protocols" and a valid Sec-WebSocket-Accept header
9. `test_perform_upgrade_bad_request` -- Simulate a non-upgrade GET request, verify output contains "400 Bad Request"
  </action>
  <verify>
`cargo test -p snow-rt -- ws::handshake::tests` -- all 9 tests pass. The RFC test vector for Sec-WebSocket-Accept matches exactly.
  </verify>
  <done>Sec-WebSocket-Accept computation matches RFC 6455 test vector. perform_upgrade reads HTTP request, validates headers, writes 101 or 400. All 9 handshake unit tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement close handshake and text frame UTF-8 validation</name>
  <files>crates/snow-rt/src/ws/close.rs, crates/snow-rt/src/ws/mod.rs</files>
  <action>
Create `crates/snow-rt/src/ws/close.rs` implementing the close handshake and frame validation logic per RFC 6455 Section 5.5.1 and Section 7.

**parse_close_payload(payload: &[u8]) -> (u16, String):**
- If payload >= 2 bytes: status code is `u16::from_be_bytes([payload[0], payload[1]])`, reason is UTF-8 lossy decode of remaining bytes
- If payload < 2 bytes: return (1005, "") -- 1005 = "no status code present" per RFC 6455 Section 7.4.1
- Pub function -- used by the frame processing loop

**build_close_payload(code: u16, reason: &str) -> Vec&lt;u8&gt;:**
- 2 bytes for status code (big-endian) + reason bytes
- Truncate reason to 123 bytes max (control frames MUST have payload <= 125 bytes; 2 for code + 123 for reason = 125)
- Pub function -- used to construct close frames

**validate_text_payload(payload: &[u8]) -> Result&lt;(), ()&gt;:**
- Call `std::str::from_utf8(payload)` -- if Err, return Err(())
- If Ok, return Ok(())
- This is the UTF-8 validation for PROTO-05. Pub(crate) function.

**send_close&lt;W: Write&gt;(writer: &mut W, code: u16, reason: &str) -> Result&lt;(), String&gt;:**
- Build close payload with `build_close_payload(code, reason)`
- Call `super::frame::write_frame(writer, WsOpcode::Close, &payload, true)` to send the close frame
- Pub function -- Phase 60 will use this to send close frames

**WsCloseCode constants** (pub consts in close.rs):
- `NORMAL: u16 = 1000` -- Normal closure
- `GOING_AWAY: u16 = 1001` -- Going away
- `PROTOCOL_ERROR: u16 = 1002` -- Protocol error (used for unknown opcodes, PROTO-09)
- `INVALID_DATA: u16 = 1007` -- Invalid frame payload data (used for UTF-8 failure, PROTO-05)
- `INTERNAL_ERROR: u16 = 1011` -- Internal server error (used when actor crashes, Phase 60)

**process_frame&lt;S: Read + Write&gt;(stream: &mut S, frame: WsFrame) -> Result&lt;Option&lt;WsFrame&gt;, String&gt;:**
- This is a convenience function that handles protocol-level frame validation. It processes one frame and returns either:
  - Ok(Some(frame)) -- a data frame (text/binary) ready for the application
  - Ok(None) -- a control frame that was handled (pong sent in response to ping, close echoed)
  - Err -- protocol error (connection should be closed)
- Match on frame.opcode:
  - **Text**: Call `validate_text_payload(&frame.payload)`. If invalid UTF-8, send close with code 1007, return Err. If valid, return Ok(Some(frame)).
  - **Binary**: Return Ok(Some(frame)) directly (raw byte delivery, no validation needed).
  - **Close**: Parse the close payload. Echo a close frame back with the same status code. Return Err("close") to signal connection end. (The caller should stop the read loop.)
  - **Ping**: Send a Pong frame back with the same payload: `write_frame(stream, WsOpcode::Pong, &frame.payload, true)`. Return Ok(None).
  - **Pong**: Ignore (return Ok(None)). Phase 61 will use Pong for heartbeat tracking.
  - **Continuation**: Return Ok(Some(frame)) for now -- Phase 61 will handle reassembly. (Recognized but not assembled.)

**Update ws/mod.rs:** Add `pub mod close;` and re-export: `pub use close::{parse_close_payload, build_close_payload, send_close, validate_text_payload, process_frame, WsCloseCode};`

Also update the mod.rs doc comment to summarize all three submodules (frame, handshake, close).

**Unit tests** in close.rs:
1. `test_parse_close_normal` -- payload [0x03, 0xE8, b'o', b'k'] -> (1000, "ok")
2. `test_parse_close_empty` -- empty payload -> (1005, "")
3. `test_parse_close_code_only` -- payload [0x03, 0xE8] -> (1000, "")
4. `test_build_close_payload` -- build_close_payload(1000, "bye") -> [0x03, 0xE8, b'b', b'y', b'e']
5. `test_build_close_truncates_reason` -- build_close_payload(1000, &"x".repeat(200)) -> payload length == 125 (2 + 123)
6. `test_validate_text_valid_utf8` -- "Hello" bytes -> Ok(())
7. `test_validate_text_invalid_utf8` -- [0xFF, 0xFE] -> Err(())
8. `test_process_text_frame` -- Create a text WsFrame with "Hello", call process_frame with a Cursor, verify Ok(Some(frame))
9. `test_process_binary_frame` -- Create a binary WsFrame with [0x01, 0x02, 0x03], verify Ok(Some(frame))
10. `test_process_close_frame` -- Create a close WsFrame with code 1000, call process_frame with a writable Cursor, verify Err (connection ends) and verify the Cursor received an echoed close frame
11. `test_process_ping_sends_pong` -- Create a ping WsFrame with payload "ping", call process_frame, verify Ok(None) and verify the Cursor received a pong frame with payload "ping"
12. `test_process_invalid_utf8_text` -- Create a text WsFrame with [0xFF, 0xFE], call process_frame, verify Err and verify close code 1007 was sent
  </action>
  <verify>
`cargo test -p snow-rt -- ws::close::tests` -- all 12 tests pass. `cargo test -p snow-rt -- ws` -- all tests across frame, handshake, and close pass. `cargo test -p snow-rt` -- full snow-rt test suite passes with no regressions.
  </verify>
  <done>Close handshake parses and builds close payloads correctly. UTF-8 validation rejects invalid text frames with close code 1007. process_frame handles all opcodes correctly (text, binary, close, ping, pong, continuation). Unknown opcodes are caught at the frame level (Plan 01). 12 unit tests pass. Full snow-rt test suite has no regressions.</done>
</task>

</tasks>

<verification>
Run the complete Phase 59 verification:

1. `cargo test -p snow-rt -- ws` -- All WebSocket tests pass (frame + handshake + close)
2. `cargo test -p snow-rt` -- Full snow-rt suite passes (no regressions)
3. `cargo test --workspace` -- Full workspace passes
4. Verify RFC 6455 compliance checklist:
   - PROTO-01: perform_upgrade writes 101 with correct Sec-WebSocket-Accept
   - PROTO-02: read_frame handles 7-bit, 16-bit, 64-bit lengths
   - PROTO-03: apply_mask unmasks client frames
   - PROTO-04: write_frame writes unmasked server frames
   - PROTO-05: validate_text_payload checks UTF-8, 1007 on failure
   - PROTO-06: Binary frames delivered as raw bytes
   - PROTO-07: Close handshake echoes close frame with status codes
   - PROTO-08: write_bad_request sends HTTP 400 for malformed upgrades
   - PROTO-09: WsOpcode::from_u8 rejects unknown opcodes (close 1002 triggered by caller)
</verification>

<success_criteria>
1. All PROTO-01 through PROTO-09 requirements covered
2. All unit tests pass (frame: 9, handshake: 9, close: 12 = ~30 tests)
3. Sec-WebSocket-Accept computation matches RFC 6455 test vector exactly
4. No regressions in existing snow-rt tests
5. Clean module structure: ws/{mod.rs, frame.rs, handshake.rs, close.rs}
6. Phase 60 can import perform_upgrade, read_frame, write_frame, process_frame, send_close without touching any Phase 59 code
</success_criteria>

<output>
After completion, create `.planning/phases/59-protocol-core/59-02-SUMMARY.md`
</output>
