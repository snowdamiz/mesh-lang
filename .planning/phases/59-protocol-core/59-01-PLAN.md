---
phase: 59-protocol-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/Cargo.toml
  - crates/snow-rt/src/ws/mod.rs
  - crates/snow-rt/src/ws/frame.rs
  - crates/snow-rt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "A masked client frame with 7-bit payload length can be parsed and unmasked correctly"
    - "A masked client frame with 16-bit payload length (126-65535 bytes) can be parsed and unmasked"
    - "A masked client frame with 64-bit payload length can be parsed (with MSB=0 check)"
    - "An unmasked server frame can be written with correct header encoding for all three length ranges"
    - "The XOR masking operation is symmetric (mask then unmask returns original)"
    - "All six standard opcodes are recognized (continuation, text, binary, close, ping, pong)"
    - "Unknown opcodes produce an error rather than silently accepting"
  artifacts:
    - path: "crates/snow-rt/Cargo.toml"
      provides: "sha1 0.10 dependency"
      contains: "sha1"
    - path: "crates/snow-rt/src/ws/mod.rs"
      provides: "WebSocket module declarations and re-exports"
      contains: "pub mod frame"
    - path: "crates/snow-rt/src/ws/frame.rs"
      provides: "WsOpcode enum, WsFrame struct, read_frame, write_frame, apply_mask"
      contains: "pub fn read_frame"
    - path: "crates/snow-rt/src/lib.rs"
      provides: "ws module declaration"
      contains: "pub mod ws"
  key_links:
    - from: "crates/snow-rt/src/ws/frame.rs"
      to: "std::io::Read"
      via: "read_exact for frame header and payload bytes"
      pattern: "read_exact"
    - from: "crates/snow-rt/src/ws/frame.rs"
      to: "std::io::Write"
      via: "write_all for frame output"
      pattern: "write_all"
    - from: "crates/snow-rt/src/ws/mod.rs"
      to: "crates/snow-rt/src/ws/frame.rs"
      via: "module re-exports"
      pattern: "pub use frame"
---

<objective>
Implement the WebSocket frame codec: the WsOpcode enum, WsFrame struct, frame reader (with masking), and frame writer. Add sha1 dependency to Cargo.toml and create the ws/ module structure.

Purpose: The frame codec is the foundation of the entire WebSocket implementation. Every other WebSocket feature (handshake, close, text validation, actor integration) depends on being able to read and write frames. This plan establishes the wire-level data types and I/O functions per RFC 6455 Section 5.2-5.3.

Output: Working frame parser and writer with unit tests, new ws/ module in snow-rt, sha1 dependency added.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-protocol-core/59-RESEARCH.md

@crates/snow-rt/Cargo.toml
@crates/snow-rt/src/lib.rs
@crates/snow-rt/src/http/mod.rs
@crates/snow-rt/src/http/server.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sha1 dependency and create ws/ module skeleton</name>
  <files>crates/snow-rt/Cargo.toml, crates/snow-rt/src/ws/mod.rs, crates/snow-rt/src/lib.rs</files>
  <action>
1. Add `sha1 = "0.10"` to `[dependencies]` in `crates/snow-rt/Cargo.toml`, with a comment `# Phase 59: WebSocket Sec-WebSocket-Accept (RFC 6455)`. Place it after the existing sha2/hmac/md-5/pbkdf2/base64 block.

2. Create `crates/snow-rt/src/ws/mod.rs` following the same pattern as `http/mod.rs`:
   - Module doc comment explaining it provides the WebSocket protocol layer (RFC 6455)
   - `pub mod frame;` declaration (handshake and close will be added in Plan 02)
   - Re-export key types: `pub use frame::{WsOpcode, WsFrame, read_frame, write_frame, apply_mask};`

3. Add `pub mod ws;` to `crates/snow-rt/src/lib.rs`, after the existing `pub mod http;` line.

4. Run `cargo check -p snow-rt` to verify the new module compiles (frame.rs will be empty at this point, so create a placeholder with just `//! WebSocket frame codec.` if needed to pass compilation, then Task 2 fills it in).
  </action>
  <verify>
`cargo check -p snow-rt` compiles without errors. The ws/ directory exists with mod.rs. lib.rs declares pub mod ws.
  </verify>
  <done>sha1 0.10 is in Cargo.toml, ws/mod.rs exists with module declarations, lib.rs exports the ws module, cargo check passes.</done>
</task>

<task type="auto">
  <name>Task 2: Implement frame codec (read_frame, write_frame, apply_mask)</name>
  <files>crates/snow-rt/src/ws/frame.rs</files>
  <action>
Implement the WebSocket frame codec in `crates/snow-rt/src/ws/frame.rs` per RFC 6455 Section 5.2-5.3. The research file (59-RESEARCH.md) contains verified code patterns -- use them as the foundation.

**WsOpcode enum** (derive Debug, Clone, Copy, PartialEq):
- Continuation = 0x0, Text = 0x1, Binary = 0x2, Close = 0x8, Ping = 0x9, Pong = 0xA
- Include a `from_u8(byte: u8) -> Result<WsOpcode, String>` constructor that returns Err for unknown opcodes (this is how PROTO-09 "unknown opcode" detection works at the frame level)

**WsFrame struct** (derive Debug):
- `pub fin: bool` -- FIN bit (true = final fragment)
- `pub opcode: WsOpcode`
- `pub payload: Vec<u8>` -- unmasked payload bytes

**apply_mask(payload: &mut [u8], mask_key: &[u8; 4]):**
- XOR each byte with `mask_key[i % 4]` per RFC 6455 Section 5.3
- The operation is symmetric (applying twice returns original)

**read_frame<R: Read>(reader: &mut R) -> Result<WsFrame, String>:**
- Read 2-byte header: extract FIN bit (byte0 & 0x80), RSV bits (must be 0, else error), opcode (byte0 & 0x0F via WsOpcode::from_u8)
- Extract MASK bit (byte1 & 0x80) and 7-bit payload length (byte1 & 0x7F)
- Three length encodings: 0-125 = direct, 126 = read 2 more bytes as u16 big-endian, 127 = read 8 more bytes as u64 big-endian
- For 64-bit length: check MSB is 0 (`if len >> 63 != 0`), and add a safety cap of 64MB (`if len > 64 * 1024 * 1024`) to prevent OOM
- If MASK bit set: read 4-byte mask key, then read payload, then apply_mask
- If MASK bit not set: just read payload
- IMPORTANT: Use `reader.read_exact()` for all reads -- do NOT use BufReader here (per research anti-pattern). The caller controls buffering.

**write_frame<W: Write>(writer: &mut W, opcode: WsOpcode, payload: &[u8], fin: bool) -> Result<(), String>:**
- Byte 0: FIN bit (0x80 if fin) | opcode as u8
- Byte 1: MASK=0 (server MUST NOT mask per RFC 6455) | payload length encoding
- Length encoding: 0-125 = direct in byte 1, 126-65535 = byte 1 is 126 + 2 bytes big-endian u16, 65536+ = byte 1 is 127 + 8 bytes big-endian u64
- Write payload bytes, flush

**Unit tests** (in a `#[cfg(test)] mod tests` block at bottom of frame.rs):
1. `test_mask_roundtrip` -- mask "Hello" with [0x37, 0xfa, 0x21, 0x3d], verify masked != original, unmask, verify == original
2. `test_read_7bit_text_frame` -- Construct a masked text frame "Hi" (FIN=1, opcode=1, MASK=1, len=2, key=[0,0,0,0], payload=b"Hi"), parse it, verify fin=true, opcode=Text, payload=b"Hi"
3. `test_read_16bit_length` -- Construct a masked frame with 200-byte payload (length_byte=126, followed by 200u16 big-endian), verify correct parse
4. `test_read_64bit_length` -- Construct a masked frame with length_byte=127 and a small payload (use 300 bytes), verify the 64-bit path works
5. `test_write_small_frame` -- Write a text frame "Hello", read it back (unmasked, since server writes don't mask), verify bytes match expected: [0x81, 0x05, b'H', b'e', b'l', b'l', b'o']
6. `test_write_medium_frame` -- Write a 200-byte frame, verify the 16-bit length encoding in the output
7. `test_unknown_opcode` -- Construct a frame with opcode byte 0x03 (reserved), verify read_frame returns Err containing "unknown opcode"
8. `test_nonzero_rsv_rejected` -- Construct a frame with RSV1 bit set (byte0 = 0xC1 for FIN+RSV1+Text), verify read_frame returns Err
9. `test_frame_roundtrip` -- write_frame then read the bytes back with read_frame (for unmasked server frames)

All tests use `std::io::Cursor` for in-memory byte buffers. No network I/O needed.
  </action>
  <verify>
`cargo test -p snow-rt -- ws::frame::tests` -- all 9 tests pass. `cargo check -p snow-rt` compiles cleanly.
  </verify>
  <done>WsOpcode enum handles all 6 opcodes + unknown detection. WsFrame struct represents parsed frames. read_frame correctly parses all 3 payload length encodings with masking. write_frame produces correct unmasked server frames. apply_mask implements symmetric XOR. 9 unit tests pass covering all code paths.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-rt -- ws` passes all frame codec tests
- `cargo check -p snow-rt` compiles without errors or new warnings
- Frame parser handles 7-bit, 16-bit, and 64-bit payload lengths
- Masking/unmasking works correctly (symmetric XOR)
- Server frames are written without masking
- Unknown opcodes produce errors (not silent acceptance)
- RSV bits are validated (non-zero = error)
</verification>

<success_criteria>
1. sha1 0.10 dependency added to snow-rt Cargo.toml
2. ws/ module exists in snow-rt with frame.rs
3. WsOpcode enum covers all 6 standard opcodes
4. read_frame parses masked client frames with all 3 length encodings
5. write_frame produces unmasked server frames with correct headers
6. All unit tests pass
7. No regressions (existing cargo test still passes)
</success_criteria>

<output>
After completion, create `.planning/phases/59-protocol-core/59-01-SUMMARY.md`
</output>
