---
phase: 64-node-connection-authentication
plan: 03
type: execute
wave: 3
depends_on: ["64-02"]
files_modified:
  - crates/snow-rt/src/dist/node.rs
autonomous: true

must_haves:
  truths:
    - "A dead node connection is detected via heartbeat within the configured timeout interval"
    - "Each authenticated connection has a reader thread receiving messages and a heartbeat thread sending pings"
    - "Connection cleanup removes the session from NodeState when a node disconnects"
    - "Two Snow nodes can start, connect, authenticate, and maintain a heartbeat-monitored connection"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "HeartbeatState, heartbeat_loop, reader_loop, spawn_session_threads, connection lifecycle tests"
      contains: "heartbeat_loop"
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "Heartbeat ping/pong wire format"
      contains: "HEARTBEAT_PING"
  key_links:
    - from: "crates/snow-rt/src/dist/node.rs heartbeat_loop"
      to: "NodeSession.shutdown"
      via: "AtomicBool set on pong timeout triggers session cleanup"
      pattern: "shutdown.store(true"
    - from: "crates/snow-rt/src/dist/node.rs reader_loop"
      to: "NodeSession.stream"
      via: "Arc<Mutex<NodeStream>> shared read access"
      pattern: "stream.lock()"
    - from: "crates/snow-rt/src/dist/node.rs cleanup_session"
      to: "NodeState.sessions + node_id_map"
      via: "Remove session entry on disconnect"
      pattern: "sessions.write().remove"
---

<objective>
Implement heartbeat-based dead connection detection, the reader thread for incoming messages, and connection lifecycle management for Snow node sessions.

Purpose: Without heartbeat, dead TCP connections can go undetected indefinitely (TCP keepalive defaults are too slow). This plan adds ping/pong heartbeat monitoring (default 60s interval, NODE-08), a reader thread to process incoming data, and cleanup logic to tear down sessions when connections die. This completes the Phase 64 success criteria.

Output: HeartbeatState, heartbeat thread, reader thread, session cleanup, and integration tests in `dist/node.rs`.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-node-connection-authentication/64-RESEARCH.md
@.planning/phases/64-node-connection-authentication/64-01-SUMMARY.md
@.planning/phases/64-node-connection-authentication/64-02-SUMMARY.md
@crates/snow-rt/src/dist/node.rs
@crates/snow-rt/src/ws/server.rs (HeartbeatState pattern, reader thread pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Heartbeat ping/pong and reader thread</name>
  <files>crates/snow-rt/src/dist/node.rs</files>
  <action>
Add heartbeat and reader loop to `dist/node.rs`:

1. **Heartbeat wire format constants**:
   - `HEARTBEAT_PING: u8 = 0xF0` -- ping message tag
   - `HEARTBEAT_PONG: u8 = 0xF1` -- pong message tag
   - Heartbeat messages use the same `write_msg` / `read_msg` length-prefixed format: `[u32 len=9][u8 tag][8 bytes payload]`.

2. **HeartbeatState struct** (follow `ws/server.rs:96-133` pattern):
   ```rust
   struct HeartbeatState {
       last_ping_sent: Instant,
       last_pong_received: Instant,
       ping_interval: Duration,     // default 60s (configurable via NODE-08)
       pong_timeout: Duration,      // default 15s
       pending_ping_payload: Option<[u8; 8]>,
   }
   ```
   - `HeartbeatState::new(interval: Duration, timeout: Duration)` -- initializes with `Instant::now()` for both timestamps.
   - `should_send_ping(&self) -> bool` -- true if `elapsed since last_ping_sent >= ping_interval`.
   - `is_pong_overdue(&self) -> bool` -- true if `pending_ping_payload.is_some()` AND `elapsed since last_ping_sent >= pong_timeout`.

3. **`reader_loop` function** (runs on a dedicated OS thread per session):
   ```rust
   fn reader_loop(
       stream: Arc<Mutex<NodeStream>>,
       shutdown: Arc<AtomicBool>,
       heartbeat_tx: Option<Sender<[u8; 8]>>,  // channel to notify heartbeat of pong
   )
   ```
   - Loop: check shutdown flag, try to read a message from the stream with a brief timeout.
   - Set TCP read timeout to 100ms (via `TcpStream::set_read_timeout`) to allow periodic shutdown checks -- extract the underlying TcpStream reference from NodeStream for this. Alternatively, use the stream directly with a 100ms timeout pattern (matching WS server's approach).
   - On successful read: check the message tag:
     - `HEARTBEAT_PING`: respond immediately with `HEARTBEAT_PONG` carrying the same 8-byte payload (write pong directly via stream lock).
     - `HEARTBEAT_PONG`: forward the 8-byte payload to the heartbeat thread via `heartbeat_tx` channel (or directly update HeartbeatState if sharing state via Arc).
     - Other tags: Phase 65 will handle actual message routing. For now, just ignore/drop non-heartbeat messages.
   - On `WouldBlock`/`TimedOut`: continue (normal for non-blocking/timeout reads).
   - On connection reset / EOF / other error: set `shutdown.store(true, SeqCst)`, break.

   **Design choice:** Instead of a channel, share the HeartbeatState via `Arc<Mutex<HeartbeatState>>` between reader_loop and heartbeat_loop. The reader updates `last_pong_received` and clears `pending_ping_payload` when it sees a matching pong. This is simpler than a channel and matches the WS server's approach.

4. **`heartbeat_loop` function** (runs on a dedicated OS thread per session):
   ```rust
   fn heartbeat_loop(
       stream: Arc<Mutex<NodeStream>>,
       shutdown: Arc<AtomicBool>,
       heartbeat_state: Arc<Mutex<HeartbeatState>>,
       session_name: String,  // for logging
   )
   ```
   - Loop with `thread::sleep(Duration::from_millis(500))` between iterations (poll interval).
   - Check shutdown flag -- break if true.
   - Lock heartbeat_state:
     - If `is_pong_overdue()`: dead connection detected. Set `shutdown.store(true, SeqCst)`. Eprintln warning: `"node heartbeat timeout: {session_name}"`. Break. (Phase 66 will fire `:nodedown` signals here.)
     - If `should_send_ping()`: generate 8-byte random payload, send `HEARTBEAT_PING` via stream lock, update `last_ping_sent` and `pending_ping_payload`.
   - After loop exits (shutdown or timeout): call `cleanup_session`.

5. **`spawn_session_threads` function**:
   ```rust
   fn spawn_session_threads(session: &Arc<NodeSession>)
   ```
   - Create `Arc<Mutex<HeartbeatState>>` with default intervals (60s ping, 15s timeout).
   - Spawn reader thread: `std::thread::Builder::new().name(format!("snow-node-reader-{}", session.remote_name)).spawn(...)`.
   - Spawn heartbeat thread: `std::thread::Builder::new().name(format!("snow-node-heartbeat-{}", session.remote_name)).spawn(...)`.
   - Both threads receive clones of `session.stream`, `session.shutdown`, and the shared heartbeat state.

6. **Wire `spawn_session_threads` into Plan 02's connection paths**:
   - In `snow_node_connect`: after `register_session`, call `spawn_session_threads(&session)`.
   - In the accept loop: after `register_session`, call `spawn_session_threads(&session)`.

7. **`cleanup_session` function**:
   ```rust
   fn cleanup_session(remote_name: &str)
   ```
   - Remove session from `state.sessions` by remote_name.
   - Get the node_id from the removed session, remove from `state.node_id_map`.
   - Phase 66 will add `:nodedown` notification here.
  </action>
  <verify>
Run `cargo build -p snow-rt 2>&1 | head -50` -- no compile errors.
Run `cargo test -p snow-rt 2>&1 | tail -20` -- all existing tests pass.
  </verify>
  <done>
HeartbeatState tracks ping/pong timing with configurable intervals. Reader thread receives messages and responds to heartbeat pings. Heartbeat thread sends periodic pings and detects dead connections within timeout. Session cleanup removes entries from NodeState. Reader and heartbeat threads are spawned for every authenticated connection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for node connection lifecycle</name>
  <files>crates/snow-rt/src/dist/node.rs</files>
  <action>
Add comprehensive tests to the `#[cfg(test)] mod tests` block in `dist/node.rs`:

1. **`test_heartbeat_state_timing`**:
   - Create HeartbeatState with 100ms interval, 50ms timeout (short for test speed).
   - Verify `should_send_ping()` is false initially.
   - Sleep 100ms, verify `should_send_ping()` is true.
   - Simulate ping sent (update last_ping_sent, set pending_ping_payload).
   - Verify `is_pong_overdue()` is false immediately.
   - Sleep 60ms (past 50ms timeout), verify `is_pong_overdue()` is true.
   - Simulate pong received (clear pending_ping_payload, update last_pong_received).
   - Verify `is_pong_overdue()` is false.

2. **`test_handshake_in_memory`**:
   - Use `std::io::Cursor<Vec<u8>>` (or a pair of in-memory pipes via `std::os::unix::net::UnixStream::pair()`) to test the handshake protocol without real TLS.
   - Create two threads simulating initiator and acceptor.
   - Both share the same cookie string.
   - Initiator calls `perform_handshake(stream, state, true)`.
   - Acceptor calls `perform_handshake(stream, state, false)`.
   - Verify both return `Ok` with the correct remote name.

3. **`test_handshake_wrong_cookie`**:
   - Same in-memory pipe setup as above.
   - Initiator uses cookie "correct", acceptor uses cookie "wrong".
   - Verify one side returns `Err` containing "cookie mismatch" or "authentication failed".

4. **`test_node_connect_full_lifecycle`**:
   - This test exercises the full flow: start a "server" node on localhost with a random port, then connect a "client" to it.
   - Since `snow_node_start` uses a global OnceLock and can only be called once, this test should either:
     - Use lower-level functions directly (bind listener, spawn accept thread, then connect), OR
     - Be marked `#[ignore]` if it requires global state that conflicts with other tests.
   - Approach: Create a TcpListener on port 0 (OS-assigned), get the actual port. Spawn accept thread that does TLS + handshake. On main thread, do TCP connect + TLS + handshake. Verify both sides see each other's names.
   - This test validates SUCCESS CRITERIA 2 (connect with mutual auth) and 4 (TLS encrypted).

5. **`test_write_msg_read_msg_roundtrip`**:
   - Test the wire format helpers with in-memory streams.
   - Write a message, read it back, verify payload matches.
   - Test with empty payload, max-size payload (4096 bytes), and payload just over max (expect error on read).

Important: Use `#[test]` for unit tests that don't need global state. Use `#[test] #[ignore]` for the full lifecycle test if it conflicts with other tests due to global singleton usage. Tests involving real TCP connections should use port 0 for OS-assigned ports to avoid port conflicts.
  </action>
  <verify>
Run `cargo test -p snow-rt -- test_heartbeat_state --nocapture` -- timing test passes.
Run `cargo test -p snow-rt -- test_handshake --nocapture` -- handshake tests pass.
Run `cargo test -p snow-rt -- test_write_msg_read_msg --nocapture` -- wire format test passes.
Run `cargo test -p snow-rt 2>&1 | tail -5` -- all tests pass (no regressions).
  </verify>
  <done>
HeartbeatState timing test validates ping/pong detection logic. In-memory handshake test validates mutual authentication succeeds with matching cookies. Wrong-cookie test validates clear error message on mismatch. Wire format roundtrip test validates length-prefixed message encoding. Full lifecycle test demonstrates end-to-end node connection. All 1,524+ existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles without errors
2. `cargo test -p snow-rt -- test_heartbeat_state` passes
3. `cargo test -p snow-rt -- test_handshake_in_memory` passes
4. `cargo test -p snow-rt -- test_handshake_wrong_cookie` passes
5. `cargo test -p snow-rt -- test_write_msg_read_msg` passes
6. HeartbeatState detects dead connections within configured timeout
7. Reader thread responds to heartbeat pings automatically
8. Connection cleanup removes session from NodeState
9. All existing 1,524 tests still pass
</verification>

<success_criteria>
- Heartbeat ping/pong with configurable interval (default 60s) and timeout (default 15s)
- Dead connection detected within `ping_interval + pong_timeout` (NODE-08)
- Reader thread processes incoming heartbeat messages
- Connection cleanup removes session from all NodeState maps
- Handshake tested with matching and mismatching cookies
- Wire format tested for correctness
- Full node connection lifecycle validated end-to-end
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/64-node-connection-authentication/64-03-SUMMARY.md`
</output>
