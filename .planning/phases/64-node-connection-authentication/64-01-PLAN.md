---
phase: 64-node-connection-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/dist/node.rs
  - crates/snow-rt/src/dist/mod.rs
autonomous: true

must_haves:
  truths:
    - "NodeState singleton holds node identity (name, host, port, cookie, creation counter)"
    - "TLS ServerConfig and ClientConfig are built from an ephemeral self-signed certificate"
    - "TCP listener accepts incoming connections on the configured port"
    - "snow_node_start extern C function initializes the node and starts listening"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "NodeState, NodeRegistry, TLS config builders, ephemeral cert generation, TCP listener"
      contains: "NODE_STATE"
    - path: "crates/snow-rt/src/dist/mod.rs"
      provides: "Re-export of node module"
      contains: "pub mod node"
  key_links:
    - from: "crates/snow-rt/src/dist/node.rs"
      to: "rustls ServerConfig/ClientConfig"
      via: "build_node_server_config / build_node_client_config"
      pattern: "ServerConfig::builder"
    - from: "crates/snow-rt/src/dist/node.rs"
      to: "std::net::TcpListener"
      via: "listener thread spawned in snow_node_start"
      pattern: "TcpListener::bind"
---

<objective>
Implement the node identity system, TLS configuration, and TCP listener for Snow's distributed actor system.

Purpose: Establish the foundational types and startup flow so that `Node.start("name@host", cookie: "secret")` makes a Snow runtime into a named, addressable node that can accept incoming connections. This plan creates the infrastructure that Plan 02 (handshake) and Plan 03 (heartbeat/reader) build upon.

Output: `dist/node.rs` with NodeState singleton, ephemeral TLS cert generation, TCP listener thread, and `snow_node_start` extern "C" entry point.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-node-connection-authentication/64-RESEARCH.md
@crates/snow-rt/src/dist/mod.rs
@crates/snow-rt/src/dist/wire.rs
@crates/snow-rt/src/actor/registry.rs (ProcessRegistry OnceLock+RwLock pattern)
@crates/snow-rt/src/actor/process.rs (ProcessId PID bit-packing, from_remote)
@crates/snow-rt/src/actor/mod.rs (extern "C" fn patterns, dist_send_stub)
@crates/snow-rt/src/http/server.rs (TLS ServerConfig pattern)
@crates/snow-rt/src/db/pg.rs (TLS ClientConfig, HMAC-SHA256 patterns)
@crates/snow-rt/src/ws/server.rs (WsStream enum, reader thread pattern)
@crates/snow-rt/src/gc.rs (snow_rt_init, ring crypto provider installation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: NodeState singleton with TLS configs and ephemeral certificate</name>
  <files>crates/snow-rt/src/dist/node.rs, crates/snow-rt/src/dist/mod.rs</files>
  <action>
Create `crates/snow-rt/src/dist/node.rs` with the following components:

1. **NodeState struct** (global singleton via `static NODE_STATE: OnceLock<NodeState>`):
   - `name: String` -- full node name "name@host"
   - `host: String` -- host portion
   - `port: u16` -- TCP listener port
   - `cookie: String` -- shared secret for authentication
   - `creation: AtomicU8` -- monotonically incrementing, wraps at 255
   - `next_node_id: AtomicU16` -- assigns node_ids to remote nodes (starts at 1; 0 = local)
   - `tls_server_config: Arc<rustls::ServerConfig>` -- for accepting connections
   - `tls_client_config: Arc<rustls::ClientConfig>` -- for initiating connections
   - `sessions: RwLock<FxHashMap<String, Arc<NodeSession>>>` -- connected nodes (name -> session)
   - `node_id_map: RwLock<FxHashMap<u16, String>>` -- reverse map for PID routing (Phase 65)
   - `listener_shutdown: AtomicBool` -- signals listener thread to stop

   Add method `NodeState::assign_node_id(&self) -> u16` that atomically increments `next_node_id`. Add method `NodeState::creation(&self) -> u8` that loads the creation counter.

2. **NodeSession struct** (placeholder -- Plan 02 will flesh it out):
   - `remote_name: String`
   - `remote_creation: u8`
   - `node_id: u16` -- the node_id assigned to this remote node
   - `shutdown: AtomicBool`

3. **Ephemeral TLS certificate generation** (`generate_ephemeral_cert() -> (CertificateDer<'static>, PrivateKeyDer<'static>)`):
   - Use `ring::signature::EcdsaKeyPair::generate_pkcs8()` with `ECDSA_P256_SHA256_ASN1_SIGNING` to generate a key pair.
   - Construct a minimal self-signed X.509 DER certificate. Use a hardcoded DER template approach: define a byte array with the ASN.1 structure for a minimal self-signed cert (version 3, serial number 1, CN=snow-node, validity 1 year, ECDSA P-256 signature algorithm). Splice in the public key bytes from the generated key pair at the correct offset. Sign the TBS (to-be-signed) portion with the private key.
   - The certificate does NOT need to be CA-trusted (we skip verification on the client side). It just needs to be structurally valid enough for rustls `with_single_cert()` to accept it.
   - If the hardcoded template approach proves too complex, fall back to a simpler approach: generate the key pair, then build the minimal ASN.1 programmatically using raw byte construction (OID encoding, SEQUENCE/BIT STRING wrappers). The key insight is that this cert is never validated, so it can be very minimal.

4. **TLS config builders**:
   - `build_node_server_config(cert, key) -> Arc<ServerConfig>`: Uses `ServerConfig::builder().with_no_client_auth().with_single_cert(vec![cert], key)`. Follow the pattern from `http/server.rs`.
   - `build_node_client_config() -> Arc<ClientConfig>`: Uses `ClientConfig::builder().dangerous().with_custom_certificate_verifier(Arc::new(SkipCertVerification)).with_no_client_auth()`. Implement `SkipCertVerification` as a struct implementing `rustls::client::danger::ServerCertVerifier` that returns `Ok(ServerCertVerified::assertion())` for all certificates. Also implement `verify_tls12_signature` and `verify_tls13_signature` by delegating to `rustls::crypto::ring::default_provider().verify_tls12_signature()` / `verify_tls13_signature()` (or using the `WebPkiSupportedAlgorithms` approach). Implement `supported_verify_schemes` returning the default ring schemes.

5. **parse_node_name helper** (`parse_node_name(name: &str) -> Result<(&str, &str, u16), String>`):
   - Parse "name@host" -> (name_part, host, default_port 9000)
   - Parse "name@host:port" -> (name_part, host, parsed_port)
   - Return error for invalid format (no @, empty parts, invalid port)

6. **Update `dist/mod.rs`**: Add `pub mod node;` alongside existing `pub mod wire;`.

Do NOT add the TCP listener or `snow_node_start` yet -- that's Task 2.
  </action>
  <verify>
Run `cargo build -p snow-rt 2>&1 | head -50` -- should compile with no errors. The NodeState struct, TLS builders, cert generation, and SkipCertVerification should all be valid Rust.
  </verify>
  <done>
NodeState singleton type exists with all fields. Ephemeral ECDSA P-256 certificate can be generated. TLS ServerConfig and ClientConfig are buildable. SkipCertVerification skips PKI validation. parse_node_name correctly parses "name@host" and "name@host:port" formats. dist/mod.rs re-exports the node module.
  </done>
</task>

<task type="auto">
  <name>Task 2: TCP listener thread and snow_node_start extern C entry point</name>
  <files>crates/snow-rt/src/dist/node.rs</files>
  <action>
Add the TCP listener and `snow_node_start` entry point to `dist/node.rs`:

1. **`snow_node_start` extern "C" function**:
   ```rust
   #[no_mangle]
   pub extern "C" fn snow_node_start(
       name_ptr: *const u8,
       name_len: u64,
       cookie_ptr: *const u8,
       cookie_len: u64,
   ) -> i64
   ```
   - Extract name and cookie strings from raw pointers (same pattern as `snow_actor_register` in `actor/mod.rs`).
   - Call `parse_node_name` to extract host and port.
   - Generate ephemeral TLS certificate via `generate_ephemeral_cert()`.
   - Build server and client TLS configs.
   - Initialize `NODE_STATE` via `OnceLock::get_or_init()`. If already initialized, return -1 (node already started).
   - Bind `TcpListener` to `host:port`. If port 0, use OS-assigned port and store the actual port in NodeState. On bind failure, return -2.
   - Spawn a background OS thread (`std::thread::spawn`) running `accept_loop` that:
     - Loops calling `listener.accept()`
     - On each accepted connection, spawns another thread to handle the TLS handshake and authentication (Plan 02 will implement the handshake body; for now, just log and drop the connection).
     - Checks `listener_shutdown` AtomicBool each iteration; breaks if true.
     - Uses `listener.set_nonblocking(false)` with a reasonable accept timeout pattern (or `listener.set_nonblocking(true)` with `thread::sleep(100ms)` polling to check shutdown flag).
   - Return 0 on success.

2. **`accept_loop` function** (private):
   - Accepts TCP connections in a loop.
   - For now (before Plan 02), each accepted connection is just dropped with a comment `// Plan 02: perform_handshake() here`.
   - Uses the shutdown flag pattern from WS server: check `AtomicBool` periodically.
   - Handle `WouldBlock` / `EAGAIN` gracefully (continue looping after brief sleep).

3. **`node_state()` public helper**: Returns `Option<&'static NodeState>` by reading the OnceLock. This is the access point for other code to check if we're running as a node.

4. **Add a unit test** `test_parse_node_name` that validates:
   - `"foo@localhost"` -> Ok(("foo", "localhost", 9000))
   - `"bar@10.0.0.1:4000"` -> Ok(("bar", "10.0.0.1", 4000))
   - `"invalid"` -> Err (no @ symbol)
   - `"@host"` -> Err (empty name)
   - `"name@"` -> Err (empty host)
  </action>
  <verify>
Run `cargo test -p snow-rt -- test_parse_node_name --nocapture` -- the parse tests should pass.
Run `cargo build -p snow-rt 2>&1 | head -50` -- no compile errors.
  </verify>
  <done>
`snow_node_start` extern "C" function initializes NodeState, generates ephemeral TLS cert, binds TCP listener, and spawns accept loop thread. `node_state()` accessor provides read access to the singleton. TCP listener accepts connections (handshake stub for Plan 02). parse_node_name tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles without errors
2. `cargo test -p snow-rt -- test_parse_node_name` passes
3. `dist/node.rs` contains NodeState with all required fields
4. `dist/mod.rs` exports both `wire` and `node` modules
5. Ephemeral cert generation function exists and produces valid DER
6. TLS ServerConfig and ClientConfig can be constructed
</verification>

<success_criteria>
- NodeState singleton pattern established (OnceLock + parking_lot::RwLock<FxHashMap>)
- Ephemeral ECDSA P-256 certificate generated at node startup (no user-provided certs needed)
- TLS configs ready for both server (accepting) and client (connecting) roles
- TCP listener running on background thread, accepting connections
- `snow_node_start` extern "C" callable from LLVM codegen
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/64-node-connection-authentication/64-01-SUMMARY.md`
</output>
