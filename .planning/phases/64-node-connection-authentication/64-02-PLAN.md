---
phase: 64-node-connection-authentication
plan: 02
type: execute
wave: 2
depends_on: ["64-01"]
files_modified:
  - crates/snow-rt/src/dist/node.rs
autonomous: true

must_haves:
  truths:
    - "Node.connect establishes a TLS connection and completes mutual cookie authentication"
    - "Wrong cookie is rejected with a clear error message, not a crash or silent failure"
    - "Simultaneous connection attempts between two nodes resolve via name-based tiebreaker"
    - "Incoming connections on the listener complete the same handshake as acceptor"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "Handshake protocol, HMAC challenge/response, snow_node_connect, NodeSession with stream"
      contains: "perform_handshake"
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "snow_node_connect extern C function"
      contains: "snow_node_connect"
  key_links:
    - from: "crates/snow-rt/src/dist/node.rs"
      to: "hmac::Hmac<sha2::Sha256>"
      via: "compute_response and verify_response functions"
      pattern: "HmacSha256::new_from_slice"
    - from: "crates/snow-rt/src/dist/node.rs"
      to: "rustls StreamOwned"
      via: "TLS stream wrapping for authenticated connections"
      pattern: "StreamOwned::new"
    - from: "crates/snow-rt/src/dist/node.rs"
      to: "NodeState.sessions"
      via: "Inserting authenticated NodeSession into session map"
      pattern: "sessions.write"
---

<objective>
Implement the HMAC-SHA256 cookie challenge/response handshake protocol and `Node.connect` for establishing authenticated, TLS-encrypted connections between Snow nodes.

Purpose: This is the core authentication layer. After TLS encrypts the connection, a 4-message binary handshake proves both sides know the shared cookie. Wrong cookies produce a clear error. This plan also wires the listener's accept loop (from Plan 01) to perform the handshake on incoming connections.

Output: Complete handshake protocol in `dist/node.rs`, `snow_node_connect` extern "C" function, and NodeSession creation for authenticated connections.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-node-connection-authentication/64-RESEARCH.md
@.planning/phases/64-node-connection-authentication/64-01-SUMMARY.md
@crates/snow-rt/src/dist/node.rs
@crates/snow-rt/src/db/pg.rs (HMAC-SHA256 pattern from SCRAM auth)
@crates/snow-rt/src/actor/mod.rs (extern "C" fn pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: HMAC-SHA256 challenge/response and binary handshake protocol</name>
  <files>crates/snow-rt/src/dist/node.rs</files>
  <action>
Add the handshake protocol to `dist/node.rs`:

1. **Handshake message tags** (constants):
   - `HANDSHAKE_NAME: u8 = 1` -- initiator sends their name + creation
   - `HANDSHAKE_CHALLENGE: u8 = 2` -- acceptor sends status + challenge + their name + creation
   - `HANDSHAKE_REPLY: u8 = 3` -- initiator sends response to challenge + own challenge
   - `HANDSHAKE_ACK: u8 = 4` -- acceptor sends response to initiator's challenge

2. **Wire format helpers** (length-prefixed binary messages, all little-endian):
   - `write_msg(stream, payload: &[u8]) -> io::Result<()>`: Write `[u32 length][payload]`.
   - `read_msg(stream) -> io::Result<Vec<u8>>`: Read `[u32 length]`, then read exactly that many bytes. Enforce max message size (e.g., 4096 bytes for handshake messages).

3. **HMAC-SHA256 functions** (follow `db/pg.rs` SCRAM pattern):
   - `generate_challenge() -> [u8; 32]`: Use `rand::random::<[u8; 32]>()`.
   - `compute_response(cookie: &str, challenge: &[u8; 32]) -> [u8; 32]`: HMAC-SHA256(cookie, challenge). Use `Hmac::<Sha256>::new_from_slice(cookie.as_bytes())`, `mac.update(challenge)`, `mac.finalize().into_bytes()`, copy to `[u8; 32]`.
   - `verify_response(cookie: &str, challenge: &[u8; 32], response: &[u8; 32]) -> bool`: Compute HMAC, then use `mac.verify_slice(response).is_ok()` for constant-time comparison (prevents timing attacks per research pitfall 3).

4. **Handshake message builders/parsers**:
   - `send_name(stream, name: &str, creation: u8)`: Build payload `[tag=1][u16 name_len][name_bytes][u8 creation]`, send via `write_msg`.
   - `recv_name(stream) -> Result<(String, u8), String>`: Read msg, parse name + creation.
   - `send_challenge(stream, name: &str, creation: u8, challenge: &[u8; 32])`: Build payload `[tag=2][u16 name_len][name_bytes][u8 creation][32 bytes challenge]`.
   - `recv_challenge(stream) -> Result<(String, u8, [u8; 32]), String>`: Parse name, creation, challenge.
   - `send_challenge_reply(stream, response: &[u8; 32], own_challenge: &[u8; 32])`: Build payload `[tag=3][32 bytes response][32 bytes own_challenge]`.
   - `recv_challenge_reply(stream) -> Result<([u8; 32], [u8; 32]), String>`: Parse response + challenge.
   - `send_challenge_ack(stream, response: &[u8; 32])`: Build payload `[tag=4][32 bytes response]`.
   - `recv_challenge_ack(stream) -> Result<[u8; 32], String>`: Parse response.

5. **`perform_handshake` function**:
   ```rust
   fn perform_handshake(
       stream: &mut (impl Read + Write),
       state: &NodeState,
       is_initiator: bool,
   ) -> Result<(String, u8), String>
   ```
   - **Initiator flow**: send_name -> recv_challenge (get their name, creation, challenge) -> compute_response to their challenge -> generate own challenge -> send_challenge_reply -> recv_challenge_ack -> verify_response to own challenge -> return (remote_name, remote_creation)
   - **Acceptor flow**: recv_name (get their name, creation) -> generate challenge -> send_challenge (with own name, creation, challenge) -> recv_challenge_reply -> verify_response (if fail, return `Err("cookie mismatch: authentication failed")`) -> compute_response to their challenge -> send_challenge_ack -> return (remote_name, remote_creation)
   - On any I/O error, return `Err` with descriptive message.
   - On cookie mismatch, return `Err("cookie mismatch: authentication failed from <remote_name>")`.

6. **Simultaneous connection tiebreaker**: In the acceptor flow, after receiving the remote name, check if we already have a pending outgoing connection to that node. If so, apply the tiebreaker: the node with the lexicographically smaller name keeps its outgoing connection, the other drops. For Phase 64, implement this as a check in `NodeState.sessions` -- if the remote name already has a session, reject the incoming connection with `Err("already connected")`.

Add unit tests for the HMAC functions:
- `test_compute_response_deterministic` -- same inputs produce same output
- `test_verify_response_correct` -- correct response verifies
- `test_verify_response_wrong_cookie` -- wrong cookie fails verification
  </action>
  <verify>
Run `cargo test -p snow-rt -- test_compute_response --nocapture` and `cargo test -p snow-rt -- test_verify_response --nocapture` -- HMAC tests pass.
Run `cargo build -p snow-rt 2>&1 | head -50` -- no compile errors.
  </verify>
  <done>
Binary handshake protocol with 4-message exchange is implemented. HMAC-SHA256 challenge/response uses constant-time comparison via `verify_slice`. Handshake handles both initiator and acceptor flows. HMAC unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: snow_node_connect and accept loop integration</name>
  <files>crates/snow-rt/src/dist/node.rs</files>
  <action>
1. **Flesh out NodeSession struct** (expand the placeholder from Plan 01):
   - `remote_name: String`
   - `remote_creation: u8`
   - `node_id: u16` -- assigned by local NodeState
   - `stream: Arc<Mutex<NodeStream>>` -- the TLS stream, shared between writer and reader threads
   - `shutdown: Arc<AtomicBool>` -- signals reader/heartbeat threads to stop
   - `connected_at: Instant`

2. **NodeStream enum** (follow WsStream pattern from `ws/server.rs`):
   ```rust
   pub(crate) enum NodeStream {
       ServerTls(StreamOwned<rustls::ServerConnection, TcpStream>),
       ClientTls(StreamOwned<rustls::ClientConnection, TcpStream>),
   }
   ```
   Implement `Read` and `Write` for `NodeStream` by delegating to the inner stream. The server variant is used when we accepted the connection; the client variant when we initiated it.

3. **`snow_node_connect` extern "C" function**:
   ```rust
   #[no_mangle]
   pub extern "C" fn snow_node_connect(
       name_ptr: *const u8,
       name_len: u64,
   ) -> i64
   ```
   - Extract the target node address string (format: "name@host:port").
   - Check NODE_STATE is initialized (return -1 if not: "node not started").
   - Parse host:port from the target. Port is REQUIRED in the connect address.
   - Open a TCP connection to host:port (`TcpStream::connect`). On failure return -2.
   - Wrap in TLS client connection using `state.tls_client_config`. Create `rustls::ClientConnection::new(config, server_name)` where server_name is `"snow-node".try_into().unwrap()` (the actual name doesn't matter since we skip verification). Wrap in `StreamOwned::new(client_conn, tcp_stream)`.
   - Call `perform_handshake(&mut tls_stream, state, true /* initiator */)`. On failure (wrong cookie or I/O error), return -3.
   - Assign a node_id via `state.assign_node_id()`.
   - Create `NodeSession` with the TLS stream wrapped in `Arc<Mutex<NodeStream::ClientTls(stream)>>`.
   - Insert session into `state.sessions` and `state.node_id_map`.
   - Plan 03 will spawn reader + heartbeat threads for this session.
   - Return 0 on success.

4. **Wire up the accept loop** (from Plan 01's stub):
   - Replace the `// Plan 02: perform_handshake() here` comment in the accept loop.
   - For each accepted TcpStream:
     - Wrap in TLS server connection using `state.tls_server_config`. Create `rustls::ServerConnection::new(config)`, wrap in `StreamOwned::new(server_conn, tcp_stream)`.
     - Call `perform_handshake(&mut tls_stream, state, false /* acceptor */)`.
     - On failure: log warning (eprintln) with the error, drop the connection, continue accepting.
     - On success: create NodeSession with `NodeStream::ServerTls(stream)`, assign node_id, insert into sessions/node_id_map.
     - Plan 03 will spawn reader + heartbeat threads.

5. **`register_session` helper** (private):
   - Takes remote_name, remote_creation, node_id, stream, and inserts into NodeState.
   - Returns `Arc<NodeSession>`.
   - Checks for duplicate connections (same remote_name already in sessions). If duplicate, apply tiebreaker: node with lexicographically smaller name keeps its connection. If we lose, return error.
  </action>
  <verify>
Run `cargo build -p snow-rt 2>&1 | head -50` -- no compile errors.
Run `cargo test -p snow-rt 2>&1 | tail -20` -- all existing tests still pass.
  </verify>
  <done>
`snow_node_connect` opens TCP connection, wraps in TLS, performs HMAC-SHA256 handshake, and registers the authenticated session. Accept loop performs handshake on incoming connections. NodeStream enum supports both server and client TLS variants. Wrong cookies produce clear error messages. Duplicate connections are detected and resolved.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles without errors
2. `cargo test -p snow-rt -- test_compute_response` passes
3. `cargo test -p snow-rt -- test_verify_response` passes
4. `perform_handshake` handles both initiator and acceptor flows
5. `snow_node_connect` returns -3 on cookie mismatch (not crash/panic)
6. Accept loop wired to perform handshake on incoming connections
7. All existing tests still pass (no regressions)
</verification>

<success_criteria>
- HMAC-SHA256 challenge/response with constant-time comparison implemented
- 4-message binary handshake protocol (NAME, CHALLENGE, REPLY, ACK) working
- `snow_node_connect` extern "C" callable from LLVM codegen
- Wrong cookie produces `Err("cookie mismatch: authentication failed")`, not panic
- Incoming connections on listener complete the same handshake
- NodeSession created and registered for authenticated connections
- TLS encryption active on all inter-node connections (NODE-03)
</success_criteria>

<output>
After completion, create `.planning/phases/64-node-connection-authentication/64-02-SUMMARY.md`
</output>
