---
phase: 53-sqlite-driver
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/Cargo.toml
  - crates/snow-rt/src/db/mod.rs
  - crates/snow-rt/src/db/sqlite.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "snow_sqlite_open accepts a SnowString path and returns a SnowResult with an opaque u64 handle (tag 0) or error string (tag 1)"
    - "snow_sqlite_close recovers the Box<SqliteConn> from u64 handle and calls sqlite3_close"
    - "snow_sqlite_execute prepares, binds text params, steps, and returns SnowResult<Int, String> with rows affected"
    - "snow_sqlite_query prepares, binds text params, iterates rows, and returns SnowResult<List<Map<String, String>>, String>"
    - "Sqlite module is registered in typeck with open/close/query/execute function signatures"
    - "LLVM intrinsics are declared for all 4 snow_sqlite_* functions"
    - "MIR known_functions and map_builtin_name map sqlite_open -> snow_sqlite_open etc."
    - "SqliteConn type lowers to MirType::Int (i64) for GC safety"
  artifacts:
    - path: "crates/snow-rt/src/db/sqlite.rs"
      provides: "SQLite C FFI wrapper functions"
      contains: "snow_sqlite_open"
    - path: "crates/snow-rt/src/db/mod.rs"
      provides: "db module declaration"
      contains: "pub mod sqlite"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for sqlite functions"
      contains: "snow_sqlite_open"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Sqlite module in stdlib_modules"
      contains: "Sqlite"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "known_functions and name mapping"
      contains: "snow_sqlite_open"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Sqlite module functions map to known_functions entries"
      pattern: "sqlite_open.*snow_sqlite_open"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "known_functions reference LLVM-declared intrinsics"
      pattern: "snow_sqlite_open"
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/db/sqlite.rs"
      via: "LLVM declarations match extern C function signatures"
      pattern: "snow_sqlite_open"
---

<objective>
Implement the SQLite driver runtime functions and register them through the full compiler pipeline.

Purpose: Enable Snow programs to open SQLite databases, execute parameterized queries, and retrieve results. This plan creates the foundation: 4 extern C runtime functions wrapping the SQLite C API via `libsqlite3-sys`, plus the typechecker, MIR, and LLVM registration needed to compile Snow code that calls `Sqlite.open`, `Sqlite.close`, `Sqlite.query`, and `Sqlite.execute`.

Output: Working runtime functions with full compiler pipeline registration. Not yet E2E tested (Plan 02).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-sqlite-driver/53-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Runtime -- SQLite C FFI wrapper functions and dependency setup</name>
  <files>
    crates/snow-rt/Cargo.toml
    crates/snow-rt/src/db/mod.rs
    crates/snow-rt/src/db/sqlite.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
**1. Add `libsqlite3-sys` dependency to `crates/snow-rt/Cargo.toml`:**

```toml
libsqlite3-sys = { version = "0.36", features = ["bundled"] }
```

Add under `[dependencies]`. The `bundled` feature compiles SQLite from the C amalgamation source, producing a static library with zero system dependencies.

**2. Create `crates/snow-rt/src/db/mod.rs`:**

```rust
pub mod sqlite;
```

**3. Create `crates/snow-rt/src/db/sqlite.rs`:**

Implement 4 extern C functions following the existing `snow_http_router` pattern (Box::into_raw for opaque handles) and `SnowResult` return convention (tag 0 = Ok, tag 1 = Err).

Use `libsqlite3_sys::*` for all SQLite C API calls. Use `std::ffi::CString` for null-terminated string conversion from SnowString. Use `std::ffi::CStr` for reading error messages from `sqlite3_errmsg`.

**Key design decisions (from research):**
- Connection handle is `u64` (not `*mut u8`) for GC safety (SQLT-07)
- All params bound as text via `sqlite3_bind_text` with `SQLITE_TRANSIENT` (-1)
- Use a `StmtGuard` Drop wrapper to prevent statement leaks on error paths
- Convert SnowString to CString before passing to SQLite (SnowString is length-prefixed, not null-terminated)

**Functions to implement:**

```rust
use libsqlite3_sys::*;
use std::ffi::{CStr, CString};

struct SqliteConn {
    db: *mut sqlite3,
}

/// RAII guard ensuring sqlite3_finalize is always called
struct StmtGuard {
    stmt: *mut sqlite3_stmt,
}
impl Drop for StmtGuard {
    fn drop(&mut self) {
        unsafe { sqlite3_finalize(self.stmt); }
    }
}
```

**`snow_sqlite_open(path: *const SnowString) -> *mut u8`:**
1. Extract path string from SnowString (read len + data, convert to &str)
2. Create CString from the path
3. Call `sqlite3_open_v2(cstr.as_ptr(), &mut db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, std::ptr::null())`
4. On success (rc == SQLITE_OK): `Box::into_raw(Box::new(SqliteConn { db })) as u64`, return via `alloc_result(0, handle as *mut u8)`
5. On error: get error message via `CStr::from_ptr(sqlite3_errmsg(db))`, convert to SnowString, call `sqlite3_close(db)`, return `alloc_result(1, err_string_ptr)`

Use `crate::io::alloc_result` for constructing SnowResult. The SnowString read pattern is:
```rust
let path_str = unsafe {
    let len = *(path as *const u64);
    let data_ptr = (path as *const u8).add(8);
    let slice = std::slice::from_raw_parts(data_ptr, len as usize);
    std::str::from_utf8_unchecked(slice)
};
```

**`snow_sqlite_close(conn_handle: u64)`:**
1. `let conn = unsafe { Box::from_raw(conn_handle as *mut SqliteConn) }`
2. `unsafe { sqlite3_close(conn.db); }`
3. Box drops, freeing Rust memory

**`snow_sqlite_execute(conn_handle: u64, sql: *const SnowString, params: *mut u8) -> *mut u8`:**
1. Recover conn: `let conn = unsafe { &*(conn_handle as *const SqliteConn) }` (borrow, don't consume)
2. Convert sql SnowString to CString
3. Call `sqlite3_prepare_v2(conn.db, sql_cstr.as_ptr(), -1, &mut stmt, std::ptr::null_mut())`
4. Wrap stmt in StmtGuard immediately
5. Bind params from the SnowList:
   - Read SnowList: `len` at offset 0 (u64), then `len` pointers to SnowString at offset 8
   - For each param i: extract SnowString text, create CString, call `sqlite3_bind_text(stmt, (i+1) as c_int, cstr.as_ptr(), -1, SQLITE_TRANSIENT)` where `SQLITE_TRANSIENT` is `std::mem::transmute::<isize, extern "C" fn(*mut std::ffi::c_void)>(-1isize)`
6. Step: `sqlite3_step(stmt)` -- expect SQLITE_DONE
7. Get changes: `sqlite3_changes(conn.db)` as i64
8. StmtGuard drops (finalizes statement)
9. Return `alloc_result(0, rows_affected as *mut u8)` for Ok, or `alloc_result(1, err_string)` on any error

**`snow_sqlite_query(conn_handle: u64, sql: *const SnowString, params: *mut u8) -> *mut u8`:**
1. Same setup as execute: recover conn, prepare statement, bind params
2. Get column count: `sqlite3_column_count(stmt)`
3. Get column names: for each col, `CStr::from_ptr(sqlite3_column_name(stmt, i))` -> String
4. Create result SnowList (use `snow_list_new()` from `crate::collections::list`)
5. Loop `sqlite3_step(stmt)` while result == SQLITE_ROW:
   - Create a SnowMap for this row (use `crate::collections::map::snow_map_new()`)
   - For each column: `sqlite3_column_text(stmt, i)` -> CStr -> SnowString, then `snow_map_put(map, col_name_snow_str, value_snow_str)`
   - Append map to list: `snow_list_append(list, map as *mut u8)`
6. Handle NULL columns: if `sqlite3_column_type(stmt, i) == SQLITE_NULL`, store empty string `""`
7. StmtGuard drops
8. Return `alloc_result(0, list)` for Ok, or `alloc_result(1, err_string)` on error

**Important:** For SQLITE_TRANSIENT, define it as:
```rust
const SQLITE_TRANSIENT_VALUE: isize = -1;
// When calling sqlite3_bind_text, pass:
// unsafe { std::mem::transmute::<isize, Option<unsafe extern "C" fn(*mut std::ffi::c_void)>>(SQLITE_TRANSIENT_VALUE) }
```

**SnowList layout** (from `crate::collections::list`): The SnowList is `{ len: u64, items: [*mut u8; len] }`. Use `snow_list_new()` to create, `snow_list_append(list, item)` to append.

**SnowMap**: Use `snow_map_new()` (returns string-keyed map by default for Snow's typed map system) and `snow_map_put(map, key, value)`. Check how `snow_map_new_typed` works -- for string-keyed maps, pass type indicator 1.

**4. Update `crates/snow-rt/src/lib.rs`:**

Add `pub mod db;` to the module declarations.

Add re-exports:
```rust
pub use db::sqlite::{
    snow_sqlite_open, snow_sqlite_close, snow_sqlite_execute, snow_sqlite_query,
};
```

**5. Verify:** `cargo build -p snow-rt` compiles successfully. This confirms:
- `libsqlite3-sys` bundled builds the SQLite amalgamation
- All FFI function signatures type-check
- Module structure is correct
  </action>
  <verify>
Run `cargo build -p snow-rt` -- must compile without errors.
Run `cargo test -p snow-rt` -- existing tests must still pass.
  </verify>
  <done>
Four extern C functions (snow_sqlite_open, snow_sqlite_close, snow_sqlite_execute, snow_sqlite_query) compile in snow-rt with libsqlite3-sys bundled. Module db/sqlite.rs exists and is re-exported from lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline -- intrinsics, type checker, and MIR lowering for Sqlite module</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
Register the Sqlite module through the 4-file compiler pipeline, following the exact HTTP module pattern from Phase 51.

**1. `crates/snow-codegen/src/codegen/intrinsics.rs` -- Add LLVM function declarations:**

In `declare_intrinsics()`, add after the HTTP section:

```rust
// ── SQLite ──────────────────────────────────────────────────────

// snow_sqlite_open(path: ptr) -> ptr (SnowResult)
module.add_function("snow_sqlite_open",
    ptr_type.fn_type(&[ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_sqlite_close(conn: i64) -> void
module.add_function("snow_sqlite_close",
    void_type.fn_type(&[i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_sqlite_execute(conn: i64, sql: ptr, params: ptr) -> ptr (SnowResult)
module.add_function("snow_sqlite_execute",
    ptr_type.fn_type(&[i64_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));

// snow_sqlite_query(conn: i64, sql: ptr, params: ptr) -> ptr (SnowResult)
module.add_function("snow_sqlite_query",
    ptr_type.fn_type(&[i64_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));
```

Note: `conn` parameter is `i64_type` (not `ptr_type`) because SqliteConn handle is u64/i64 for GC safety.

**2. `crates/snow-typeck/src/builtins.rs` -- Register SqliteConn type and function signatures:**

In `register_builtins()`, add an opaque `SqliteConn` type. This is used as the connection handle type in function signatures. It should map to Int at the MIR level.

```rust
// SqliteConn opaque type -- lowered to Int (i64) for GC safety
let sqlite_conn_t = Ty::Con("SqliteConn".to_string(), vec![]);
```

Register function types for sqlite_open, sqlite_close, sqlite_execute, sqlite_query:
- `sqlite_open`: `(String) -> Result<SqliteConn, String>`
- `sqlite_close`: `(SqliteConn) -> Unit`
- `sqlite_execute`: `(SqliteConn, String, List<String>) -> Result<Int, String>`
- `sqlite_query`: `(SqliteConn, String, List<String>) -> Result<List<Map<String, String>>, String>`

Follow the existing pattern for registering built-in function types (look at how http_router, http_serve etc. are registered).

**3. `crates/snow-typeck/src/infer.rs` -- Register Sqlite module:**

In `stdlib_modules()`, add a Sqlite module entry:

```rust
let sqlite_conn_t = Ty::Con("SqliteConn".to_string(), vec![]);
let mut sqlite_mod = HashMap::new();
sqlite_mod.insert("open".to_string(), Scheme::mono(Ty::fun(
    vec![Ty::string()],
    Ty::result(sqlite_conn_t.clone(), Ty::string())
)));
sqlite_mod.insert("close".to_string(), Scheme::mono(Ty::fun(
    vec![sqlite_conn_t.clone()],
    Ty::Tuple(vec![])
)));
sqlite_mod.insert("execute".to_string(), Scheme::mono(Ty::fun(
    vec![sqlite_conn_t.clone(), Ty::string(), Ty::list(Ty::string())],
    Ty::result(Ty::int(), Ty::string())
)));
sqlite_mod.insert("query".to_string(), Scheme::mono(Ty::fun(
    vec![sqlite_conn_t.clone(), Ty::string(), Ty::list(Ty::string())],
    Ty::result(Ty::list(Ty::map(Ty::string(), Ty::string())), Ty::string())
)));
modules.insert("Sqlite".to_string(), sqlite_mod);
```

Add `"Sqlite"` to `STDLIB_MODULE_NAMES` array.

**4. `crates/snow-codegen/src/mir/lower.rs` -- Register known functions and name mapping:**

In the `known_functions` initialization section:

```rust
// SQLite
self.known_functions.insert("snow_sqlite_open".to_string(),
    MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_sqlite_close".to_string(),
    MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Unit)));
self.known_functions.insert("snow_sqlite_execute".to_string(),
    MirType::FnPtr(vec![MirType::Int, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_sqlite_query".to_string(),
    MirType::FnPtr(vec![MirType::Int, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
```

Note: The conn parameter is `MirType::Int` (i64) for GC safety. The path/sql/params are `MirType::Ptr`.

In `map_builtin_name()`, add:
```rust
"sqlite_open" => "snow_sqlite_open".to_string(),
"sqlite_close" => "snow_sqlite_close".to_string(),
"sqlite_execute" => "snow_sqlite_execute".to_string(),
"sqlite_query" => "snow_sqlite_query".to_string(),
```

Add `"Sqlite"` to `STDLIB_MODULES` array.

**Critical: SqliteConn type lowering.** In the MIR type lowering, ensure that `SqliteConn` type is lowered to `MirType::Int` (not `MirType::Ptr`). Check how other opaque types are lowered in `lower_type()` or equivalent. If there's no existing mapping for `SqliteConn`, add one:
- In the type lowering match arm for `Ty::Con(name, _)`: add `"SqliteConn" => MirType::Int`

This is critical for SQLT-07 (GC safety). If the handle were `MirType::Ptr`, the GC could try to trace through it, causing corruption.
  </action>
  <verify>
Run `cargo build -p snow-codegen` -- must compile.
Run `cargo test -p snow-codegen` -- existing tests must pass.
Run `cargo test -p snow-typeck` -- existing tests must pass.
Run `cargo build` (full workspace) -- everything must compile together.
  </verify>
  <done>
Sqlite module registered in typechecker (stdlib_modules + STDLIB_MODULE_NAMES) with open/close/execute/query functions. LLVM intrinsics declared for all 4 functions. MIR known_functions and map_builtin_name entries added. SqliteConn type lowers to MirType::Int. Full workspace compiles.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- full workspace compiles with libsqlite3-sys bundled
2. `cargo test` -- all existing tests pass (no regressions)
3. Verify `libsqlite3-sys` bundled compiled SQLite from source (check build output for `cc` invocation of sqlite3.c)
4. Grep for `snow_sqlite_open` in all 4 pipeline files (db/sqlite.rs, intrinsics.rs, lower.rs) confirms three-point registration
5. Grep for `"Sqlite"` in infer.rs and lower.rs confirms module registration
</verification>

<success_criteria>
- snow-rt builds with `libsqlite3-sys` bundled (zero system dependencies for SQLite)
- 4 extern C functions exist: snow_sqlite_open, snow_sqlite_close, snow_sqlite_execute, snow_sqlite_query
- Full compiler pipeline registered: intrinsics, typeck, MIR lowering
- SqliteConn type maps to MirType::Int (i64) for GC safety
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/53-sqlite-driver/53-01-SUMMARY.md`
</output>
