---
phase: 53-sqlite-driver
plan: 02
type: execute
wave: 2
depends_on: ["53-01"]
files_modified:
  - tests/e2e/stdlib_sqlite.snow
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "Snow program can open a SQLite database, create a table, insert rows, and query them back"
    - "Query results are List<Map<String, String>> with column names as keys"
    - "Execute returns rows affected count as Int"
    - "Parameterized queries prevent SQL injection (params bound via ? placeholders)"
    - "Compiled binary has zero external SQLite dependencies (bundled)"
  artifacts:
    - path: "tests/e2e/stdlib_sqlite.snow"
      provides: "Snow fixture testing full SQLite CRUD lifecycle"
      contains: "Sqlite.open"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "Rust E2E test harness invoking snowc build + run"
      contains: "e2e_sqlite"
  key_links:
    - from: "tests/e2e/stdlib_sqlite.snow"
      to: "crates/snow-rt/src/db/sqlite.rs"
      via: "Sqlite.open/close/query/execute calls compile to snow_sqlite_* extern C functions"
      pattern: "Sqlite\\.open"
    - from: "crates/snowc/tests/e2e_stdlib.rs"
      to: "tests/e2e/stdlib_sqlite.snow"
      via: "read_fixture loads Snow source, compile_and_run executes it"
      pattern: "stdlib_sqlite"
---

<objective>
End-to-end test verifying the full SQLite driver pipeline: Snow source -> compiler -> linked binary -> SQLite operations.

Purpose: Prove all 7 SQLT requirements work end-to-end. The test compiles a Snow program that opens an in-memory SQLite database, creates a table, inserts rows with parameterized queries, queries them back, and prints results. The Rust test harness verifies the output.

Output: Passing E2E test confirming SQLite driver works from Snow user code.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-sqlite-driver/53-RESEARCH.md
@.planning/phases/53-sqlite-driver/53-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Snow fixture and E2E test for SQLite CRUD lifecycle</name>
  <files>
    tests/e2e/stdlib_sqlite.snow
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
**1. Create `tests/e2e/stdlib_sqlite.snow`:**

Write a Snow program that exercises all SQLite operations. Use `:memory:` for the database path (in-memory SQLite database, no filesystem cleanup needed).

```snow
fn main() do
  # SQLT-01: Open database
  let db = Sqlite.open(":memory:")?

  # SQLT-04: Execute DDL
  let _ = Sqlite.execute(db, "CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age TEXT NOT NULL)", [])?

  # SQLT-04 + SQLT-05: Insert with parameterized queries
  let inserted1 = Sqlite.execute(db, "INSERT INTO users (name, age) VALUES (?, ?)", ["Alice", "30"])?
  println(Int.to_string(inserted1))

  let inserted2 = Sqlite.execute(db, "INSERT INTO users (name, age) VALUES (?, ?)", ["Bob", "25"])?
  println(Int.to_string(inserted2))

  # SQLT-03: Query rows
  let rows = Sqlite.query(db, "SELECT name, age FROM users ORDER BY name", [])?
  # rows is List<Map<String, String>>

  # Print each row's name and age
  List.map(rows, fn(row) do
    let name = Map.get(row, "name")
    let age = Map.get(row, "age")
    case name do
      Some(n) -> case age do
        Some(a) -> println(String.concat(String.concat(n, ":"), a))
        None -> println("no age")
      end
      None -> println("no name")
    end
  end)

  # SQLT-05: Parameterized query
  let filtered = Sqlite.query(db, "SELECT name FROM users WHERE age = ?", ["30"])?
  List.map(filtered, fn(row) do
    let name = Map.get(row, "name")
    case name do
      Some(n) -> println(String.concat("filtered:", n))
      None -> println("no name")
    end
  end)

  # SQLT-02: Close connection
  Sqlite.close(db)

  println("done")
end
```

**Important notes on the Snow fixture:**
- Use `?` operator for Result unwrapping (established pattern from Phase 14)
- All params are `List<String>` -- pass `["30"]` not `[30]`
- `Map.get` returns `Option<String>`, use `case` to unwrap
- Column types are all TEXT in the table definition to match the string-only param/result model
- `List.map` is used for iteration (Snow has no for-each loop; map with side effects is the pattern)
- Use `Int.to_string` to convert the execute return value for printing

**2. Add E2E test to `crates/snowc/tests/e2e_stdlib.rs`:**

Add a new test function at the end of the file, following the existing pattern (e.g., `e2e_http_middleware`):

```rust
#[test]
fn e2e_sqlite() {
    let source = read_fixture("stdlib_sqlite.snow");
    let output = compile_and_run(&source);
    // Verify insert counts
    assert!(output.contains("1"), "First insert should affect 1 row");
    // Verify query results
    assert!(output.contains("Alice:30"), "Should find Alice with age 30");
    assert!(output.contains("Bob:25"), "Should find Bob with age 25");
    // Verify parameterized query
    assert!(output.contains("filtered:Alice"), "Filtered query should find Alice");
    // Verify completion
    assert!(output.contains("done"), "Program should complete successfully");
}
```

Use `compile_and_run` (not the HTTP-specific helper) since SQLite doesn't need a server.

**Verification approach:** The test compiles the Snow fixture with `snowc build`, runs the resulting binary, and asserts on stdout content. The binary uses in-memory SQLite (`:memory:`) so there's no filesystem state to clean up.

**Expected stdout:**
```
1
1
Alice:30
Bob:25
filtered:Alice
done
```
  </action>
  <verify>
Run `cargo test -p snowc --test e2e_stdlib e2e_sqlite -- --nocapture` -- must pass.
The test compiles a Snow program using Sqlite.open/execute/query/close and verifies correct output.
  </verify>
  <done>
E2E test passes: Snow program opens in-memory SQLite database, creates table, inserts rows with parameterized queries, queries them back with correct column names and values, filters with parameterized WHERE clause, and closes connection. All stdout assertions pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snowc --test e2e_stdlib e2e_sqlite` -- E2E test passes
2. Snow fixture demonstrates all 7 SQLT requirements:
   - SQLT-01: Sqlite.open(":memory:") succeeds
   - SQLT-02: Sqlite.close(db) runs without error
   - SQLT-03: Sqlite.query returns List<Map<String, String>> with correct data
   - SQLT-04: Sqlite.execute returns Int (rows affected)
   - SQLT-05: ? placeholders with List<String> params work for both execute and query
   - SQLT-06: Binary compiles and runs without system SQLite (bundled)
   - SQLT-07: Database handle survives across multiple function calls (implicit GC safety)
3. `cargo test` -- full test suite passes (no regressions)
</verification>

<success_criteria>
- E2E test compiles Snow program, runs binary, verifies stdout
- Insert operations return correct rows-affected counts
- Query results contain correct column names and values
- Parameterized queries filter correctly
- No external SQLite dependency needed (bundled into binary)
</success_criteria>

<output>
After completion, create `.planning/phases/53-sqlite-driver/53-02-SUMMARY.md`
</output>
