---
phase: 100-relationships-preloading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "User.__relationship_meta__() returns List<String> with 5-field encoded strings containing kind, association name, target struct, foreign key, and target table"
    - "FK convention: has_many/has_one uses {owner_lowercase}_id, belongs_to uses {assoc_name}_id"
    - "Target table uses naive pluralization: {target_lowercase}s"
    - "Existing __relationships__() output unchanged (backward compatible)"
  artifacts:
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "__relationship_meta__ type signature registration"
      contains: "__relationship_meta__"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Enhanced metadata generation with FK and target table"
      contains: "__relationship_meta__"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "E2E tests for relationship_meta output"
      contains: "relationship_meta"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "Schema derive registration"
      pattern: "__relationship_meta__"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/meshc/tests/e2e.rs"
      via: "MIR function generation verified by e2e"
      pattern: "relationship_meta"
---

<objective>
Add `__relationship_meta__()` schema metadata function that returns enhanced 5-field encoded relationship strings ("kind:name:target:fk:target_table") containing the foreign key column and target table name needed by the preloader.

Purpose: The existing `__relationships__()` returns "kind:name:target" which lacks the FK column and target table information that `Repo.preload` needs to build its batch IN queries. This plan adds a new metadata function without modifying the existing one.

Output: `__relationship_meta__()` callable on any Schema-derived struct, returning List<String> with full preloading metadata.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/100-relationships-preloading/100-RESEARCH.md

Key source files:
@crates/mesh-typeck/src/infer.rs (lines 2564-2600 -- Schema metadata registration)
@crates/mesh-codegen/src/mir/lower.rs (lines 4485-4589 -- generate_schema_metadata)
@crates/mesh-codegen/src/mir/lower.rs (lines 6424-6441 -- Schema field access resolution)
@crates/mesh-typeck/src/infer.rs (lines 5897-5909 -- Schema field access typeck)
@crates/meshc/tests/e2e.rs (lines 3303-3330 -- existing relationship e2e test)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add __relationship_meta__() to compiler pipeline (typeck + MIR + field access resolution)</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
  </files>
  <action>
**Type checker (infer.rs):**

1. In the Schema derive block (~line 2584, after `__relationships__` registration), add:
```rust
// __relationship_meta__ :: () -> List<String>
// Each relationship encoded as "kind:name:target:fk:target_table" string.
let meta_fn_name = format!("{}.__relationship_meta__", name);
env.insert(meta_fn_name, Scheme::mono(Ty::fun(vec![], Ty::list(Ty::string()))));
```

2. In the field access resolution check (~line 5899), add `"__relationship_meta__"` to the condition:
```rust
if field_name == "__table__" || field_name == "__fields__"
    || field_name == "__primary_key__" || field_name == "__relationships__"
    || field_name == "__field_types__" || field_name == "__relationship_meta__"
    || (field_name.starts_with("__") && field_name.ends_with("_col__"))
```

**MIR lowerer (lower.rs):**

3. In `generate_schema_metadata()` (~after line 4589, after the `__relationships__` block), add a new `__relationship_meta__` function. This generates the 5-field encoding:

```rust
// ── __relationship_meta__() ──────────────────────────────────────
// Returns List<String> where each string is "kind:name:target:fk:target_table".
let meta_elements: Vec<MirExpr> = relationships
    .iter()
    .filter_map(|rel| {
        let kind = rel.kind_text()?;
        let assoc = rel.assoc_name()?;
        let target = rel.target_type()?;

        // Infer foreign key by convention:
        // - belongs_to :user, User -> fk is "user_id" (assoc_name + "_id")
        // - has_many :posts, Post on User -> fk is "user_id" (owner_lowercase + "_id")
        // - has_one :profile, Profile on User -> fk is "user_id" (owner_lowercase + "_id")
        let fk = match kind.as_str() {
            "belongs_to" => format!("{}_id", assoc),
            "has_many" | "has_one" => format!("{}_id", name.to_lowercase()),
            _ => return None,
        };

        // Infer target table by naive pluralization (lowercase + "s")
        let target_table = format!("{}s", target.to_lowercase());

        Some(MirExpr::StringLit(
            format!("{}:{}:{}:{}:{}", kind, assoc, target, fk, target_table),
            MirType::String,
        ))
    })
    .collect();

let meta_fn_name = format!("{}____relationship_meta__", name);
self.functions.push(MirFunction {
    name: meta_fn_name.clone(),
    params: vec![],
    return_type: MirType::Ptr,
    body: MirExpr::ListLit {
        elements: meta_elements,
        ty: MirType::Ptr,
    },
    is_closure_fn: false,
    captures: vec![],
    has_tail_calls: false,
});
self.known_functions.insert(
    meta_fn_name,
    MirType::FnPtr(vec![], Box::new(MirType::Ptr)),
);
```

4. In the Schema metadata field access resolution (~line 6432), add `"__relationship_meta__"` to the condition:
```rust
if field == "__table__" || field == "__fields__"
    || field == "__primary_key__" || field == "__relationships__"
    || field == "__field_types__" || field == "__relationship_meta__"
    || (field.starts_with("__") && field.ends_with("_col__"))
```

IMPORTANT: Do NOT modify the existing `__relationships__()` function. The new function is an ADDITION alongside it. The `name` variable in `generate_schema_metadata` is the struct name (e.g. "User"), which is used for FK inference on has_many/has_one.
  </action>
  <verify>
Run `cargo build --workspace 2>&1 | tail -5` -- should compile with zero errors.
Run `cargo test -p meshc --test e2e -- e2e_deriving_schema_relationships --exact 2>&1 | tail -3` -- existing relationship test still passes unchanged.
  </verify>
  <done>
`__relationship_meta__` registered in typeck, generated in MIR with 5-field encoding, and resolvable via field access. Existing `__relationships__` tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for __relationship_meta__() output</name>
  <files>
    crates/meshc/tests/e2e.rs
  </files>
  <action>
Add three e2e tests after the existing `e2e_deriving_schema_relationships` test (~line 3330):

**Test 1: has_many relationship metadata**
```rust
/// __relationship_meta__() returns 5-field encoded strings with FK and target table.
#[test]
fn e2e_relationship_meta_has_many() {
    let output = compile_and_run(r#"
struct User do
  id :: String
  name :: String
  has_many :posts, Post
end deriving(Schema)

struct Post do
  id :: String
  title :: String
  user_id :: String
  belongs_to :user, User
end deriving(Schema)

fn main() do
  let meta = User.__relationship_meta__()
  let m0 = List.get(meta, 0)
  println(m0)
  let post_meta = Post.__relationship_meta__()
  let pm0 = List.get(post_meta, 0)
  println(pm0)
end
"#);
    assert_eq!(output, "has_many:posts:Post:user_id:posts\nbelongs_to:user:User:user_id:users\n");
}
```
The has_many FK is "user_id" (owner "User" lowercased + "_id"). The belongs_to FK is "user_id" (assoc "user" + "_id"). Target tables are "posts" and "users" respectively.

**Test 2: has_one relationship metadata**
```rust
/// __relationship_meta__() for has_one relationships.
#[test]
fn e2e_relationship_meta_has_one() {
    let output = compile_and_run(r#"
struct User do
  id :: String
  name :: String
  has_one :profile, Profile
end deriving(Schema)

struct Profile do
  id :: String
  bio :: String
  user_id :: String
  belongs_to :user, User
end deriving(Schema)

fn main() do
  let meta = User.__relationship_meta__()
  let m0 = List.get(meta, 0)
  println(m0)
end
"#);
    assert_eq!(output, "has_one:profile:Profile:user_id:profiles\n");
}
```
has_one FK is "user_id" (owner "User" lowercased + "_id"), target table "profiles".

**Test 3: multiple relationships on one struct**
```rust
/// __relationship_meta__() with multiple relationships on one struct.
#[test]
fn e2e_relationship_meta_multiple() {
    let output = compile_and_run(r#"
struct User do
  id :: String
  name :: String
  has_many :posts, Post
  has_one :profile, Profile
end deriving(Schema)

struct Post do
  id :: String
  title :: String
end deriving(Schema)

struct Profile do
  id :: String
  bio :: String
end deriving(Schema)

fn main() do
  let meta = User.__relationship_meta__()
  let m0 = List.get(meta, 0)
  let m1 = List.get(meta, 1)
  println(m0)
  println(m1)
end
"#);
    assert_eq!(output, "has_many:posts:Post:user_id:posts\nhas_one:profile:Profile:user_id:profiles\n");
}
```
  </action>
  <verify>
Run `cargo test -p meshc --test e2e -- e2e_relationship_meta 2>&1 | tail -5` -- all 3 new tests pass.
Run `cargo test -p meshc --test e2e 2>&1 | tail -3` -- full e2e suite passes with zero regressions.
  </verify>
  <done>
Three e2e tests verify: has_many FK inference ("user_id" from owner struct), belongs_to FK inference ("user_id" from assoc name), has_one FK inference, target table pluralization, and multiple relationships on one struct. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` compiles cleanly
2. `cargo test -p meshc --test e2e -- e2e_deriving_schema_relationships` -- existing test passes (backward compat)
3. `cargo test -p meshc --test e2e -- e2e_relationship_meta` -- all 3 new tests pass
4. `cargo test -p meshc --test e2e` -- full suite passes with zero regressions
</verification>

<success_criteria>
- `__relationship_meta__()` callable on Schema-derived structs via `User.__relationship_meta__()`
- Returns List<String> with "kind:name:target:fk:target_table" encoding
- FK inference: has_many/has_one use {owner_lowercase}_id, belongs_to uses {assoc_name}_id
- Target table: naive pluralization {target_lowercase}s
- Existing `__relationships__()` output unchanged
- All e2e tests pass including 3 new ones
</success_criteria>

<output>
After completion, create `.planning/phases/100-relationships-preloading/100-01-SUMMARY.md`
</output>
