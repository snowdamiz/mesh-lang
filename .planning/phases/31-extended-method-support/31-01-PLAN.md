---
phase: 31-extended-method-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
autonomous: true

must_haves:
  truths:
    - "42.to_string() resolves through the type checker without errors (non-struct types trigger retry-based method resolution)"
    - "true.to_string() resolves through the type checker without errors"
    - "my_list.to_string() resolves through the type checker when Display is registered for List<T>"
    - "'hello'.length() resolves through the type checker via stdlib module method fallback"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Non-struct concrete type NoSuchField error + stdlib module method fallback in infer_field_access"
      contains: "NoSuchField.*Ty::Con|stdlib_modules.*method"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Display impl registration for List<T>"
      contains: "Display.*List"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "infer_call retry mechanism"
      via: "Err(NoSuchField) from infer_field_access triggers retry with is_method_call=true"
      pattern: "NoSuchField.*Ty::Con"
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "TraitRegistry.resolve_trait_method"
      via: "Display impl for List<T> enables method resolution for to_string on lists"
      pattern: "Display.*List.*to_string"
---

<objective>
Fix the type checker so method dot-syntax works on non-struct types (primitives, collections) and stdlib module functions (String.length, etc.) are callable via dot syntax.

Purpose: Phase 30 established method resolution for struct types only. The retry mechanism in infer_call works correctly, but infer_field_access returns Ok(fresh_var) for non-struct types instead of Err(NoSuchField), so the retry never triggers. Additionally, stdlib module functions like `length` are not resolved as methods. This plan fixes both gaps at the type checker level.

Output: Modified infer.rs with non-struct concrete type error and stdlib method fallback; modified builtins.rs with Display impl for List<T>.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-extended-method-support/31-RESEARCH.md
@.planning/phases/30-core-method-resolution/30-01-SUMMARY.md
@.planning/phases/30-core-method-resolution/30-02-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/builtins.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix non-struct method resolution gap and add stdlib module method fallback</name>
  <files>crates/snow-typeck/src/infer.rs</files>
  <action>
Two changes in `infer_field_access` (the function near line 3962 that handles FieldAccess expressions):

**Change 1: Fix non-struct fresh_var fallback (line 4126)**

The last line of `infer_field_access` is `Ok(ctx.fresh_var())`. This fires when the base type is not a struct and `is_method_call=false`. For concrete non-struct types (Int, Float, String, Bool, any Ty::Con or Ty::App not in the struct registry), this masks method resolution because the retry mechanism in `infer_call` only triggers on `Err(NoSuchField)`.

Replace the final `Ok(ctx.fresh_var())` with a check: if `resolved_base` is a concrete type (`Ty::Con(_)` or `Ty::App(_, _)`), return `Err(NoSuchField)` instead. Only return `Ok(ctx.fresh_var())` for truly unresolved types (`Ty::Var`).

```rust
// Before the final Ok(ctx.fresh_var()):
// For known concrete non-struct types, emit NoSuchField to trigger method retry.
match &resolved_base {
    Ty::Con(_) | Ty::App(_, _) => {
        let err = TypeError::NoSuchField {
            ty: resolved_base,
            field_name,
            span: fa.syntax().text_range(),
        };
        ctx.errors.push(err.clone());
        return Err(err);
    }
    _ => {} // Ty::Var, Ty::Fun, etc. -- leave as fresh_var for unresolved types
}

Ok(ctx.fresh_var())
```

This makes `42.to_string()`, `true.to_string()`, and `my_list.to_string()` trigger the retry mechanism in `infer_call`, which calls `infer_field_access(is_method_call=true)`. The `is_method_call=true` path (lines 4102-4123) already works for primitives via TraitRegistry -- Display/Debug/Hash are registered for Int/Float/String/Bool in builtins.rs.

**Change 2: Stdlib module method fallback in is_method_call=true path (near line 4102)**

After the trait method resolution fails and before emitting NoSuchMethod (near line 4117), add a fallback that checks if the method name matches a stdlib module function for the receiver type.

In the `is_method_call=true` branch for non-struct types (line 4102 block), after `resolve_trait_method` returns None (line 4113) and before the NoSuchMethod error (line 4117), insert:

```rust
// Stdlib module method fallback: check if this is a module function
// callable as a method on the receiver type.
let module_name = match &resolved_base {
    t if *t == Ty::string() => Some("String"),
    t if matches!(t, Ty::App(box Ty::Con(c), _) if c.name == "List") => Some("List"),
    t if matches!(t, Ty::App(box Ty::Con(c), _) if c.name == "Map") => Some("Map"),
    t if *t == Ty::Con(TyCon::new("Set")) || matches!(t, Ty::App(box Ty::Con(c), _) if c.name == "Set") => Some("Set"),
    _ => None,
};
if let Some(mod_name) = module_name {
    let modules = stdlib_modules();
    if let Some(mod_fns) = modules.get(mod_name) {
        if let Some(scheme) = mod_fns.get(&field_name) {
            let fn_ty = scheme.instantiate(ctx);
            return Ok(fn_ty);
        }
    }
}
```

IMPORTANT: The function type returned from `stdlib_modules()` already includes the receiver/self parameter as the first parameter (e.g., `String.length` has type `(String) -> Int`). This is correct because `infer_call`'s retry path (line 2710-2721) will prepend the receiver as the first argument and unify the function type with `(receiver_ty, ...explicit_args) -> ret_ty`. The first parameter of the stdlib function type will unify against the receiver type.

Note on pattern matching: If `box` patterns are not stable/available, use `if let Ty::App(con, _) = t { if let Ty::Con(c) = con.as_ref() { ... } }` instead.

**Verification approach:** After these changes, `cargo test -p snow-typeck` should pass all existing tests (the fresh_var -> NoSuchField change should not break anything because the retry mechanism catches and resolves NoSuchField for method calls, and plain field access on non-struct types was already semantically incorrect).
  </action>
  <verify>
Run `cargo test -p snow-typeck` -- all existing tests pass with 0 regressions. If any tests fail because they relied on the fresh_var fallback for non-struct field access in non-method-call context, that test was testing incorrect behavior and should be updated.
  </verify>
  <done>
`infer_field_access` returns Err(NoSuchField) for concrete non-struct types when is_method_call=false, triggering the retry mechanism. The is_method_call=true path resolves stdlib module functions as methods. `42.to_string()`, `"hello".length()`, and collection method calls all pass type checking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Display impl for List<T> in builtins</name>
  <files>crates/snow-typeck/src/builtins.rs</files>
  <action>
In `register_compiler_known_traits` in `builtins.rs`, add Display impls for collection types after the existing Display impls for primitives (after line 789).

Follow the exact same pattern as the List<T> Eq/Ord registration (lines 682-725):

```rust
// ── Display/Debug for collection types (Phase 31) ──────────────────
// Register Display for List<T> so my_list.to_string() works via method dot-syntax.
// The actual Display implementation is handled by wrap_collection_to_string in MIR lowering.
{
    let list_t = Ty::App(Box::new(Ty::Con(TyCon::new("List"))), vec![Ty::Con(TyCon::new("T"))]);
    let mut methods = FxHashMap::default();
    methods.insert(
        "to_string".to_string(),
        ImplMethodSig {
            has_self: true,
            param_count: 0,
            return_type: Some(Ty::string()),
        },
    );
    let _ = registry.register_impl(ImplDef {
        trait_name: "Display".to_string(),
        impl_type: list_t,
        impl_type_name: "List".to_string(),
        methods,
    });
}
```

Also register Display for Map<K,V> and Set using the same pattern:

For Map<K,V>:
```rust
{
    let map_kv = Ty::App(
        Box::new(Ty::Con(TyCon::new("Map"))),
        vec![Ty::Con(TyCon::new("K")), Ty::Con(TyCon::new("V"))],
    );
    let mut methods = FxHashMap::default();
    methods.insert(
        "to_string".to_string(),
        ImplMethodSig {
            has_self: true,
            param_count: 0,
            return_type: Some(Ty::string()),
        },
    );
    let _ = registry.register_impl(ImplDef {
        trait_name: "Display".to_string(),
        impl_type: map_kv,
        impl_type_name: "Map".to_string(),
        methods,
    });
}
```

For Set (unparameterized in current type system):
```rust
{
    let set_t = Ty::Con(TyCon::new("Set"));
    let mut methods = FxHashMap::default();
    methods.insert(
        "to_string".to_string(),
        ImplMethodSig {
            has_self: true,
            param_count: 0,
            return_type: Some(Ty::string()),
        },
    );
    let _ = registry.register_impl(ImplDef {
        trait_name: "Display".to_string(),
        impl_type: set_t,
        impl_type_name: "Set".to_string(),
        methods,
    });
}
```

These registrations tell the TraitRegistry that List<T>, Map<K,V>, and Set implement Display. The actual runtime behavior for collection Display is already handled by `wrap_collection_to_string` in the MIR lowering (which was replicated in the method interception path in Phase 30-02).
  </action>
  <verify>
Run `cargo test -p snow-typeck` -- all existing tests pass. Specifically verify the `builtins_register_compiler_known_traits` test still passes. If there is an assertion on trait count, update it to account for the new Display impls.
  </verify>
  <done>
`resolve_trait_method("to_string", &List<Int>)` returns `Some(Ty::string())`. Display is registered for List<T>, Map<K,V>, and Set in the TraitRegistry. `my_list.to_string()` passes type checking.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` -- all existing tests pass with 0 regressions
2. `cargo check --workspace` -- full workspace compiles
3. The retry mechanism in infer_call triggers for `42.to_string()` (concrete non-struct type returns NoSuchField)
4. Stdlib module functions resolve as methods in the type checker (String.length via dot-syntax)
5. Display for List<T>/Map<K,V>/Set is registered in TraitRegistry
</verification>

<success_criteria>
- All existing typeck tests pass (0 regressions)
- Full workspace compiles
- Non-struct concrete types return Err(NoSuchField) from infer_field_access when is_method_call=false
- Stdlib module method fallback resolves String.length, String.trim, etc. as method calls
- Display for List<T>, Map<K,V>, Set registered in TraitRegistry
</success_criteria>

<output>
After completion, create `.planning/phases/31-extended-method-support/31-01-SUMMARY.md`
</output>
