---
phase: 31-extended-method-support
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "42.to_string() compiles and returns '42' at runtime"
    - "true.to_string() compiles and returns 'true' at runtime"
    - "my_list.to_string() compiles and returns the list's string representation at runtime"
    - "point.to_string().length() compiles and returns the length of the string representation"
    - "person.name.length() compiles -- field access followed by method call works"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Stdlib module method fallback in resolve_trait_callee"
      contains: "string_.*method.*fallback|snow_string_"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2e tests for primitive methods, generic methods, chaining, and mixed access"
      contains: "method_dot_syntax_primitive|method_dot_syntax_chain"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "map_builtin_name"
      via: "Stdlib module method fallback uses prefixed name lookup to find runtime functions"
      pattern: "string_.*snow_string_"
    - from: "crates/snowc/tests/e2e.rs"
      to: "full compiler pipeline"
      via: "E2e tests compile and run Snow source, verifying stdout output"
      pattern: "compile_and_run"
---

<objective>
Add stdlib module method fallback in MIR lowering and comprehensive e2e tests proving all four Phase 31 success criteria work end-to-end.

Purpose: Plan 01 fixes the type checker so primitive, generic, and stdlib module method calls pass type checking. This plan adds the corresponding MIR lowering support so stdlib module functions (like String.length) are correctly resolved at the MIR level when called via dot syntax, then proves everything works with compile-and-run e2e tests.

Output: Modified lower.rs with stdlib module method fallback in resolve_trait_callee; new e2e tests in e2e.rs covering METH-04, METH-05, CHAIN-01, CHAIN-02.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-extended-method-support/31-RESEARCH.md
@.planning/phases/31-extended-method-support/31-01-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snowc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add stdlib module method fallback in resolve_trait_callee</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
In `resolve_trait_callee` (line 3377), after the trait lookup fails (the `find_method_traits` returns empty AND the monomorphized generic fallback loop finds nothing) and before the defense-in-depth warning (line 3422), add a stdlib module method fallback.

The fallback maps the receiver's MirType to a module prefix, constructs the prefixed function name, and checks if it exists in `known_functions` or as a mapped builtin.

```rust
// Stdlib module method fallback: check if this is a module function
// callable as a method on the receiver's type (e.g., "hello".length() -> snow_string_length).
let module_method = match first_arg_ty {
    MirType::String => {
        let prefixed = format!("string_{}", name);
        let runtime = map_builtin_name(&prefixed);
        if self.known_functions.contains_key(&runtime) || runtime.starts_with("snow_string_") {
            Some(runtime)
        } else {
            None
        }
    }
    MirType::Ptr => {
        // List/Map/Set methods -- try list_ prefix first (most common collection).
        // The typeck type determines which collection it is, but at MIR level
        // List/Map/Set all lower to Ptr. Use list_ prefix for now.
        let prefixed = format!("list_{}", name);
        let runtime = map_builtin_name(&prefixed);
        if self.known_functions.contains_key(&runtime) || runtime.starts_with("snow_list_") {
            Some(runtime)
        } else {
            None
        }
    }
    _ => None,
};
if let Some(runtime_name) = module_method {
    return MirExpr::Var(runtime_name, var_ty.clone());
}
```

Place this AFTER the monomorphized generic fallback loop (after the `for trait_name in &known_traits` loop, around line 3420) and BEFORE the defense-in-depth warning (line 3422).

**Important considerations:**

1. The `map_builtin_name` function (line 6789) already maps `"string_length"` -> `"snow_string_length"`, `"string_trim"` -> `"snow_string_trim"`, etc. So the fallback constructs the prefixed name and maps it through `map_builtin_name` to get the runtime name.

2. For String methods, the check `runtime.starts_with("snow_string_")` catches cases where `map_builtin_name` returns the mapped name even if it's not in `known_functions` (builtins may be registered via extern declarations rather than known_functions).

3. For collection (Ptr) methods, only List module functions are supported initially since List is the most common collection and the success criteria only tests `my_list.to_string()` (which goes through the collection Display dispatch path, not this fallback). The Ptr fallback is a safety net for `my_list.length()` if that pattern is tested.

4. The `to_string` method on collections is already handled by the collection Display dispatch in the method interception path (lines 3516-3530). This stdlib fallback only fires for non-Display methods like `length`, `append`, etc.

5. Do NOT modify `map_builtin_name` -- it already has all the String module mappings. If any String method is missing from `map_builtin_name`, add the mapping there (e.g., if `"string_contains"` is missing, add `"string_contains" => "snow_string_contains".to_string()`).

**Verification:** After this change, the MIR lowering should resolve `"hello".length()` to `snow_string_length("hello")`. Run `cargo test -p snow-codegen` to verify no regressions in existing MIR tests.
  </action>
  <verify>
Run `cargo test -p snow-codegen` -- all existing codegen tests pass with 0 regressions. The method dot-syntax MIR tests from Phase 30-02 continue to work.
  </verify>
  <done>
`resolve_trait_callee` has a stdlib module method fallback that resolves String module functions (length, trim, contains, etc.) when called via dot syntax. `"hello".length()` produces a MIR call to `snow_string_length`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for all Phase 31 success criteria</name>
  <files>crates/snowc/tests/e2e.rs</files>
  <action>
Add compile-and-run e2e tests that prove all four Phase 31 success criteria work end-to-end. Follow the same pattern as the existing Phase 30 e2e tests (which use `compile_and_run` or similar test helpers in e2e.rs).

**Test 1: Primitive method calls (METH-04)**
```snow
let x = 42
let s = x.to_string()
println(s)
let b = true
println(b.to_string())
```
Expected output: `42\ntrue\n`

This tests that `42.to_string()` resolves through the retry mechanism -> Display trait -> `snow_int_to_string`, and `true.to_string()` -> `snow_bool_to_string`.

**Test 2: Generic type method calls (METH-05)**
```snow
let xs = [1, 2, 3]
let s = xs.to_string()
println(s)
```
Expected output: `[1, 2, 3]\n` (the standard List Display format)

This tests that `my_list.to_string()` resolves through Display for List<T> -> collection Display dispatch -> `wrap_collection_to_string`.

**Test 3: Chained method calls (CHAIN-01)**
```snow
struct Point { x: Int, y: Int } deriving(Display)
let p = Point { x: 1, y: 2 }
let len = String.length(p.to_string())
println("${len}")
```
Expected output: a number representing the string length (e.g., `16` for `"Point(1, 2)"` or whatever the Display format produces).

IMPORTANT: For chaining `p.to_string().length()`, both the typeck stdlib fallback AND the MIR stdlib fallback must work. If the full chain `p.to_string().length()` does not work in the snowc pipeline (because the intermediate String type from `to_string()` may not correctly trigger the stdlib fallback for `length()`), use an alternative that demonstrates the chaining concept: call `String.length(p.to_string())` in the test or use string interpolation `"${String.length(p.to_string())}"`. If the full dot-syntax chain DOES work, use `p.to_string().length()` directly.

Test both forms if possible:
- `p.to_string().length()` -- true chaining
- `String.length(p.to_string())` -- module-qualified equivalent (known to work)

If the first form fails, note it as a limitation and use the second form.

**Test 4: Mixed field access and method calls (CHAIN-02)**
```snow
struct Person { name: String, age: Int }
let p = Person { name: "Alice", age: 30 }
let len = String.length(p.name)
println("${len}")
```
Expected output: `5\n` (length of "Alice")

Similar approach: try `p.name.length()` first. If it works via the stdlib method fallback chain, use it. If not, use `String.length(p.name)` and note the limitation.

**Test 5: Primitive float method call**
```snow
let f = 3.14
println(f.to_string())
```
Expected output: `3.14\n` (or however the Float Display format renders)

**Naming convention:** Follow the existing naming pattern from Phase 30 e2e tests. Suggested test function names:
- `method_dot_syntax_primitive_int`
- `method_dot_syntax_primitive_bool`
- `method_dot_syntax_generic_list`
- `method_dot_syntax_chain_to_string_length`
- `method_dot_syntax_mixed_field_method`

Adapt test content based on what actually works in the full compiler pipeline. If a test form doesn't compile, adapt it while preserving the intent and note the adaptation. The MIR-level tests (in lower.rs test module) can cover the ideal form if the e2e pipeline has limitations.
  </action>
  <verify>
Run `cargo test -p snowc -- method_dot_syntax` -- all new e2e tests pass. Run the full test suite `cargo test --workspace` to verify 0 regressions across all 1,242+ existing tests.
  </verify>
  <done>
At least 4 compile-and-run e2e tests pass, covering: (1) primitive method calls on Int and Bool, (2) generic type method calls on List, (3) chained or composed method+function calls, (4) mixed field access with method/function calls. Full test suite passes with 0 regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (existing 1,242+ tests + new e2e tests, 0 regressions)
2. `42.to_string()` produces `"42"` in a compiled Snow program
3. `true.to_string()` produces `"true"` in a compiled Snow program
4. `[1,2,3].to_string()` produces the list's string representation in a compiled Snow program
5. Chaining or composition of to_string() with length works end-to-end
6. Mixed field access (person.name) followed by a string function works end-to-end
</verification>

<success_criteria>
- All four Phase 31 success criteria have corresponding passing e2e tests
- Full workspace test suite passes with 0 regressions
- Stdlib module method fallback resolves String module functions at MIR level
- Primitive, generic, chaining, and mixed field/method patterns all compile and produce correct output
</success_criteria>

<output>
After completion, create `.planning/phases/31-extended-method-support/31-02-SUMMARY.md`
</output>
