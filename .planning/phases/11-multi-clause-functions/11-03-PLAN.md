---
phase: 11-multi-clause-functions
plan: 03
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-fmt/src/walker.rs
  - tests/e2e/multi_clause.snow
  - tests/e2e/multi_clause_guards.snow
  - tests/e2e/multi_clause_errors.snow
autonomous: true

must_haves:
  truths:
    - "`fn fib(0) = 0; fn fib(1) = 1; fn fib(n) = fib(n-1) + fib(n-2)` compiles and produces correct output when called"
    - "`fn abs(n) when n < 0 = -n; fn abs(n) = n` compiles and produces correct output"
    - "Multi-clause functions with constructor patterns compile and run correctly"
    - "Formatter handles = expr body form without crashing"
    - "All existing e2e tests continue to pass"
  artifacts:
    - path: "tests/e2e/multi_clause.snow"
      provides: "E2E test for basic multi-clause function definitions"
      contains: "fib"
    - path: "tests/e2e/multi_clause_guards.snow"
      provides: "E2E test for guard clauses on multi-clause functions"
      contains: "when"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "MIR lowering support for = expr body and guard clauses"
      contains: "FN_EXPR_BODY"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-parser/src/ast/item.rs"
      via: "MIR lowerer reads expr_body() and guard() from FnDef"
      pattern: "expr_body\\(\\)|has_eq_body"
    - from: "tests/e2e/multi_clause.snow"
      to: "snowc compiler binary"
      via: "E2E test compiled and executed"
      pattern: "fn fib"
---

<objective>
Complete the multi-clause functions feature with MIR lowering support, formatter support, and comprehensive end-to-end tests that verify the full compiler pipeline from source code to execution.

Purpose: Plans 01 and 02 added parser and type checker support. This plan ensures the full pipeline works: MIR lowering handles the desugared case expressions (and the new = expr body form), the formatter can handle the new syntax, and e2e tests prove the feature works from the user's perspective.

Output: Working multi-clause function support proven by e2e tests, plus formatter support for the new syntax.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-multi-clause-functions/11-CONTEXT.md
@.planning/phases/11-multi-clause-functions/11-RESEARCH.md
@.planning/phases/11-multi-clause-functions/11-01-SUMMARY.md
@.planning/phases/11-multi-clause-functions/11-02-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-fmt/src/walker.rs
@tests/e2e/functions.snow
@tests/e2e/pattern_match.snow
</context>

<tasks>

<task type="auto">
  <name>Task 1: MIR lowering and formatter support for = expr body form</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
**Step 1: Update MIR lowering for = expr body form.**

The MIR lowerer's `lower_fn_def` (line ~387 in `crates/snow-codegen/src/mir/lower.rs`) currently reads the function body from `fn_def.body()` which returns the BLOCK child. For multi-clause functions, the type checker desugars them into a single function with a case expression, so the lowerer should see a normal function with a case body. However, single-clause `= expr` functions (e.g., `fn double(x) = x * 2`) need explicit handling.

In `lower_fn_def`, after checking for `fn_def.body()` (BLOCK), also check for `fn_def.expr_body()` (the new accessor from Plan 01). If `expr_body()` returns `Some(expr)`:
- Lower the expression directly as the function's body (no block wrapping needed)
- The expression becomes the function's return value

Also check: the type checker in Plan 02 may transform multi-clause functions into a synthetic representation that the lowerer can handle. If the type checker desugars by creating internal data structures (not AST), then the lowerer may need to read a different representation. Coordinate with what Plan 02 actually produces. Most likely, the type checker stores the desugared case expression result in the type map, and the lowerer operates on the original AST (the first clause's FnDef) which the type checker has enriched with type information. In that case, the lowerer needs to:
- Detect that a FnDef is the "canonical" representative of a multi-clause group
- Access the desugared case body somehow

The simplest approach: the type checker creates a wrapper that makes the multi-clause function look like a single function with a case body to the lowerer. If this isn't feasible, the lowerer can also do its own grouping and desugaring at the MIR level, since it iterates over items similarly.

**Practical fallback:** If the type checker stores desugared information in a side table, the lowerer reads from that table. If not, the lowerer performs its own grouping (same logic as type checker) and creates a MIR function with a MIR case expression.

Check `lower_fn_def` to understand how it processes the body. The key is that however the desugaring works, the final MIR must contain a `MirExpr::Match` (or equivalent) with the clause patterns as arms.

**Step 2: Handle guard clauses in MIR lowering.**

If guard clauses are part of the desugared case expression, they should already be handled by the existing `lower_case_expr` which processes `MirMatchArm` with optional guards. Verify this works.

If the lowerer needs to explicitly handle GUARD_CLAUSE nodes on FnDef: lower the guard expression using the standard `lower_expr` and attach it to the appropriate MirMatchArm.

**Step 3: Update formatter for = expr body form.**

In `crates/snow-fmt/src/walker.rs`, the `walk_fn_def` function (line ~170) handles FN_DEF nodes. It currently expects DO_KW and END_KW tokens. Update it to also handle:

- `WHEN_KW` token: emit ` when ` followed by the guard expression
- `GUARD_CLAUSE` node: walk child expression
- `EQ` token (when it's part of `= expr` body, not `==`): emit ` = ` followed by the body expression
- `FN_EXPR_BODY` node: walk the expression child (the body)
- When `FN_EXPR_BODY` is present, do NOT emit `do` / `end` (since this is the `= expr` form)

The formatter must correctly format:
```snow
fn fib(0) = 0
fn fib(1) = 1
fn fib(n) = fib(n - 1) + fib(n - 2)
fn abs(n) when n < 0 = -n
fn abs(n) = n
```

Also handle pattern parameters in the PARAM_LIST -- the formatter walks PARAM nodes, which may now contain pattern children (LITERAL_PAT, WILDCARD_PAT, CONSTRUCTOR_PAT, etc.) instead of just IDENT tokens. The walker should delegate to the pattern walking logic for these.
  </action>
  <verify>
Run `cargo build` -- full workspace compiles.

Run `cargo test` -- all tests pass.

Test formatter on a multi-clause function snippet:
```
echo 'fn fib(0) = 0
fn fib(1) = 1
fn fib(n) = fib(n - 1) + fib(n - 2)' | cargo run -p snow-fmt -- --stdin
```
Output should be properly formatted (or at least not crash).
  </verify>
  <done>
- MIR lowerer handles = expr body form functions
- MIR lowerer handles desugared multi-clause functions (case expression in body)
- Formatter handles = expr body form without crashing
- Formatter handles guard clauses (when keyword)
- Formatter handles pattern parameters (literals, wildcards, constructors in param position)
- `cargo build` and `cargo test` pass
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end tests for multi-clause functions</name>
  <files>
    tests/e2e/multi_clause.snow
    tests/e2e/multi_clause_guards.snow
  </files>
  <action>
Create comprehensive end-to-end tests that compile and run Snow programs using multi-clause functions. These test the FULL pipeline: lexer -> parser -> type checker -> MIR -> LLVM codegen -> execution.

**Test 1: `tests/e2e/multi_clause.snow` -- Basic multi-clause functions.**

```snow
# Basic fibonacci with multi-clause function
fn fib(0) = 0
fn fib(1) = 1
fn fib(n) = fib(n - 1) + fib(n - 2)

# Multi-parameter patterns
fn add(0, y) = y
fn add(x, 0) = x
fn add(x, y) = x + y

# Boolean patterns
fn to_string(true) = "yes"
fn to_string(false) = "no"

# Single-clause = expr form (verify it works too)
fn double(x) = x * 2

# Mix of = expr and do/end (different functions)
fn square(x) do
  x * x
end

fn main() do
  IO.println(fib(10))          # Should print 55
  IO.println(add(0, 5))        # Should print 5
  IO.println(add(3, 0))        # Should print 3
  IO.println(add(3, 4))        # Should print 7
  IO.println(to_string(true))  # Should print "yes"
  IO.println(double(21))       # Should print 42
  IO.println(square(6))        # Should print 36
end
```

Verify: compile with `snowc`, run the binary, check output matches expected.

**Test 2: `tests/e2e/multi_clause_guards.snow` -- Guard clauses.**

```snow
# Guard clauses with when keyword
fn abs(n) when n < 0 = -n
fn abs(n) = n

# Guards with function calls (per user decision: arbitrary Bool expressions)
fn classify(n) when n > 0 = "positive"
fn classify(n) when n < 0 = "negative"
fn classify(n) = "zero"

# Guards with compound expressions
fn safe_div(_, b) when b == 0 = 0
fn safe_div(a, b) = a / b

fn main() do
  IO.println(abs(-5))           # Should print 5
  IO.println(abs(3))            # Should print 3
  IO.println(classify(10))      # Should print "positive"
  IO.println(classify(-3))      # Should print "negative"
  IO.println(classify(0))       # Should print "zero"
  IO.println(safe_div(10, 2))   # Should print 5
  IO.println(safe_div(10, 0))   # Should print 0
end
```

**Running e2e tests:**

Check existing e2e test patterns in `tests/e2e/`. Look at how `functions.snow` and `pattern_match.snow` are compiled and tested. Follow the same pattern:
- Compile: `cargo run -p snowc -- tests/e2e/multi_clause.snow -o /tmp/multi_clause`
- Execute: `/tmp/multi_clause`
- Verify output

Also verify ALL existing e2e tests still pass by running the full e2e test suite (however it's invoked -- check for a test runner script or Cargo test target).

**Test 3: Verify error cases (not a separate file, but verify during development).**

Manually verify these error cases produce correct diagnostics:
- Catch-all before last clause: `fn foo(_) = 0; fn foo(1) = 1` -> error
- Return type mismatch: `fn bar(0) = 0; fn bar(n) = "hello"` -> type error
- Non-consecutive clauses: `fn baz(0) = 0; let x = 1; fn baz(n) = n` -> redefinition error

These don't need to be e2e tests (they should fail to compile), but verify they produce the expected error messages.
  </action>
  <verify>
Compile and run both e2e tests:
```bash
cargo run -p snowc -- tests/e2e/multi_clause.snow -o /tmp/multi_clause && /tmp/multi_clause
cargo run -p snowc -- tests/e2e/multi_clause_guards.snow -o /tmp/multi_clause_guards && /tmp/multi_clause_guards
```

Run all existing e2e tests to confirm no regressions:
```bash
# Run whatever test suite/script exists for e2e tests
cargo test
```

Verify error cases produce correct diagnostics (compile should fail with clear errors).
  </verify>
  <done>
- `tests/e2e/multi_clause.snow` compiles and runs, producing correct output for fib, add, to_string, double, square
- `tests/e2e/multi_clause_guards.snow` compiles and runs, producing correct output for abs, classify, safe_div
- All existing e2e tests continue to pass (no regressions)
- Error cases (catch-all not last, type mismatch, non-consecutive) produce clear error messages
- Multi-clause functions work with: literal patterns, variable patterns, wildcard patterns, guard clauses, multiple parameters
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- full workspace compiles
2. `cargo test` -- all tests pass (unit + e2e)
3. Multi-clause fib function produces correct results (fib(10) = 55)
4. Guard clauses work correctly (abs(-5) = 5, abs(3) = 3)
5. All existing e2e tests pass without modification
6. Formatter handles new syntax without crashing
</verification>

<success_criteria>
- Complete multi-clause function support proven by e2e tests
- fib(10) = 55 via multi-clause definition
- Guard clauses work with when keyword and arbitrary Bool expressions
- MIR lowering handles both = expr and do/end body forms
- Formatter handles new syntax
- Zero regressions in existing test suite
- All four roadmap success criteria are satisfied:
  1. fn fib(0)/fib(1)/fib(n) compiles and runs correctly
  2. Exhaustiveness warning for non-exhaustive multi-clause functions
  3. Type inference unifies return types across clauses
  4. Works with all existing pattern types
</success_criteria>

<output>
After completion, create `.planning/phases/11-multi-clause-functions/11-03-SUMMARY.md`
</output>
