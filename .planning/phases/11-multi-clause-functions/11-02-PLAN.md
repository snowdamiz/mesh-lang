---
phase: 11-multi-clause-functions
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/error.rs
autonomous: true

must_haves:
  truths:
    - "Consecutive `fn fib(0) = 0`, `fn fib(1) = 1`, `fn fib(n) = ...` are grouped and desugared into a single function with case expression"
    - "Type inference unifies return types across all clauses -- returning Int in one clause and String in another is a type error"
    - "Exhaustiveness warning fires when multi-clause function does not cover all cases"
    - "Catch-all clause not last produces a compiler error"
    - "Different arities are separate functions -- fn foo(x) and fn foo(x, y) coexist"
    - "Guard expressions accept arbitrary Bool expressions including function calls and arithmetic"
    - "Existing single-clause do/end functions continue to type-check correctly"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Multi-clause function grouping, desugaring, and type checking"
      contains: "group_multi_clause"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "New diagnostic variants for multi-clause function errors"
      contains: "catch_all"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "infer_case"
      via: "Desugared case expression processed by existing infer_case"
      pattern: "infer_case"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "check_exhaustiveness"
      via: "Exhaustiveness checking applied to desugared case"
      pattern: "check_exhaustiveness"
---

<objective>
Implement multi-clause function grouping, desugaring to case expressions, and all semantic validation in the Snow type checker.

Purpose: This is the semantic core of multi-clause functions. The parser (Plan 01) produces individual FnDef nodes for each clause. The type checker must: (1) group consecutive same-name, same-arity FnDef nodes into multi-clause functions, (2) desugar them into single functions with internal case expressions, (3) validate clause ordering (catch-all must be last), (4) relax guard validation to allow arbitrary Bool expressions, and (5) let the existing case expression infrastructure handle exhaustiveness checking and return type unification.

Output: Modified type checker that correctly processes multi-clause function definitions while maintaining full backward compatibility with existing single-clause functions.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-multi-clause-functions/11-CONTEXT.md
@.planning/phases/11-multi-clause-functions/11-RESEARCH.md
@.planning/phases/11-multi-clause-functions/11-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/error.rs
@crates/snow-parser/src/ast/item.rs
@crates/snow-parser/src/ast/pat.rs
@crates/snow-parser/src/ast/expr.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement clause grouping and desugaring in the type checker</name>
  <files>
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
The core change is in `infer_item` (around line 707) where `Item::FnDef` is matched. Instead of inferring each FnDef individually, the type checker needs a pre-pass that groups consecutive same-name, same-arity FnDef nodes, then desugars them.

**Step 1: Add a clause grouping pre-pass.**

Add a helper function `group_multi_clause_fns` that takes a slice of Item nodes and returns a modified list where consecutive FnDef items with the same name and arity are collapsed into a single "canonical" FnDef. Approach:

```
fn group_multi_clause_fns(items: &[Item]) -> Vec<GroupedItem>
```

Where `GroupedItem` is either:
- `Single(Item)` -- a non-FnDef item or a standalone FnDef (only one clause)
- `MultiClause { first: FnDef, clauses: Vec<FnDef> }` -- consecutive same-name, same-arity FnDef items

Grouping rules (per user decisions):
- Group by name AND arity (param count). `fn foo(x)` and `fn foo(x, y)` are SEPARATE functions.
- Only group CONSECUTIVE FnDef items. If a non-fn item appears between two `fn fib(...)` definitions, the second starts a NEW group (and is a redefinition error -- handled later).
- Only FnDef items with `has_eq_body() == true` OR whose only clause uses do/end are candidates. A single do/end FnDef is just a regular function (not multi-clause).
- Specifically: a function is multi-clause if there are 2+ consecutive FnDef nodes with the same name. A single FnDef with `= expr` body is also valid (it's a 1-clause multi-clause function, which is fine -- just desugar normally).

**Step 2: Validate clause properties.**

When processing a `MultiClause` group:
1. **pub/generics/return type only on first clause:** Check that only the first clause has `visibility()`, generic params, return type annotation, or where clause. If subsequent clauses have these, emit a diagnostic: "visibility/generics/return type should only appear on the first clause of a multi-clause function".
2. **Catch-all must be last (user decision -- LOCKED):** A clause is catch-all if ALL its parameters are wildcard patterns or simple variable bindings (no literals, no constructors, no tuple patterns with inner literals). If a catch-all clause appears before the last position, emit an ERROR (not warning): "catch-all clause must be the last clause in a multi-clause function". Detection: iterate clause params, check if each param has a pattern child -- if no param has a pattern child (all are plain IDENT), it's catch-all. Also: if any param's pattern is `WILDCARD_PAT` or `IDENT_PAT` for ALL params, it's catch-all.
3. **Arity consistency:** All clauses in a group must have the same number of parameters. If not, emit error.

**Step 3: Desugar to a case expression.**

For a multi-clause group, create a synthetic function and call `infer_fn_def` on it. The desugaring is conceptual (not actually creating AST nodes) -- instead, the type checker directly constructs the type inference result as if the function contained a case expression.

Practical approach: create a new function `infer_multi_clause_fn` that:

1. Takes the first FnDef (for name, visibility, generics, return type) and all clause FnDefs.
2. Generates fresh type variables for each parameter position (like `__p0`, `__p1`, ...).
3. For each clause, extracts the parameter patterns and body expression.
4. Creates the equivalent of case arm inference:
   - For single-param functions: directly unify each clause's pattern with the param type, then infer the body.
   - For multi-param functions: treat patterns as a tuple pattern -- create a tuple type for the params and a tuple pattern for each clause.
5. Unifies all clause body types (like `infer_case` does for arm bodies).
6. Runs exhaustiveness checking on the collected patterns (reuse `check_exhaustiveness`).
7. Runs redundancy checking (reuse existing `check_redundancy`).
8. Returns the function type.

**Key implementation details for desugaring without creating AST nodes:**

The simplest approach that maximally reuses existing code: build the same data structures that `infer_case` uses, and call the same validation functions. Specifically:

- For each clause, call `infer_pattern` on each param's pattern to get pattern types and bindings.
- Unify pattern types with the corresponding parameter types.
- Push a scope for each clause body, insert pattern bindings, infer the body expression, pop scope.
- Collect arm patterns for exhaustiveness checking.
- Track guard presence (guarded arms excluded from exhaustiveness).

This mirrors what `infer_case` does at lines ~2355-2510, but driven by function clauses instead of case arms.

**Step 4: Integrate grouping into the main inference loop.**

Modify the function that iterates over items (the block inference or source file inference). Before the item loop, call `group_multi_clause_fns` on the items. Then iterate over the grouped items:
- `Single(item)` -> process as before (call `infer_item`)
- `MultiClause { first, clauses }` -> call `infer_multi_clause_fn`

The grouping must happen at every scope level where FnDef items appear:
- Top-level source file items
- Module body items
- Impl block methods

Check each of these code paths in infer.rs and apply the grouping pre-pass.

**Step 5: Handle redefinition errors for non-consecutive same-name functions.**

After grouping, scan all grouped items. If a function name appears in multiple groups (non-consecutive), emit: "function `name/arity` already defined at line X. Multi-clause functions must have consecutive clauses."

**Important constraints (from user decisions -- LOCKED):**
- First-match wins: clauses tried top-to-bottom
- Wildcard/catch-all must be last: compiler error if not
- Different arities are separate functions
- All parameters support patterns

**Runtime behavior (Claude's discretion decision):**
- When no clause matches at runtime: PANIC with message "no matching clause for function 'name/arity'"
- This is handled by exhaustiveness: if patterns are non-exhaustive AND no catch-all, the exhaustiveness warning fires. At runtime, the desugared case expression's panic path handles this.
  </action>
  <verify>
Run `cargo build -p snow-typeck` -- must compile.

Run `cargo test -p snow-typeck` -- all existing tests pass.

Run `cargo build` (full workspace) -- must compile (codegen may need minor adjustments to handle FN_EXPR_BODY if encountered during lowering).
  </verify>
  <done>
- Consecutive same-name, same-arity FnDef nodes are grouped and type-checked as one function
- Return types are unified across clauses (type error on mismatch)
- Exhaustiveness checking applies to multi-clause patterns
- Catch-all not-last is a compiler error
- Different arities treated as separate functions
- Existing single-clause functions continue to work
- `cargo build` succeeds for the full workspace
- `cargo test -p snow-typeck` passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Relax guard validation and add multi-clause error diagnostics</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/error.rs
  </files>
  <action>
**Step 1: Relax `validate_guard_expr` for multi-clause functions.**

Per the user decision (LOCKED): "Guard expressions can be arbitrary expressions that return Bool, including function calls -- not limited to simple comparisons."

The current `validate_guard_expr` (line ~2281) is restrictive: it only allows comparisons, boolean ops, literals, name refs, and named function calls. It disallows arithmetic, field access, method calls, etc.

Two approaches:
- **Option A (simpler):** Remove the `validate_guard_expr` call entirely for multi-clause function guards. Instead, just type-check the guard expression normally with `infer_expr` and verify it unifies with `Ty::Bool`. This matches the user decision -- any expression that returns Bool is valid.
- **Option B (preserve for case guards):** Keep `validate_guard_expr` for case expression guards but skip it for multi-clause function guards.

**Use Option A for multi-clause function guards, keep existing behavior for case expressions (Option B).** In `infer_multi_clause_fn`, when processing a clause's guard, do NOT call `validate_guard_expr`. Instead, just call `infer_expr` on the guard and unify the result with `Ty::Bool`. If unification fails, emit a type error: "guard expression must return Bool, got {actual_type}".

Also, in `infer_case` (for regular case expressions), consider relaxing the guard validation there too for consistency. The user decision says guards allow arbitrary Bool expressions -- this likely applies to case expression guards too. But to minimize scope, only relax for multi-clause function guards in this plan. Case expression guard relaxation can be a follow-up if desired.

**Step 2: Add diagnostic variants to error.rs.**

Add new error/warning types in `crates/snow-typeck/src/error.rs` (or wherever diagnostics are emitted -- check if errors are emitted inline with `ctx.error()` or via an error enum):

- **Error:** "catch-all clause must be the last clause of function `{name}/{arity}` -- clauses after a catch-all are unreachable"
- **Error:** "function `{name}/{arity}` already defined at line {line} -- multi-clause functions must have consecutive clauses"
- **Error:** "all clauses of `{name}/{arity}` must have the same number of parameters -- clause at line {line} has {n} parameters, expected {expected}"
- **Warning:** "unreachable clause in function `{name}/{arity}` at line {line} -- previous clauses already cover this pattern" (reuse existing redundancy warning mechanism from case expressions)
- **Warning (if applicable):** "visibility/generics/return type annotation on non-first clause of `{name}/{arity}` will be ignored"
- **Error:** "guard expression must return Bool, found {type}"

Check how existing diagnostics are emitted. The codebase uses `ctx.error()` and `ctx.warnings.push()` patterns. Follow the same patterns for new diagnostics.

**Step 3: Wire guard processing into multi-clause inference.**

In `infer_multi_clause_fn`, for each clause:
1. Check if the clause has a guard (via `fn_def.guard()` accessor from Plan 01)
2. If yes: push scope, insert pattern bindings, call `infer_expr` on the guard expression, unify with Bool, mark this arm as guarded (exclude from exhaustiveness matrix)
3. Track `arm_has_guard` just like `infer_case` does

This ensures that guarded clauses:
- Are type-checked correctly (guard must be Bool)
- Are excluded from exhaustiveness checking (a guarded arm might not match even if the pattern matches)
- Allow the same pattern in multiple clauses (one guarded, one not)
  </action>
  <verify>
Run `cargo build` (full workspace) -- must compile.

Run `cargo test` (full workspace) -- all tests pass.

Verify with a mental trace: `fn abs(n) when n < 0 = -n` followed by `fn abs(n) = n` should:
1. Group as 2-clause function `abs/1`
2. First clause: pattern `n`, guard `n < 0`, body `-n`
3. Second clause: pattern `n`, no guard, body `n`
4. Guard type-checks (n < 0 returns Bool)
5. Both bodies return Int (unified)
6. Second clause is catch-all (last position -- valid)
  </verify>
  <done>
- Guard expressions in multi-clause functions accept arbitrary Bool expressions (function calls, arithmetic comparisons, field access)
- Guard type must be Bool or type error
- Guarded clauses excluded from exhaustiveness checking
- All diagnostic messages are clear and include function name/arity and line numbers
- Catch-all not-last produces error with helpful message
- Redefinition of non-consecutive same-name functions produces error with line reference
- `cargo build` and `cargo test` pass across the full workspace
  </done>
</task>

</tasks>

<verification>
1. `cargo build` (full workspace) compiles cleanly
2. `cargo test` (full workspace) -- all existing tests pass
3. Type checker correctly groups and desugars multi-clause functions
4. Guard validation is relaxed for multi-clause function guards
5. Error diagnostics fire correctly for: catch-all not last, arity mismatch, non-consecutive clauses
</verification>

<success_criteria>
- Multi-clause functions are grouped, desugared, and type-checked
- Return type unification across clauses works (Int + String = type error)
- Exhaustiveness warnings fire for non-exhaustive multi-clause functions
- Catch-all not-last is a compiler error
- Guards accept arbitrary Bool expressions per user decision
- All existing code continues to compile and pass tests
</success_criteria>

<output>
After completion, create `.planning/phases/11-multi-clause-functions/11-02-SUMMARY.md`
</output>
