---
phase: 11-multi-clause-functions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-parser/src/parser/items.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/ast/item.rs
  - crates/snow-parser/src/syntax_kind.rs
autonomous: true

must_haves:
  truths:
    - "Parser accepts `fn fib(0) = 0` (= expr body form with literal pattern param)"
    - "Parser accepts `fn fib(n) = fib(n-1) + fib(n-2)` (= expr body form with ident pattern param)"
    - "Parser accepts `fn abs(n) when n < 0 = -n` (guard clause with when keyword)"
    - "Parser accepts `fn foo(Some(x)) = x` (constructor pattern in param position)"
    - "Parser accepts `fn foo(_) = 0` (wildcard pattern in param position)"
    - "Parser accepts `fn add(0, y) = y` (multiple pattern params)"
    - "Existing `fn foo(x) do ... end` syntax continues to parse without errors"
  artifacts:
    - path: "crates/snow-parser/src/parser/items.rs"
      provides: "parse_fn_def with = expr body and pattern param support"
      contains: "EQ"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "parse_fn_clause_param for pattern-aware parameter parsing"
      contains: "parse_fn_clause_param"
    - path: "crates/snow-parser/src/ast/item.rs"
      provides: "FnDef AST accessors for guard, expr_body, has_eq_body"
      contains: "guard"
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "FN_EXPR_BODY syntax kind for = expr body nodes"
      contains: "FN_EXPR_BODY"
  key_links:
    - from: "crates/snow-parser/src/parser/items.rs"
      to: "crates/snow-parser/src/parser/expressions.rs"
      via: "parse_fn_clause_param called from parse_fn_def"
      pattern: "parse_fn_clause_param"
    - from: "crates/snow-parser/src/parser/items.rs"
      to: "crates/snow-parser/src/parser/patterns.rs"
      via: "parse_pattern reused for pattern params"
      pattern: "parse_pattern"
---

<objective>
Extend the Snow parser to accept multi-clause function syntax: `fn name(pattern) [when guard] = expr` alongside the existing `fn name(param) do ... end` form.

Purpose: This is the syntax foundation for multi-clause functions. Without parser support, the type checker and codegen cannot process multi-clause definitions. The parser must produce FnDef AST nodes for both the existing do/end form and the new = expr form, with pattern parameters and optional guard clauses.

Output: Modified parser that accepts both `= expr` and `do/end` body forms, pattern parameters (literals, wildcards, constructors, tuples) alongside traditional named parameters, and `when` guard clauses on function definitions. All existing code continues to parse unchanged.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-multi-clause-functions/11-CONTEXT.md
@.planning/phases/11-multi-clause-functions/11-RESEARCH.md
@crates/snow-parser/src/parser/items.rs
@crates/snow-parser/src/parser/expressions.rs
@crates/snow-parser/src/parser/patterns.rs
@crates/snow-parser/src/ast/item.rs
@crates/snow-parser/src/syntax_kind.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add syntax kind and parser support for = expr body form and pattern params</name>
  <files>
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/parser/items.rs
    crates/snow-parser/src/parser/expressions.rs
  </files>
  <action>
**Step 1: Add new SyntaxKind variant.**

In `crates/snow-parser/src/syntax_kind.rs`, add a new composite node kind `FN_EXPR_BODY` after the existing function-related kinds (near `FN_DEF`). This wraps the expression in `fn name(pattern) = expr` so the AST can distinguish between a `do/end` block body and an `= expr` body. Also update the test `syntax_kind_has_enough_variants` to include this new kind and bump the count.

**Step 2: Add `parse_fn_clause_param` in expressions.rs.**

In `crates/snow-parser/src/parser/expressions.rs`, add a new function `pub(crate) fn parse_fn_clause_param(p: &mut Parser)` that parses a single function parameter that may be a pattern. Detection logic:

- `INT_LITERAL`, `FLOAT_LITERAL`, `TRUE_KW`, `FALSE_KW`, `NIL_KW` -> call `super::patterns::parse_pattern(p)` and wrap result in PARAM node
- `MINUS` followed by `INT_LITERAL` or `FLOAT_LITERAL` -> negative literal pattern, call parse_pattern
- `IDENT` where text is `"_"` -> wildcard pattern, call parse_pattern
- `L_PAREN` -> tuple pattern, call parse_pattern
- `IDENT` where first char is uppercase AND next token is `L_PAREN` -> constructor pattern, call parse_pattern
- `IDENT` (lowercase, not `_`) -> parse as regular PARAM node (advance ident, optionally parse `:: Type` annotation). This is the backward-compatible path for normal identifier parameters.
- `SELF_KW` -> parse as regular PARAM (existing behavior)

The function should open a PARAM marker, parse the content, and close with `SyntaxKind::PARAM`. For pattern cases, the pattern node becomes a child of the PARAM node.

Also add `pub(crate) fn parse_fn_clause_param_list(p: &mut Parser)` that works like `parse_param_list` but calls `parse_fn_clause_param` instead of `parse_param`.

**Step 3: Modify `parse_fn_def` in items.rs.**

Modify `parse_fn_def` in `crates/snow-parser/src/parser/items.rs` to support both body forms. After parsing the parameter list (and optional return type and where clause):

1. **Detect = expr form vs do/end form:**
   - Check for `WHEN_KW` first. If present, parse the guard clause: open a `GUARD_CLAUSE` marker, advance past `when`, call `super::expressions::expr(p)` to parse the guard expression, close the marker. Then continue to body detection.
   - If `EQ` token (not `EQ_EQ`): this is the `= expr` body form. Advance past `=`. Open a `FN_EXPR_BODY` marker. Call `super::expressions::expr(p)` to parse the body expression. Close the marker. Close the `FN_DEF` marker. Return.
   - If `DO_KW` token: proceed with existing `do ... end` parsing (unchanged).
   - If neither: error.

2. **Detect pattern params:** The parameter list must use `parse_fn_clause_param_list` instead of `parse_param_list` when pattern parameters are present. Detection approach: always use `parse_fn_clause_param_list` for ALL fn def parameter lists. The `parse_fn_clause_param` function handles both regular params (IDENT with optional type annotation) and pattern params transparently. This ensures backward compatibility -- existing `fn foo(x :: Int) do ... end` still works because `parse_fn_clause_param` falls through to the regular param path for plain identifiers.

   Replace the call `parse_param_list(p)` in `parse_fn_def` with `super::expressions::parse_fn_clause_param_list(p)`.

**Important constraints (from user decisions):**
- Guard clauses use `when` keyword (already exists as `WHEN_KW` and `GUARD_CLAUSE` SyntaxKind)
- Guard expressions can be arbitrary Bool expressions including function calls
- All parameters support patterns, not just the first
- Both `= expr` and `do/end` body forms are supported (Claude's discretion decision)

**What NOT to do:**
- Do NOT change the parse_param_list function itself (other callers like actor_def still need the original)
- Do NOT change the lexer (WHEN_KW and EQ already exist as token types)
- Do NOT break existing tests -- all current `fn` definitions must continue to parse identically
  </action>
  <verify>
Run `cargo build -p snow-parser` from the workspace root. It must compile without errors.

Run `cargo test -p snow-parser` to verify all existing parser tests pass (no regressions).

Manually verify parse output by adding a quick test or using the parser on a snippet: `fn fib(0) = 0` should produce a tree with FN_DEF containing PARAM_LIST > PARAM > LITERAL_PAT, EQ, FN_EXPR_BODY > LITERAL.
  </verify>
  <done>
- `cargo build -p snow-parser` succeeds
- `cargo test -p snow-parser` passes (no regressions)
- Parser accepts: `fn fib(0) = 0`, `fn fib(n) = n`, `fn abs(n) when n < 0 = -n`, `fn foo(Some(x)) = x`, `fn foo(_) = 0`, `fn add(0, y) = y`
- Parser still accepts: `fn foo(x) do x + 1 end`, `fn bar(x :: Int) do x end`
- FN_DEF nodes contain GUARD_CLAUSE child when `when` is present
- FN_DEF nodes contain FN_EXPR_BODY child when `= expr` form is used
  </done>
</task>

<task type="auto">
  <name>Task 2: Add AST accessors for guard clauses and expression body</name>
  <files>
    crates/snow-parser/src/ast/item.rs
  </files>
  <action>
Add new accessor methods to the `FnDef` AST node in `crates/snow-parser/src/ast/item.rs`:

1. **`pub fn guard(&self) -> Option<GuardClause>`** - Returns the GUARD_CLAUSE child node if present. This requires adding a new AST node type:
   ```
   ast_node!(GuardClause, GUARD_CLAUSE);
   ```
   With an accessor `pub fn expr(&self) -> Option<super::expr::Expr>` that returns the guard expression.

2. **`pub fn expr_body(&self) -> Option<super::expr::Expr>`** - Returns the expression from the FN_EXPR_BODY node if this is an `= expr` form function. Looks for the first FN_EXPR_BODY child, then gets the Expr child within it.

3. **`pub fn has_eq_body(&self) -> bool`** - Returns true if this FnDef uses the `= expr` form (has an FN_EXPR_BODY child). Useful for the type checker to detect multi-clause function candidates.

4. **Update `FnDef::body()` accessor** -- Ensure it still works for `do/end` form (returns the BLOCK child). The `= expr` form has no BLOCK child, so `body()` returns `None` for those. This is correct -- callers check `expr_body()` instead.

Also update the `Param` AST node to expose pattern children:

5. **`pub fn pattern(&self) -> Option<super::pat::Pattern>`** - Returns the pattern child of a PARAM node if it contains a pattern (literal, wildcard, constructor, tuple) instead of a plain IDENT. Uses `Pattern::cast` on children.

These accessors are critical wiring -- the type checker in Plan 02 will use `guard()`, `expr_body()`, `has_eq_body()`, and `Param::pattern()` to detect and desugar multi-clause functions.
  </action>
  <verify>
Run `cargo build -p snow-parser` -- must compile without errors.

Run `cargo test -p snow-parser` -- all tests pass.

Verify the new methods are accessible by checking they compile (the type checker in Plan 02 will be the real consumer).
  </verify>
  <done>
- `FnDef` has `guard()`, `expr_body()`, `has_eq_body()` methods
- `GuardClause` AST node exists with `expr()` method
- `Param` has `pattern()` method
- `cargo build -p snow-parser` succeeds
- `cargo test -p snow-parser` passes
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-parser` compiles cleanly
2. `cargo test -p snow-parser` -- all existing tests pass (zero regressions)
3. The parser can be tested on multi-clause syntax snippets to verify correct CST structure
</verification>

<success_criteria>
- Parser accepts both `fn name(pattern) [when guard] = expr` and `fn name(param) do ... end` forms
- Pattern parameters work: literal (0, 1, true), wildcard (_), constructor (Some(x)), tuple ((a, b)), variable (n)
- Guard clauses parse: `fn abs(n) when n < 0 = -n` produces FN_DEF with GUARD_CLAUSE child
- All existing Snow code continues to parse identically (no regressions)
- AST accessors (guard, expr_body, has_eq_body, Param::pattern) are available for downstream consumers
</success_criteria>

<output>
After completion, create `.planning/phases/11-multi-clause-functions/11-01-SUMMARY.md`
</output>
