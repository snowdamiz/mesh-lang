---
phase: 02-parser-ast
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - crates/snow-parser/src/parser/items.rs
  - crates/snow-parser/src/parser/patterns.rs
  - crates/snow-parser/src/parser/mod.rs
  - crates/snow-parser/tests/parser_tests.rs
autonomous: true

must_haves:
  truths:
    - "Function definitions (pub fn name(params) do ... end) parse with visibility, name, params, optional return type, and body"
    - "Module definitions (module Name do ... end) parse with nested items"
    - "Import declarations (import Module, from Module import name1, name2) parse correctly"
    - "Struct definitions (struct Name do field :: Type ... end) parse with typed fields"
    - "Patterns (ident, literal, wildcard _, tuple, struct) parse in match arms and let bindings"
    - "Type annotations (:: Type, :: Type[A, B]) parse structurally"
    - "Private-by-default: only items with explicit pub are marked with VISIBILITY node"
    - "No glob imports: from Module import * is rejected"
  artifacts:
    - path: "crates/snow-parser/src/parser/items.rs"
      provides: "fn def, module def, import, struct def parsers"
      contains: "fn parse_fn_def"
    - path: "crates/snow-parser/src/parser/patterns.rs"
      provides: "Pattern parser for match arms and let bindings"
      contains: "fn parse_pattern"
  key_links:
    - from: "crates/snow-parser/src/parser/items.rs"
      to: "crates/snow-parser/src/parser/expressions.rs"
      via: "Function bodies and struct defaults call expression parser"
      pattern: "expressions::expr\\(|parse_block_body\\("
    - from: "crates/snow-parser/src/parser/patterns.rs"
      to: "crates/snow-parser/src/parser/expressions.rs"
      via: "Guards in match arms use expression parser"
      pattern: "expr\\(p\\)"
    - from: "crates/snow-parser/src/parser/mod.rs"
      to: "crates/snow-parser/src/parser/items.rs"
      via: "Top-level and block parsing dispatches to item parsers"
      pattern: "items::parse_"
---

<objective>
Add declaration/item parsing (fn, module, import, struct), pattern parsing, type annotations, and visibility to the parser. This completes the parser's grammar coverage for all Snow Phase 2 constructs.

Purpose: Declarations define the structure of Snow programs -- functions, modules, imports, and data types. Patterns enable destructuring in match arms and let bindings. Together with the expression parser from Plans 02-03, this makes the parser feature-complete for Phase 2.
Output: Parser handles all Snow declaration forms with correct visibility, plus pattern matching syntax and structural type annotations.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-parser-ast/02-CONTEXT.md
@.planning/phases/02-parser-ast/02-RESEARCH.md
@.planning/phases/02-parser-ast/02-03-SUMMARY.md
@crates/snow-common/src/token.rs
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/mod.rs
@crates/snow-parser/src/parser/expressions.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement item parsers (fn, module, import, struct) with patterns and types</name>
  <files>
    crates/snow-parser/src/parser/items.rs
    crates/snow-parser/src/parser/patterns.rs
    crates/snow-parser/src/parser/mod.rs
  </files>
  <action>
    Create `crates/snow-parser/src/parser/items.rs` and `crates/snow-parser/src/parser/patterns.rs`.

    **1. Item dispatch** -- Add to `parser/mod.rs`:
    - `pub(crate) fn parse_source_file(p: &mut Parser)`: opens SOURCE_FILE node, loops calling `parse_item_or_stmt(p)` with newline separators until EOF, closes SOURCE_FILE.
    - `pub(crate) fn parse_item_or_stmt(p: &mut Parser)`: dispatches based on current token:
      - `PUB_KW` -> peek ahead: if FN_KW/DEF_KW/STRUCT_KW/MODULE_KW/TRAIT_KW/TYPE_KW follows, call the corresponding item parser with pub=true. Otherwise error.
      - `FN_KW` / `DEF_KW` -> `items::parse_fn_def(p)` (Note: in expression position, FN_KW starts a closure. The disambiguation: at statement level (top of block or after newline), FN_KW followed by IDENT is a named function definition. FN_KW followed by L_PAREN or ARROW is a closure. If ambiguous, default to closure and let item context override.)
      - `MODULE_KW` -> `items::parse_module_def(p)`
      - `IMPORT_KW` -> `items::parse_import_decl(p)`
      - `FROM_KW`... wait, `from` is not a keyword in the token list. Check: the TokenKind enum does not have a `From` keyword. This means `from` is parsed as an IDENT. The parser must check: if current is IDENT and text is `"from"`, treat it as `from Module import name1, name2`.
      - `STRUCT_KW` -> `items::parse_struct_def(p)`
      - `LET_KW` -> already handled in expressions.rs parse_block_body as parse_let_binding
      - `RETURN_KW` -> already handled
      - Otherwise -> `expressions::expr(p)` (expression-statement)
    - Update `parse_block_body` (in expressions.rs) to call `parse_item_or_stmt(p)` instead of directly dispatching, so blocks can contain function definitions and other items.

    **2. Function definition** -- `items.rs: pub(crate) fn parse_fn_def(p: &mut Parser)`:
    - Open marker.
    - Optional visibility: if PUB_KW, open VISIBILITY marker, advance PUB_KW, close VISIBILITY. (Per discretion: private-by-default, pub is explicit.)
    - Expect FN_KW (or DEF_KW -- handle both, per research open question. Parse identically, the AST can normalize later).
    - Expect IDENT (function name). Wrap in NAME node.
    - Parse parameter list: `expressions::parse_param_list(p)` (reuse from Plan 03).
    - Optional return type: if ARROW (`->`) follows, open TYPE_ANNOTATION marker, advance ARROW, parse type expression (call `parse_type(p)`), close TYPE_ANNOTATION.
    - Expect DO_KW. Record do_span.
    - Parse body: `expressions::parse_block_body(p)`.
    - Expect END_KW. If missing, error_with_related referencing do_span.
    - Close as FN_DEF.

    **3. Module definition** -- `items.rs: pub(crate) fn parse_module_def(p: &mut Parser)`:
    - Open marker.
    - Optional PUB_KW visibility (same pattern as fn).
    - Expect MODULE_KW.
    - Expect IDENT (module name). Wrap in NAME node.
    - Expect DO_KW. Record do_span.
    - Parse module body: loop calling `parse_item_or_stmt(p)` with newline separators until END_KW (modules contain items, not arbitrary expressions -- but for simplicity, reuse the same dispatch).
    - Expect END_KW with related span.
    - Close as MODULE_DEF.
    - Nested modules: `module Outer do module Inner do ... end end` -- naturally handled by recursion.

    **4. Import declarations** -- `items.rs`:
    - `pub(crate) fn parse_import_decl(p: &mut Parser)`:
      - Open marker.
      - Advance IMPORT_KW.
      - Expect IDENT (module name). Could be a dotted path: if DOT follows, parse `Module.Submodule` as a PATH node.
      - Close as IMPORT_DECL.

    - `pub(crate) fn parse_from_import_decl(p: &mut Parser)`:
      - Open marker.
      - Current is IDENT with text "from" -- advance it (treated as contextual keyword).
      - Parse module path: IDENT, possibly dotted.
      - Expect IMPORT_KW.
      - Parse import list: open IMPORT_LIST marker, parse comma-separated IDENTs (the names being imported). Each gets wrapped in NAME node.
      - If any IDENT has text `"*"`, emit error: "glob imports are not allowed in Snow -- import specific names instead" (per locked decision: no glob imports).
      - Actually, `*` is a STAR token, not an IDENT. Check for STAR token after IMPORT_KW and reject: "glob imports (`*`) are not allowed -- list the names you want to import".
      - Close IMPORT_LIST.
      - Close as FROM_IMPORT_DECL.

    **5. Struct definition** -- `items.rs: pub(crate) fn parse_struct_def(p: &mut Parser)`:
    - Open marker.
    - Optional PUB_KW visibility.
    - Expect STRUCT_KW.
    - Expect IDENT (struct name). Wrap in NAME.
    - Optional type parameters: if L_BRACKET, parse TYPE_PARAM_LIST (comma-separated IDENTs in brackets). E.g., `struct Pair[A, B]`.
    - Expect DO_KW. Record do_span.
    - Parse fields: loop until END_KW:
      - Eat newlines.
      - Open STRUCT_FIELD marker.
      - Optional PUB_KW for field visibility.
      - Expect IDENT (field name).
      - Expect COLON_COLON for type annotation.
      - Parse type: `parse_type(p)`.
      - Optional default: if EQ, advance, parse `expr(p)`.
      - Close as STRUCT_FIELD.
    - Expect END_KW with related span.
    - Close as STRUCT_DEF.

    **6. Type parsing** -- `items.rs or a shared location: fn parse_type(p: &mut Parser)`:
    - Parse structural type expressions (semantic validation deferred to Phase 3).
    - Simple type: IDENT (e.g., `Int`, `String`).
    - Generic type: IDENT + L_BRACKET + comma-separated types + R_BRACKET (e.g., `List[Int]`, `Result[T, E]`).
    - Function type: `fn(Type, Type) -> ReturnType` -- if this is too complex for now, defer and just parse as path + optional brackets.
    - Dotted path type: `Module.Type` -- parse as PATH node.
    - For Phase 2, keep it simple: types are paths with optional generic parameters.

    **7. Pattern parsing** -- `patterns.rs: pub(crate) fn parse_pattern(p: &mut Parser)`:
    - `_` (underscore IDENT): open marker, advance, close as WILDCARD_PAT. Check: `_` is parsed as an IDENT by the lexer. Check text equals `"_"`.
    - INT_LITERAL / FLOAT_LITERAL / TRUE_KW / FALSE_KW / NIL_KW / STRING_START: open marker, advance (for strings, parse full string), close as LITERAL_PAT.
    - IDENT (not `_`): could be a variable binding or a constructor name.
      - If followed by L_PAREN or L_BRACE: constructor/struct pattern.
      - Otherwise: open marker, advance IDENT, close as IDENT_PAT (variable binding).
    - L_PAREN: tuple pattern -- open marker, advance, parse comma-separated patterns, expect R_PAREN, close as TUPLE_PAT.
    - This gives enough pattern parsing for Phase 2. More complex patterns (nested, guard-integrated, struct destructuring) can be extended in Phase 4.

    - Update case/match arm parsing (in expressions.rs `parse_case_expr`): replace the expression-based pattern parsing with `patterns::parse_pattern(p)`.
    - Update let binding (in expressions.rs `parse_let_binding`): optionally use `patterns::parse_pattern(p)` instead of just expecting IDENT, so `let (a, b) = pair` works.

    **8. Wire everything** -- Update `parser/mod.rs`:
    - Add `pub(crate) mod items;` and `pub(crate) mod patterns;`
    - Wire `parse_source_file` as the top-level entry point.
    - Update the stubbed `parse()` in lib.rs to call through: tokenize -> create Parser -> parse_source_file -> build_tree -> return Parse.
  </action>
  <verify>
    Run `cargo check -p snow-parser` -- compiles.
    Run `cargo test -p snow-parser` -- existing tests still pass (expression tests should be unaffected).
  </verify>
  <done>
    Parser handles fn/def definitions with pub visibility, module definitions with nesting, import and from-import declarations (no glob), struct definitions with typed fields, pattern parsing (wildcard, ident, literal, tuple), and structural type annotations. parse_source_file is the top-level entry point. pub fn parse(source) -> Parse works end-to-end.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add item, pattern, and integration snapshot tests</name>
  <files>
    crates/snow-parser/tests/parser_tests.rs
  </files>
  <action>
    Extend `crates/snow-parser/tests/parser_tests.rs` with snapshot tests for declarations, patterns, and full programs.

    **Function definitions:**
    - `fn greet(name) do\n  "hello"\nend` -- simple fn
    - `pub fn add(x, y) do\n  x + y\nend` -- pub visibility
    - `fn typed(x :: Int, y :: Int) -> Int do\n  x + y\nend` -- with type annotations and return type
    - `def greet(name) do\n  "hello"\nend` -- def keyword (should parse identically to fn)

    **Module definitions:**
    - `module Math do\n  pub fn add(x, y) do\n    x + y\n  end\nend` -- module with function
    - `module Outer do\n  module Inner do\n  end\nend` -- nested modules

    **Import declarations:**
    - `import Math` -- whole module import
    - `from Math import sqrt, pow` -- selective import (test that "from" as contextual keyword works)

    **Struct definitions:**
    - `struct Point do\n  x :: Float\n  y :: Float\nend` -- basic struct
    - `pub struct Pair[A, B] do\n  first :: A\n  second :: B\nend` -- generic struct with pub

    **Patterns:**
    - `case x do\n  0 -> "zero"\n  _ -> "other"\nend` -- literal and wildcard patterns
    - `let (a, b) = pair` -- tuple destructuring in let
    - `case point do\n  (0, 0) -> "origin"\n  (x, y) -> "other"\nend` -- tuple pattern in case

    **Type annotations:**
    - `let x :: Int = 5` -- basic type
    - `let xs :: List[Int] = []` -- generic type (if list literals exist; if not, test the annotation parsing)

    **Full program integration tests:**
    - A multi-function module:
      ```
      module Calculator do
        pub fn add(x, y) do
          x + y
        end

        pub fn subtract(x, y) do
          x - y
        end

        fn helper() do
          42
        end
      end
      ```
    - A program with imports, functions, and expressions:
      ```
      import IO
      from Math import sqrt

      pub fn distance(x, y) do
        let dx = x * x
        let dy = y * y
        sqrt(dx + dy)
      end
      ```
    - A program with pipe chains and closures:
      ```
      let result = data
        |> map(fn (x) -> x * 2 end)
        |> filter(fn (x) -> x > 10 end)
      ```

    **Error cases:**
    - `fn do end` -- missing function name
    - `module do end` -- missing module name
    - `from Math import *` -- glob import rejected

    Each test should use `insta::assert_snapshot!` with the debug tree output. For the public parse API tests, use `snow_parser::parse(source)` directly.
  </action>
  <verify>
    Run `cargo test -p snow-parser` -- all tests pass.
    Run `cargo insta test -p snow-parser --review` to accept new snapshots.
    Run `cargo test --workspace` -- no regressions.
  </verify>
  <done>
    15+ new snapshot tests covering fn/def definitions, modules (nested), imports (including from-import), structs (with generics), patterns (wildcard, ident, literal, tuple), type annotations, full program integration tests, and error cases. Public parse() API works end-to-end. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass.
2. `pub fn add(x, y) do x + y end` produces FN_DEF with VISIBILITY, NAME, PARAM_LIST, BLOCK.
3. `module Math do ... end` produces MODULE_DEF with nested items.
4. `from Math import sqrt, pow` produces FROM_IMPORT_DECL with IMPORT_LIST.
5. `from Math import *` produces an error (no glob imports).
6. `struct Point do x :: Float y :: Float end` produces STRUCT_DEF with STRUCT_FIELD children.
7. Patterns in case/match arms parse correctly (wildcard, literal, ident, tuple).
8. `snow_parser::parse(source)` works end-to-end from source string to SyntaxNode.
</verification>

<success_criteria>
- Function definitions parse with optional pub, name, params, return type, do/end body
- Module definitions parse with nesting support
- Both import styles work (import Module, from Module import names)
- Glob imports are rejected with clear error
- Struct definitions parse with typed fields and optional generic params
- Patterns work in case arms and let bindings
- Type annotations parse structurally (path with optional generic params)
- Public parse() API works end-to-end
- 15+ new snapshot tests all pass
- Full program integration tests demonstrate complete grammar coverage
</success_criteria>

<output>
After completion, create `.planning/phases/02-parser-ast/02-04-SUMMARY.md`
</output>
