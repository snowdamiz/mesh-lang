---
phase: 02-parser-ast
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/parser/mod.rs
autonomous: true

must_haves:
  truths:
    - "Pratt parser handles all binary operators with correct precedence and associativity"
    - "Unary prefix operators (-, !, not) parse correctly"
    - "Function calls with argument lists parse including nested calls"
    - "Field access chains (a.b.c) parse left-to-right"
    - "Pipe operator |> is left-associative with lowest expression binding power"
    - "Index access (a[0]) parses as postfix"
    - "Grouped expressions in parentheses parse correctly"
    - "Literal atoms (int, float, true, false, nil, string, identifiers) parse as leaf nodes"
  artifacts:
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "Pratt expression parser with binding power tables"
      contains: "fn expr_bp"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "Binding power tables for all Snow operators"
      contains: "fn infix_binding_power"
  key_links:
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/parser/mod.rs"
      via: "Uses Parser struct methods (open, close, advance, current, expect)"
      pattern: "p\\.open\\(\\)|p\\.close\\(|p\\.advance\\(\\)|p\\.current\\(\\)"
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "References SyntaxKind variants for node and token kinds"
      pattern: "SyntaxKind::"
---

<objective>
Implement the Pratt expression parser for all Snow operators and basic expression forms (literals, identifiers, binary/unary operators, function calls, field access, indexing, pipe, grouping).

Purpose: The expression parser is the algorithmic core of the parser. Pratt parsing with binding power handles precedence and associativity elegantly. This plan covers all expression atoms and operators EXCEPT compound expressions (if/else, case/match, closures, blocks) which are added in Plan 03.
Output: Working Pratt parser that correctly handles Snow's operator precedence, verified by unit tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-parser-ast/02-CONTEXT.md
@.planning/phases/02-parser-ast/02-RESEARCH.md
@.planning/phases/02-parser-ast/02-01-SUMMARY.md
@crates/snow-common/src/token.rs
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Pratt expression parser with binding power tables</name>
  <files>
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-parser/src/parser/mod.rs
  </files>
  <action>
    Create `crates/snow-parser/src/parser/expressions.rs` with the full Pratt expression parser.

    1. Define binding power tables:

       `fn infix_binding_power(op: SyntaxKind) -> Option<(u8, u8)>`:
       - Pipe `PIPE` (|>): (3, 4) -- lowest expression precedence, left-associative
       - Logical OR: `OR_KW` / `PIPE_PIPE`: (5, 6) -- left-assoc
       - Logical AND: `AND_KW` / `AMP_AMP`: (7, 8) -- left-assoc
       - Equality: `EQ_EQ`, `NOT_EQ`: (9, 10) -- left-assoc
       - Comparison: `LT`, `GT`, `LT_EQ`, `GT_EQ`: (11, 12) -- left-assoc
       - Range: `DOT_DOT`: (13, 14) -- left-assoc
       - Concat: `DIAMOND` (<>), `PLUS_PLUS` (++): (15, 16) -- left-assoc (may be right-assoc for ++ lists later; left for now)
       - Additive: `PLUS`, `MINUS`: (17, 18) -- left-assoc
       - Multiplicative: `STAR`, `SLASH`, `PERCENT`: (19, 20) -- left-assoc

       `fn prefix_binding_power(op: SyntaxKind) -> Option<((), u8)>`:
       - `MINUS`: ((), 23) -- unary negation (higher than any infix)
       - `BANG`: ((), 23) -- logical not
       - `NOT_KW`: ((), 23) -- keyword `not`

       Postfix operations (calls, field access, indexing) bind tighter than everything: handled inline in the Pratt loop with implicit binding power 25.

    2. Implement `pub(crate) fn expr(p: &mut Parser)`:
       - Calls `expr_bp(p, 0)` as entry point.

    3. Implement `fn expr_bp(p: &mut Parser, min_bp: u8)`:
       This is the core Pratt loop. Structure:

       **Atom/prefix parsing (LHS):**
       - `INT_LITERAL` / `FLOAT_LITERAL`: open marker, advance, close as LITERAL.
       - `TRUE_KW` / `FALSE_KW` / `NIL_KW`: open marker, advance, close as LITERAL.
       - `IDENT`: open marker, advance, close as NAME_REF. (Later plans may extend this for paths like `Module.name`.)
       - `STRING_START`: call `parse_string_expr(p)` to handle the full string with interpolation (delegate to helper).
       - `L_PAREN`: parse grouped expression -- open marker, advance (increments paren_depth via Parser.advance), call `expr_bp(p, 0)`, expect R_PAREN, close as TUPLE_EXPR or just let it be a paren group. For now, close as a grouped expression. If there's a comma inside, it's a tuple -- but for Plan 02, just handle single-expression grouping. Tuple parsing can be a simple extension: after first expr, if comma follows, parse more exprs and close as TUPLE_EXPR.
       - Prefix operators (`MINUS`, `BANG`, `NOT_KW`): get binding power, open marker, advance op token, recurse with `expr_bp(p, r_bp)`, close as UNARY_EXPR.
       - If none match: call `p.error("expected expression")` and return. Since first-error-only, parser will stop.

       **Postfix/infix loop (after LHS parsed):**
       Loop checking `p.current()`:
       - `L_PAREN` (function call): if implicit postfix BP >= min_bp, use `p.open_before(lhs_mark)` to wrap, call `parse_arg_list(p)`, close as CALL_EXPR.
       - `DOT` (field access): if postfix BP >= min_bp, open_before, advance `.`, expect IDENT, close as FIELD_ACCESS.
       - `L_BRACKET` (index access): if postfix BP >= min_bp, open_before, advance `[`, call `expr_bp(p, 0)`, expect `]`, close as INDEX_EXPR.
       - Infix operators: lookup `infix_binding_power(current)`. If Some and l_bp >= min_bp, open_before, advance operator, recurse `expr_bp(p, r_bp)`, close as BINARY_EXPR (or PIPE_EXPR for pipe operator).
       - Otherwise: break the loop.

       **Important:** Always check `p.has_error()` before continuing the loop. If an error occurred, break immediately.

    4. Implement `fn parse_arg_list(p: &mut Parser)`:
       - Open marker, expect L_PAREN (which increments paren_depth in advance()).
       - Parse comma-separated expressions: `expr(p)`, then loop: if COMMA, advance comma, parse another expr.
       - Expect R_PAREN. Close as ARG_LIST.
       - Handle empty arg list: `foo()` -> ARG_LIST with just the parens.

    5. Implement `fn parse_string_expr(p: &mut Parser)`:
       - Open marker.
       - Expect STRING_START (advance it).
       - Loop until STRING_END or EOF:
         - STRING_CONTENT: advance (becomes child token in CST).
         - INTERPOLATION_START: open child marker, advance InterpolationStart, call `expr(p)`, expect INTERPOLATION_END, close child as INTERPOLATION.
         - STRING_END: advance, break.
         - Otherwise: error "unexpected token in string".
       - Close as STRING_EXPR.

    6. Update `crates/snow-parser/src/parser/mod.rs`:
       - Add `pub(crate) mod expressions;` to the module declarations.
       - Make Parser fields/methods accessible to expressions.rs (pub(crate) visibility).
  </action>
  <verify>
    Run `cargo check -p snow-parser` -- compiles without errors.
  </verify>
  <done>
    Pratt expression parser exists with binding power tables for all Snow operators. Handles atoms (literals, idents, strings), prefix operators, all infix operators with correct precedence, and postfix operations (calls, field access, indexing). String interpolation expressions handled.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add expression parser tests proving correct precedence</name>
  <files>
    crates/snow-parser/tests/parser_tests.rs
    crates/snow-parser/src/parser/mod.rs
  </files>
  <action>
    1. Create a test helper in `crates/snow-parser/src/parser/mod.rs` (or in a test utility):
       - `pub(crate) fn parse_expr_from_source(source: &str) -> (rowan::GreenNode, Vec<ParseError>)`:
         Tokenizes source with `snow_lexer::Lexer::tokenize()`, creates Parser, calls `expressions::expr(&mut parser)`, calls `build_tree()`.
       - This is a test-only helper. Mark it `#[cfg(test)]` or put it behind a feature flag. Alternatively, add a minimal internal `parse_source_file` function that wraps expression parsing in a SOURCE_FILE node (will be extended in later plans).

    2. Create `crates/snow-parser/tests/parser_tests.rs`:
       - Import `snow_parser` types.
       - Create a helper function `parse_and_debug(source: &str) -> String` that parses source, gets the SyntaxNode, and formats it as a debug tree string (rowan's `SyntaxNode` has `debug_print()` or you can write a recursive tree printer showing kind + text for each node/token).

    3. Write insta snapshot tests covering:
       - **Literals**: `42`, `3.14`, `true`, `false`, `nil`, `"hello"`
       - **Simple binary**: `1 + 2`, `a * b + c` (verify * binds tighter than +)
       - **Precedence chain**: `1 + 2 * 3 - 4 / 2` (verify correct tree shape)
       - **Unary prefix**: `-x`, `!flag`, `not done`
       - **Unary with binary**: `-x + y` (unary binds tighter)
       - **Comparison**: `a == b`, `x < y + 1`
       - **Logical**: `a and b or c` (and binds tighter than or)
       - **Pipe operator**: `x |> foo()`, `x |> foo() |> bar()` (left-associative, lowest precedence)
       - **Function call**: `foo()`, `foo(1, 2, 3)`, `foo(a, b + c)`
       - **Nested calls**: `foo(bar(x))`
       - **Field access**: `a.b`, `a.b.c`
       - **Index**: `a[0]`, `a[i + 1]`
       - **Mixed postfix**: `a.b(c)[d]`
       - **Grouped**: `(a + b) * c`
       - **String interpolation**: `"hello ${name} world"`, `"${a + b}"`
       - **Pipe with call**: `data |> map(f) |> filter(g)`
       - **Simple error**: `+` (missing LHS -- verify error is produced)

    4. Each test should use `insta::assert_snapshot!` with the debug tree output. The tree format should show node kinds and token text clearly, e.g.:
       ```
       SOURCE_FILE
         BINARY_EXPR
           LITERAL
             INT_LITERAL "1"
           PLUS "+"
           BINARY_EXPR
             LITERAL
               INT_LITERAL "2"
             STAR "*"
             LITERAL
               INT_LITERAL "3"
       ```
  </action>
  <verify>
    Run `cargo test -p snow-parser` -- all tests pass.
    Run `cargo insta test -p snow-parser --review` if needed to accept new snapshots.
    Run `cargo test --workspace` -- no regressions in other crates.
  </verify>
  <done>
    Expression parser has 15+ snapshot tests proving correct operator precedence, associativity, postfix binding, pipe operator behavior, string interpolation, and error handling. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (Phase 1 + new parser tests).
2. Precedence is correct: `1 + 2 * 3` produces tree with * deeper than + (multiplication binds tighter).
3. Pipe is left-associative: `a |> b |> c` produces `((a |> b) |> c)` tree shape.
4. String interpolation: `"${expr}"` produces STRING_EXPR with INTERPOLATION child containing the expression.
5. Error on invalid expression: parser produces ParseError and stops.
</verification>

<success_criteria>
- Pratt parser handles all binary operators (pipe, logical, comparison, arithmetic, range, concat)
- Prefix operators (-, !, not) work with correct binding power
- Postfix operations (call, field access, index) bind tighter than all infix
- String interpolation expressions parse with INTERPOLATION child nodes
- 15+ snapshot tests prove correct precedence and tree structure
- All workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-parser-ast/02-02-SUMMARY.md`
</output>
