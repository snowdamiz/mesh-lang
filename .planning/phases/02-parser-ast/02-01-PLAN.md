---
phase: 02-parser-ast
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/snow-parser/Cargo.toml
  - crates/snow-parser/src/lib.rs
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/cst.rs
  - crates/snow-parser/src/parser/mod.rs
  - crates/snow-parser/src/error.rs
autonomous: true

must_haves:
  truths:
    - "snow-parser crate exists in workspace and compiles"
    - "SyntaxKind enum covers all 85 TokenKind variants plus ~30-40 composite node kinds"
    - "Parser struct consumes token stream and produces rowan GreenNode via events"
    - "Newlines inside delimiters are transparently skipped by parser lookahead"
    - "ParseError carries message, span, and optional related span"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "SyntaxKind enum with repr(u16), TokenKind-to-SyntaxKind conversion"
      contains: "enum SyntaxKind"
    - path: "crates/snow-parser/src/cst.rs"
      provides: "SnowLanguage impl, SyntaxNode/SyntaxToken type aliases"
      contains: "impl rowan::Language for SnowLanguage"
    - path: "crates/snow-parser/src/parser/mod.rs"
      provides: "Event-based Parser struct with open/close/advance/expect, newline significance"
      contains: "struct Parser"
    - path: "crates/snow-parser/src/error.rs"
      provides: "ParseError with message, span, related span"
      contains: "struct ParseError"
  key_links:
    - from: "crates/snow-parser/src/syntax_kind.rs"
      to: "snow-common TokenKind"
      via: "From<TokenKind> conversion"
      pattern: "impl From<TokenKind>"
    - from: "crates/snow-parser/src/parser/mod.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "uses SyntaxKind in events"
      pattern: "use crate::syntax_kind::SyntaxKind"
    - from: "crates/snow-parser/src/parser/mod.rs"
      to: "rowan::GreenNodeBuilder"
      via: "build_tree converts events to green tree"
      pattern: "GreenNodeBuilder"
---

<objective>
Create the snow-parser crate with rowan-based CST infrastructure, event-based Parser struct, and newline significance handling.

Purpose: Establishes the parser foundation that all subsequent parsing plans build on. The SyntaxKind enum, rowan language types, and event-based parser architecture are prerequisites for any actual parsing.
Output: Compiling snow-parser crate with Parser struct capable of consuming tokens and producing rowan green trees, but no actual grammar rules yet.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-parser-ast/02-CONTEXT.md
@.planning/phases/02-parser-ast/02-RESEARCH.md
@crates/snow-common/src/token.rs
@crates/snow-common/src/span.rs
@crates/snow-common/src/error.rs
@crates/snow-lexer/src/lib.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snow-parser crate with SyntaxKind enum and rowan types</name>
  <files>
    Cargo.toml
    crates/snow-parser/Cargo.toml
    crates/snow-parser/src/lib.rs
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/cst.rs
    crates/snow-parser/src/error.rs
  </files>
  <action>
    1. Add `"crates/snow-parser"` to the workspace members in root `Cargo.toml`. Add `rowan = "0.16"` to `[workspace.dependencies]`.

    2. Create `crates/snow-parser/Cargo.toml`:
       - Dependencies: `snow-common = { path = "../snow-common" }`, `snow-lexer = { path = "../snow-lexer" }`, `rowan = { workspace = true }`
       - Dev-dependencies: `insta = { workspace = true }`, `serde = { workspace = true }`

    3. Create `crates/snow-parser/src/syntax_kind.rs`:
       - Define `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] #[repr(u16)] pub enum SyntaxKind` with:
         - All 85 token kinds mapped from TokenKind (use SCREAMING_SNAKE_CASE: `Let` -> `LET_KW`, `Plus` -> `PLUS`, `Ident` -> `IDENT`, `IntLiteral` -> `INT_LITERAL`, etc.)
         - Composite node kinds (~35): SOURCE_FILE, FN_DEF, LET_BINDING, RETURN_EXPR, IF_EXPR, ELSE_BRANCH, CASE_EXPR, MATCH_ARM, BINARY_EXPR, UNARY_EXPR, CALL_EXPR, PIPE_EXPR, FIELD_ACCESS, INDEX_EXPR, BLOCK, PARAM_LIST, PARAM, ARG_LIST, MODULE_DEF, IMPORT_DECL, FROM_IMPORT_DECL, STRUCT_DEF, STRUCT_FIELD, CLOSURE_EXPR, LITERAL, NAME, NAME_REF, PATH, TYPE_ANNOTATION, VISIBILITY, WILDCARD_PAT, IDENT_PAT, LITERAL_PAT, TUPLE_PAT, STRUCT_PAT, STRING_EXPR, INTERPOLATION, TRAILING_CLOSURE, TUPLE_EXPR, TYPE_PARAM_LIST, IMPORT_LIST, STRUCT_LITERAL, STRUCT_LITERAL_FIELD
         - TOMBSTONE and ERROR_NODE sentinel kinds (first two values, 0 and 1)
       - Implement `From<TokenKind> for SyntaxKind` that maps each TokenKind variant to its corresponding SyntaxKind variant.
       - Implement helper methods: `pub fn is_trivia(self) -> bool` (returns true for WHITESPACE, NEWLINE, COMMENT).

    4. Create `crates/snow-parser/src/cst.rs`:
       - Define `pub enum SnowLanguage {}`.
       - Implement `rowan::Language for SnowLanguage` with `type Kind = SyntaxKind`. Use `unsafe { std::mem::transmute::<u16, SyntaxKind>(raw.0) }` for `kind_from_raw` and `rowan::SyntaxKind(kind as u16)` for `kind_to_raw`.
       - Define type aliases: `pub type SyntaxNode = rowan::SyntaxNode<SnowLanguage>;` and `pub type SyntaxToken = rowan::SyntaxToken<SnowLanguage>;` and `pub type SyntaxElement = rowan::SyntaxElement<SnowLanguage>;`.

    5. Create `crates/snow-parser/src/error.rs`:
       - Define `#[derive(Debug, Clone, PartialEq)] pub struct ParseError` with fields: `pub message: String`, `pub span: Span`, `pub related: Option<(String, Span)>`.
       - Implement `Display` for ParseError showing the message.
       - Implement convenience constructors: `new(message, span)` and `with_related(message, span, related_message, related_span)`.

    6. Create `crates/snow-parser/src/lib.rs`:
       - Declare modules: `pub mod syntax_kind;`, `pub mod cst;`, `pub mod error;`, `mod parser;`
       - Re-export key types: `pub use syntax_kind::SyntaxKind;`, `pub use cst::{SyntaxNode, SyntaxToken, SyntaxElement};`, `pub use error::ParseError;`
       - Stub the public parse API (placeholder): `pub fn parse(_source: &str) -> Parse { todo!() }` with `pub struct Parse { green: rowan::GreenNode, errors: Vec<ParseError> }` and accessor methods `syntax(&self) -> SyntaxNode`, `errors(&self) -> &[ParseError]`.
  </action>
  <verify>
    Run `cargo check -p snow-parser` -- should compile with no errors (parse function will be `todo!()` which is fine for type checking).
    Run `cargo test -p snow-common` -- existing tests still pass (no regressions).
  </verify>
  <done>
    snow-parser crate exists in workspace, compiles, and has SyntaxKind enum covering all TokenKind variants plus composite node kinds. Rowan language type is implemented. ParseError type has message + span + related span.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement event-based Parser struct with newline significance</name>
  <files>
    crates/snow-parser/src/parser/mod.rs
  </files>
  <action>
    Create `crates/snow-parser/src/parser/mod.rs` with the event-based parser architecture.

    1. Define `Event` enum:
       ```
       enum Event {
           Open { kind: SyntaxKind },
           Close,
           Advance,
           Error { message: String },
       }
       ```

    2. Define `MarkOpened` struct (just an index into events vec) and `MarkClosed` struct.

    3. Define `Parser` struct:
       - Fields: `tokens: Vec<Token>`, `pos: usize`, `events: Vec<Event>`, `source: &str`, `paren_depth: u32`, `bracket_depth: u32`, `brace_depth: u32`, `errors: Vec<ParseError>`, `has_error: bool` (flag to stop on first error).
       - Constructor: `new(tokens: Vec<Token>, source: &str) -> Self` (filter out Eof at end if desired, or keep it).

    4. Core methods:
       - `fn current(&self) -> SyntaxKind` -- returns kind of current token, skipping insignificant newlines (newlines when any delimiter depth > 0). Returns EOF if past end.
       - `fn nth(&self, n: usize) -> SyntaxKind` -- lookahead N tokens, skipping insignificant newlines. Returns EOF if past end.
       - `fn current_text(&self) -> &str` -- returns text slice for current token using span and source.
       - `fn current_span(&self) -> Span` -- returns span of current token.
       - `fn at(&self, kind: SyntaxKind) -> bool` -- checks if current() equals kind.
       - `fn at_any(&self, kinds: &[SyntaxKind]) -> bool` -- checks if current matches any.

    5. Mutation methods:
       - `fn open(&mut self) -> MarkOpened` -- pushes `Event::Open { kind: TOMBSTONE }`, returns marker.
       - `fn open_before(&mut self, completed: MarkClosed) -> MarkOpened` -- inserts an Open event before a previously completed node (for wrapping, e.g., turning an ident into a call_expr's child). Uses the MarkClosed index to find where to insert.
       - `fn close(&mut self, m: MarkOpened, kind: SyntaxKind) -> MarkClosed` -- patches the Open event at marker with the real kind, pushes Close event.
       - `fn advance(&mut self)` -- emits all skipped newline/whitespace tokens as Advance events (they become trivia in the CST), then emits Advance for the current significant token. Updates delimiter depths when consuming `(`, `)`, `[`, `]`, `{`, `}`.
       - `fn advance_with_error(&mut self, message: &str)` -- wraps current token in an error node, advances.
       - `fn expect(&mut self, kind: SyntaxKind) -> bool` -- if current matches, advance and return true. Otherwise, emit error and return false. On error, set `has_error = true`.
       - `fn eat(&mut self, kind: SyntaxKind) -> bool` -- like expect but no error on mismatch, just returns false.
       - `fn eat_newlines(&mut self)` -- consume any significant newlines (used as statement separators).

    6. Error methods:
       - `fn error(&mut self, message: &str)` -- pushes ParseError with current span, sets has_error flag.
       - `fn error_with_related(&mut self, message: &str, related_span: Span, related_msg: &str)` -- same but with related span (for unclosed delimiters).
       - `fn has_error(&self) -> bool` -- returns the flag. Parse functions should check this and bail early.

    7. Newline significance logic (centralized in `skip_to_significant` helper used by `current()` and `nth()`):
       - If `paren_depth > 0 || bracket_depth > 0 || brace_depth > 0`, skip all NEWLINE tokens.
       - Also skip WHITESPACE and COMMENT tokens (these are always trivia in the token cursor; they get added to the CST via advance()).
       - Do NOT skip newlines when at zero delimiter depth -- they are significant.
       - Note: The advance() method must still emit Advance events for skipped trivia tokens so they appear in the CST.

    8. Tree building: `fn build_tree(self) -> (rowan::GreenNode, Vec<ParseError>)`:
       - Creates `rowan::GreenNodeBuilder::new()`.
       - Walks the events list. For each:
         - `Open { kind }`: call `builder.start_node(kind.into())`. Handle `open_before` by tracking forward parent stack.
         - `Close`: call `builder.finish_node()`.
         - `Advance`: look up the token at the current token position, call `builder.token(syntax_kind, text)` for the token. Advance the token position.
         - `Error`: wrap in an ERROR_NODE.
       - After all events, call `builder.finish()` to get the GreenNode.
       - Use the "forward parent" technique from rust-analyzer for `open_before`: when processing events, if an Open was inserted before a completed node, adjust the processing order. (The standard approach: events are stored in order, but `open_before` modifies the event at the completed node's open position. The simpler approach for first-error-only: track a stack of "forward parents" that get opened before the next Advance.)
       - Return (green_node, errors).

    9. Add a simple smoke test in the file: `#[cfg(test)] mod tests` with a test that creates a Parser from a few tokens (e.g., `let x = 5`) and calls `advance()` a few times, then `build_tree()`, verifying a GreenNode is produced with the right structure.
  </action>
  <verify>
    Run `cargo test -p snow-parser` -- smoke test passes.
    Run `cargo check -p snow-parser` -- no compilation errors.
  </verify>
  <done>
    Parser struct exists with event-based architecture, delimiter-depth tracking for newline significance, open/close/advance API, error reporting with related spans, and build_tree that produces rowan GreenNode. Smoke test proves tokens flow through to a green tree.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` -- all crates compile.
2. `cargo test --workspace` -- all existing tests (57 from Phase 1) still pass plus new parser smoke test(s).
3. SyntaxKind enum has a variant for every TokenKind (verify via a test that converts all 85 TokenKind values to SyntaxKind without panic).
4. Parser can consume tokens and produce a GreenNode with correct token text preserved.
</verification>

<success_criteria>
- snow-parser crate compiles and is part of workspace
- SyntaxKind has 85+ token variants + 35+ node variants
- Parser struct has event-based open/close/advance/expect API
- Newlines inside delimiters are skipped by current()/nth()
- build_tree() produces rowan GreenNode from parser events
- ParseError has message, span, and optional related span
- All workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-parser-ast/02-01-SUMMARY.md`
</output>
