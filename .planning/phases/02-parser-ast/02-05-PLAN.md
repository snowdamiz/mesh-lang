---
phase: 02-parser-ast
plan: 05
type: execute
wave: 5
depends_on: ["02-04"]
files_modified:
  - crates/snow-parser/src/ast/mod.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-parser/src/ast/item.rs
  - crates/snow-parser/src/ast/pat.rs
  - crates/snow-parser/src/lib.rs
  - crates/snow-parser/tests/parser_tests.rs
autonomous: true

must_haves:
  truths:
    - "Typed AST nodes wrap rowan SyntaxNode with zero-cost accessors"
    - "All CST node kinds have corresponding typed AST wrappers"
    - "AST nodes can be obtained from SyntaxNode via cast() method"
    - "FnDef AST node provides name(), param_list(), body(), visibility(), return_type()"
    - "LetBinding AST node provides name/pattern, type annotation, initializer"
    - "IfExpr provides condition(), then_branch(), else_branch()"
    - "The public parse() API returns a Parse object with syntax() and errors()"
    - "Snapshot tests cover all grammar constructs and prove lossless round-trip"
  artifacts:
    - path: "crates/snow-parser/src/ast/mod.rs"
      provides: "AstNode trait and cast infrastructure"
      contains: "trait AstNode"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "Typed wrappers for expression CST nodes"
      contains: "struct IfExpr"
    - path: "crates/snow-parser/src/ast/item.rs"
      provides: "Typed wrappers for item/declaration CST nodes"
      contains: "struct FnDef"
    - path: "crates/snow-parser/src/ast/pat.rs"
      provides: "Typed wrappers for pattern CST nodes"
      contains: "struct IdentPat"
  key_links:
    - from: "crates/snow-parser/src/ast/mod.rs"
      to: "crates/snow-parser/src/cst.rs"
      via: "AstNode trait wraps SyntaxNode, cast checks SyntaxKind"
      pattern: "SyntaxNode|SyntaxKind"
    - from: "crates/snow-parser/src/lib.rs"
      to: "crates/snow-parser/src/ast/mod.rs"
      via: "Public API re-exports AST types"
      pattern: "pub use ast::|pub mod ast"
    - from: "crates/snow-parser/src/lib.rs"
      to: "crates/snow-parser/src/parser/mod.rs"
      via: "parse() calls parser::parse_source_file and build_tree"
      pattern: "parse_source_file|build_tree"
---

<objective>
Create the typed AST layer on top of the rowan CST and finalize the public parse() API with comprehensive snapshot tests proving all grammar constructs work correctly.

Purpose: The typed AST provides zero-cost typed accessors for downstream phases (type checker, codegen). The public API makes the parser consumable by other crates. Comprehensive tests prove the parser is feature-complete for Phase 2 requirements.
Output: Complete snow-parser crate with typed AST wrappers, public parse API, and 40+ snapshot tests covering all Snow grammar constructs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-parser-ast/02-CONTEXT.md
@.planning/phases/02-parser-ast/02-RESEARCH.md
@.planning/phases/02-parser-ast/02-04-SUMMARY.md
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/cst.rs
@crates/snow-parser/src/parser/mod.rs
@crates/snow-parser/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed AST layer with AstNode trait and typed wrappers</name>
  <files>
    crates/snow-parser/src/ast/mod.rs
    crates/snow-parser/src/ast/expr.rs
    crates/snow-parser/src/ast/item.rs
    crates/snow-parser/src/ast/pat.rs
    crates/snow-parser/src/lib.rs
  </files>
  <action>
    Create the typed AST layer following the rust-analyzer pattern: each typed AST node wraps a SyntaxNode and provides typed accessor methods. Zero runtime cost -- just references into the CST.

    **1. `ast/mod.rs` -- AstNode trait and utilities:**

    ```rust
    use crate::cst::{SyntaxNode, SyntaxToken, SyntaxKind};

    pub mod expr;
    pub mod item;
    pub mod pat;

    /// Trait for typed AST nodes that wrap rowan SyntaxNode.
    pub trait AstNode: Sized {
        fn cast(node: SyntaxNode) -> Option<Self>;
        fn syntax(&self) -> &SyntaxNode;
    }

    /// Helper: find first child node of a specific kind.
    fn child_node<N: AstNode>(parent: &SyntaxNode) -> Option<N> {
        parent.children().find_map(N::cast)
    }

    /// Helper: find first child token of a specific kind.
    fn child_token(parent: &SyntaxNode, kind: SyntaxKind) -> Option<SyntaxToken> {
        parent.children_with_tokens()
            .filter_map(|it| it.into_token())
            .find(|t| t.kind() == kind.into())
    }
    ```

    **2. `ast/item.rs` -- Declaration/item AST nodes:**

    Implement typed wrappers for each item SyntaxKind:

    - **`SourceFile`** (wraps SOURCE_FILE):
      - `items(&self) -> impl Iterator<Item = Item>` -- iterate over top-level items
      - `fn_defs(&self) -> impl Iterator<Item = FnDef>` -- convenience
      - `modules(&self) -> impl Iterator<Item = ModuleDef>` -- convenience

    - **`FnDef`** (wraps FN_DEF):
      - `visibility(&self) -> Option<SyntaxToken>` -- returns PUB_KW token if present
      - `name(&self) -> Option<SyntaxToken>` -- returns IDENT token (function name)
      - `param_list(&self) -> Option<ParamList>` -- typed PARAM_LIST child
      - `return_type(&self) -> Option<TypeAnnotation>` -- TYPE_ANNOTATION child
      - `body(&self) -> Option<Block>` -- BLOCK child (the do...end body)

    - **`ParamList`** (wraps PARAM_LIST):
      - `params(&self) -> impl Iterator<Item = Param>` -- iterate Param children

    - **`Param`** (wraps PARAM):
      - `name(&self) -> Option<SyntaxToken>` -- IDENT
      - `type_annotation(&self) -> Option<TypeAnnotation>` -- optional :: Type

    - **`TypeAnnotation`** (wraps TYPE_ANNOTATION):
      - `type_name(&self) -> Option<SyntaxToken>` -- IDENT (basic type name)
      - Children for generic params if present

    - **`ModuleDef`** (wraps MODULE_DEF):
      - `visibility(&self) -> Option<SyntaxToken>`
      - `name(&self) -> Option<SyntaxToken>`
      - `items(&self) -> impl Iterator<Item = Item>` -- nested items

    - **`ImportDecl`** (wraps IMPORT_DECL):
      - `module_path(&self) -> Option<SyntaxToken>` -- module name

    - **`FromImportDecl`** (wraps FROM_IMPORT_DECL):
      - `module_path(&self) -> Option<SyntaxToken>`
      - `import_list(&self) -> Option<ImportList>` -- the names

    - **`ImportList`** (wraps IMPORT_LIST):
      - `names(&self) -> impl Iterator<Item = SyntaxToken>` -- imported names

    - **`StructDef`** (wraps STRUCT_DEF):
      - `visibility(&self) -> Option<SyntaxToken>`
      - `name(&self) -> Option<SyntaxToken>`
      - `fields(&self) -> impl Iterator<Item = StructField>`

    - **`StructField`** (wraps STRUCT_FIELD):
      - `visibility(&self) -> Option<SyntaxToken>`
      - `name(&self) -> Option<SyntaxToken>`
      - `type_annotation(&self) -> Option<TypeAnnotation>`

    - **`Item`** enum wrapping all item kinds -- for iteration:
      ```rust
      pub enum Item {
          FnDef(FnDef),
          ModuleDef(ModuleDef),
          ImportDecl(ImportDecl),
          FromImportDecl(FromImportDecl),
          StructDef(StructDef),
          LetBinding(LetBinding),
      }
      ```

    - **`LetBinding`** (wraps LET_BINDING):
      - `name(&self) -> Option<SyntaxToken>` -- IDENT or pattern
      - `type_annotation(&self) -> Option<TypeAnnotation>`
      - `initializer(&self) -> Option<Expr>` -- expression after =

    **3. `ast/expr.rs` -- Expression AST nodes:**

    - **`Expr`** enum wrapping all expression kinds:
      ```rust
      pub enum Expr {
          Literal(Literal),
          NameRef(NameRef),
          BinaryExpr(BinaryExpr),
          UnaryExpr(UnaryExpr),
          CallExpr(CallExpr),
          PipeExpr(PipeExpr),
          FieldAccess(FieldAccess),
          IndexExpr(IndexExpr),
          IfExpr(IfExpr),
          CaseExpr(CaseExpr),
          ClosureExpr(ClosureExpr),
          Block(Block),
          StringExpr(StringExpr),
          ReturnExpr(ReturnExpr),
          TupleExpr(TupleExpr),
      }
      ```

    - **`Literal`** (wraps LITERAL): `token(&self) -> Option<SyntaxToken>`
    - **`NameRef`** (wraps NAME_REF): `ident(&self) -> Option<SyntaxToken>`
    - **`BinaryExpr`** (wraps BINARY_EXPR): `lhs()`, `op()`, `rhs()`
    - **`UnaryExpr`** (wraps UNARY_EXPR): `op()`, `operand()`
    - **`CallExpr`** (wraps CALL_EXPR): `callee()`, `arg_list()`, `trailing_closure()`
    - **`PipeExpr`** (wraps PIPE_EXPR): `lhs()`, `rhs()`
    - **`FieldAccess`** (wraps FIELD_ACCESS): `base()`, `field_name()`
    - **`IndexExpr`** (wraps INDEX_EXPR): `base()`, `index()`
    - **`IfExpr`** (wraps IF_EXPR): `condition()`, `then_branch() -> Option<Block>`, `else_branch() -> Option<ElseBranch>`
    - **`ElseBranch`** (wraps ELSE_BRANCH): `block() -> Option<Block>`, `if_expr() -> Option<IfExpr>` (for else-if)
    - **`CaseExpr`** (wraps CASE_EXPR): `scrutinee()`, `arms() -> impl Iterator<Item = MatchArm>`
    - **`MatchArm`** (wraps MATCH_ARM): `pattern()`, `guard()`, `body()`
    - **`ClosureExpr`** (wraps CLOSURE_EXPR): `param_list()`, `body()`
    - **`Block`** (wraps BLOCK): `stmts() -> impl Iterator<...>`, `tail_expr() -> Option<Expr>` (last expression)
    - **`StringExpr`** (wraps STRING_EXPR): `parts() -> impl Iterator<...>` (string content and interpolations)
    - **`ReturnExpr`** (wraps RETURN_EXPR): `value() -> Option<Expr>`

    **4. `ast/pat.rs` -- Pattern AST nodes:**

    - **`Pattern`** enum: WildcardPat, IdentPat, LiteralPat, TuplePat
    - **`WildcardPat`** (wraps WILDCARD_PAT)
    - **`IdentPat`** (wraps IDENT_PAT): `name() -> Option<SyntaxToken>`
    - **`LiteralPat`** (wraps LITERAL_PAT): `literal() -> Option<SyntaxToken>`
    - **`TuplePat`** (wraps TUPLE_PAT): `patterns() -> impl Iterator<Item = Pattern>`

    **5. Update `lib.rs`:**
    - Add `pub mod ast;`
    - Re-export key AST types: `pub use ast::{expr::*, item::*, pat::*};` or selective re-exports.
    - Implement the real `parse()` function (replace the `todo!()`):
      ```rust
      pub fn parse(source: &str) -> Parse {
          let tokens: Vec<Token> = snow_lexer::Lexer::tokenize(source);
          let mut parser = parser::Parser::new(tokens, source);
          parser::parse_source_file(&mut parser);
          let (green, errors) = parser.build_tree();
          Parse { green, errors }
      }
      ```
    - Add `Parse::tree(&self) -> SourceFile` convenience that casts the root SyntaxNode to SourceFile.

    **Implementation notes:**
    - Each AST node struct has a single field: `syntax: SyntaxNode`.
    - The `cast()` method checks `node.kind() == TARGET_KIND` and wraps if matching.
    - Accessor methods navigate children of the underlying SyntaxNode.
    - Use a macro to reduce boilerplate if there are many nodes:
      ```rust
      macro_rules! ast_node {
          ($name:ident, $kind:ident) => {
              #[derive(Debug, Clone)]
              pub struct $name { syntax: SyntaxNode }
              impl AstNode for $name {
                  fn cast(node: SyntaxNode) -> Option<Self> {
                      if node.kind() == SyntaxKind::$kind.into() { Some(Self { syntax: node }) } else { None }
                  }
                  fn syntax(&self) -> &SyntaxNode { &self.syntax }
              }
          };
      }
      ```
    - Use rowan's `SyntaxNode::kind()` which returns `rowan::SyntaxKind` -- convert back to `SyntaxKind` using the Language trait.
  </action>
  <verify>
    Run `cargo check -p snow-parser` -- compiles.
    Run `cargo test -p snow-parser` -- all existing tests pass.
    Verify: `snow_parser::parse("let x = 5")` returns a Parse with no errors and a valid SyntaxNode tree.
  </verify>
  <done>
    Typed AST layer provides zero-cost wrappers for all CST node kinds. AstNode trait with cast()/syntax() methods. Expr enum, Item enum, Pattern enum for polymorphic access. Public parse(source) -> Parse API works end-to-end. All accessor methods (name, params, body, etc.) traverse the CST.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive snapshot tests and error message quality verification</name>
  <files>
    crates/snow-parser/tests/parser_tests.rs
  </files>
  <action>
    Finalize the test suite with comprehensive coverage, AST accessor tests, and error message quality tests. This task ensures Phase 2 success criteria are met.

    **1. Full program snapshot tests via the public parse() API:**

    Use `snow_parser::parse(source)` for all tests now (not internal helpers). The debug tree should include all tokens (lossless CST).

    Add full program tests:

    - **Complete module with multiple functions:**
      ```
      module Greeter do
        pub fn greet(name) do
          "Hello, ${name}!"
        end

        fn private_helper() do
          42
        end
      end
      ```

    - **Program with imports, pipe chains, and closures:**
      ```
      import IO
      from List import map, filter

      let numbers = [1, 2, 3, 4, 5]
      let result = numbers
        |> map(fn (x) -> x * 2 end)
        |> filter(fn (x) -> x > 4 end)
      ```
      (Note: list literals `[1, 2, 3]` may not be parsed yet -- if not, use a simpler example or add basic list literal parsing as L_BRACKET exprs R_BRACKET.)

    - **Nested if/else with case:**
      ```
      fn classify(x) do
        if x > 0 do
          case x do
            1 -> "one"
            _ -> "positive"
          end
        else
          "non-positive"
        end
      end
      ```

    - **Struct definition and usage:**
      ```
      pub struct Point do
        x :: Float
        y :: Float
      end

      fn origin() do
        Point { x: 0.0, y: 0.0 }
      end
      ```
      (Note: struct literal syntax `Point { x: 0.0 }` -- verify this parses or note if not yet supported.)

    **2. AST accessor tests (unit tests, not snapshots):**

    - Parse `pub fn add(x, y) do x + y end`, cast root to SourceFile, get first FnDef, verify:
      - `fn_def.visibility().is_some()` (has pub)
      - `fn_def.name().unwrap().text() == "add"`
      - `fn_def.param_list().unwrap().params().count() == 2`

    - Parse `let x :: Int = 5`, get LetBinding, verify:
      - `let_binding.type_annotation().is_some()`
      - `let_binding.initializer().is_some()`

    - Parse `if true do 1 else 2 end`, get IfExpr, verify:
      - `if_expr.else_branch().is_some()`

    **3. Error message quality tests:**

    Verify error messages match the Elm-friendly + Rust-precise standard:

    - `fn foo() do 1` (missing end):
      - Error message contains "expected `end`"
      - Error has related span pointing to `do`

    - `if x do 1 else if y do 2` (missing end on nested if):
      - Error references the innermost unclosed `do`

    - `from Math import *` (glob import):
      - Error contains "glob imports" or "not allowed"

    - `let = 5` (missing binding name):
      - Error mentions expected identifier/pattern

    - Verify each error has a non-empty message and a valid span (start < end, within source bounds).

    **4. Lossless round-trip test:**

    For each parsed tree, verify the CST text equals the original source:
    ```rust
    let source = "pub fn add(x, y) do\n  x + y\nend\n";
    let parse = snow_parser::parse(source);
    assert_eq!(parse.syntax().text().to_string(), source);
    ```
    This proves the CST is truly lossless -- all whitespace, comments, and tokens preserved.

    Add round-trip tests for 5+ source strings of varying complexity.
  </action>
  <verify>
    Run `cargo test -p snow-parser` -- all tests pass (should be 40+ total across all plan phases).
    Run `cargo insta test -p snow-parser --review` to accept final snapshots.
    Run `cargo test --workspace` -- no regressions (Phase 1 tests + all parser tests pass).
  </verify>
  <done>
    40+ total parser tests across all plans. Full program snapshots demonstrate complete grammar coverage. AST accessor tests prove typed wrappers work. Error tests prove Elm/Rust quality messages with related spans. Lossless round-trip tests prove CST preserves all source text. All workspace tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (57 Phase 1 + 40+ Phase 2 parser tests).
2. `snow_parser::parse(source).syntax().text() == source` for all test inputs (lossless CST).
3. AST accessor methods return correct values (FnDef.name(), IfExpr.condition(), etc.).
4. Error messages reference related spans (unclosed do -> "started here").
5. No glob imports allowed (error produced for `from X import *`).
6. `cargo doc -p snow-parser` generates documentation for public API.
</verification>

<success_criteria>
- AstNode trait with cast()/syntax() for all node types
- Typed wrappers for all expressions, items, and patterns
- Public parse(source) -> Parse API works end-to-end
- Parse::syntax() returns rowan SyntaxNode, Parse::errors() returns Vec<ParseError>
- Lossless CST: parsed_tree.text() == original_source for all inputs
- 40+ total tests across the parser test suite
- Error messages are descriptive with related spans for unclosed delimiters
- Full program integration tests parse correctly
- All workspace tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-parser-ast/02-05-SUMMARY.md`
</output>
