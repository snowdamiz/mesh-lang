---
phase: 02-parser-ast
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/parser/mod.rs
  - crates/snow-parser/tests/parser_tests.rs
autonomous: true

must_haves:
  truths:
    - "if/else expressions parse as expressions returning the value of their last expression"
    - "case/match expressions parse with pattern -> body arms"
    - "Closures (fn params -> body end) parse as expression atoms"
    - "do/end blocks parse as a sequence of statements where last expression is the block value"
    - "Newlines act as statement separators in blocks at zero delimiter depth"
    - "Trailing closures attach to the preceding function call"
    - "let bindings parse with optional type annotation and initializer"
    - "return expressions parse with optional value"
  artifacts:
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "if/else, case/match, closure, block, string interpolation compound expressions"
      contains: "fn parse_if_expr"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "Trailing closure parsing after call expressions"
      contains: "parse_trailing_closure"
  key_links:
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/parser/mod.rs"
      via: "Block parsing calls expr() for each statement in sequence"
      pattern: "parse_block_body|parse_stmt"
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/parser/expressions.rs"
      via: "if/case/closure expressions call expr_bp recursively"
      pattern: "expr_bp\\(p|expr\\(p"
---

<objective>
Add compound expressions (if/else, case/match, closures, blocks with do/end) and basic statements (let bindings, return) to the parser. These constructs bridge expressions and statements -- they are expressions that contain blocks, which contain statement sequences.

Purpose: After Plan 02 handles simple expressions and operators, this plan adds the expression forms that contain nested blocks and introduce names. This completes the expression language and enables parsing real Snow programs.
Output: Parser handles all expression and basic statement forms, with blocks acting as statement sequences where newlines are significant separators.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-parser-ast/02-CONTEXT.md
@.planning/phases/02-parser-ast/02-RESEARCH.md
@.planning/phases/02-parser-ast/02-02-SUMMARY.md
@crates/snow-common/src/token.rs
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/mod.rs
@crates/snow-parser/src/parser/expressions.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement compound expressions and block parsing</name>
  <files>
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-parser/src/parser/mod.rs
  </files>
  <action>
    Extend `crates/snow-parser/src/parser/expressions.rs` with compound expression forms and block parsing.

    1. **Block parsing** -- `pub(crate) fn parse_block_body(p: &mut Parser)`:
       - A block is a sequence of statements separated by significant newlines (or semicolons).
       - Loop: eat any leading newlines, then check if current token starts a statement.
       - A "statement" is either:
         - `LET_KW`: call `parse_let_binding(p)` (defined below)
         - `RETURN_KW`: call `parse_return_expr(p)`
         - Otherwise: call `expr(p)` to parse an expression-statement
       - After each statement, expect either a NEWLINE, SEMICOLON, or a token that ends the block (END_KW, ELSE_KW, EOF). Eat the newline/semicolon separator.
       - The last expression in the block is implicitly the block's value. No special handling needed at this level -- the AST layer determines this.
       - Stop the loop when current token is END_KW, ELSE_KW, EOF, or error.

    2. **Let binding** -- `fn parse_let_binding(p: &mut Parser)`:
       - Open marker.
       - Advance LET_KW.
       - Parse pattern or just IDENT for now (simple let): expect IDENT.
       - Optional type annotation: if COLON_COLON (`::`) follows, advance it, then parse a type expression (for now, just expect an IDENT as the type name, possibly with `[` type params `]`). Wrap in TYPE_ANNOTATION node.
       - Expect EQ (`=`).
       - Parse initializer: call `expr(p)`.
       - Close as LET_BINDING.

    3. **Return expression** -- `fn parse_return_expr(p: &mut Parser)`:
       - Open marker.
       - Advance RETURN_KW.
       - If the next token looks like an expression start (not a newline, not END_KW, not EOF), parse the return value with `expr(p)`.
       - Close as RETURN_EXPR.

    4. **If/else expression** -- `fn parse_if_expr(p: &mut Parser)`:
       - Open marker (already opened by Pratt atom dispatch).
       - Advance IF_KW.
       - Parse condition: `expr(p)` (this is why if/else is an expression in the Pratt parser -- condition is any expression).
       - Expect DO_KW. Record do_span for error reporting.
       - Parse body: `parse_block_body(p)`.
       - Check for ELSE_KW:
         - If present: advance ELSE_KW. Open ELSE_BRANCH marker.
           - If next is IF_KW: parse `parse_if_expr(p)` for else-if chain (wrap in ELSE_BRANCH).
           - Otherwise: parse `parse_block_body(p)` for else block, expect END_KW.
           - Close ELSE_BRANCH.
         - If no ELSE: expect END_KW. If missing, error with related span pointing to do_span: "expected `end` to close `do` block started at line X, column Y".
       - Close as IF_EXPR.

    5. **Case/match expression** -- `fn parse_case_expr(p: &mut Parser)`:
       - Open marker.
       - Advance CASE_KW (or MATCH_KW -- handle both identically per research recommendation).
       - Parse scrutinee expression: `expr(p)`.
       - Expect DO_KW. Record do_span.
       - Parse match arms: loop until END_KW or EOF:
         - Eat newlines.
         - If END_KW: break.
         - Open MATCH_ARM marker.
         - Parse pattern (for now, parse as expression -- Plan 04 will add proper pattern parsing. In the interim, patterns look like expressions: literals, identifiers, wildcards. Treat `_` identifier as wildcard).
         - Optional WHEN_KW guard: if present, advance, parse guard expression.
         - Expect ARROW (`->`).
         - Parse arm body: `expr(p)` (single expression per arm for now; can extend to blocks later).
         - Close as MATCH_ARM.
         - Eat newlines between arms.
       - Expect END_KW with related span to do_span.
       - Close as CASE_EXPR.

    6. **Closure expression** -- `fn parse_closure(p: &mut Parser)`:
       - Open marker.
       - Advance FN_KW.
       - Parse parameter list:
         - If L_PAREN: `parse_param_list(p)` (comma-separated identifiers in parens).
         - If no parens, parameters might be specified differently. For Snow closures, syntax is `fn (x, y) -> body end` or `fn x -> body end`. Parse params in parens.
       - Expect ARROW (`->`).
       - Parse body: `expr(p)` or `parse_block_body(p)` if DO_KW follows.
       - If body started with DO_KW, expect END_KW.
       - Otherwise, the body is a single expression (no end needed for `fn (x) -> x * 2 end` -- actually, Snow closures do use `end`. Check: in Elixir-style, `fn x -> body end` uses `end`).
       - Per Snow syntax: anonymous functions are `fn (params) -> body end`. Always expect END_KW to close.
       - Close as CLOSURE_EXPR.

    7. **Trailing closure** -- Extend the call expression handling in the Pratt loop:
       - After parsing CALL_EXPR's arg list `)`, check if `p.current() == DO_KW`.
       - If so: open TRAILING_CLOSURE marker, advance DO_KW, record do_span.
         - Optional closure params: if `PIPE` follows... wait, trailing closures use `do |params| ... end` syntax. But PIPE is `|>` in Snow's lexer. The `|` character produces Error token from lexer.
         - **Resolution:** For trailing closure params like `do |x, y| ... end`, the bare `|` is an Error token from the lexer. The parser should recognize the pattern: after DO_KW, if the next token is an Error token with text `"|"`, treat it as the start of a parameter list. Read params until another `"|"` Error token, then parse block body, expect END_KW.
         - Alternatively, if this is too fragile, trailing closure params can use a different syntax for now (e.g., `do (x, y) -> ... end`). Use the approach that matches the user's stated syntax: `list.map() do |x| ... end`.
         - Implementation: After DO_KW, peek at current token. If it's an Error token, check its text via `p.current_text()`. If text is `"|"`, consume it (as trivia or advance through it), parse comma-separated IDENT params, expect another `"|"` Error token, then parse_block_body, expect END_KW.
       - Close as TRAILING_CLOSURE, which is a child of the CALL_EXPR.

    8. **Integrate into Pratt atom dispatch**: In `expr_bp`, add cases for:
       - `IF_KW` -> call `parse_if_expr(p)`
       - `CASE_KW` / `MATCH_KW` -> call `parse_case_expr(p)`
       - `FN_KW` -> call `parse_closure(p)` (but only when FN_KW appears in expression position; in item position it's a function definition -- Plan 04 will handle disambiguation)

    9. **Parse param list** -- `pub(crate) fn parse_param_list(p: &mut Parser)`:
       - Open PARAM_LIST marker.
       - Expect L_PAREN.
       - Loop: parse PARAM (ident with optional type annotation), comma-separated.
       - Each PARAM: open marker, expect IDENT, optional `::` type annotation, close as PARAM.
       - Expect R_PAREN.
       - Close as PARAM_LIST.
  </action>
  <verify>
    Run `cargo check -p snow-parser` -- compiles.
    Run `cargo test -p snow-parser` -- existing expression tests still pass.
  </verify>
  <done>
    Parser handles if/else (including else-if chains), case/match with arms, closures with params, do/end blocks with statement sequences, let bindings with optional type annotations, return expressions, and trailing closures on function calls. Newlines separate statements in blocks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add compound expression and statement snapshot tests</name>
  <files>
    crates/snow-parser/tests/parser_tests.rs
  </files>
  <action>
    Extend `crates/snow-parser/tests/parser_tests.rs` with snapshot tests for all new constructs.

    Add tests for:

    **Let bindings:**
    - `let x = 5` -- simple binding
    - `let name :: String = "hello"` -- with type annotation
    - Multi-line: `let x = 1\nlet y = 2` (two let statements separated by newline)

    **Return:**
    - `return x`
    - `return x + 1`

    **If/else:**
    - `if true do\n  1\nend` -- simple if
    - `if x > 0 do\n  x\nelse\n  -x\nend` -- if/else
    - `if a do\n  1\nelse if b do\n  2\nelse\n  3\nend` -- else-if chain
    - `if true do 1 end` -- single-line if (no newline between do and body)

    **Case/match:**
    - `case x do\n  1 -> "one"\n  2 -> "two"\n  _ -> "other"\nend` -- basic case
    - `match value do\n  true -> 1\n  false -> 0\nend` -- match keyword

    **Closures:**
    - `fn (x) -> x + 1 end` -- simple closure
    - `fn (x, y) -> x + y end` -- multi-param
    - `fn () -> 42 end` -- no params

    **Blocks:**
    - `let x = 1\nx + 1` -- two statements, last is the value
    - Expressions separated by newlines in a function body context

    **Trailing closures:**
    - `list.map() do |x| x + 1 end` -- trailing closure with param (if `|` handling works)
    - `run() do\n  42\nend` -- trailing closure without params

    **Error cases:**
    - `if x do\n  1\n` -- missing end (error references do span)
    - `let = 5` -- missing identifier

    **Newline significance:**
    - Multi-line expression inside parens: `foo(\n  1,\n  2\n)` (newlines ignored inside parens)
    - Expression continuation: `x +\n  y` (newline after operator is continuation)
    - Statement break: `x\ny` (two separate expression-statements)

    Each test should use `insta::assert_snapshot!` with the debug tree output.
  </action>
  <verify>
    Run `cargo test -p snow-parser` -- all tests pass.
    Run `cargo insta test -p snow-parser --review` to accept new snapshots.
    Run `cargo test --workspace` -- no regressions.
  </verify>
  <done>
    15+ new snapshot tests covering if/else, case/match, closures, blocks, let bindings, return, trailing closures, error cases, and newline significance. All tests pass and demonstrate correct CST structure.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass.
2. `if x do 1 else 2 end` parses as IF_EXPR with two branches.
3. `case x do 1 -> "a" 2 -> "b" end` parses as CASE_EXPR with MATCH_ARM children.
4. `fn (x) -> x + 1 end` parses as CLOSURE_EXPR with PARAM_LIST and body expression.
5. `let x = 5` parses as LET_BINDING.
6. Blocks separate statements on newlines: `x\ny` produces two expression-statements.
7. Newlines inside parens are ignored: `foo(\n1\n)` parses as single call.
8. Missing `end` error references where `do` was opened.
</verification>

<success_criteria>
- if/else (including else-if chains) parses as expression with ELSE_BRANCH nodes
- case/match parses with MATCH_ARM children containing patterns and bodies
- Closures parse with parameter list and body
- do/end blocks contain statement sequences separated by newlines
- let bindings parse with optional type annotation
- Trailing closures attach to preceding function call
- Unclosed do/end produces error referencing the opening do span
- 15+ new snapshot tests all pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-parser-ast/02-03-SUMMARY.md`
</output>
