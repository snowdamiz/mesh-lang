---
phase: 43-math-stdlib
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "User can call Math.pow(2.0, 10.0) and get 1024.0"
    - "User can call Math.sqrt(144.0) and get 12.0"
    - "User can call Math.floor(3.7) and get 3 (Int)"
    - "User can call Math.ceil(3.2) and get 4 (Int)"
    - "User can call Math.round(3.5) and get 4 (Int)"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Type signatures for pow, sqrt, floor, ceil, round in Math module"
      contains: "pow"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Builtin name mappings for pow, sqrt, floor, ceil, round"
      contains: "snow_math_pow"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "LLVM intrinsic dispatch for pow, sqrt, floor, ceil, round"
      contains: "llvm.sqrt"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "E2E tests for pow, sqrt, floor, ceil, round"
      contains: "math_pow"
  key_links:
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "LLVM intrinsics"
      via: "Intrinsic::find for llvm.pow, llvm.sqrt, llvm.floor, llvm.ceil, llvm.round + fptosi for return"
      pattern: "llvm\\.pow|llvm\\.sqrt|llvm\\.floor|llvm\\.ceil|llvm\\.round"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "floor/ceil/round return Int"
      via: "llvm.floor/ceil/round returns f64, followed by fptosi to convert to i64"
      pattern: "build_float_to_signed_int"
---

<objective>
Add pow, sqrt, floor, ceil, and round to the Math module using LLVM intrinsics, completing all math stdlib requirements.

Purpose: Delivers the remaining math functions (MATH-03, MATH-04, MATH-05). pow and sqrt are Float-only. floor/ceil/round take Float and return Int (via intrinsic + fptosi).
Output: Complete Math stdlib with all 7 requirements satisfied and comprehensive e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-math-stdlib/43-RESEARCH.md
@.planning/phases/43-math-stdlib/43-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snowc/tests/e2e_stdlib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register pow/sqrt/floor/ceil/round type signatures and name mappings</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**In `crates/snow-typeck/src/infer.rs`**, add to the Math module section (created in Plan 01):

- `pow`: `Scheme::mono(Ty::fun(vec![Ty::float(), Ty::float()], Ty::float()))` -- Float-only per research recommendation. Users convert with `Int.to_float()` if needed.
- `sqrt`: `Scheme::mono(Ty::fun(vec![Ty::float()], Ty::float()))` -- Float-only per research recommendation.
- `floor`: `Scheme::mono(Ty::fun(vec![Ty::float()], Ty::int()))` -- Takes Float, returns Int.
- `ceil`: `Scheme::mono(Ty::fun(vec![Ty::float()], Ty::int()))` -- Takes Float, returns Int.
- `round`: `Scheme::mono(Ty::fun(vec![Ty::float()], Ty::int()))` -- Takes Float, returns Int.

Note: pow and sqrt are Float-only (not polymorphic). floor/ceil/round return Int, not Float -- this matches the requirement "convert Float to Int" and is the whole point of these functions.

**In `crates/snow-codegen/src/mir/lower.rs`**, add to `map_builtin_name()`:

```
"math_pow" => "snow_math_pow".to_string(),
"math_sqrt" => "snow_math_sqrt".to_string(),
"math_floor" => "snow_math_floor".to_string(),
"math_ceil" => "snow_math_ceil".to_string(),
"math_round" => "snow_math_round".to_string(),
```
  </action>
  <verify>
Run `cargo check -p snow-typeck -p snow-codegen` -- must compile cleanly.
  </verify>
  <done>
All five function signatures registered in typeck. All five name mappings added to MIR lowering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LLVM intrinsic codegen for pow/sqrt/floor/ceil/round</name>
  <files>
    crates/snow-codegen/src/codegen/expr.rs
  </files>
  <action>
**In `crates/snow-codegen/src/codegen/expr.rs`**, extend the math intrinsic match block (added in Plan 01's Task 2) with five new arms:

```rust
"snow_math_pow" => {
    let base_val = self.codegen_expr(&args[0])?;
    let exp_val = self.codegen_expr(&args[1])?;
    // llvm.pow.f64(base, exp) -> f64
    let intrinsic = Intrinsic::find("llvm.pow").ok_or("llvm.pow not found")?;
    let f64_ty = self.context.f64_type();
    let decl = intrinsic.get_declaration(&self.module, &[f64_ty.into()])
        .ok_or("Failed to get llvm.pow declaration")?;
    let result = self.builder.build_call(decl, &[base_val.into(), exp_val.into()], "pow")
        .map_err(|e| e.to_string())?;
    return result.try_as_basic_value().left().ok_or("pow returned void".into());
}
"snow_math_sqrt" => {
    let arg_val = self.codegen_expr(&args[0])?;
    // llvm.sqrt.f64(val) -> f64
    let intrinsic = Intrinsic::find("llvm.sqrt").ok_or("llvm.sqrt not found")?;
    let f64_ty = self.context.f64_type();
    let decl = intrinsic.get_declaration(&self.module, &[f64_ty.into()])
        .ok_or("Failed to get llvm.sqrt declaration")?;
    let result = self.builder.build_call(decl, &[arg_val.into()], "sqrt")
        .map_err(|e| e.to_string())?;
    return result.try_as_basic_value().left().ok_or("sqrt returned void".into());
}
"snow_math_floor" => {
    let arg_val = self.codegen_expr(&args[0])?;
    // llvm.floor.f64(val) -> f64, then fptosi -> i64
    let intrinsic = Intrinsic::find("llvm.floor").ok_or("llvm.floor not found")?;
    let f64_ty = self.context.f64_type();
    let decl = intrinsic.get_declaration(&self.module, &[f64_ty.into()])
        .ok_or("Failed to get llvm.floor declaration")?;
    let float_result = self.builder.build_call(decl, &[arg_val.into()], "floor")
        .map_err(|e| e.to_string())?
        .try_as_basic_value().left().ok_or("floor returned void")?;
    let int_result = self.builder
        .build_float_to_signed_int(float_result.into_float_value(), self.context.i64_type(), "floor_to_int")
        .map_err(|e| e.to_string())?;
    return Ok(int_result.into());
}
"snow_math_ceil" => {
    let arg_val = self.codegen_expr(&args[0])?;
    // llvm.ceil.f64(val) -> f64, then fptosi -> i64
    let intrinsic = Intrinsic::find("llvm.ceil").ok_or("llvm.ceil not found")?;
    let f64_ty = self.context.f64_type();
    let decl = intrinsic.get_declaration(&self.module, &[f64_ty.into()])
        .ok_or("Failed to get llvm.ceil declaration")?;
    let float_result = self.builder.build_call(decl, &[arg_val.into()], "ceil")
        .map_err(|e| e.to_string())?
        .try_as_basic_value().left().ok_or("ceil returned void")?;
    let int_result = self.builder
        .build_float_to_signed_int(float_result.into_float_value(), self.context.i64_type(), "ceil_to_int")
        .map_err(|e| e.to_string())?;
    return Ok(int_result.into());
}
"snow_math_round" => {
    let arg_val = self.codegen_expr(&args[0])?;
    // llvm.round.f64(val) -> f64, then fptosi -> i64
    let intrinsic = Intrinsic::find("llvm.round").ok_or("llvm.round not found")?;
    let f64_ty = self.context.f64_type();
    let decl = intrinsic.get_declaration(&self.module, &[f64_ty.into()])
        .ok_or("Failed to get llvm.round declaration")?;
    let float_result = self.builder.build_call(decl, &[arg_val.into()], "round")
        .map_err(|e| e.to_string())?
        .try_as_basic_value().left().ok_or("round returned void")?;
    let int_result = self.builder
        .build_float_to_signed_int(float_result.into_float_value(), self.context.i64_type(), "round_to_int")
        .map_err(|e| e.to_string())?;
    return Ok(int_result.into());
}
```

Key design: floor/ceil/round each do TWO operations: (1) the LLVM intrinsic (f64 -> f64), then (2) fptosi (f64 -> i64). This is because the type checker declares them as `Float -> Int` per the requirement.
  </action>
  <verify>
Run `cargo check -p snow-codegen` -- must compile cleanly.
  </verify>
  <done>
All five operations emit correct LLVM intrinsics. floor/ceil/round chain intrinsic + fptosi to return Int.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add e2e tests for pow, sqrt, floor, ceil, round and integration tests</name>
  <files>
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Add e2e tests at the end of `crates/snowc/tests/e2e_stdlib.rs`:

**Test: Math.pow**
```rust
#[test]
fn math_pow() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.pow(2.0, 10.0)}")
  println("${Math.pow(3.0, 2.0)}")
  println("${Math.pow(10.0, 0.0)}")
end
"#);
    assert!(out.contains("1024"));
    assert!(out.contains("9"));
    // 10^0 = 1
    assert!(out.lines().nth(2).unwrap().contains("1"));
}
```

**Test: Math.sqrt**
```rust
#[test]
fn math_sqrt() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.sqrt(144.0)}")
  println("${Math.sqrt(2.0)}")
  println("${Math.sqrt(0.0)}")
end
"#);
    assert!(out.contains("12"));
    assert!(out.contains("1.41421"));
    assert!(out.contains("0"));
}
```

**Test: Math.floor**
```rust
#[test]
fn math_floor() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.floor(3.7)}")
  println("${Math.floor(3.0)}")
  println("${Math.floor(-2.3)}")
end
"#);
    assert_eq!(out.trim(), "3\n3\n-3");
}
```

**Test: Math.ceil**
```rust
#[test]
fn math_ceil() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.ceil(3.2)}")
  println("${Math.ceil(3.0)}")
  println("${Math.ceil(-2.7)}")
end
"#);
    assert_eq!(out.trim(), "4\n3\n-2");
}
```

**Test: Math.round**
```rust
#[test]
fn math_round() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.round(3.5)}")
  println("${Math.round(3.4)}")
  println("${Math.round(-2.5)}")
  println("${Math.round(0.5)}")
end
"#);
    // llvm.round uses "round half away from zero"
    assert_eq!(out.trim(), "4\n3\n-3\n1");
}
```

**Test: Combined usage (integration test)**
```rust
#[test]
fn math_combined_usage() {
    let out = compile_and_run(r#"
fn main() do
  let radius = 5.0
  let area = Math.pow(radius, 2.0)
  println("${area}")
  let side = Math.sqrt(area)
  println("${side}")
  let pi_approx = Math.round(Math.pi)
  println("${pi_approx}")
  let converted = Float.to_int(Math.sqrt(Int.to_float(16)))
  println("${converted}")
end
"#);
    assert!(out.contains("25"));
    assert!(out.contains("5"));
    assert!(out.contains("3"));  // round(pi) = 3
    assert!(out.contains("4"));  // sqrt(16) = 4
}
```

**Test: Math.pow with Int.to_float (verifying ergonomics)**
```rust
#[test]
fn math_pow_with_conversion() {
    let out = compile_and_run(r#"
fn main() do
  let result = Math.pow(Int.to_float(2), Int.to_float(8))
  println("${Float.to_int(result)}")
end
"#);
    assert_eq!(out.trim(), "256");
}
```
  </action>
  <verify>
Run `cargo test -p snowc --test e2e_stdlib -- math_pow math_sqrt math_floor math_ceil math_round math_combined math_pow_with` -- all new tests pass. Then run full test suite: `cargo test -p snowc --test e2e_stdlib` and `cargo test -p snowc --test e2e` -- zero regressions.
  </verify>
  <done>
All math operations tested: pow, sqrt, floor, ceil, round. Combined integration test exercises chaining (sqrt + Int.to_float + Float.to_int). Negative numbers, zero, and edge cases covered. Zero regressions. All 7 MATH requirements satisfied.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` -- entire workspace compiles
2. `cargo test -p snowc --test e2e_stdlib` -- all stdlib tests pass (existing + Plan 01 + Plan 02)
3. `cargo test -p snowc --test e2e` -- full e2e suite passes (zero regressions)
4. Combined test demonstrates: Math.pow + Math.sqrt + Math.round + Math.pi + Int.to_float + Float.to_int all work together
5. floor/ceil/round correctly return Int (not Float)
</verification>

<success_criteria>
- Math.pow(Float, Float) -> Float works correctly
- Math.sqrt(Float) -> Float works correctly
- Math.floor(Float) -> Int rounds down (including negative numbers: floor(-2.3) = -3)
- Math.ceil(Float) -> Int rounds up (including negative numbers: ceil(-2.7) = -2)
- Math.round(Float) -> Int rounds to nearest (half away from zero)
- Combined usage across all Math/Int/Float operations works
- All existing e2e tests pass (zero regressions)
- Requirements covered: MATH-03, MATH-04, MATH-05 (completing all 7 MATH requirements)
</success_criteria>

<output>
After completion, create `.planning/phases/43-math-stdlib/43-02-SUMMARY.md`
</output>
