---
phase: 43-math-stdlib
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "User can call Math.abs(-42) and get 42 (Int)"
    - "User can call Math.abs(-3.14) and get 3.14 (Float)"
    - "User can call Math.min(10, 20) and Math.max(10, 20) for both Int and Float"
    - "User can reference Math.pi as a Float constant without parentheses"
    - "User can call Int.to_float(42) and get 42.0"
    - "User can call Float.to_int(3.14) and get 3 (truncation toward zero)"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Math, Int, Float module type signatures in stdlib_modules()"
      contains: "Math"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Module name registration and builtin name mapping for Math/Int/Float"
      contains: "snow_math_abs"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "LLVM intrinsic dispatch for math operations"
      contains: "llvm.fabs"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "E2E tests for Math.abs, min, max, pi, Int.to_float, Float.to_int"
      contains: "math_abs"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Module names must match: Math/Int/Float in both STDLIB_MODULE_NAMES and STDLIB_MODULES"
      pattern: "Math.*Int.*Float"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/expr.rs"
      via: "map_builtin_name produces snow_math_* names that codegen intercepts"
      pattern: "snow_math_abs|snow_math_min|snow_math_max|snow_math_pi"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "LLVM intrinsics"
      via: "Intrinsic::find for llvm.abs, llvm.fabs, llvm.smin, llvm.smax, llvm.minnum, llvm.maxnum"
      pattern: "Intrinsic::find"
---

<objective>
Register Math, Int, and Float stdlib modules through all four compiler layers and implement core math operations (abs, min, max, pi) plus type conversions (Int.to_float, Float.to_int) using LLVM intrinsics.

Purpose: Establishes the new module infrastructure and delivers the most frequently needed math operations. Covers MATH-01 (abs), MATH-02 (min/max), MATH-06 (pi), and MATH-07 (type conversion).
Output: Working Math.abs, Math.min, Math.max, Math.pi, Int.to_float, Float.to_int with e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-math-stdlib/43-RESEARCH.md
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snowc/tests/e2e_stdlib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Math/Int/Float modules in typeck and MIR lowering</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**In `crates/snow-typeck/src/infer.rs`:**

1. In `stdlib_modules()`, add three new module registrations after the existing modules:

**Math module** -- use TyVar(92000) for the polymorphic type variable `t` in abs/min/max:
```
let t_var = TyVar(92000);
let t = Ty::Var(t_var);
```
- `abs`: `Scheme { vars: vec![t_var], ty: Ty::fun(vec![t.clone()], t.clone()) }` -- polymorphic (Int -> Int or Float -> Float)
- `min`: `Scheme { vars: vec![t_var], ty: Ty::fun(vec![t.clone(), t.clone()], t.clone()) }` -- polymorphic
- `max`: `Scheme { vars: vec![t_var], ty: Ty::fun(vec![t.clone(), t.clone()], t.clone()) }` -- polymorphic
- `pi`: `Scheme::mono(Ty::float())` -- constant, NOT a function. Type is just Float (not () -> Float).

**Int module:**
- `to_float`: `Scheme::mono(Ty::fun(vec![Ty::int()], Ty::float()))`

**Float module:**
- `to_int`: `Scheme::mono(Ty::fun(vec![Ty::float()], Ty::int()))`

2. Add "Math", "Int", "Float" to `STDLIB_MODULE_NAMES` array (line ~484).

**In `crates/snow-codegen/src/mir/lower.rs`:**

1. Add "Math", "Int", "Float" to `STDLIB_MODULES` array (line ~7199).

2. In `map_builtin_name()`, add these mappings:
```
"math_abs" => "snow_math_abs".to_string(),
"math_min" => "snow_math_min".to_string(),
"math_max" => "snow_math_max".to_string(),
"math_pi" => "snow_math_pi".to_string(),
"int_to_float" => "snow_int_to_float".to_string(),
"float_to_int" => "snow_float_to_int".to_string(),
```

Note: `Math.pi` accessed without parentheses goes through `lower_field_access` which produces `MirExpr::Var("snow_math_pi", MirType::Float)`. This is correct -- codegen will intercept the variable name and emit a constant. No function call needed.
  </action>
  <verify>
Run `cargo check -p snow-typeck -p snow-codegen` -- must compile with zero errors. The modules are registered but not yet codegen'd, so no runtime test yet.
  </verify>
  <done>
Math, Int, Float appear in both STDLIB_MODULE_NAMES and STDLIB_MODULES. Type signatures registered. Builtin name mappings added. Project compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LLVM intrinsic codegen for abs/min/max/pi and type conversions</name>
  <files>
    crates/snow-codegen/src/codegen/expr.rs
  </files>
  <action>
**In `crates/snow-codegen/src/codegen/expr.rs`:**

1. In `codegen_var()`, add a special case at the top (before the function reference check) to handle `snow_math_pi`:
```rust
if name == "snow_math_pi" {
    return Ok(self.context.f64_type().const_float(std::f64::consts::PI).into());
}
```
This handles `Math.pi` accessed as a variable (no parentheses).

2. In `codegen_call()`, add a match block after the existing special-case checks (after the `__snow_make_tuple` check around line 623, before the "Check if it's a direct call to a known function" block). This block intercepts `snow_math_*` and `snow_int_*` / `snow_float_*` names and emits LLVM intrinsics instead of function calls:

```rust
// Math/Int/Float stdlib intrinsics (Phase 43)
if let MirExpr::Var(name, _) = func {
    match name.as_str() {
        "snow_math_abs" => {
            let arg_val = self.codegen_expr(&args[0])?;
            return match args[0].ty() {
                MirType::Int => {
                    // llvm.abs.i64(val, is_int_min_poison=false)
                    let intrinsic = Intrinsic::find("llvm.abs").ok_or("llvm.abs not found")?;
                    let i64_ty = self.context.i64_type();
                    let decl = intrinsic.get_declaration(&self.module, &[i64_ty.into()])
                        .ok_or("Failed to get llvm.abs declaration")?;
                    let is_poison = self.context.bool_type().const_int(0, false);
                    let result = self.builder.build_call(decl, &[arg_val.into(), is_poison.into()], "abs")
                        .map_err(|e| e.to_string())?;
                    result.try_as_basic_value().left().ok_or("abs returned void".into())
                }
                MirType::Float => {
                    // llvm.fabs.f64(val)
                    let intrinsic = Intrinsic::find("llvm.fabs").ok_or("llvm.fabs not found")?;
                    let f64_ty = self.context.f64_type();
                    let decl = intrinsic.get_declaration(&self.module, &[f64_ty.into()])
                        .ok_or("Failed to get llvm.fabs declaration")?;
                    let result = self.builder.build_call(decl, &[arg_val.into()], "fabs")
                        .map_err(|e| e.to_string())?;
                    result.try_as_basic_value().left().ok_or("fabs returned void".into())
                }
                other => Err(format!("Math.abs: unsupported type {:?}", other)),
            };
        }
        "snow_math_min" => {
            let lhs = self.codegen_expr(&args[0])?;
            let rhs = self.codegen_expr(&args[1])?;
            return match args[0].ty() {
                MirType::Int => {
                    let intrinsic = Intrinsic::find("llvm.smin").ok_or("llvm.smin not found")?;
                    let i64_ty = self.context.i64_type();
                    let decl = intrinsic.get_declaration(&self.module, &[i64_ty.into()])
                        .ok_or("Failed to get llvm.smin declaration")?;
                    let result = self.builder.build_call(decl, &[lhs.into(), rhs.into()], "smin")
                        .map_err(|e| e.to_string())?;
                    result.try_as_basic_value().left().ok_or("smin returned void".into())
                }
                MirType::Float => {
                    let intrinsic = Intrinsic::find("llvm.minnum").ok_or("llvm.minnum not found")?;
                    let f64_ty = self.context.f64_type();
                    let decl = intrinsic.get_declaration(&self.module, &[f64_ty.into()])
                        .ok_or("Failed to get llvm.minnum declaration")?;
                    let result = self.builder.build_call(decl, &[lhs.into(), rhs.into()], "minnum")
                        .map_err(|e| e.to_string())?;
                    result.try_as_basic_value().left().ok_or("minnum returned void".into())
                }
                other => Err(format!("Math.min: unsupported type {:?}", other)),
            };
        }
        "snow_math_max" => {
            let lhs = self.codegen_expr(&args[0])?;
            let rhs = self.codegen_expr(&args[1])?;
            return match args[0].ty() {
                MirType::Int => {
                    let intrinsic = Intrinsic::find("llvm.smax").ok_or("llvm.smax not found")?;
                    let i64_ty = self.context.i64_type();
                    let decl = intrinsic.get_declaration(&self.module, &[i64_ty.into()])
                        .ok_or("Failed to get llvm.smax declaration")?;
                    let result = self.builder.build_call(decl, &[lhs.into(), rhs.into()], "smax")
                        .map_err(|e| e.to_string())?;
                    result.try_as_basic_value().left().ok_or("smax returned void".into())
                }
                MirType::Float => {
                    let intrinsic = Intrinsic::find("llvm.maxnum").ok_or("llvm.maxnum not found")?;
                    let f64_ty = self.context.f64_type();
                    let decl = intrinsic.get_declaration(&self.module, &[f64_ty.into()])
                        .ok_or("Failed to get llvm.maxnum declaration")?;
                    let result = self.builder.build_call(decl, &[lhs.into(), rhs.into()], "maxnum")
                        .map_err(|e| e.to_string())?;
                    result.try_as_basic_value().left().ok_or("maxnum returned void".into())
                }
                other => Err(format!("Math.max: unsupported type {:?}", other)),
            };
        }
        "snow_int_to_float" => {
            let arg_val = self.codegen_expr(&args[0])?;
            let int_val = arg_val.into_int_value();
            let float_val = self.builder
                .build_signed_int_to_float(int_val, self.context.f64_type(), "int_to_float")
                .map_err(|e| e.to_string())?;
            return Ok(float_val.into());
        }
        "snow_float_to_int" => {
            let arg_val = self.codegen_expr(&args[0])?;
            let float_val = arg_val.into_float_value();
            let int_val = self.builder
                .build_float_to_signed_int(float_val, self.context.i64_type(), "float_to_int")
                .map_err(|e| e.to_string())?;
            return Ok(int_val.into());
        }
        _ => {} // Fall through to normal call handling
    }
}
```

Add `use inkwell::intrinsics::Intrinsic;` at the top of the file if not already imported.

IMPORTANT: The `codegen_call` function already has a `if let MirExpr::Var(name, _) = func` block that checks for service_call, actor_send, and make_tuple. The math intrinsic block should be added INSIDE that same block (extending it) or as a NEW `if let` block immediately after it but before the "direct call to a known function" block. The cleanest approach is to add a new `if let` block since the existing one uses early returns.
  </action>
  <verify>
Run `cargo check -p snow-codegen` -- must compile with zero errors.
  </verify>
  <done>
All six operations (abs, min, max for Int/Float; pi constant; Int.to_float; Float.to_int) are intercepted in codegen and emitted as LLVM intrinsics/instructions. No runtime functions needed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add e2e tests for core math operations and type conversions</name>
  <files>
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Add e2e tests at the end of `crates/snowc/tests/e2e_stdlib.rs` using the existing `compile_and_run()` helper.

**Test: Math.abs for Int and Float**
```rust
#[test]
fn math_abs_int() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.abs(-42)}")
  println("${Math.abs(42)}")
  println("${Math.abs(0)}")
end
"#);
    assert_eq!(out.trim(), "42\n42\n0");
}

#[test]
fn math_abs_float() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.abs(-3.14)}")
  println("${Math.abs(3.14)}")
end
"#);
    assert!(out.contains("3.14"));
}
```

**Test: Math.min and Math.max for Int and Float**
```rust
#[test]
fn math_min_max_int() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.min(10, 20)}")
  println("${Math.max(10, 20)}")
  println("${Math.min(-5, 3)}")
  println("${Math.max(-5, 3)}")
end
"#);
    assert_eq!(out.trim(), "10\n20\n-5\n3");
}

#[test]
fn math_min_max_float() {
    let out = compile_and_run(r#"
fn main() do
  println("${Math.min(1.5, 2.5)}")
  println("${Math.max(1.5, 2.5)}")
end
"#);
    assert!(out.contains("1.5"));
    assert!(out.contains("2.5"));
}
```

**Test: Math.pi constant (accessed without parentheses)**
```rust
#[test]
fn math_pi_constant() {
    let out = compile_and_run(r#"
fn main() do
  let pi = Math.pi
  println("${pi}")
end
"#);
    assert!(out.contains("3.14159"));
}
```

**Test: Int.to_float and Float.to_int conversions**
```rust
#[test]
fn int_to_float_conversion() {
    let out = compile_and_run(r#"
fn main() do
  let f = Int.to_float(42)
  println("${f}")
end
"#);
    assert!(out.contains("42"));
}

#[test]
fn float_to_int_conversion() {
    let out = compile_and_run(r#"
fn main() do
  println("${Float.to_int(3.14)}")
  println("${Float.to_int(3.99)}")
  println("${Float.to_int(-2.7)}")
end
"#);
    // fptosi truncates toward zero
    assert_eq!(out.trim(), "3\n3\n-2");
}
```

**Test: Math.abs with variable (not just literal)**
```rust
#[test]
fn math_abs_with_variable() {
    let out = compile_and_run(r#"
fn main() do
  let x = -99
  println("${Math.abs(x)}")
end
"#);
    assert_eq!(out.trim(), "99");
}
```

**Test: Type annotations still work for Int and Float**
```rust
#[test]
fn int_float_type_annotations_still_work() {
    let out = compile_and_run(r#"
fn main() do
  let x: Int = 42
  let y: Float = 3.14
  println("${x}")
end
"#);
    assert_eq!(out.trim(), "42");
}
```

Ensure tests verify the pitfalls from research: Float.to_int truncates (not rounds), Math.pi works without parens, Int/Float are still valid type names.
  </action>
  <verify>
Run `cargo test -p snowc --test e2e_stdlib -- math_ int_to_float float_to_int int_float_type` -- all new tests pass. Also run the full e2e test suite: `cargo test -p snowc --test e2e_stdlib` to confirm zero regressions.
  </verify>
  <done>
All e2e tests pass: Math.abs (Int + Float), Math.min/max (Int + Float), Math.pi (constant, no parens), Int.to_float, Float.to_int (truncation), type annotations unaffected. Zero regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` -- entire workspace compiles
2. `cargo test -p snowc --test e2e_stdlib` -- all stdlib tests pass (existing + new)
3. `cargo test -p snowc --test e2e` -- full e2e suite passes (zero regressions)
4. Manual compile-and-run of a Snow program using all 6 operations confirms correct output
</verification>

<success_criteria>
- Math.abs works for both Int and Float arguments (polymorphic dispatch)
- Math.min/max work for both Int and Float arguments
- Math.pi is accessible as a constant (no parentheses) with value 3.14159...
- Int.to_float converts integer to float
- Float.to_int truncates float toward zero
- Int and Float still work as type names in annotations
- All existing e2e tests pass (zero regressions)
- Requirements covered: MATH-01, MATH-02, MATH-06, MATH-07
</success_criteria>

<output>
After completion, create `.planning/phases/43-math-stdlib/43-01-SUMMARY.md`
</output>
