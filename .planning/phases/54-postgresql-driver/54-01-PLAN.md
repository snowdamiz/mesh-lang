---
phase: 54-postgresql-driver
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/db/pg.rs
  - crates/snow-rt/src/db/mod.rs
  - crates/snow-rt/Cargo.toml
  - crates/snow-rt/src/lib.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/types.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
autonomous: true

must_haves:
  truths:
    - "snow_pg_connect parses postgres:// URL and establishes TCP connection with StartupMessage"
    - "snow_pg_connect completes SCRAM-SHA-256 authentication handshake (4-message SASL exchange)"
    - "snow_pg_connect completes MD5 authentication handshake (md5(md5(pass+user)+salt))"
    - "snow_pg_close sends Terminate message and drops PgConn"
    - "snow_pg_execute sends Parse/Bind/Execute/Sync and returns row count from CommandComplete"
    - "snow_pg_query sends Parse/Bind/Describe(Portal)/Execute/Sync and returns List<Map<String,String>> from RowDescription+DataRow"
    - "PgConn type is registered in typeck as opaque type lowering to MirType::Int"
    - "Pg module appears in STDLIB_MODULE_NAMES and STDLIB_MODULES"
    - "All 4 snow_pg_* functions have LLVM intrinsic declarations"
  artifacts:
    - path: "crates/snow-rt/src/db/pg.rs"
      provides: "PostgreSQL wire protocol client with 4 extern C functions"
      contains: "snow_pg_connect"
    - path: "crates/snow-rt/src/db/mod.rs"
      provides: "pub mod pg declaration"
      contains: "pub mod pg"
    - path: "crates/snow-rt/Cargo.toml"
      provides: "Crypto dependencies for SCRAM-SHA-256 and MD5 auth"
      contains: "sha2"
    - path: "crates/snow-rt/src/lib.rs"
      provides: "Re-exports for snow_pg_* functions"
      contains: "snow_pg_connect"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "PgConn type and pg_* function signatures"
      contains: "pg_connect"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Pg module in stdlib_modules and STDLIB_MODULE_NAMES"
      contains: "\"Pg\""
    - path: "crates/snow-codegen/src/mir/types.rs"
      provides: "PgConn => MirType::Int mapping"
      contains: "PgConn"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "known_functions + map_builtin_name + STDLIB_MODULES for Pg"
      contains: "snow_pg_connect"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for snow_pg_* functions"
      contains: "snow_pg_connect"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "Pg module functions reference pg_* builtins"
      pattern: "pg_connect|pg_close|pg_execute|pg_query"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/db/pg.rs"
      via: "map_builtin_name maps pg_connect to snow_pg_connect"
      pattern: "pg_connect.*snow_pg_connect"
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/db/pg.rs"
      via: "LLVM declarations match extern C function signatures"
      pattern: "snow_pg_connect"
---

<objective>
Implement the full PostgreSQL driver: pure Rust wire protocol client with SCRAM-SHA-256 and MD5 authentication, plus the complete compiler pipeline registration (typeck, MIR, LLVM intrinsics) following the exact SQLite pattern from Phase 53.

Purpose: This is the core implementation plan. After completion, Snow programs can call Pg.connect/close/execute/query, and the compiler knows how to type-check and code-generate these calls.
Output: 4 working extern C runtime functions, all compiler pipeline registrations, crypto dependencies added.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-postgresql-driver/54-RESEARCH.md
@.planning/phases/53-sqlite-driver/53-01-SUMMARY.md

# Reference files for the SQLite pattern to copy:
@crates/snow-rt/src/db/sqlite.rs
@crates/snow-rt/src/db/mod.rs
@crates/snow-rt/Cargo.toml
@crates/snow-rt/src/lib.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/types.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: PostgreSQL wire protocol runtime with SCRAM-SHA-256 and MD5 auth</name>
  <files>
    crates/snow-rt/src/db/pg.rs
    crates/snow-rt/src/db/mod.rs
    crates/snow-rt/Cargo.toml
    crates/snow-rt/src/lib.rs
  </files>
  <action>
Create `crates/snow-rt/src/db/pg.rs` implementing a pure Rust PostgreSQL wire protocol v3 client. This is the main implementation file (~400-600 lines). Use the code examples from the RESEARCH.md as starting points.

**Dependencies (Cargo.toml):** Add to snow-rt's `[dependencies]`:
```toml
sha2 = "0.10"
hmac = "0.12"
md-5 = "0.10"
pbkdf2 = { version = "0.12", default-features = false, features = ["hmac"] }
base64 = "0.22"
rand = "0.9"
```

**PgConn struct:** Holds `TcpStream`. Stored as `Box::into_raw(Box::new(PgConn { stream })) as u64` for GC safety (identical pattern to SqliteConn).

**URL parsing:** Hand-roll a parser for `postgres://user:pass@host:port/database`. Split on `://`, then `@`, then `:` and `/`. Handle default port 5432. Handle percent-decoding for passwords with `%XX` sequences. This is ~30 lines, no need for the `url` crate.

**Wire protocol helpers (private functions):**
- `write_startup_message(buf, user, database)` -- Version 3.0 (196608), user/database params, null terminator
- `write_parse(buf, query)` -- Byte1('P'), unnamed statement, query text, 0 param type OIDs
- `write_bind(buf, params)` -- Byte1('B'), unnamed portal/stmt, format code 0 (text) for all params and results, param values with Int32 length prefix
- `write_describe_portal(buf)` -- Byte1('D'), Byte1('P'), unnamed portal
- `write_execute(buf)` -- Byte1('E'), unnamed portal, 0 rows limit
- `write_sync(buf)` -- Byte1('S'), Int32(4)
- `write_password_message(buf, password)` -- Byte1('p'), password string
- `write_sasl_initial_response(buf, mechanism, data)` -- Byte1('p'), mechanism name, data
- `write_sasl_response(buf, data)` -- Byte1('p'), data
- `read_message(stream) -> (u8, Vec<u8>)` -- Read Byte1 tag + Int32 length + body bytes. Use `stream.read_exact()`.

**MD5 authentication (compute_md5_password):**
- Formula: `"md5" + hex(md5(hex(md5(password + username)) + salt_4_bytes))`
- Use `md5::Md5` from the `md-5` crate (import as `use md5::{Md5, Digest}`)

**SCRAM-SHA-256 authentication:**
- `scram_client_first(username)` -- Generate 24-char alphanumeric nonce via `rand::rng()`, return `("n,,n={user},r={nonce}", nonce)`
- `scram_client_final(password, client_nonce, server_first_msg)` -- Parse `r=`, `s=`, `i=` from server-first. Verify server nonce starts with client nonce. Compute SaltedPassword via `pbkdf2_hmac::<Sha256>`. Compute ClientKey, StoredKey, AuthMessage, ClientSignature, ClientProof (XOR), ServerSignature. Return client-final-message and expected server signature.
- Client-first-bare for AuthMessage uses `n=,r={client_nonce}` (empty username, PostgreSQL ignores it)
- Channel binding `c=biws` (base64 of "n,,")

**snow_pg_connect(url: *const SnowString) -> *mut u8:**
1. Extract Rust &str from SnowString (same pattern as sqlite.rs: `std::slice::from_raw_parts` + `std::str::from_utf8`)
2. Parse URL into host, port, user, password, database
3. `TcpStream::connect_timeout(&addr, Duration::from_secs(10))`
4. Send StartupMessage
5. Read response: match on auth type byte
   - `0` (AuthOk): No auth needed
   - `5` (MD5): Read 4-byte salt, compute MD5 password, send PasswordMessage, read AuthOk
   - `10` (SASL): Read mechanism list, verify SCRAM-SHA-256 present, run SCRAM flow (SASLInitialResponse -> read AuthSASLContinue -> SASLResponse -> read AuthSASLFinal -> read AuthOk)
6. After AuthOk: read messages in loop until ReadyForQuery ('Z'): handle ParameterStatus ('S'), BackendKeyData ('K'), skip others
7. Box PgConn, return `alloc_result(0, handle as u64)` as Ok, or `alloc_result(1, error_string_ptr)` as Err

**snow_pg_close(conn_handle: u64):**
1. `unsafe { Box::from_raw(conn_handle as *mut PgConn) }`
2. Send Terminate message: Byte1('X') + Int32(4)
3. Drop closes TcpStream

**snow_pg_execute(conn_handle: u64, sql: *const SnowString, params: *mut u8) -> *mut u8:**
1. Recover `&mut PgConn` from handle (use `&mut *` not `Box::from_raw` -- we don't want to drop it)
2. Extract SQL string and params list (iterate Snow list like sqlite.rs does)
3. Build and send: Parse + Bind + Execute + Sync (pipelined, single write)
4. Read messages until ReadyForQuery:
   - ParseComplete ('1'): skip
   - BindComplete ('2'): skip
   - CommandComplete ('C'): parse tag string, extract last number as row count
   - ErrorResponse ('E'): collect error message (find field code 'M' for human-readable message), continue reading until ReadyForQuery
   - ReadyForQuery ('Z'): break
5. Return `alloc_result(0, rows_affected)` or `alloc_result(1, error_string)`

**snow_pg_query(conn_handle: u64, sql: *const SnowString, params: *mut u8) -> *mut u8:**
1. Same param extraction as execute
2. Build and send: Parse + Bind + Describe(Portal) + Execute + Sync
3. Read messages until ReadyForQuery:
   - ParseComplete ('1'): skip
   - BindComplete ('2'): skip
   - RowDescription ('T'): parse Int16 num_fields, then for each field: String name + skip 18 bytes (table OID, col num, type OID, type size, type modifier, format code). Store column names in a Vec.
   - DataRow ('D'): parse Int16 num_cols, then for each col: Int32 length (-1 = NULL), then `length` bytes of text data. Build a SnowMap per row using `snow_map_new_typed(1)` (string keys) + `snow_map_put`. Append to SnowList.
   - CommandComplete ('C'): skip
   - ErrorResponse ('E'): collect error, continue until ReadyForQuery
   - ReadyForQuery ('Z'): break
4. Return `alloc_result(0, list_ptr)` or `alloc_result(1, error_string)`

**Important notes:**
- For reading params from the Snow List, follow the exact pattern from sqlite.rs (the `snow_list_len`/`snow_list_get` or manual pointer arithmetic pattern)
- For NULL values in DataRow (length = -1), store empty string "" in the map
- ErrorResponse message format: sequence of (Byte1 field_type, String value) pairs terminated by Byte1(0). Field 'M' = human-readable message.
- All strings sent in protocol messages are null-terminated
- Do NOT use `Box::from_raw` in execute/query -- that would free the connection. Use `&mut *(handle as *mut PgConn)` instead.

**mod.rs:** Add `pub mod pg;` alongside existing `pub mod sqlite;`

**lib.rs:** Add re-exports for `snow_pg_connect`, `snow_pg_close`, `snow_pg_execute`, `snow_pg_query` following the exact pattern of the sqlite re-exports.
  </action>
  <verify>
Run `cargo build -p snow-rt` -- must compile with no errors. All 4 `snow_pg_*` symbols should be present in the static library:
```bash
cargo build -p snow-rt && nm target/debug/libsnow_rt.a 2>/dev/null | grep snow_pg
```
All 4 functions should appear as defined (T) symbols.
  </verify>
  <done>
`crates/snow-rt/src/db/pg.rs` exists with 4 extern C functions implementing PostgreSQL wire protocol v3 with SCRAM-SHA-256 and MD5 auth. Crypto dependencies added to Cargo.toml. `cargo build -p snow-rt` succeeds. All 4 `snow_pg_*` symbols present in the static library.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Pg module in compiler pipeline (typeck, MIR, LLVM intrinsics)</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/types.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
Follow the EXACT same pattern as SQLite (Phase 53) for all 5 files. The RESEARCH.md provides the exact code for each file. This is mechanical copy-paste-rename from Sqlite to Pg.

**1. `crates/snow-typeck/src/builtins.rs`** -- Add PgConn opaque type + 4 function signatures:
- `PgConn` type: `Ty::Con(TyCon::new("PgConn"))`, insert as `Scheme::mono`
- `pg_connect`: `(String) -> Result<PgConn, String>`
- `pg_close`: `(PgConn) -> ()`  (Unit = `Ty::Tuple(vec![])`)
- `pg_execute`: `(PgConn, String, List<String>) -> Result<Int, String>`
- `pg_query`: `(PgConn, String, List<String>) -> Result<List<Map<String, String>>, String>`

Place these right after the existing `sqlite_*` entries for consistency.

**2. `crates/snow-typeck/src/infer.rs` -- `stdlib_modules()`** -- Add Pg module with 4 methods:
- `connect`, `close`, `execute`, `query` with same type signatures as builtins
- Insert as `modules.insert("Pg".to_string(), pg_mod);`
- Add `"Pg"` to `STDLIB_MODULE_NAMES` array (at the end, after `"Sqlite"`)

**3. `crates/snow-codegen/src/mir/types.rs` -- `resolve_con()`** -- Add:
```rust
"PgConn" => MirType::Int,
```
Right after the existing `"SqliteConn" => MirType::Int` line.

**4. `crates/snow-codegen/src/mir/lower.rs`** -- Three additions:
- **known_functions**: Add 4 entries mapping `snow_pg_connect/close/execute/query` to their MIR function types. Signatures: connect takes Ptr returns Ptr, close takes Int returns Unit, execute takes (Int, Ptr, Ptr) returns Ptr, query takes (Int, Ptr, Ptr) returns Ptr.
- **map_builtin_name()**: Add 4 mappings: `pg_connect -> snow_pg_connect`, `pg_close -> snow_pg_close`, `pg_execute -> snow_pg_execute`, `pg_query -> snow_pg_query`.
- **STDLIB_MODULES**: Add `"Pg"` to the array (after `"Sqlite"`).

**5. `crates/snow-codegen/src/codegen/intrinsics.rs` -- `declare_intrinsics()`** -- Add 4 LLVM function declarations:
- `snow_pg_connect`: `(ptr) -> ptr`
- `snow_pg_close`: `(i64) -> void`
- `snow_pg_execute`: `(i64, ptr, ptr) -> ptr`
- `snow_pg_query`: `(i64, ptr, ptr) -> ptr`
All with `Linkage::External`. Place after the existing `snow_sqlite_*` declarations.
  </action>
  <verify>
Run `cargo build -p snow-typeck && cargo build -p snow-codegen` -- both must compile with no errors. Then run the full test suite to ensure no regressions:
```bash
cargo test --workspace
```
All existing tests must pass. The new Pg module should be recognized by the type checker.
  </verify>
  <done>
PgConn type registered in builtins. Pg module with connect/close/execute/query in stdlib_modules. PgConn lowers to MirType::Int. 4 known_functions + 4 map_builtin_name entries + STDLIB_MODULES updated. 4 LLVM intrinsic declarations added. `cargo test --workspace` passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` succeeds with all crypto deps
2. `nm target/debug/libsnow_rt.a 2>/dev/null | grep snow_pg` shows all 4 symbols
3. `cargo build -p snow-typeck` succeeds
4. `cargo build -p snow-codegen` succeeds
5. `cargo test --workspace` passes with no regressions
</verification>

<success_criteria>
- All 4 `snow_pg_*` extern C functions implemented with wire protocol v3
- SCRAM-SHA-256 and MD5 authentication both implemented
- PgConn uses Box::into_raw as u64 for GC safety
- Full compiler pipeline registered (typeck, MIR types, MIR lower, LLVM intrinsics)
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/54-postgresql-driver/54-01-SUMMARY.md`
</output>
