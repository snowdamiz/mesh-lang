---
phase: 54-postgresql-driver
plan: 02
type: execute
wave: 2
depends_on: ["54-01"]
files_modified:
  - tests/e2e/stdlib_pg.snow
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: false

user_setup:
  - service: postgresql
    why: "E2E test requires a running PostgreSQL instance"
    env_vars:
      - name: SNOW_PG_TEST_URL
        source: "Local PostgreSQL or Docker: postgres://snow_test:snow_test@localhost:5432/snow_test"
    dashboard_config:
      - task: "Create test user and database"
        location: "psql or Docker: CREATE USER snow_test PASSWORD 'snow_test'; CREATE DATABASE snow_test OWNER snow_test;"

must_haves:
  truths:
    - "Snow program connects to PostgreSQL with Pg.connect(url) and gets Result<PgConn, String>"
    - "Snow program creates a table via Pg.execute and gets Ok(0)"
    - "Snow program inserts rows with $1 parameters via Pg.execute and gets Ok(rows_affected)"
    - "Snow program queries rows with $1 parameters via Pg.query and gets Ok(List<Map<String,String>>)"
    - "Snow program reads column values from Map using Map.get"
    - "Snow program closes connection with Pg.close"
    - "Full CRUD lifecycle compiles to native binary and runs end-to-end"
  artifacts:
    - path: "tests/e2e/stdlib_pg.snow"
      provides: "Snow fixture testing full PostgreSQL CRUD lifecycle"
      contains: "Pg.connect"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "Rust E2E test harness with e2e_pg test function"
      contains: "e2e_pg"
  key_links:
    - from: "tests/e2e/stdlib_pg.snow"
      to: "crates/snow-rt/src/db/pg.rs"
      via: "Pg.connect/query/execute/close call snow_pg_* runtime functions"
      pattern: "Pg\\.(connect|query|execute|close)"
    - from: "crates/snowc/tests/e2e_stdlib.rs"
      to: "tests/e2e/stdlib_pg.snow"
      via: "E2E test compiles and runs the Snow fixture"
      pattern: "stdlib_pg\\.snow"
---

<objective>
Create an end-to-end test that compiles a Snow program using all PostgreSQL driver functions (connect, execute with DDL/DML, query with parameters, close) and runs it against a real PostgreSQL instance.

Purpose: Proves the full pipeline works: Snow source -> typeck -> MIR -> LLVM -> native binary -> TCP connection to PostgreSQL -> wire protocol -> correct results.
Output: E2E test fixture and test harness entry.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-postgresql-driver/54-RESEARCH.md
@.planning/phases/54-postgresql-driver/54-01-SUMMARY.md
@.planning/phases/53-sqlite-driver/53-02-SUMMARY.md

# Reference files:
@tests/e2e/stdlib_sqlite.snow
@crates/snowc/tests/e2e_stdlib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Snow fixture and E2E test for PostgreSQL CRUD lifecycle</name>
  <files>
    tests/e2e/stdlib_pg.snow
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
**Snow fixture (`tests/e2e/stdlib_pg.snow`):**

Follow the exact pattern from `tests/e2e/stdlib_sqlite.snow` (which Phase 53-02 established). Use a helper function with `Result` return type for `?` chaining, and case dispatch in `main()`.

Just hardcode the connection string for simplicity (matching the SQLite pattern which hardcodes ":memory:"). The E2E test harness can set up the environment.

```snow
fn run_db() -> Int!String do
  let conn = Pg.connect("postgres://snow_test:snow_test@localhost:5432/snow_test")?

  # Drop table if exists (ignore error by using a fresh execute)
  let _ = Pg.execute(conn, "DROP TABLE IF EXISTS snow_e2e_test", [])

  # Create table
  let created = Pg.execute(conn, "CREATE TABLE snow_e2e_test (id SERIAL PRIMARY KEY, name TEXT NOT NULL, age INTEGER NOT NULL)", [])?
  println("created: ${created}")

  # Insert with parameters
  let ins1 = Pg.execute(conn, "INSERT INTO snow_e2e_test (name, age) VALUES ($1, $2)", ["Alice", "30"])?
  println("inserted: ${ins1}")

  let ins2 = Pg.execute(conn, "INSERT INTO snow_e2e_test (name, age) VALUES ($1, $2)", ["Bob", "25"])?
  println("inserted: ${ins2}")

  # Query all rows
  let rows = Pg.query(conn, "SELECT id, name, age FROM snow_e2e_test ORDER BY name", [])?
  List.map(rows, fn(row) do
    let name = Map.get(row, "name")
    let age = Map.get(row, "age")
    println(name <> " is " <> age)
  end)

  # Query with parameter
  let filtered = Pg.query(conn, "SELECT name FROM snow_e2e_test WHERE age > $1", ["26"])?
  List.map(filtered, fn(row) do
    let name = Map.get(row, "name")
    println("older: " <> name)
  end)

  Pg.close(conn)
  Ok(0)
end

fn main() do
  case run_db() do
    Ok(_) -> println("done")
    Err(msg) -> println("error: " <> msg)
  end
end
```

Key Snow syntax notes (from Phase 53-02 lessons):
- Use `<>` for string concatenation (not `++` or `String.concat`)
- Use `${x}` for string interpolation of Int values
- `Map.get` returns `String` directly (not `Option`)
- `?` operator requires the enclosing function to return `Result` (hence the `run_db()` helper)
- `Int!String` is shorthand for `Result<Int, String>`
- All PG parameters are strings (even numbers like "30", "25", "26")

**E2E test harness (`crates/snowc/tests/e2e_stdlib.rs`):**

Add a new test function `e2e_pg` following the exact pattern of the existing `e2e_sqlite` test. The test should:
1. Compile `tests/e2e/stdlib_pg.snow` to a native binary
2. Run the binary
3. Assert stdout contains expected output lines:
   - `"created: 0"` (CREATE TABLE affects 0 rows in PG, unlike SQLite)
   - `"inserted: 1"` (appears twice)
   - `"Alice is 30"`
   - `"Bob is 25"`
   - `"older: Alice"`
   - `"done"`

**Important:** The test should be marked with `#[ignore]` since it requires a running PostgreSQL instance. The user can run it explicitly with `cargo test e2e_pg -- --ignored`. Add a comment explaining this.

Also: The DROP TABLE IF EXISTS at the start ensures the test is idempotent. The `let _ =` pattern discards the result so it doesn't fail if the table doesn't exist (though with IF EXISTS it should return Ok(0)).

Note: PostgreSQL `CREATE TABLE` returns a CommandComplete tag of `"CREATE TABLE"` with no row count number, so the execute function should return 0 for DDL statements. If the CommandComplete tag's last token is not a number, return 0. Similarly, `DROP TABLE` returns `"DROP TABLE"`. Handle this in the runtime (Plan 01) by using `str::parse::<i64>().unwrap_or(0)` on the last token.
  </action>
  <verify>
First verify the fixture compiles:
```bash
cargo run -p snowc -- tests/e2e/stdlib_pg.snow -o /tmp/test_pg
```
This should compile without type errors (proving the full compiler pipeline works).

Then if PostgreSQL is available, run:
```bash
/tmp/test_pg
```
Expected output should include "created:", "inserted:", person names, and "done".

Run the full E2E test (if PostgreSQL running):
```bash
cargo test e2e_pg -- --ignored
```
  </verify>
  <done>
`tests/e2e/stdlib_pg.snow` exists with full CRUD lifecycle test. `crates/snowc/tests/e2e_stdlib.rs` has `e2e_pg` test function (marked `#[ignore]`). The Snow fixture compiles without type errors. When run against a PostgreSQL instance with the test user/database, it produces correct output showing connect, DDL, insert with params, query with column access, filtered query, and close.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify PostgreSQL E2E test against real database</name>
  <files>tests/e2e/stdlib_pg.snow</files>
  <action>
User verifies the complete PostgreSQL driver works end-to-end against a real PostgreSQL instance. This checkpoint confirms wire protocol, authentication, parameterized queries, and result parsing all work correctly.
  </action>
  <verify>
1. Ensure PostgreSQL is running locally (Docker or native):
   ```bash
   # Option A: Docker (easiest)
   docker run --name snow-pg-test -e POSTGRES_USER=snow_test -e POSTGRES_PASSWORD=snow_test -e POSTGRES_DB=snow_test -p 5432:5432 -d postgres:16

   # Option B: If PostgreSQL is already installed, create the test user/db:
   # psql -U postgres -c "CREATE USER snow_test PASSWORD 'snow_test';"
   # psql -U postgres -c "CREATE DATABASE snow_test OWNER snow_test;"
   ```

2. Compile and run the Snow test program:
   ```bash
   cargo run -p snowc -- tests/e2e/stdlib_pg.snow -o /tmp/test_pg && /tmp/test_pg
   ```

3. Expected output:
   ```
   created: 0
   inserted: 1
   inserted: 1
   Alice is 30
   Bob is 25
   older: Alice
   done
   ```

4. Run the ignored E2E test:
   ```bash
   cargo test e2e_pg -- --ignored
   ```

5. Clean up Docker (if used):
   ```bash
   docker rm -f snow-pg-test
   ```
  </verify>
  <done>User confirms output matches expected results and E2E test passes against real PostgreSQL.</done>
</task>

</tasks>

<verification>
1. `tests/e2e/stdlib_pg.snow` compiles without type errors
2. Binary connects to PostgreSQL and performs full CRUD lifecycle
3. Output matches expected lines (created, inserted, query results, done)
4. `cargo test e2e_pg -- --ignored` passes
</verification>

<success_criteria>
- Snow program exercises all 8 PG requirements (PG-01 through PG-08) through real database interaction
- Full compilation pipeline works: Snow source -> type check -> MIR -> LLVM IR -> native binary
- Wire protocol correctly handles parameterized queries with $1, $2 placeholders
- Authentication works (SCRAM-SHA-256 with default Docker PostgreSQL 16)
</success_criteria>

<output>
After completion, create `.planning/phases/54-postgresql-driver/54-02-SUMMARY.md`
</output>
