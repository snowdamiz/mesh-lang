---
phase: 76-iterator-protocol
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-typeck/src/builtins.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-rt/src/collections/list.rs
  - crates/mesh-rt/src/collections/map.rs
  - crates/mesh-rt/src/collections/set.rs
  - crates/mesh-rt/src/collections/range.rs
  - crates/mesh-rt/src/option.rs
autonomous: true

must_haves:
  truths:
    - "Iterator trait is registered with `type Item` associated type and `fn next(self)` method"
    - "Iterable trait is registered with `type Item`, `type Iter` associated types and `fn iter(self)` method"
    - "Built-in List, Map, Set, Range have registered Iterable impls with correct Item types"
    - "Runtime iterator handle functions exist for all four collection types (new + next)"
    - "Type checker resolves Item type for Iterable types in for-in expressions"
    - "All existing for-in test cases pass unchanged (zero regressions)"
  artifacts:
    - path: "crates/mesh-typeck/src/builtins.rs"
      provides: "Iterator and Iterable trait defs + Iterable impls for List/Map/Set/Range"
      contains: "Iterator"
    - path: "crates/mesh-rt/src/collections/list.rs"
      provides: "ListIterator struct + mesh_list_iter_new + mesh_list_iter_next"
      contains: "mesh_list_iter_new"
    - path: "crates/mesh-rt/src/collections/map.rs"
      provides: "MapIterator struct + mesh_map_iter_new + mesh_map_iter_next"
      contains: "mesh_map_iter_new"
    - path: "crates/mesh-rt/src/collections/set.rs"
      provides: "SetIterator struct + mesh_set_iter_new + mesh_set_iter_next"
      contains: "mesh_set_iter_new"
    - path: "crates/mesh-rt/src/collections/range.rs"
      provides: "RangeIterator struct + mesh_range_iter_new + mesh_range_iter_next"
      contains: "mesh_range_iter_new"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Iterable/Iterator fallback in infer_for_in before Unknown path"
      contains: "Iterable"
  key_links:
    - from: "crates/mesh-typeck/src/builtins.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "register_trait + register_impl calls for Iterator and Iterable"
      pattern: "register_trait.*Iterator"
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "trait_registry.has_impl and resolve_associated_type for Iterable"
      pattern: "has_impl.*Iterable"
    - from: "crates/mesh-rt/src/collections/list.rs"
      to: "crates/mesh-rt/src/option.rs"
      via: "alloc_option for returning Option from mesh_list_iter_next"
      pattern: "alloc_option"
---

<objective>
Register Iterator and Iterable traits with associated types, add runtime iterator handle functions for all built-in collections, and extend the type checker to resolve element types for Iterable types in for-in expressions.

Purpose: Establish the type-system and runtime foundation for iterator-based for-in loops and future pipe-style iterator composition.
Output: Iterator/Iterable traits registered, runtime iterator handles for List/Map/Set/Range, typeck Iterable resolution in infer_for_in.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/76-iterator-protocol/76-RESEARCH.md
@.planning/phases/74-associated-types/74-02-SUMMARY.md
@.planning/phases/75-numeric-traits/75-02-SUMMARY.md
@crates/mesh-typeck/src/builtins.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-typeck/src/traits.rs
@crates/mesh-rt/src/option.rs
@crates/mesh-rt/src/collections/list.rs
@crates/mesh-rt/src/collections/map.rs
@crates/mesh-rt/src/collections/set.rs
@crates/mesh-rt/src/collections/range.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Iterator and Iterable traits in builtins + built-in Iterable impls</name>
  <files>crates/mesh-typeck/src/builtins.rs</files>
  <action>
In `register_compiler_known_traits` (after the Neg trait block, before the Eq trait block), add the following trait registrations:

**1. Iterator trait:**
```rust
registry.register_trait(TraitDef {
    name: "Iterator".to_string(),
    methods: vec![TraitMethodSig {
        name: "next".to_string(),
        has_self: true,
        param_count: 0,
        return_type: None,  // Option<Self.Item> -- resolved per impl
        has_default_body: false,
    }],
    associated_types: vec![AssocTypeDef { name: "Item".to_string() }],
});
```

**2. Iterable trait:**
```rust
registry.register_trait(TraitDef {
    name: "Iterable".to_string(),
    methods: vec![TraitMethodSig {
        name: "iter".to_string(),
        has_self: true,
        param_count: 0,
        return_type: None,  // Self.Iter -- resolved per impl
        has_default_body: false,
    }],
    associated_types: vec![
        AssocTypeDef { name: "Item".to_string() },
        AssocTypeDef { name: "Iter".to_string() },
    ],
});
```

**3. Built-in Iterable impls for List<T>, Set<T>, Map<K,V>, and Range:**

For each built-in collection, register an Iterable impl. Use TyCon names like `ListIterator`, `MapIterator`, `SetIterator`, `RangeIterator` for the Iter associated type. These are opaque type names used only for trait resolution and name mangling -- they map to MirType::Ptr at MIR level.

For List<T>:
- `type Item = T` (the generic param)
- `type Iter = ListIterator` (opaque iterator handle type)
- Method `iter` with has_self=true, param_count=0

For Map<K,V>:
- `type Item = Tuple(K,V)` -- map iterators yield key-value pairs
- `type Iter = MapIterator`
- Method `iter` with has_self=true, param_count=0

For Set<T>:
- `type Item = T`
- `type Iter = SetIterator`
- Method `iter` with has_self=true, param_count=0

For Range (Int..Int):
- Use `Ty::int()` for the impl_type (ranges are syntactic sugar, not a generic type)
- **OR** use a `Ty::Con(TyCon::new("Range"))` if the type system recognizes Range
- `type Item = Int`
- `type Iter = RangeIterator`
- Method `iter` with has_self=true, param_count=0

Also register Iterator impls for each iterator handle type:
- `impl Iterator for ListIterator` with `type Item = T` (use a fresh type var or match the Iterable's Item)
- `impl Iterator for MapIterator` with `type Item = Tuple(K,V)`
- `impl Iterator for SetIterator` with `type Item = T`
- `impl Iterator for RangeIterator` with `type Item = Int`

**IMPORTANT:** Use the exact same pattern as the arithmetic traits (Phase 75): `AssocTypeDef`, `FxHashMap` for associated_types in ImplDef. The `impl_type_name` field is critical -- it's used in name mangling (e.g., `Iterable__iter__List`, `Iterator__next__ListIterator`).

**IMPORTANT:** For generic types like List<T>, use `Ty::App(Box::new(Ty::Con(TyCon::new("List"))), vec![Ty::Con(TyCon::new("T"))])` as the impl_type. The T parameter must flow through to the Item associated type. Look at how existing impls handle this (e.g., in the register_trait_impls_for_list function or similar patterns).

**NOTE:** If there is no Range type in the type system, skip the Range Iterable impl for now -- ranges use the DotDot syntax which is handled specially by the parser and never reaches the Iterable check.
  </action>
  <verify>
Run `cargo build -p mesh-typeck 2>&1 | head -20` -- must compile cleanly with no errors. The trait definitions and impls must be properly structured (register_impl validates associated type counts).
  </verify>
  <done>
Iterator and Iterable traits registered with correct associated types. Built-in Iterable impls registered for List, Map, Set (and Range if applicable). Iterator impls registered for corresponding iterator handle types. mesh-typeck compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add runtime iterator handle functions for List, Map, Set, and Range</name>
  <files>crates/mesh-rt/src/collections/list.rs, crates/mesh-rt/src/collections/map.rs, crates/mesh-rt/src/collections/set.rs, crates/mesh-rt/src/collections/range.rs, crates/mesh-rt/src/option.rs</files>
  <action>
Add iterator state structs and extern "C" functions for each collection type. These are runtime handles that maintain iteration state (current index) and return `Option<T>` values via `MeshOption` (tag 0 = Some, tag 1 = None).

**Pattern for each collection type (using List as example):**

```rust
// In crates/mesh-rt/src/collections/list.rs

/// Internal iterator state for List iteration.
#[repr(C)]
struct ListIterator {
    list: *mut u8,    // The underlying MeshList pointer
    index: i64,       // Current position
    length: i64,      // Cached length (avoids repeated calls)
}

#[no_mangle]
pub extern "C" fn mesh_list_iter_new(list: *mut u8) -> *mut u8 {
    unsafe {
        let len = mesh_list_length(list);
        let iter = mesh_gc_alloc_actor(
            std::mem::size_of::<ListIterator>() as u64,
            std::mem::align_of::<ListIterator>() as u64,
        ) as *mut ListIterator;
        (*iter).list = list;
        (*iter).index = 0;
        (*iter).length = len;
        iter as *mut u8
    }
}

#[no_mangle]
pub extern "C" fn mesh_list_iter_next(iter_ptr: *mut u8) -> *mut u8 {
    unsafe {
        let iter = iter_ptr as *mut ListIterator;
        if (*iter).index >= (*iter).length {
            // None: tag=1, value=null
            alloc_option(1, std::ptr::null_mut()) as *mut u8
        } else {
            let elem = mesh_list_get((*iter).list, (*iter).index);
            (*iter).index += 1;
            // Some: tag=0, value=elem as pointer
            // elem is i64 from mesh_list_get; store as *mut u8
            alloc_option(0, elem as usize as *mut u8) as *mut u8
        }
    }
}
```

Import `alloc_option` from `crate::option` and `mesh_gc_alloc_actor` from `crate::gc` in each file.

**For Map (crates/mesh-rt/src/collections/map.rs):**
- `MapIterator` struct with `map: *mut u8`, `index: i64`, `size: i64`
- `mesh_map_iter_new(map) -> *mut u8` -- creates iterator, caches `mesh_map_size(map)`
- `mesh_map_iter_next(iter) -> *mut u8` -- returns `Option<Pair>` where Pair is a GC-allocated `{key: *mut u8, val: *mut u8}` tuple. Use the existing `alloc_pair` helper if available, or allocate a two-element struct via `mesh_gc_alloc_actor`. The key and value are retrieved via `mesh_map_entry_key(map, index)` and `mesh_map_entry_value(map, index)`.

**For Set (crates/mesh-rt/src/collections/set.rs):**
- `SetIterator` struct with `set: *mut u8`, `index: i64`, `size: i64`
- `mesh_set_iter_new(set) -> *mut u8`
- `mesh_set_iter_next(iter) -> *mut u8` -- returns `Option<elem>` using `mesh_set_element_at(set, index)`

**For Range (crates/mesh-rt/src/collections/range.rs):**
- `RangeIterator` struct with `current: i64`, `end: i64`
- `mesh_range_iter_new(start: i64, end: i64) -> *mut u8`
- `mesh_range_iter_next(iter) -> *mut u8` -- returns `Option<Int>`. When current < end, return Some(current) and increment; otherwise return None. Note: Int values are stored as i64, so store the value directly as `current as usize as *mut u8`.

**CRITICAL:** All iterator structs must be allocated with `mesh_gc_alloc_actor` so the GC tracks them. The iterator's internal pointer to the collection acts as a GC root keeping the collection alive during iteration.

**CRITICAL:** Option tag encoding: `tag 0 = Some`, `tag 1 = None`. Verify against `crates/mesh-rt/src/option.rs` MeshOption struct.
  </action>
  <verify>
Run `cargo build -p mesh-rt 2>&1 | head -20` -- must compile cleanly. Check that all 8 new functions are present: `mesh_list_iter_new`, `mesh_list_iter_next`, `mesh_map_iter_new`, `mesh_map_iter_next`, `mesh_set_iter_new`, `mesh_set_iter_next`, `mesh_range_iter_new`, `mesh_range_iter_next`.
  </verify>
  <done>
All 8 runtime iterator functions compile. Each collection type has an iterator struct with GC-allocated state and proper Option return values (tag 0 = Some, tag 1 = None).
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend infer_for_in with Iterable/Iterator fallback + verify zero regressions</name>
  <files>crates/mesh-typeck/src/infer.rs</files>
  <action>
Modify `infer_for_in` (around line 4196) to check for Iterable/Iterator trait implementation BEFORE the `CollectionType::Unknown` fallback.

In the `match extract_collection_elem_type(&iter_ty)` block, change the `CollectionType::Unknown` arm from:

```rust
CollectionType::Unknown => {
    let var_name = for_in
        .binding_name()
        .and_then(|n| n.text())
        .unwrap_or_else(|| "_".to_string());
    env.insert(var_name, Scheme::mono(Ty::int()));
}
```

To:

```rust
CollectionType::Unknown => {
    let var_name = for_in
        .binding_name()
        .and_then(|n| n.text())
        .unwrap_or_else(|| "_".to_string());

    // Check if the type implements Iterable (collection -> iterator).
    if trait_registry.has_impl("Iterable", &iter_ty) {
        if let Some(item_ty) = trait_registry.resolve_associated_type("Iterable", "Item", &iter_ty) {
            env.insert(var_name, Scheme::mono(item_ty));
        } else {
            // Iterable impl exists but no Item type resolved -- fallback to Int
            env.insert(var_name, Scheme::mono(Ty::int()));
        }
    }
    // Check if the type directly implements Iterator (type IS an iterator).
    else if trait_registry.has_impl("Iterator", &iter_ty) {
        if let Some(item_ty) = trait_registry.resolve_associated_type("Iterator", "Item", &iter_ty) {
            env.insert(var_name, Scheme::mono(item_ty));
        } else {
            env.insert(var_name, Scheme::mono(Ty::int()));
        }
    }
    // True fallback: bind as Int (existing behavior).
    else {
        env.insert(var_name, Scheme::mono(Ty::int()));
    }
}
```

**IMPORTANT:** This code runs ONLY for types not recognized as List/Map/Set/Range by `extract_collection_elem_type`. Those built-in types continue to use their existing paths (ITER-05 zero regressions). The Iterable/Iterator check is the FALLBACK for user-defined types.

**IMPORTANT:** The `trait_registry` parameter is already available in `infer_for_in`'s signature. No new parameters needed.

After making this change, run the FULL workspace test suite to verify zero regressions on existing for-in tests.
  </action>
  <verify>
Run `cargo test --workspace 2>&1 | tail -20` -- all existing tests must pass. Specifically verify the for-in tests pass by running `cargo test -p meshc e2e_for_in 2>&1` (or the appropriate test filter for for-in E2E tests). Zero regressions is a hard requirement (ITER-05).
  </verify>
  <done>
infer_for_in checks for Iterable/Iterator traits before falling back to Int. All existing workspace tests pass with zero regressions. The type checker correctly resolves Item types for user-defined Iterable/Iterator types.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace 2>&1 | tail -5` -- full workspace compiles
2. `cargo test --workspace 2>&1 | tail -5` -- all existing tests pass
3. Iterator and Iterable traits visible in builtins (grep for "Iterator" in builtins.rs)
4. Runtime functions present (grep for "mesh_list_iter_new" in list.rs)
5. Typeck Iterable check present (grep for "Iterable" in infer.rs)
</verification>

<success_criteria>
- Iterator trait registered with `type Item` and `fn next(self)`
- Iterable trait registered with `type Item`, `type Iter`, and `fn iter(self)`
- Iterable impls registered for List, Map, Set (and Range if applicable)
- Iterator impls registered for ListIterator, MapIterator, SetIterator (and RangeIterator)
- 8 runtime functions compile: mesh_{list,map,set,range}_iter_{new,next}
- infer_for_in resolves Item type for Iterable/Iterator types
- Zero regressions on all existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/76-iterator-protocol/76-01-SUMMARY.md`
</output>
