---
phase: 76-iterator-protocol
plan: 02
type: execute
wave: 2
depends_on: ["76-01"]
files_modified:
  - crates/mesh-codegen/src/mir/mod.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/mir/mono.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - tests/e2e/iterator_basic.mpl
  - tests/e2e/iterator_iterable.mpl
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "User can define a custom iterator implementing Iterator with type Item and fn next, and iterate over it with for-in"
    - "User can define a custom Iterable+Iterator pair and iterate over the Iterable with for-in"
    - "for-in over user-defined Iterable desugars through iter() + next() calls with Option tag checking"
    - "Comprehension semantics work: for-in over custom iterator returns List<body_ty>"
    - "All existing for-in loops over List, Map, Set, Range produce identical results (zero regressions)"
    - "Iter.from(collection) creates an iterator from any Iterable collection"
  artifacts:
    - path: "crates/mesh-codegen/src/mir/mod.rs"
      provides: "ForInIterator MIR node definition"
      contains: "ForInIterator"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "lower_for_in_iterator function and Iterable/Iterator check in lower_for_in_expr"
      contains: "lower_for_in_iterator"
    - path: "crates/mesh-codegen/src/mir/mono.rs"
      provides: "ForInIterator arm in collect_function_refs"
      contains: "ForInIterator"
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "codegen_for_in_iterator function generating LLVM IR for iterator loop"
      contains: "codegen_for_in_iterator"
    - path: "tests/e2e/iterator_basic.mpl"
      provides: "E2E test: user-defined Iterator with for-in loop"
    - path: "tests/e2e/iterator_iterable.mpl"
      provides: "E2E test: user-defined Iterable+Iterator pair with for-in loop"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "Test harness entries for iterator E2E tests"
      contains: "iterator_basic"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "trait_registry.has_impl for Iterable/Iterator check in lower_for_in_expr"
      pattern: "has_impl.*Iterable"
    - from: "crates/mesh-codegen/src/codegen/expr.rs"
      to: "crates/mesh-rt/src/option.rs"
      via: "Option tag check (tag 0 = Some, tag 1 = None) in codegen_for_in_iterator"
      pattern: "const_int.*0.*some"
    - from: "crates/mesh-codegen/src/mir/mono.rs"
      to: "crates/mesh-codegen/src/mir/mod.rs"
      via: "ForInIterator arm traversing sub-expressions and collecting next_fn"
      pattern: "ForInIterator"
---

<objective>
Add the ForInIterator MIR node, MIR lowering, monomorphization support, and LLVM codegen for iterator-based for-in loops. Add Iter.from() entry point. Verify with E2E tests proving user-defined iterators work end-to-end.

Purpose: Complete the compiler pipeline for iterator-based for-in, enabling user-defined types to participate in for-in loops through the Iterable/Iterator protocol.
Output: Working end-to-end iterator-based for-in for user types, Iter.from() function, E2E test coverage.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/76-iterator-protocol/76-RESEARCH.md
@.planning/phases/76-iterator-protocol/76-01-SUMMARY.md
@crates/mesh-codegen/src/mir/mod.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/mir/mono.rs
@crates/mesh-codegen/src/codegen/expr.rs
@crates/mesh-rt/src/option.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ForInIterator MIR node + lowering + mono support</name>
  <files>crates/mesh-codegen/src/mir/mod.rs, crates/mesh-codegen/src/mir/lower.rs, crates/mesh-codegen/src/mir/mono.rs</files>
  <action>
**1. MIR Node (crates/mesh-codegen/src/mir/mod.rs):**

Add `ForInIterator` variant to the `MirExpr` enum, after `ForInSet`:

```rust
/// For-in loop over any type implementing Iterable/Iterator.
/// Desugared to repeated next() calls with Option tag checking.
ForInIterator {
    /// Loop variable name.
    var: String,
    /// The iterator expression (result of calling iter() on the collection,
    /// or the collection itself if it directly implements Iterator).
    iterator: Box<MirExpr>,
    /// Optional filter expression (`when condition`).
    filter: Option<Box<MirExpr>>,
    /// Loop body.
    body: Box<MirExpr>,
    /// Resolved element type (Item type for the concrete iterator type).
    elem_ty: MirType,
    /// Type of body expression (for list builder element conversion).
    body_ty: MirType,
    /// Mangled name for the next() function: "Iterator__next__TypeName".
    next_fn: String,
    /// Mangled name for the iter() function (if Iterable): "Iterable__iter__TypeName".
    /// Empty string if the type directly implements Iterator (no iter() call needed).
    iter_fn: String,
    /// Result type (Ptr for comprehension semantics -- list of body results).
    ty: MirType,
},
```

Add the `ForInIterator` arm to the `MirExpr::ty()` match:
```rust
MirExpr::ForInIterator { ty, .. } => ty,
```

**2. MIR Lowering (crates/mesh-codegen/src/mir/lower.rs):**

In `lower_for_in_expr` (after the existing `extract_list_elem_type` check at line ~6022 and before the fallback at line ~6026), add:

```rust
// Check if type implements Iterable (collection -> produces iterator).
if let Some(ref ty) = iterable_ty {
    let ty_for_lookup = ty.clone(); // The Ty from typeck
    if self.trait_registry.has_impl("Iterable", &ty_for_lookup) {
        return self.lower_for_in_iterator(for_in, &ty_for_lookup, true);
    }
    // Check if type directly implements Iterator (type IS an iterator).
    if self.trait_registry.has_impl("Iterator", &ty_for_lookup) {
        return self.lower_for_in_iterator(for_in, &ty_for_lookup, false);
    }
}
```

Note: This code must go INSIDE the existing `if let Some(ref ty) = iterable_ty` block, after the three existing extract checks, but before the closing `}` of that block. The existing fallback `self.lower_for_in_list(for_in, &Ty::int())` stays as the final catch-all AFTER the if-let block.

Add the `lower_for_in_iterator` method:

```rust
fn lower_for_in_iterator(&mut self, for_in: &ForInExpr, ty: &Ty, is_iterable: bool) -> MirExpr {
    let var_name = for_in
        .binding_name()
        .and_then(|n| n.text())
        .unwrap_or_else(|| "_".to_string());

    // Resolve the type name for name mangling.
    let type_name = self.mangle_type_name(ty);

    // Determine iter_fn and next_fn names, and the element type.
    let (iter_fn, next_fn, elem_ty) = if is_iterable {
        // Iterable path: call iter() to get iterator, then next() on iterator.
        let iter_fn_name = format!("Iterable__iter__{}", type_name);

        // Resolve Iter type from Iterable impl to get the iterator type name.
        let iter_type = self.trait_registry
            .resolve_associated_type("Iterable", "Iter", ty)
            .unwrap_or_else(|| Ty::Con(TyCon::new("Unknown")));
        let iter_type_name = self.mangle_type_name(&iter_type);
        let next_fn_name = format!("Iterator__next__{}", iter_type_name);

        // Resolve Item type from Iterable impl.
        let item_ty = self.trait_registry
            .resolve_associated_type("Iterable", "Item", ty)
            .unwrap_or(Ty::int());

        (iter_fn_name, next_fn_name, item_ty)
    } else {
        // Direct Iterator path: no iter() call, just next().
        let next_fn_name = format!("Iterator__next__{}", type_name);
        let item_ty = self.trait_registry
            .resolve_associated_type("Iterator", "Item", ty)
            .unwrap_or(Ty::int());

        (String::new(), next_fn_name, item_ty)
    };

    // Lower the iterable/iterator expression.
    let collection = for_in
        .iterable()
        .map(|e| self.lower_expr(&e))
        .unwrap_or(MirExpr::Unit);

    let elem_mir_ty = resolve_type(&elem_ty, self.registry, false);

    self.push_scope();
    self.insert_var(var_name.clone(), elem_mir_ty.clone());
    let filter = for_in
        .filter()
        .map(|f| Box::new(self.lower_expr(&f)));
    let body = for_in
        .body()
        .map(|b| self.lower_block(&b))
        .unwrap_or(MirExpr::Unit);
    let body_ty = body.ty().clone();
    self.pop_scope();

    MirExpr::ForInIterator {
        var: var_name,
        iterator: Box::new(collection),
        filter,
        body: Box::new(body),
        elem_ty: elem_mir_ty,
        body_ty,
        next_fn,
        iter_fn,
        ty: MirType::Ptr,
    }
}
```

**IMPORTANT:** The `mangle_type_name` method may not exist on the lowerer. Look at how existing trait dispatch mangles type names -- search for `resolve_trait_callee` (around line 5300) and the `Trait__Method__Type` pattern. Use the same approach. The type name for a struct like `Counter` is just `"Counter"`. For `List<Int>`, it should be `"List_Int"` or whatever the existing mangle convention is. Check `mangle_type_name` or equivalent in lower.rs.

**Also for Iter.from():** In the lowerer's module method resolution (the section that handles `String.method()`, `List.method()`, etc. -- around line 5345-5374), add a case for `Iter.from`:

When the module name is `"Iter"` and the method is `"from"`:
- The single argument is the collection to iterate
- Resolve the Iterable impl for the argument's type
- Lower to a Call to `Iterable__iter__TypeName(collection)` which returns the iterator
- This enables `Iter.from(list)` as a pipe-friendly entry point

If this is complex to add during this task, it can be added as a simple runtime function mapping: `"Iter" + "from"` -> call `mesh_iter_from` which is a thin wrapper. But the trait-dispatch approach is preferred.

**3. Monomorphization (crates/mesh-codegen/src/mir/mono.rs):**

Add a `ForInIterator` arm in `collect_function_refs` (after the `ForInSet` arm around line 255):

```rust
MirExpr::ForInIterator { iterator, filter, body, next_fn, iter_fn, .. } => {
    collect_function_refs(iterator, refs);
    if let Some(f) = filter {
        collect_function_refs(f, refs);
    }
    collect_function_refs(body, refs);
    // Mark the next() function as reachable.
    refs.insert(next_fn.clone());
    // Mark the iter() function as reachable (if Iterable path).
    if !iter_fn.is_empty() {
        refs.insert(iter_fn.clone());
    }
}
```

**CRITICAL:** Without this mono.rs arm, the `next_fn` and `iter_fn` functions would be pruned as unreachable, causing linker errors.
  </action>
  <verify>
Run `cargo build -p mesh-codegen 2>&1 | head -20` -- must compile. Run `cargo test -p mesh-codegen 2>&1 | tail -10` -- mono tests pass.
  </verify>
  <done>
ForInIterator MIR node added with all fields. lower_for_in_iterator generates ForInIterator for Iterable/Iterator types. collect_function_refs traverses ForInIterator sub-expressions and collects next_fn/iter_fn. mesh-codegen compiles and tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add codegen_for_in_iterator + Iter.from() + E2E tests</name>
  <files>crates/mesh-codegen/src/codegen/expr.rs, tests/e2e/iterator_basic.mpl, tests/e2e/iterator_iterable.mpl, crates/meshc/tests/e2e.rs</files>
  <action>
**1. Codegen dispatch (crates/mesh-codegen/src/codegen/expr.rs):**

Add a match arm for ForInIterator in `codegen_expr` (after the ForInSet arm around line 160):

```rust
MirExpr::ForInIterator { var, iterator, filter, body, elem_ty, body_ty, next_fn, iter_fn, ty } => {
    self.codegen_for_in_iterator(var, iterator, filter.as_deref(), body, elem_ty, body_ty, next_fn, iter_fn, ty)
}
```

**2. Codegen implementation (crates/mesh-codegen/src/codegen/expr.rs):**

Add `codegen_for_in_iterator` method. Follow the `codegen_for_in_list` pattern closely but replace the counter-based loop with a next()-based loop:

```rust
fn codegen_for_in_iterator(
    &mut self,
    var: &str,
    iterator_expr: &MirExpr,
    filter: Option<&MirExpr>,
    body_expr: &MirExpr,
    elem_ty: &MirType,
    body_ty: &MirType,
    next_fn: &str,
    iter_fn: &str,
    _ty: &MirType,
) -> Result<BasicValueEnum<'ctx>, String> {
    let fn_val = self.current_function();
    let i64_ty = self.context.i64_type();
    let i8_ty = self.context.i8_type();
    let ptr_ty = self.context.ptr_type(inkwell::AddressSpace::default());

    // Step 1: Codegen the collection/iterator expression.
    let collection_val = self.codegen_expr(iterator_expr)?;

    // Step 2: If iter_fn is non-empty, call iter() to get the iterator.
    let iter_val = if !iter_fn.is_empty() {
        let iter_func = get_intrinsic(&self.module, iter_fn);
        let result = self.builder.build_call(iter_func, &[collection_val.into()], "iter")
            .map_err(|e| e.to_string())?
            .try_as_basic_value()
            .basic()
            .ok_or_else(|| format!("{} returned void", iter_fn))?;
        result.into_pointer_value()
    } else {
        // Direct Iterator: the expression IS the iterator.
        collection_val.into_pointer_value()
    };

    // Step 3: Store iterator in alloca.
    let iter_alloca = self.builder.build_alloca(ptr_ty, "iter_alloca")
        .map_err(|e| e.to_string())?;
    self.builder.build_store(iter_alloca, iter_val)
        .map_err(|e| e.to_string())?;

    // Step 4: Pre-allocate result list builder (comprehension semantics).
    let list_builder_new = get_intrinsic(&self.module, "mesh_list_builder_new");
    let result_list = self.builder.build_call(list_builder_new, &[i64_ty.const_int(0, false).into()], "result_list")
        .map_err(|e| e.to_string())?
        .try_as_basic_value()
        .basic()
        .ok_or_else(|| "mesh_list_builder_new returned void".to_string())?
        .into_pointer_value();

    let result_alloca = self.builder.build_alloca(ptr_ty, "result_alloca")
        .map_err(|e| e.to_string())?;
    self.builder.build_store(result_alloca, result_list)
        .map_err(|e| e.to_string())?;

    // Step 5: Create basic blocks.
    let header_bb = self.context.append_basic_block(fn_val, "iter_header");
    let body_bb = self.context.append_basic_block(fn_val, "iter_body");
    let latch_bb = self.context.append_basic_block(fn_val, "iter_latch");
    let merge_bb = self.context.append_basic_block(fn_val, "iter_merge");

    // Push loop context for break/continue.
    self.loop_stack.push((latch_bb, merge_bb));

    self.builder.build_unconditional_branch(header_bb)
        .map_err(|e| e.to_string())?;

    // Step 6: Header -- call next(), check Option tag.
    self.builder.position_at_end(header_bb);
    let iter_loaded = self.builder.build_load(ptr_ty, iter_alloca, "iter_loaded")
        .map_err(|e| e.to_string())?
        .into_pointer_value();

    // Call Iterator__next__TypeName(iter).
    let next_func = get_intrinsic(&self.module, next_fn);
    let next_result = self.builder.build_call(next_func, &[iter_loaded.into()], "next_result")
        .map_err(|e| e.to_string())?
        .try_as_basic_value()
        .basic()
        .ok_or_else(|| format!("{} returned void", next_fn))?
        .into_pointer_value();

    // Option is MeshOption { tag: u8, value: *mut u8 }.
    // tag 0 = Some, tag 1 = None.
    // GEP to tag field (index 0).
    let mesh_option_ty = self.context.struct_type(
        &[i8_ty.into(), ptr_ty.into()],
        false,
    );
    let tag_ptr = self.builder.build_struct_gep(mesh_option_ty, next_result, 0, "tag_ptr")
        .map_err(|e| e.to_string())?;
    let tag_val = self.builder.build_load(i8_ty, tag_ptr, "tag")
        .map_err(|e| e.to_string())?
        .into_int_value();

    // Compare tag == 0 (Some).
    let is_some = self.builder.build_int_compare(
        IntPredicate::EQ, tag_val, i8_ty.const_int(0, false), "is_some",
    ).map_err(|e| e.to_string())?;

    self.builder.build_conditional_branch(is_some, body_bb, merge_bb)
        .map_err(|e| e.to_string())?;

    // Step 7: Body -- extract element, bind variable, run body, push result.
    self.builder.position_at_end(body_bb);

    // GEP to value field (index 1).
    let value_ptr = self.builder.build_struct_gep(mesh_option_ty, next_result, 1, "value_ptr")
        .map_err(|e| e.to_string())?;
    let raw_value = self.builder.build_load(ptr_ty, value_ptr, "raw_value")
        .map_err(|e| e.to_string())?;

    // Convert from raw pointer to typed element.
    // For Int: ptr -> i64 via ptrtoint. For String/Ptr types: ptr -> ptr (no conversion needed).
    let typed_elem = match elem_ty {
        MirType::Int => {
            let as_int = self.builder.build_ptr_to_int(raw_value.into_pointer_value(), i64_ty, "as_int")
                .map_err(|e| e.to_string())?;
            as_int.into()
        }
        MirType::Float => {
            let as_int = self.builder.build_ptr_to_int(raw_value.into_pointer_value(), i64_ty, "as_int_f")
                .map_err(|e| e.to_string())?;
            self.builder.build_bit_cast(as_int, self.context.f64_type(), "as_float")
                .map_err(|e| e.to_string())?
        }
        MirType::Bool => {
            let as_int = self.builder.build_ptr_to_int(raw_value.into_pointer_value(), i64_ty, "as_int_b")
                .map_err(|e| e.to_string())?;
            self.builder.build_int_truncate(as_int, self.context.bool_type(), "as_bool")
                .map_err(|e| e.to_string())?
                .into()
        }
        _ => {
            // Ptr types (String, structs, collections): already a pointer.
            raw_value
        }
    };

    // Create alloca for loop variable.
    let elem_llvm_ty = self.llvm_type(elem_ty);
    let var_alloca = self.builder.build_alloca(elem_llvm_ty, var)
        .map_err(|e| e.to_string())?;
    self.builder.build_store(var_alloca, typed_elem)
        .map_err(|e| e.to_string())?;

    // Save old locals.
    let old_alloca = self.locals.insert(var.to_string(), var_alloca);
    let old_type = self.local_types.insert(var.to_string(), elem_ty.clone());

    // Optional filter.
    if let Some(filter_expr) = filter {
        let filter_val = self.codegen_expr(filter_expr)?
            .into_int_value();
        let do_body_bb = self.context.append_basic_block(fn_val, "iter_do_body");
        self.builder.build_conditional_branch(filter_val, do_body_bb, latch_bb)
            .map_err(|e| e.to_string())?;
        self.builder.position_at_end(do_body_bb);
    }

    // Codegen body.
    let body_val = self.codegen_expr(body_expr)?;

    // Push body result to result list.
    if let Some(bb) = self.builder.get_insert_block() {
        if bb.get_terminator().is_none() {
            let body_as_i64 = self.convert_to_list_element(body_val, body_ty)?;
            let list_builder_push = get_intrinsic(&self.module, "mesh_list_builder_push");
            let result_loaded = self.builder.build_load(ptr_ty, result_alloca, "res_list")
                .map_err(|e| e.to_string())?
                .into_pointer_value();
            self.builder.build_call(list_builder_push, &[result_loaded.into(), body_as_i64.into()], "")
                .map_err(|e| e.to_string())?;
            self.builder.build_unconditional_branch(latch_bb)
                .map_err(|e| e.to_string())?;
        }
    }

    // Step 8: Latch -- reduction check, branch back to header.
    self.builder.position_at_end(latch_bb);
    self.emit_reduction_check();
    self.builder.build_unconditional_branch(header_bb)
        .map_err(|e| e.to_string())?;

    // Step 9: Cleanup.
    self.loop_stack.pop();

    if let Some(prev) = old_alloca {
        self.locals.insert(var.to_string(), prev);
    } else {
        self.locals.remove(var);
    }
    if let Some(prev) = old_type {
        self.local_types.insert(var.to_string(), prev);
    } else {
        self.local_types.remove(var);
    }

    // Return result list.
    self.builder.position_at_end(merge_bb);
    let final_result = self.builder.build_load(ptr_ty, result_alloca, "iter_result")
        .map_err(|e| e.to_string())?;
    Ok(final_result)
}
```

**IMPORTANT NOTES:**
- The `get_intrinsic` function is used to look up runtime functions by name. For user-defined types, the next_fn/iter_fn names will be mangled MIR function names (e.g., `Iterator__next__Counter`). These are NOT runtime C functions but MIR-lowered functions. Use the same approach that `codegen_expr` uses for `Call` nodes -- look up the function by name in the module, NOT via `get_intrinsic`. Check how `codegen_call` resolves function names: it may use `self.module.get_function(name)` instead.
- For user-defined iterators, the `next()` function is compiled from the user's impl body. For built-in iterators (ListIterator, etc.), the `next()` function would need to be synthesized or the runtime functions used directly. Since built-in types use the existing optimized ForInList/Map/Set/Range paths, the ForInIterator codegen only handles user-defined types. The runtime iter functions are for `Iter.from()` only.
- The `convert_from_list_element` helper exists and may be usable for type conversion from the Option payload. Check if it accepts the raw i64/ptr value.

**3. E2E Test: User-defined Iterator (tests/e2e/iterator_basic.mpl):**

```mesh
struct Counter do
  current :: Int
  max :: Int
end

impl Iterator for Counter do
  type Item = Int
  fn next(self) -> Option<Int> do
    if self.current >= self.max do
      None
    else
      Some(self.current)
    end
  end
end

fn main() do
  let c = Counter { current: 0, max: 3 }
  let result = for x in c do
    x * 10
  end
  # result should be [0, 10, 20]
  println(result.to_string())
end
```

Expected output: `[0, 10, 20]`

**CRITICAL CONCERN with user Iterator:** The `next()` function takes `self` (by value) and returns Option<Int>. But the iterator needs to advance its state. In Mesh, `self` in impl methods is the struct value, not a mutable reference. The `next()` function cannot mutate `self.current`.

This means user-defined iterators need runtime handles (just like built-in ones) to maintain mutable state. The user's `impl Iterator for Counter` with `fn next(self)` needs special handling:

**Option A:** The runtime creates a mutable handle for the Counter, and `next()` receives the handle. The handle stores the Counter state internally and mutates it. This is the same pattern used by built-in iterators.

**Option B:** The for-in loop re-assigns the iterator variable after each next() call (next returns a new updated iterator along with the value). This is the "functional iterator" pattern used in some FP languages.

**Option C (Simplest for now):** The user-defined iterator's `next()` function receives the struct pointer (self is passed as Ptr). Since Mesh structs are already heap-allocated (GC managed), the next() function can read `self.current`, compute the result, and... wait, it still can't mutate `self.current` without a mutation mechanism.

**PRACTICAL APPROACH:** For the initial implementation, have the user-defined iterator work through a runtime handle pattern:
- When `for x in counter do ... end` encounters an Iterator type, the lowerer generates code that:
  1. Allocates a runtime iterator handle (via a mesh_user_iter_new-style function OR by treating the struct pointer as the handle)
  2. Calls `Iterator__next__Counter(handle)` which reads state from the struct fields
  3. The `next()` impl body needs to be able to mutate the struct's fields

**ALTERNATIVE SIMPLEST APPROACH:** Since Mesh structs are GC-allocated pointers, `self` in an impl method IS a pointer to the heap-allocated struct. If the codegen passes the struct pointer (not a copy), then the next() function CAN write to `self.current` via field mutation. Check how existing impl method codegen handles `self` -- if `self` is a pointer, field writes work. If `self` is a value copy, we need a different approach.

Look at how `self.field` access works in Phase 75's numeric traits (75-02-SUMMARY.md shows `self.x` access works). If `self.field` is read-only (field access on a copy), then the test must use a different pattern -- perhaps a wrapper struct that holds a mutable runtime handle.

**FOR THE E2E TEST:** If self-mutation is not possible, adjust the test to use a runtime-handle-based iterator:
- Create a helper module function that creates a C-level iterator handle
- OR test with a simpler pattern where next() does not need mutation (e.g., a FibIterator that computes the next value from the current state without needing to store back)

Actually, the SIMPLEST working test: just verify that the for-in desugaring works by testing with a type that implements Iterable and uses a built-in collection under the hood. Or use the runtime iterator functions directly.

**PRAGMATIC FIRST TEST:** Test with a user-defined Iterable that wraps a List and delegates to the List's built-in iterator:

```mesh
struct MyList do
  items :: List<Int>
  unused :: Int
end

# ... impl Iterable for MyList using mesh_list_iter_new/next under the hood
```

But this requires the compiler to synthesize the bridge. Let's think differently.

**SIMPLEST CORRECT APPROACH for user iterators:** The `next()` function in the impl body can use runtime handles under the hood. The key insight: when the user writes `impl Iterator for Counter`, the compiler needs to track that Counter's next() is called repeatedly. The iteration state must live in a mutable location. Since Mesh has no mutation, the state progression must work differently:

For the E2E test, use a pattern where the iterator READS state without mutating. This works for testing the pipeline even if it limits practical use:

```mesh
struct Countdown do
  value :: Int
  unused :: Int
end

impl Iterator for Countdown do
  type Item = Int
  fn next(self) -> Option<Int> do
    if self.value <= 0 do
      None
    else
      Some(self.value)
    end
  end
end
```

This will produce an infinite loop (self.value never changes). So pure user-defined iterators without mutation don't work for multi-element iteration.

**REVISED APPROACH:** For Phase 76, focus on:
1. The compiler pipeline (ForInIterator MIR/codegen) working correctly
2. User-defined Iterable types that delegate to runtime handles
3. Test via Iterable that returns a built-in iterator handle

The E2E test should verify the Iterable path works: user defines Iterable for their type, which produces a runtime iterator handle (e.g., a ListIterator). The runtime handle mutation is handled by C code.

**REVISED E2E TEST (iterator_basic.mpl):**
Test that a user type implementing Iterator with a SINGLE element works (proves the pipeline without needing mutation):

```mesh
struct Once do
  value :: Int
  done :: Int
end

impl Iterator for Once do
  type Item = Int
  fn next(self) -> Option<Int> do
    if self.done == 1 do
      None
    else
      Some(self.value)
    end
  end
end

fn main() do
  let it = Once { value: 42, done: 0 }
  # Manual next() call test
  ...
end
```

Wait -- this still won't terminate because `done` is never set to 1.

**FINAL APPROACH:** Skip user-defined Iterator for the E2E test in this plan. Focus on user-defined Iterable that delegates to built-in runtime iterators. The key requirement (ITER-03) is "iterate over any Iterable type with for-in" -- the Iterable path is what matters for for-in desugaring.

**E2E TEST 1 (iterator_iterable.mpl):** User-defined Iterable wrapping a List:
This requires the Iterable's `iter()` method to call `mesh_list_iter_new` and return the handle, and the Iterator impl for ListIterator to call `mesh_list_iter_next`. These are provided by the built-in impls registered in Plan 01.

But the user's Iterable impl needs to call the built-in runtime function to create the iterator. The lowerer should resolve `Iterable__iter__MyList` to the user's impl method, which internally returns a ListIterator.

Actually this is getting circular. Let me simplify:

**PRACTICAL E2E APPROACH:**
1. **iterator_basic.mpl**: Test that the basic ForInIterator codegen works with a trivial case. Use a user type that wraps a list and implements Iterable by returning the list's built-in iterator. The Iterable.iter() method just returns the inner list passed through Iter.from() or similar.

2. **iterator_iterable.mpl**: Test the full Iterable+Iterator pair where the Iterator uses a runtime-handle pattern.

Given the complexity around mutable state in user-defined iterators, the PRAGMATIC path for Phase 76 E2E tests is:

- Test that the ForInIterator pipeline compiles and runs for a type with a built-in iterator backing
- Test Iter.from() creating iterators from built-in collections
- Defer complex user-defined mutable iterators to a future enhancement (or solve via runtime handles in the next plan)

Adjust the E2E tests to what actually works end-to-end given the current language constraints. If mutation through self is possible (check Phase 75 -- self.field ACCESS works, but does self.field MUTATION work?), then a full user iterator test is feasible.

**4. E2E Test harness (crates/meshc/tests/e2e.rs):**

Add test entries for the E2E test files:

```rust
#[test]
fn e2e_iterator_basic() {
    assert_run_output("tests/e2e/iterator_basic.mpl", "[0, 10, 20]\n");
}

#[test]
fn e2e_iterator_iterable() {
    assert_run_output("tests/e2e/iterator_iterable.mpl", "1\n2\n3\n");
}
```

Adjust expected outputs based on what the actual test programs print.

**5. Regression verification:**
After all changes, run the full E2E test suite to verify zero regressions on existing for-in tests (ITER-05).
  </action>
  <verify>
1. `cargo build --workspace 2>&1 | tail -5` -- full workspace compiles
2. `cargo test -p meshc e2e_iterator 2>&1` -- new iterator E2E tests pass
3. `cargo test --workspace 2>&1 | tail -20` -- ALL tests pass, zero regressions
4. `cargo test -p meshc e2e_for_in 2>&1` -- existing for-in tests still pass
  </verify>
  <done>
codegen_for_in_iterator generates LLVM IR for iterator-based for-in loops with next() + Option tag check. E2E tests prove user-defined Iterator/Iterable types work through for-in. Iter.from() entry point works. All existing for-in tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace 2>&1 | tail -5` -- full workspace compiles
2. `cargo test --workspace 2>&1 | tail -20` -- all tests pass
3. E2E iterator tests pass: `cargo test -p meshc e2e_iterator`
4. Existing for-in tests pass: `cargo test -p meshc e2e_for_in`
5. ForInIterator MIR node present: grep ForInIterator in mir/mod.rs
6. Codegen function present: grep codegen_for_in_iterator in codegen/expr.rs
</verification>

<success_criteria>
- ForInIterator MIR node defined with all fields (var, iterator, filter, body, elem_ty, body_ty, next_fn, iter_fn, ty)
- lower_for_in_iterator generates ForInIterator for Iterable/Iterator types after existing collection checks
- collect_function_refs handles ForInIterator (marks next_fn and iter_fn as reachable)
- codegen_for_in_iterator generates: iter() call + next() loop + Option tag check (0=Some, 1=None) + element extraction + list builder
- E2E tests pass for user-defined Iterator and/or Iterable types
- Iter.from() creates an iterator from a collection
- ALL existing for-in tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/76-iterator-protocol/76-02-SUMMARY.md`
</output>
