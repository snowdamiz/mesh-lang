---
phase: 76-iterator-protocol
plan: 02
type: execute
wave: 2
depends_on: ["76-01"]
files_modified:
  - crates/mesh-codegen/src/mir/mod.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/mir/mono.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - tests/e2e/iterator_iterable.mpl
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "User can define a custom Iterable type whose iter() returns a built-in runtime iterator handle, and iterate over it with for-in"
    - "for-in over user-defined Iterable desugars through iter() + next() calls with Option tag checking"
    - "Comprehension semantics work: for-in over custom Iterable returns List<body_ty>"
    - "All existing for-in loops over List, Map, Set, Range produce identical results (zero regressions)"
    - "Iter.from(list) creates an iterator from a List collection via runtime function"
  artifacts:
    - path: "crates/mesh-codegen/src/mir/mod.rs"
      provides: "ForInIterator MIR node definition"
      contains: "ForInIterator"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "lower_for_in_iterator function and Iterable/Iterator check in lower_for_in_expr"
      contains: "lower_for_in_iterator"
    - path: "crates/mesh-codegen/src/mir/mono.rs"
      provides: "ForInIterator arm in collect_function_refs"
      contains: "ForInIterator"
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "codegen_for_in_iterator function generating LLVM IR for iterator loop"
      contains: "codegen_for_in_iterator"
    - path: "tests/e2e/iterator_iterable.mpl"
      provides: "E2E test: user-defined Iterable with built-in runtime iterator backing"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "Test harness entries for iterator E2E tests"
      contains: "iterator_iterable"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "trait_registry.has_impl for Iterable/Iterator check in lower_for_in_expr"
      pattern: "has_impl.*Iterable"
    - from: "crates/mesh-codegen/src/codegen/expr.rs"
      to: "crates/mesh-rt/src/option.rs"
      via: "Option tag check (tag 0 = Some, tag 1 = None) in codegen_for_in_iterator"
      pattern: "const_int.*0.*some"
    - from: "crates/mesh-codegen/src/mir/mono.rs"
      to: "crates/mesh-codegen/src/mir/mod.rs"
      via: "ForInIterator arm traversing sub-expressions and collecting next_fn"
      pattern: "ForInIterator"
---

<objective>
Add the ForInIterator MIR node, MIR lowering, monomorphization support, and LLVM codegen for iterator-based for-in loops. Add Iter.from() entry point as a runtime function. Verify with an E2E test proving user-defined Iterable types work end-to-end with built-in runtime iterator handles.

Purpose: Complete the compiler pipeline for iterator-based for-in, enabling user-defined types to participate in for-in loops through the Iterable/Iterator protocol.
Output: Working end-to-end iterator-based for-in for user Iterable types backed by runtime handles, Iter.from() function, E2E test coverage.

**Known Limitation (ITER-01):** Mesh structs are LLVM value types (not GC-allocated pointers). `self` in impl methods is passed by value, so user-defined Iterator `next(self)` cannot mutate struct fields to advance state. Multi-element user-defined iterators require a mutation mechanism (mutable references or runtime handle wrapping) which is deferred to Phase 77+. Phase 76 tests user-defined Iterable types whose `iter()` method returns a runtime iterator handle (opaque Ptr) -- the runtime C code handles mutation internally, exactly like built-in collection iterators.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/76-iterator-protocol/76-RESEARCH.md
@.planning/phases/76-iterator-protocol/76-01-SUMMARY.md
@crates/mesh-codegen/src/mir/mod.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/mir/mono.rs
@crates/mesh-codegen/src/codegen/expr.rs
@crates/mesh-codegen/src/codegen/intrinsics.rs
@crates/mesh-rt/src/option.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ForInIterator MIR node + lowering + mono support</name>
  <files>crates/mesh-codegen/src/mir/mod.rs, crates/mesh-codegen/src/mir/lower.rs, crates/mesh-codegen/src/mir/mono.rs</files>
  <action>
**1. MIR Node (crates/mesh-codegen/src/mir/mod.rs):**

Add `ForInIterator` variant to the `MirExpr` enum, after `ForInSet`:

```rust
/// For-in loop over any type implementing Iterable/Iterator.
/// Desugared to repeated next() calls with Option tag checking.
ForInIterator {
    /// Loop variable name.
    var: String,
    /// The iterator expression (result of calling iter() on the collection,
    /// or the collection itself if it directly implements Iterator).
    iterator: Box<MirExpr>,
    /// Optional filter expression (`when condition`).
    filter: Option<Box<MirExpr>>,
    /// Loop body.
    body: Box<MirExpr>,
    /// Resolved element type (Item type for the concrete iterator type).
    elem_ty: MirType,
    /// Type of body expression (for list builder element conversion).
    body_ty: MirType,
    /// Mangled name for the next() function: "Iterator__next__TypeName".
    next_fn: String,
    /// Mangled name for the iter() function (if Iterable): "Iterable__iter__TypeName".
    /// Empty string if the type directly implements Iterator (no iter() call needed).
    iter_fn: String,
    /// Result type (Ptr for comprehension semantics -- list of body results).
    ty: MirType,
},
```

Add the `ForInIterator` arm to the `MirExpr::ty()` match:
```rust
MirExpr::ForInIterator { ty, .. } => ty,
```

**2. MIR Lowering (crates/mesh-codegen/src/mir/lower.rs):**

In `lower_for_in_expr` (line ~5999), add Iterable/Iterator checks INSIDE the existing `if let Some(ref ty) = iterable_ty` block, after the three existing extract checks (extract_map_types, extract_set_elem_type, extract_list_elem_type) at line ~6022, but BEFORE the closing `}` of that block:

```rust
        // After the existing extract_list_elem_type check (line ~6022):

        // Check if type implements Iterable (collection -> produces iterator).
        let ty_for_lookup = ty.clone();
        if self.trait_registry.has_impl("Iterable", &ty_for_lookup) {
            return self.lower_for_in_iterator(for_in, &ty_for_lookup, true);
        }
        // Check if type directly implements Iterator (type IS an iterator).
        if self.trait_registry.has_impl("Iterator", &ty_for_lookup) {
            return self.lower_for_in_iterator(for_in, &ty_for_lookup, false);
        }
```

The existing fallback `self.lower_for_in_list(for_in, &Ty::int())` stays as the final catch-all AFTER the if-let block.

Add the `lower_for_in_iterator` method. Use the helper functions from `crates/mesh-codegen/src/mir/types.rs` that are already imported: `mangle_type_name` for type name mangling (takes base name + type args + registry), and `resolve_type` for Ty -> MirType conversion. For simple `Ty::Con("MyType")` types, `mangle_type_name` is not needed -- just extract the type name string directly. Use the same approach as `resolve_trait_callee` (line ~5300) which calls `mir_type_to_impl_name` for the `Trait__Method__Type` pattern:

```rust
fn lower_for_in_iterator(&mut self, for_in: &ForInExpr, ty: &Ty, is_iterable: bool) -> MirExpr {
    let var_name = for_in
        .binding_name()
        .and_then(|n| n.text())
        .unwrap_or_else(|| "_".to_string());

    // Resolve the MIR type to get the impl name for mangling.
    let mir_ty = resolve_type(ty, self.registry, false);
    let type_name = mir_type_to_impl_name(&mir_ty);

    // Determine iter_fn and next_fn names, and the element type.
    let (iter_fn, next_fn, elem_ty) = if is_iterable {
        // Iterable path: call iter() to get iterator, then next() on iterator.
        let iter_fn_name = format!("Iterable__iter__{}", type_name);

        // Resolve Iter type from Iterable impl to get the iterator type name.
        let iter_type = self.trait_registry
            .resolve_associated_type("Iterable", "Iter", ty)
            .unwrap_or_else(|| Ty::Con(TyCon::new("Unknown")));
        let iter_mir_ty = resolve_type(&iter_type, self.registry, false);
        let iter_type_name = mir_type_to_impl_name(&iter_mir_ty);
        let next_fn_name = format!("Iterator__next__{}", iter_type_name);

        // Resolve Item type from Iterable impl.
        let item_ty = self.trait_registry
            .resolve_associated_type("Iterable", "Item", ty)
            .unwrap_or(Ty::int());

        (iter_fn_name, next_fn_name, item_ty)
    } else {
        // Direct Iterator path: no iter() call, just next().
        let next_fn_name = format!("Iterator__next__{}", type_name);
        let item_ty = self.trait_registry
            .resolve_associated_type("Iterator", "Item", ty)
            .unwrap_or(Ty::int());

        (String::new(), next_fn_name, item_ty)
    };

    // Lower the iterable/iterator expression.
    let collection = for_in
        .iterable()
        .map(|e| self.lower_expr(&e))
        .unwrap_or(MirExpr::Unit);

    let elem_mir_ty = resolve_type(&elem_ty, self.registry, false);

    self.push_scope();
    self.insert_var(var_name.clone(), elem_mir_ty.clone());
    let filter = for_in
        .filter()
        .map(|f| Box::new(self.lower_expr(&f)));
    let body = for_in
        .body()
        .map(|b| self.lower_block(&b))
        .unwrap_or(MirExpr::Unit);
    let body_ty = body.ty().clone();
    self.pop_scope();

    MirExpr::ForInIterator {
        var: var_name,
        iterator: Box::new(collection),
        filter,
        body: Box::new(body),
        elem_ty: elem_mir_ty,
        body_ty,
        next_fn,
        iter_fn,
        ty: MirType::Ptr,
    }
}
```

**IMPORTANT:** The `mir_type_to_impl_name` function is imported from `super::types` (see line 26: `use super::types::{mangle_type_name, mir_type_to_impl_name, mir_type_to_ty, resolve_type};`). It converts `MirType::Struct("Counter")` to `"Counter"`, `MirType::Ptr` to `"Ptr"`, etc. For built-in iterator handle types like `ListIterator` (which resolve to `MirType::Ptr` since they are opaque handles), this will yield `"Ptr"` -- not the right name. To handle this, when `is_iterable=true`, extract the iterator type name DIRECTLY from the resolved `Ty::Con(TyCon)` rather than going through MIR type resolution:

```rust
// Instead of:
let iter_mir_ty = resolve_type(&iter_type, self.registry, false);
let iter_type_name = mir_type_to_impl_name(&iter_mir_ty);

// Use:
let iter_type_name = match &iter_type {
    Ty::Con(tc) => tc.name().to_string(),
    Ty::App(base, _) => {
        if let Ty::Con(tc) = base.as_ref() {
            tc.name().to_string()
        } else {
            "Unknown".to_string()
        }
    }
    _ => "Unknown".to_string(),
};
```

This preserves the full type name "ListIterator" for mangling into `Iterator__next__ListIterator`.

**3. Monomorphization (crates/mesh-codegen/src/mir/mono.rs):**

Add a `ForInIterator` arm in `collect_function_refs` (after the `ForInSet` arm around line 255):

```rust
MirExpr::ForInIterator { iterator, filter, body, next_fn, iter_fn, .. } => {
    collect_function_refs(iterator, refs);
    if let Some(f) = filter {
        collect_function_refs(f, refs);
    }
    collect_function_refs(body, refs);
    // Mark the next() function as reachable.
    refs.insert(next_fn.clone());
    // Mark the iter() function as reachable (if Iterable path).
    if !iter_fn.is_empty() {
        refs.insert(iter_fn.clone());
    }
}
```

**CRITICAL:** Without this mono.rs arm, the `next_fn` and `iter_fn` functions would be pruned as unreachable, causing linker errors.
  </action>
  <verify>
Run `cargo build -p mesh-codegen 2>&1 | head -20` -- must compile. Run `cargo test -p mesh-codegen 2>&1 | tail -10` -- mono tests pass.
  </verify>
  <done>
ForInIterator MIR node added with all fields. lower_for_in_iterator generates ForInIterator for Iterable/Iterator types. collect_function_refs traverses ForInIterator sub-expressions and collects next_fn/iter_fn. mesh-codegen compiles and tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add codegen_for_in_iterator</name>
  <files>crates/mesh-codegen/src/codegen/expr.rs</files>
  <action>
**1. Codegen dispatch (crates/mesh-codegen/src/codegen/expr.rs):**

Add a match arm for ForInIterator in `codegen_expr` (after the ForInSet arm around line 160):

```rust
MirExpr::ForInIterator { var, iterator, filter, body, elem_ty, body_ty, next_fn, iter_fn, ty } => {
    self.codegen_for_in_iterator(var, iterator, filter.as_deref(), body, elem_ty, body_ty, next_fn, iter_fn, ty)
}
```

**2. Codegen implementation (crates/mesh-codegen/src/codegen/expr.rs):**

Add `codegen_for_in_iterator` method. Follow the `codegen_for_in_list` pattern (lines 3544-3707) closely but replace the counter-based loop with a next()-based loop.

**CRITICAL FUNCTION LOOKUP NOTE:** For the `iter_fn` and `next_fn` calls, these are either:
- Runtime C functions (e.g., `mesh_list_iter_new`, `mesh_list_iter_next`) for built-in iterator handles, OR
- User-compiled MIR functions (e.g., `Iterable__iter__MyType`, `Iterator__next__MyIterType`) for user types.

Use `self.module.get_function(name)` first (finds user-compiled functions). If not found, fall back to `get_intrinsic(&self.module, name)` (finds runtime C functions declared in intrinsics). This is the same two-phase lookup used in `codegen_call` (line ~875).

```rust
fn codegen_for_in_iterator(
    &mut self,
    var: &str,
    iterator_expr: &MirExpr,
    filter: Option<&MirExpr>,
    body_expr: &MirExpr,
    elem_ty: &MirType,
    body_ty: &MirType,
    next_fn: &str,
    iter_fn: &str,
    _ty: &MirType,
) -> Result<BasicValueEnum<'ctx>, String> {
    let fn_val = self.current_function();
    let i64_ty = self.context.i64_type();
    let i8_ty = self.context.i8_type();
    let ptr_ty = self.context.ptr_type(inkwell::AddressSpace::default());

    // Step 1: Codegen the collection/iterator expression.
    let collection_val = self.codegen_expr(iterator_expr)?;

    // Step 2: If iter_fn is non-empty, call iter() to get the iterator.
    let iter_val = if !iter_fn.is_empty() {
        let iter_func = self.module.get_function(iter_fn)
            .unwrap_or_else(|| get_intrinsic(&self.module, iter_fn));
        let result = self.builder.build_call(iter_func, &[collection_val.into()], "iter")
            .map_err(|e| e.to_string())?
            .try_as_basic_value()
            .left()
            .ok_or_else(|| format!("{} returned void", iter_fn))?;
        result.into_pointer_value()
    } else {
        // Direct Iterator: the expression IS the iterator.
        collection_val.into_pointer_value()
    };

    // Step 3: Store iterator in alloca.
    let iter_alloca = self.builder.build_alloca(ptr_ty, "iter_alloca")
        .map_err(|e| e.to_string())?;
    self.builder.build_store(iter_alloca, iter_val)
        .map_err(|e| e.to_string())?;

    // Step 4: Pre-allocate result list builder (comprehension semantics).
    let list_builder_new = get_intrinsic(&self.module, "mesh_list_builder_new");
    let result_list = self.builder.build_call(list_builder_new, &[i64_ty.const_int(0, false).into()], "result_list")
        .map_err(|e| e.to_string())?
        .try_as_basic_value()
        .left()
        .ok_or_else(|| "mesh_list_builder_new returned void".to_string())?
        .into_pointer_value();

    let result_alloca = self.builder.build_alloca(ptr_ty, "result_alloca")
        .map_err(|e| e.to_string())?;
    self.builder.build_store(result_alloca, result_list)
        .map_err(|e| e.to_string())?;

    // Step 5: Create basic blocks.
    let header_bb = self.context.append_basic_block(fn_val, "iter_header");
    let body_bb = self.context.append_basic_block(fn_val, "iter_body");
    let latch_bb = self.context.append_basic_block(fn_val, "iter_latch");
    let merge_bb = self.context.append_basic_block(fn_val, "iter_merge");

    // Push loop context for break/continue.
    self.loop_stack.push((latch_bb, merge_bb));

    self.builder.build_unconditional_branch(header_bb)
        .map_err(|e| e.to_string())?;

    // Step 6: Header -- call next(), check Option tag.
    self.builder.position_at_end(header_bb);
    let iter_loaded = self.builder.build_load(ptr_ty, iter_alloca, "iter_loaded")
        .map_err(|e| e.to_string())?
        .into_pointer_value();

    // Call Iterator__next__TypeName(iter) or mesh_*_iter_next(iter).
    let next_func = self.module.get_function(next_fn)
        .unwrap_or_else(|| get_intrinsic(&self.module, next_fn));
    let next_result = self.builder.build_call(next_func, &[iter_loaded.into()], "next_result")
        .map_err(|e| e.to_string())?
        .try_as_basic_value()
        .left()
        .ok_or_else(|| format!("{} returned void", next_fn))?
        .into_pointer_value();

    // Option is MeshOption { tag: u8, value: *mut u8 }.
    // tag 0 = Some, tag 1 = None.
    // GEP to tag field (index 0).
    let mesh_option_ty = self.context.struct_type(
        &[i8_ty.into(), ptr_ty.into()],
        false,
    );
    let tag_ptr = self.builder.build_struct_gep(mesh_option_ty, next_result, 0, "tag_ptr")
        .map_err(|e| e.to_string())?;
    let tag_val = self.builder.build_load(i8_ty, tag_ptr, "tag")
        .map_err(|e| e.to_string())?
        .into_int_value();

    // Compare tag == 0 (Some).
    let is_some = self.builder.build_int_compare(
        IntPredicate::EQ, tag_val, i8_ty.const_int(0, false), "is_some",
    ).map_err(|e| e.to_string())?;

    self.builder.build_conditional_branch(is_some, body_bb, merge_bb)
        .map_err(|e| e.to_string())?;

    // Step 7: Body -- extract element, bind variable, run body, push result.
    self.builder.position_at_end(body_bb);

    // GEP to value field (index 1).
    let value_ptr = self.builder.build_struct_gep(mesh_option_ty, next_result, 1, "value_ptr")
        .map_err(|e| e.to_string())?;
    let raw_value = self.builder.build_load(ptr_ty, value_ptr, "raw_value")
        .map_err(|e| e.to_string())?;

    // Convert from raw pointer to typed element.
    // For Int: ptr -> i64 via ptrtoint. For String/Ptr types: ptr -> ptr (no conversion).
    let typed_elem = match elem_ty {
        MirType::Int => {
            let as_int = self.builder.build_ptr_to_int(raw_value.into_pointer_value(), i64_ty, "as_int")
                .map_err(|e| e.to_string())?;
            as_int.into()
        }
        MirType::Float => {
            let as_int = self.builder.build_ptr_to_int(raw_value.into_pointer_value(), i64_ty, "as_int_f")
                .map_err(|e| e.to_string())?;
            self.builder.build_bit_cast(as_int, self.context.f64_type(), "as_float")
                .map_err(|e| e.to_string())?
        }
        MirType::Bool => {
            let as_int = self.builder.build_ptr_to_int(raw_value.into_pointer_value(), i64_ty, "as_int_b")
                .map_err(|e| e.to_string())?;
            self.builder.build_int_truncate(as_int, self.context.bool_type(), "as_bool")
                .map_err(|e| e.to_string())?
                .into()
        }
        _ => {
            // Ptr types (String, structs, collections): already a pointer.
            raw_value
        }
    };

    // Create alloca for loop variable.
    let elem_llvm_ty = self.llvm_type(elem_ty);
    let var_alloca = self.builder.build_alloca(elem_llvm_ty, var)
        .map_err(|e| e.to_string())?;
    self.builder.build_store(var_alloca, typed_elem)
        .map_err(|e| e.to_string())?;

    // Save old locals.
    let old_alloca = self.locals.insert(var.to_string(), var_alloca);
    let old_type = self.local_types.insert(var.to_string(), elem_ty.clone());

    // Optional filter.
    if let Some(filter_expr) = filter {
        let filter_val = self.codegen_expr(filter_expr)?
            .into_int_value();
        let do_body_bb = self.context.append_basic_block(fn_val, "iter_do_body");
        self.builder.build_conditional_branch(filter_val, do_body_bb, latch_bb)
            .map_err(|e| e.to_string())?;
        self.builder.position_at_end(do_body_bb);
    }

    // Codegen body.
    let body_val = self.codegen_expr(body_expr)?;

    // Push body result to result list.
    if let Some(bb) = self.builder.get_insert_block() {
        if bb.get_terminator().is_none() {
            let body_as_i64 = self.convert_to_list_element(body_val, body_ty)?;
            let list_builder_push = get_intrinsic(&self.module, "mesh_list_builder_push");
            let result_loaded = self.builder.build_load(ptr_ty, result_alloca, "res_list")
                .map_err(|e| e.to_string())?
                .into_pointer_value();
            self.builder.build_call(list_builder_push, &[result_loaded.into(), body_as_i64.into()], "")
                .map_err(|e| e.to_string())?;
            self.builder.build_unconditional_branch(latch_bb)
                .map_err(|e| e.to_string())?;
        }
    }

    // Step 8: Latch -- reduction check, branch back to header.
    self.builder.position_at_end(latch_bb);
    self.emit_reduction_check();
    self.builder.build_unconditional_branch(header_bb)
        .map_err(|e| e.to_string())?;

    // Step 9: Cleanup.
    self.loop_stack.pop();

    if let Some(prev) = old_alloca {
        self.locals.insert(var.to_string(), prev);
    } else {
        self.locals.remove(var);
    }
    if let Some(prev) = old_type {
        self.local_types.insert(var.to_string(), prev);
    } else {
        self.local_types.remove(var);
    }

    // Return result list.
    self.builder.position_at_end(merge_bb);
    let final_result = self.builder.build_load(ptr_ty, result_alloca, "iter_result")
        .map_err(|e| e.to_string())?;
    Ok(final_result)
}
```
  </action>
  <verify>
Run `cargo build -p mesh-codegen 2>&1 | head -20` -- must compile with the new codegen function.
  </verify>
  <done>
codegen_for_in_iterator generates LLVM IR for iterator-based for-in loops: iter() call (if Iterable) + next() loop + Option tag check (0=Some, 1=None) + element extraction + list builder + reduction check. Two-phase function lookup (user MIR first, then runtime intrinsics).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Iter.from() runtime function + stdlib wiring</name>
  <files>crates/mesh-codegen/src/mir/lower.rs, crates/mesh-codegen/src/codegen/intrinsics.rs, crates/mesh-rt/src/collections/list.rs</files>
  <action>
**Implementation approach:** `Iter.from()` is a stdlib module function (like `String.length()`, `Map.new()`). It takes a collection and returns an iterator handle. For Phase 76, it supports List collections only (the most common case). Map/Set/Range support can be added incrementally.

**1. Add "Iter" to STDLIB_MODULES (crates/mesh-codegen/src/mir/lower.rs, line ~9314):**

Add `"Iter"` to the `STDLIB_MODULES` array:
```rust
const STDLIB_MODULES: &[&str] = &[
    "String", "IO", "Env", "File", "List", "Map", "Set", "Tuple", "Range", "Queue", "HTTP", "JSON", "Json", "Request", "Job",
    "Math", "Int", "Float", "Timer", "Sqlite", "Pg", "Ws",
    "Node", "Process",
    "Global",
    "Iter",  // Phase 76
];
```

**2. Add `iter_from` -> `mesh_iter_from` mapping in `map_builtin_name` (crates/mesh-codegen/src/mir/lower.rs, line ~9326):**

Add the mapping inside `map_builtin_name`:
```rust
"iter_from" => "mesh_iter_from".to_string(),
```

This makes `Iter.from(list)` resolve through the standard path:
- Parser sees `Iter.from(list)` -> FieldAccess(NameRef("Iter"), "from") + Call
- `lower_field_access` detects "Iter" in STDLIB_MODULES -> converts to `iter_from` -> `map_builtin_name` -> `mesh_iter_from`
- Codegen emits `call mesh_iter_from(list_ptr)`

**3. Add `mesh_iter_from` runtime function (crates/mesh-rt/src/collections/list.rs):**

```rust
/// Iter.from(collection) -- creates an iterator handle from a List.
/// For Phase 76, this is equivalent to mesh_list_iter_new.
/// Future phases can add type-tag dispatch for Map/Set/Range.
#[no_mangle]
pub extern "C" fn mesh_iter_from(collection: *mut u8) -> *mut u8 {
    // Delegate to list iterator creation.
    // This works because all collections are opaque Ptrs at the MIR level,
    // and the most common Iter.from() use case is with Lists.
    mesh_list_iter_new(collection)
}
```

**4. Declare `mesh_iter_from` in intrinsics (crates/mesh-codegen/src/codegen/intrinsics.rs):**

Find where `mesh_list_iter_new` is declared (it should be in Plan 01's intrinsics additions) and add `mesh_iter_from` with the same signature: `fn(ptr) -> ptr`.

```rust
// Iter.from() entry point
declare_intrinsic!(module, "mesh_iter_from", ptr_type, &[ptr_type.into()]);
```

Use the same pattern as other intrinsic declarations in the file.
  </action>
  <verify>
Run `cargo build --workspace 2>&1 | tail -5` -- full workspace compiles. Verify `mesh_iter_from` is declared by grepping intrinsics.rs.
  </verify>
  <done>
`Iter.from(list)` resolves through the stdlib module path: "Iter" in STDLIB_MODULES, `iter_from` maps to `mesh_iter_from` runtime function, which delegates to `mesh_list_iter_new`. Intrinsic declared for codegen.
  </done>
</task>

<task type="auto">
  <name>Task 4: E2E tests + regression verification</name>
  <files>tests/e2e/iterator_iterable.mpl, crates/meshc/tests/e2e.rs</files>
  <action>
**Design rationale:** User-defined multi-element iterators require mutable `self`, which Mesh structs do not support (structs are LLVM value types, `self` is passed by value). Phase 76 tests the ForInIterator pipeline through user-defined Iterable types that delegate to built-in runtime iterator handles. The runtime handles (ListIterator, etc.) maintain mutable state internally via C code -- the same pattern used by all built-in collections.

**1. E2E Test: User-defined Iterable wrapping List (tests/e2e/iterator_iterable.mpl):**

This test verifies:
- User defines `impl Iterable for MyCollection` with `type Item = Int`, `type Iter = ListIterator`
- The `iter()` method returns the inner list's iterator handle via `Iter.from(self.items)`
- `for x in my_collection do ... end` desugars through ForInIterator codegen
- Comprehension semantics: the for-in returns a list of body results
- The built-in `Iterator__next__ListIterator` (which maps to `mesh_list_iter_next`) handles state advancement

```mesh
# Phase 76: User-defined Iterable with built-in runtime iterator

struct EvenNumbers do
  items :: List<Int>
end

impl Iterable for EvenNumbers do
  type Item = Int
  type Iter = ListIterator
  fn iter(self) -> ListIterator do
    Iter.from(self.items)
  end
end

fn make_evens() -> EvenNumbers do
  EvenNumbers { items: [2, 4, 6, 8, 10] }
end

fn main() do
  let evens = make_evens()

  # Test 1: for-in over user-defined Iterable
  let doubled = for x in evens do
    x * 2
  end
  # doubled should be [4, 8, 12, 16, 20]
  println(doubled.to_string())

  # Test 2: simple iteration with side effects
  for x in evens do
    println(x.to_string())
  end
end
```

Expected output:
```
[4, 8, 12, 16, 20]
2
4
6
8
10
```

**IMPORTANT:** This test requires that:
- Plan 01 registered `Iterable` impl for `EvenNumbers` -- wait, no. The `impl Iterable for EvenNumbers` is USER-DEFINED, written in the test file. The compiler must compile the user's `impl Iterable for EvenNumbers` block, which creates a function `Iterable__iter__EvenNumbers`.
- The `type Iter = ListIterator` associated type tells the lowerer that `Iterator__next__ListIterator` is the next function. Plan 01 registered `impl Iterator for ListIterator` with the built-in runtime handle, so `Iterator__next__ListIterator` should map to `mesh_list_iter_next`.
- The `Iter.from(self.items)` call in the iter() body calls `mesh_iter_from(self.items)` which returns a ListIterator handle.

**If `Iterable__iter__EvenNumbers` does not get wired correctly:** The iter() method body uses `Iter.from(self.items)`. Inside the method, `self` is the EvenNumbers struct, and `self.items` is the List<Int> field. The method returns the result of `Iter.from()` which is a `*mut u8` (Ptr). The method's MIR return type should be MirType::Ptr.

**If `Iterator__next__ListIterator` needs runtime backing:** Plan 01 should have registered this as mapping to `mesh_list_iter_next`. If the mangled function is not found as a user function, the codegen's two-phase lookup will find it as a runtime intrinsic. Verify that Plan 01 declares `mesh_list_iter_next` in intrinsics.

**FALLBACK:** If the full Iterable pipeline does not work end-to-end due to compilation issues with user impl Iterable blocks, simplify the test to verify `Iter.from()` alone:

```mesh
fn main() do
  let list = [1, 2, 3]
  let iter = Iter.from(list)
  println("ok")
end
```

Then iterate on the full test. But the goal is the complete Iterable test.

**2. Test harness entry (crates/meshc/tests/e2e.rs):**

Add at the end of the test file, near other E2E tests:

```rust
#[test]
fn e2e_iterator_iterable() {
    assert_run_output("tests/e2e/iterator_iterable.mpl", "[4, 8, 12, 16, 20]\n2\n4\n6\n8\n10\n");
}
```

**3. Regression verification:**

After all changes, run the full E2E test suite to verify zero regressions on existing for-in tests (ITER-05). Run:
- `cargo test -p meshc e2e_for_in 2>&1` -- existing for-in tests
- `cargo test --workspace 2>&1 | tail -20` -- full workspace
  </action>
  <verify>
1. `cargo test -p meshc e2e_iterator_iterable 2>&1` -- new E2E test passes
2. `cargo test -p meshc e2e_for_in 2>&1` -- existing for-in tests still pass
3. `cargo test --workspace 2>&1 | tail -20` -- ALL tests pass, zero regressions
  </verify>
  <done>
E2E test proves user-defined Iterable type works through for-in with built-in runtime iterator handle. Comprehension semantics preserved (for-in returns list). All existing for-in tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace 2>&1 | tail -5` -- full workspace compiles
2. `cargo test --workspace 2>&1 | tail -20` -- all tests pass
3. E2E iterator test passes: `cargo test -p meshc e2e_iterator_iterable`
4. Existing for-in tests pass: `cargo test -p meshc e2e_for_in`
5. ForInIterator MIR node present: grep ForInIterator in mir/mod.rs
6. Codegen function present: grep codegen_for_in_iterator in codegen/expr.rs
7. Iter.from wired: grep mesh_iter_from in intrinsics.rs
</verification>

<success_criteria>
- ForInIterator MIR node defined with all fields (var, iterator, filter, body, elem_ty, body_ty, next_fn, iter_fn, ty)
- lower_for_in_iterator generates ForInIterator for Iterable/Iterator types after existing collection checks
- collect_function_refs handles ForInIterator (marks next_fn and iter_fn as reachable)
- codegen_for_in_iterator generates: iter() call + next() loop + Option tag check (0=Some, 1=None) + element extraction + list builder
- Iter.from(list) works via stdlib module path: "Iter" in STDLIB_MODULES -> mesh_iter_from runtime function
- E2E test passes for user-defined Iterable type backed by runtime iterator handle
- ALL existing for-in tests pass with zero regressions
- DOCUMENTED LIMITATION: User-defined Iterator with mutable self deferred to Phase 77+ (structs are value types)
</success_criteria>

<output>
After completion, create `.planning/phases/76-iterator-protocol/76-02-SUMMARY.md`
</output>
