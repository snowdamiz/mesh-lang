---
phase: 77-from-into-conversion
plan: 02
type: execute
wave: 2
depends_on: ["77-01"]
files_modified:
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - crates/mesh-typeck/src/infer.rs
  - tests/e2e/from_into.rs
autonomous: true

must_haves:
  truths:
    - "User-defined impl From<Celsius> for Fahrenheit compiles and Fahrenheit.from(c) works at runtime"
    - "Float.from(42) produces 42.0 at runtime"
    - "String.from(42) produces '42' at runtime"
    - "String.from(3.14) produces '3.14' at runtime"
    - "String.from(true) produces 'true' at runtime"
    - "The ? operator auto-converts error types when From<ExprErr> for FnErr exists"
    - "The ? operator continues to work unchanged when error types already match"
    - "Mangled names include trait type args to avoid collisions (From_Int__from__String vs From_Float__from__String)"
  artifacts:
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Extended mangling with trait type args, From dispatch mapping, ? operator From conversion in lower_try_result"
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "From dispatch to existing runtime/intrinsic functions"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Extended infer_try_expr with From fallback for mismatched error types"
    - path: "tests/e2e/from_into.rs"
      provides: "E2E tests covering user-defined From, built-in conversions, and ? error conversion"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/expr.rs"
      via: "Mangled From names (From_Int__from__Float) route to codegen intrinsics"
      pattern: "From_.*__from__"
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "infer_try_expr accepts From-convertible error types; lower_try_result inserts From.from() call"
      pattern: "has_impl_with_type_args.*From"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-rt/src/string.rs"
      via: "From_Int__from__String maps to mesh_int_to_string runtime function"
      pattern: "mesh_int_to_string"
---

<objective>
Wire up MIR lowering and codegen for From/Into conversions, extend the ? operator for From-based error type conversion, and add comprehensive E2E tests verifying all success criteria.

Purpose: Complete the From/Into feature end-to-end -- user-defined conversions compile and run, built-in conversions produce correct results, and ? auto-converts error types.
Output: Working From/Into conversions with E2E test coverage for all 4 success criteria.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-from-into-conversion/77-RESEARCH.md
@.planning/phases/77-from-into-conversion/77-01-SUMMARY.md
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/codegen/expr.rs
@crates/mesh-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MIR lowering and codegen for From conversions</name>
  <files>crates/mesh-codegen/src/mir/lower.rs, crates/mesh-codegen/src/codegen/expr.rs</files>
  <action>
**In lower.rs:**

1. **Extend `extract_impl_names`** (line 92-122): After extracting `trait_name` from the first PATH, also extract a GENERIC_ARG_LIST from the IMPL_DEF's children. Collect IDENT tokens from it as `trait_type_args: Vec<String>`. Return `(trait_name, trait_type_args, type_name)` instead of `(trait_name, type_name)`.

2. **Extend `lower_item` for ImplDef** (line 811-845): Update the mangling format. When `trait_type_args` is non-empty, mangle as `Trait_TypeArg__method__ImplType` (e.g., `From_Int__from__Float`). When empty, keep existing `Trait__method__Type` format. Update the destructure at line 812 to handle the new return type.

3. **Add From dispatch entries to `resolve_trait_callee`** (line 5316-5331): Add mappings for built-in From conversions after the existing Display/Debug/Hash section:
   ```
   "From_Int__from__Float" => "mesh_int_to_float"
   "From_Int__from__String" => "mesh_int_to_string"
   "From_Float__from__String" => "mesh_float_to_string"
   "From_Bool__from__String" => "mesh_bool_to_string"
   ```

4. **Add `map_builtin_name` entries** for the stdlib module path (where Float.from(42) arrives as `float_from`):
   ```
   "float_from" => "mesh_int_to_float"
   "string_from" => "mesh_int_to_string"   // default; codegen handles dispatch by arg type
   ```
   Wait -- `string_from` can't map to a single function since String.from accepts Int/Float/Bool. Instead, handle this in `lower_field_access` or the call lowering path: when the callee resolves to `string_from`, inspect the first argument's MIR type and dispatch accordingly:
   - MirType::Int -> mesh_int_to_string
   - MirType::Float -> mesh_float_to_string
   - MirType::Bool -> mesh_bool_to_string

   **Better approach:** In `map_builtin_name`, map `"float_from"` to `"mesh_int_to_float"` (Float.from always takes Int). For `"string_from"`, add a special case in the call lowering that checks the argument type. Actually, the simplest approach that fits existing patterns: In `lower_field_access` or `lower_call_expr`, when we detect a `string_from` callee after STDLIB_MODULES lowering, rewrite it based on the first argument type. Look at how existing polymorphic builtins are handled.

   **Simplest correct approach:** Add `"float_from" => "mesh_int_to_float"` to map_builtin_name. For string_from, add `"string_from" => "mesh_string_from"` to map_builtin_name, then in the codegen dispatch (expr.rs), intercept `mesh_string_from` and dispatch based on argument type to the correct runtime function. This follows the pattern used for other polymorphic builtins.

   Actually, even simpler: The codegen in expr.rs already has logic for `mesh_int_to_float` as a codegen intrinsic (line 790-804 -- uses sitofp). For `mesh_int_to_string`, `mesh_float_to_string`, `mesh_bool_to_string`, these are already declared runtime functions. So we just need the MIR to emit the correct function name.

   **Final approach for string_from:** In the call lowering, after `map_builtin_name("string_from")` resolves, check the argument MirType and rewrite:
   - Int arg -> `mesh_int_to_string`
   - Float arg -> `mesh_float_to_string`
   - Bool arg -> `mesh_bool_to_string`
   Add this as a post-mapping rewrite in `lower_call_expr` or create a helper `resolve_from_callee(callee_name, arg_type) -> resolved_name`.

5. **Extend `lower_try_result`** (line 8003-8060) for From-based error conversion: In the Err arm body, before constructing the return Err, check if the operand's error type differs from the function return type's error type. If they differ:
   - Look up the function return error type from `fn_ret_ty` (extract the SumType name, look up the Err variant's field type)
   - Construct a From call: `MirExpr::Call { func: From_ExprErrType__from__FnErrType, args: [err_value] }`
   - The mangled name follows the pattern: `From_{source_err_type}__from__{target_err_type}`
   - Use the converted error value in the ConstructVariant instead of the raw err_name

   To detect whether conversion is needed: compare `error_ty` (from operand) with the Err variant type of `fn_ret_ty`. If they're different MirTypes, insert the From call. If they're the same, keep existing behavior unchanged.

   For user-defined From impls (e.g., From<String> for AppError), the mangled function name is `From_String__from__AppError` which was compiled as a normal trait method in lower_item. So the call just uses that name.

6. **Add STDLIB_MODULES entries if needed:** The STDLIB_MODULES list at line 9408 already contains "Float", "String", "Int" -- no changes needed.

**In codegen/expr.rs:**

Add dispatch for `mesh_string_from` in the codegen intrinsic handling (or wherever string conversion is handled). If using the approach where MIR already emits the correct `mesh_int_to_string` / `mesh_float_to_string` / `mesh_bool_to_string` name, no changes to expr.rs are needed since those functions are already declared and handled.

If the MIR emits `mesh_int_to_float` for `Float.from(42)`, the existing codegen intrinsic at line 790 already handles it (sitofp). No new codegen needed.

For the From_X__from__Y mangled names of user-defined impls, these are normal compiled functions -- codegen handles them as regular function calls. No special codegen needed.

**Summary of codegen/expr.rs changes:** Likely NO changes needed if MIR correctly emits the right runtime function names. Only add changes if a new dispatch entry is needed.
  </action>
  <verify>
Run `cargo build --workspace` -- clean build. Verify `extract_impl_names` returns 3-tuple. Verify `resolve_trait_callee` has From dispatch entries. Verify `lower_try_result` has From conversion logic.
  </verify>
  <done>
MIR lowering handles From impls with parameterized mangled names. Built-in From conversions dispatch to existing runtime functions. lower_try_result inserts From.from() call when error types differ. Workspace builds clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend ? operator type checking and add E2E tests</name>
  <files>crates/mesh-typeck/src/infer.rs, tests/e2e/from_into.rs</files>
  <action>
**In infer.rs (`infer_try_expr`, line 6986-7011):**

Extend the Result branch (line 6992-6994) to handle From-based error conversion. Currently, line 6994 does:
```rust
let _ = ctx.unify(err_ty.clone(), args[1].clone(), ConstraintOrigin::Builtin);
```

Change to: Try unification first. If unification succeeds, great -- same behavior as before. If unification FAILS (error types are different concrete types), check if `From<err_ty> for args[1]` exists in the trait_registry:

```rust
let fn_err_ty = args[1].clone();
let err_resolved = ctx.resolve(err_ty.clone());
let fn_err_resolved = ctx.resolve(fn_err_ty.clone());

// Try direct unification first (preserves existing behavior).
if ctx.unify(err_resolved.clone(), fn_err_resolved.clone(), ConstraintOrigin::Builtin).is_err() {
    // Direct unification failed -- check for From impl.
    // Only attempt From lookup when both types are concrete (not inference variables).
    let err_is_concrete = !matches!(&err_resolved, Ty::Var(_));
    let fn_err_is_concrete = !matches!(&fn_err_resolved, Ty::Var(_));

    if err_is_concrete && fn_err_is_concrete {
        if !trait_registry.has_impl_with_type_args("From", &[err_resolved.clone()], &fn_err_resolved) {
            ctx.errors.push(TypeError::TryIncompatibleReturn {
                operand_ty: resolved.clone(),
                fn_return_ty: fn_ret_resolved.clone(),
                span,
            });
        }
        // If From impl exists, type check passes -- MIR lowering will insert the conversion.
    }
    // If either type is still a variable, let inference continue (don't error yet).
}
```

CRITICAL: This change must be backward-compatible. The existing same-error-type case (direct unification succeeds) must work exactly as before. Only the fallback path (when unification fails) is new.

Note: `infer_try_expr` receives `trait_registry: &TraitRegistry` -- it already has access. The `has_impl_with_type_args` method was added in Plan 01.

**Create E2E test file `tests/e2e/from_into.rs`:**

Add this file to the e2e test module. Include tests covering all 4 success criteria:

1. **test_user_defined_from** -- User writes `impl From<Int> for MyType` with a `from` function, calls `MyType.from(42)`, verifies conversion works:
   ```mesh
   struct Wrapper do
     value :: Int
   end

   impl From<Int> for Wrapper do
     fn from(n :: Int) -> Wrapper do
       Wrapper { value: n * 2 }
     end
   end

   fn main() do
     let w = Wrapper.from(21)
     println("${w.value}")
   end
   ```
   Expected output: `42`

2. **test_float_from_int** -- `Float.from(42)` produces `42.0`:
   ```mesh
   fn main() do
     let f = Float.from(42)
     println(Float.to_string(f))
   end
   ```
   Expected output: `42.0` (or `42` depending on float formatting)

3. **test_string_from_int** -- `String.from(42)` produces `"42"`:
   ```mesh
   fn main() do
     let s = String.from(42)
     println(s)
   end
   ```
   Expected output: `42`

4. **test_string_from_float** -- `String.from(3.14)` produces `"3.14"`:
   ```mesh
   fn main() do
     let s = String.from(3.14)
     println(s)
   end
   ```
   Expected output: `3.14` (or however mesh_float_to_string formats it)

5. **test_string_from_bool** -- `String.from(true)` produces `"true"`:
   ```mesh
   fn main() do
     let s = String.from(true)
     println(s)
   end
   ```
   Expected output: `true`

6. **test_try_operator_error_conversion** -- ? operator auto-converts error types via From:
   ```mesh
   struct AppError do
     message :: String
   end

   impl From<String> for AppError do
     fn from(msg :: String) -> AppError do
       AppError { message: msg }
     end
   end

   fn risky() -> Int!String do
     Err("something failed")
   end

   fn process() -> Int!AppError do
     let n = risky()?
     Ok(n + 1)
   end

   fn main() do
     let result = process()
     case result do
       Ok(n) -> println("ok: ${n}")
       Err(e) -> println("err: ${e.message}")
     end
   end
   ```
   Expected output: `err: something failed`

7. **test_try_operator_same_error_type** -- Existing behavior preserved (no regression):
   ```mesh
   fn risky() -> Int!String do
     Err("fail")
   end

   fn process() -> Int!String do
     let n = risky()?
     Ok(n)
   end

   fn main() do
     let result = process()
     case result do
       Ok(n) -> println("ok: ${n}")
       Err(e) -> println("err: ${e}")
     end
   end
   ```
   Expected output: `err: fail`

Follow existing E2E test patterns: compile the .mpl source, run the binary, assert stdout matches expected output. Look at existing E2E tests for the exact helper functions used (compile_and_run, assert_output, etc.).

Register the new test file in the test module if needed (check `tests/e2e/mod.rs` or `tests/e2e/main.rs`).
  </action>
  <verify>
Run `cargo test -p mesh-typeck` -- all tests pass. Run `cargo test from_into` -- new E2E tests pass. Run `cargo test` on the full workspace -- zero regressions.
  </verify>
  <done>
? operator type checking accepts From-convertible error types. All 7 E2E tests pass covering: user-defined From, Float.from, String.from (Int/Float/Bool), ? error conversion, and ? same-error-type backward compatibility. Zero regressions across full test suite.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass, zero regressions
2. E2E: User-defined `impl From<Int> for MyType` compiles and `MyType.from(42)` runs correctly
3. E2E: `Float.from(42)` produces 42.0
4. E2E: `String.from(42)` produces "42"
5. E2E: `String.from(3.14)` produces the float string representation
6. E2E: `String.from(true)` produces "true"
7. E2E: `?` operator converts error types via From when types differ
8. E2E: `?` operator continues to work when error types match (regression test)
</verification>

<success_criteria>
- User can write `impl From<Int> for MyType` and call `MyType.from(42)` at runtime
- Built-in conversions work: Float.from(42) -> 42.0, String.from(42) -> "42", String.from(3.14) -> "3.14", String.from(true) -> "true"
- The ? operator auto-converts error types when From<ExprErr> for FnErr exists
- Existing ? operator behavior preserved for same-error-type case
- All E2E tests pass
- Zero regressions across workspace
</success_criteria>

<output>
After completion, create `.planning/phases/77-from-into-conversion/77-02-SUMMARY.md`
</output>
