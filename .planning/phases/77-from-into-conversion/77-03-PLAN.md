---
phase: 77-from-into-conversion
plan: 03
type: execute
wave: 3
depends_on: ["77-02"]
files_modified:
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/types.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - tests/e2e/from_try_struct_error.mpl
  - crates/meshc/tests/e2e.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "The ? operator auto-converts error types: a function returning Result<T, AppError> can use ? on Result<T, String> if From<String> for AppError exists"
    - "Struct error types in Result variants are stored and extracted correctly at runtime without crashes"
  artifacts:
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Correct MirType for struct error types in Result variant fields and From conversion"
    - path: "crates/mesh-codegen/src/codegen/types.rs"
      provides: "Sum type layout handles struct payloads inline (not pointer-only)"
    - path: "tests/e2e/from_try_struct_error.mpl"
      provides: "E2E test verifying From<String> for AppError with ? operator"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/types.rs"
      via: "MirType::Struct in variant fields triggers correct layout sizing"
      pattern: "MirType::Struct"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/expr.rs"
      via: "From conversion call in lower_try_result uses struct MirType for target"
      pattern: "From_.*__from__"
---

<objective>
Fix Result<T, E> monomorphization to support struct error types in variant payloads, enabling the ? operator to auto-convert error types via From when the target error is a struct (e.g., AppError).

Purpose: Phase 77 success criterion #4 requires `?` to auto-convert String errors to AppError (a struct) via `From<String> for AppError`. The From conversion infrastructure is complete and wired, but struct values in Result variant payloads crash at runtime because the generic Result layout uses `{ i8, ptr }` which cannot hold inline struct values. This gap closure fixes the runtime layout so struct error types work correctly.

Output: Working struct-in-Result error conversion with passing E2E test.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-from-into-conversion/77-01-SUMMARY.md
@.planning/phases/77-from-into-conversion/77-02-SUMMARY.md
@.planning/phases/77-from-into-conversion/77-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Result variant layout for struct error types</name>
  <files>
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/types.rs
    crates/mesh-codegen/src/codegen/expr.rs
  </files>
  <action>
**Root cause:** Monomorphized Result types (e.g., `Result_Int_AppError`) use the base `Result` LLVM layout `{ i8, ptr }`. The Err variant expects a pointer-sized payload. When From conversion returns `MirType::Struct("AppError")`, there's a MIR type mismatch — the codegen misinterprets the value because the variant field says `Ptr` but the From call says `Struct`.

**Key insight:** User-defined struct constructors already return pointers at LLVM level (via `mesh_gc_alloc`). The From function's return value IS already a pointer at runtime — the bug is that the MIR type says `Struct` instead of `Ptr`, confusing the codegen.

**Fix in `lower_try_result` (around line 8162-8177):**

When `needs_from_conversion` is true and the target error type is a struct, normalize the MIR type to `Ptr` to match the Result variant layout:

```rust
let effective_err_ty = match &target_err_ty {
    MirType::Struct(_) => MirType::Ptr,
    other => other.clone(),
};
```

Use `effective_err_ty` instead of `target_err_ty` for both `err_body_ty` and the From call return type.

**Also verify:** `compile_constructor_call` in expr.rs correctly handles Err variant construction when the value is a pointer to a struct.

Run `cargo test --workspace` after changes to ensure zero regressions across all existing From E2E tests.
  </action>
  <verify>
    Run `cargo test --workspace` -- all existing tests pass (zero regressions).
    Run `cargo test -p mesh-codegen` -- all codegen tests pass.
  </verify>
  <done>
    MirType for struct error types in From conversion within lower_try_result correctly uses Ptr to match Result variant layout. Codegen compiles without type mismatch. No regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add E2E test for struct error conversion via ? operator</name>
  <files>
    tests/e2e/from_try_struct_error.mpl
    crates/meshc/tests/e2e.rs
  </files>
  <action>
Create the exact success criterion test from VERIFICATION.md's human verification section:

**Create `tests/e2e/from_try_struct_error.mpl`:**
```mesh
# Phase 77 gap closure: ? operator auto-converts String error to AppError struct via From.
# This is the exact success criterion #4 test case.

struct AppError do
  message :: String
end

impl From<String> for AppError do
  fn from(msg :: String) -> AppError do
    AppError { message: msg }
  end
end

fn risky() -> Int!String do
  Err("something failed")
end

fn process() -> Int!AppError do
  let n = risky()?
  Ok(n + 1)
end

fn main() do
  let result = process()
  case result do
    Ok(val) -> println("${val}")
    Err(e) -> println(e.message)
  end
end
```

Expected output: `something failed`

**Add E2E test function in `crates/meshc/tests/e2e.rs`:**
Follow the existing pattern (look at `from_try_error_conversion` test as a template). Add:
```rust
#[test]
fn from_try_struct_error() {
    run_e2e_test("from_try_struct_error", "something failed\n");
}
```

Run the test and confirm it passes with the expected output. If the test fails due to the struct-in-Result runtime issue, work with Task 1's fix to ensure the types align. The test MUST pass end-to-end.

**Also fix the misleading test name noted in VERIFICATION.md:** Rename `from_try_error_conversion` test function in e2e.rs to have a doc comment clarifying it tests chained ? with same error type, not From conversion. (Do NOT rename the file, just add a clarifying comment.)
  </action>
  <verify>
    Run `cargo test -p meshc from_try_struct_error` -- test passes with output "something failed\n".
    Run `cargo test --workspace` -- all tests pass including all 8+ From E2E tests.
  </verify>
  <done>
    E2E test `from_try_struct_error.mpl` compiles and runs successfully. Output is "something failed\n". The ? operator correctly converts String error to AppError struct via From<String> for AppError. Full test suite passes with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with zero regressions
2. `from_try_struct_error` E2E test passes, proving success criterion #4 works end-to-end
3. All 7 existing From E2E tests still pass (from_user_defined, from_float_from_int, from_string_from_int, from_string_from_float, from_string_from_bool, from_try_error_conversion, from_try_same_error)
4. The exact example from the VERIFICATION.md human verification section compiles and runs correctly
</verification>

<success_criteria>
- The ? operator auto-converts error types: a function returning Result<T, AppError> can use ? on Result<T, String> if From<String> for AppError exists
- Struct values in Result Err variants are handled correctly at runtime (no misaligned pointer crashes)
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/77-from-into-conversion/77-03-SUMMARY.md`
</output>
