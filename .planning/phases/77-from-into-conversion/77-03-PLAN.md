---
phase: 77-from-into-conversion
plan: 03
type: execute
wave: 1
depends_on: ["77-02"]
files_modified:
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/types.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - tests/e2e/from_try_struct_error.mpl
  - crates/meshc/tests/e2e.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "The ? operator auto-converts error types: a function returning Result<T, AppError> can use ? on Result<T, String> if From<String> for AppError exists"
    - "Struct error types in Result variants are stored and extracted correctly at runtime without crashes"
  artifacts:
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Correct MirType for struct error types in Result variant fields and From conversion"
    - path: "crates/mesh-codegen/src/codegen/types.rs"
      provides: "Sum type layout handles struct payloads inline (not pointer-only)"
    - path: "tests/e2e/from_try_struct_error.mpl"
      provides: "E2E test verifying From<String> for AppError with ? operator"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/types.rs"
      via: "MirType::Struct in variant fields triggers correct layout sizing"
      pattern: "MirType::Struct"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/expr.rs"
      via: "From conversion call in lower_try_result uses struct MirType for target"
      pattern: "From_.*__from__"
---

<objective>
Fix Result<T, E> monomorphization to support struct error types in variant payloads, enabling the ? operator to auto-convert error types via From when the target error is a struct (e.g., AppError).

Purpose: Phase 77 success criterion #4 requires `?` to auto-convert String errors to AppError (a struct) via `From<String> for AppError`. The From conversion infrastructure is complete and wired, but struct values in Result variant payloads crash at runtime because the generic Result layout uses `{ i8, ptr }` which cannot hold inline struct values. This gap closure fixes the runtime layout so struct error types work correctly.

Output: Working struct-in-Result error conversion with passing E2E test.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-from-into-conversion/77-01-SUMMARY.md
@.planning/phases/77-from-into-conversion/77-02-SUMMARY.md
@.planning/phases/77-from-into-conversion/77-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Result variant layout for struct error types</name>
  <files>
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/types.rs
    crates/mesh-codegen/src/codegen/expr.rs
  </files>
  <action>
The crash occurs because monomorphized Result types (e.g., `Result_Int_AppError`) use the base `Result` LLVM layout `{ i8, ptr }`, which only supports pointer-sized payloads. When a struct value like AppError is stored in the Err variant, the layout mismatch causes misaligned pointer crashes.

**Root cause chain:**

1. `lower_sum_type_def` (lower.rs:1829) uses the base Result type's variant definitions which have generic `Ty` fields. `resolve_type` on these generic fields produces `MirType::Ptr` for struct types because the generic parameters haven't been substituted.

2. `create_sum_type_layout` (types.rs:136) sees `MirType::Ptr` fields, so it creates `{ i8, ptr }` -- correct for heap-allocated values but wrong for inline structs.

3. When the monomorphized `Result_Int_AppError` is used at LLVM level, `lookup_sum_type_layout` (mod.rs:280) falls back to the base `Result` layout, which is still `{ i8, ptr }`.

**Fix approach -- box struct values through the runtime allocator:**

Rather than changing the sum type layout (which would break all existing Result/Option usage), the correct fix is to ensure struct values going into generic sum type variants are boxed (heap-allocated) on construction and unboxed on extraction. This matches how the runtime handles String and other pointer types in Result/Option.

Specifically:

**In `lower.rs` (`type_name_to_mir_type`):**
- The function at line 8103-8120 already correctly returns `MirType::Struct(name)` for known struct types. However, when this type is used in `lower_try_result` for constructing the Err variant of a Result, the struct value needs to be passed as a pointer (boxed). Update the From conversion error path in `lower_try_result` (lines 8162-8177) so that when the target error type is `MirType::Struct(...)`, the result of the From conversion call is wrapped in a box operation (allocate + store, returning a Ptr). This ensures the struct value is heap-allocated before being placed in the Result `{ i8, ptr }` layout.

The boxing approach:
- After the `From_Source__from__Target` call produces a `MirType::Struct(...)` value, wrap it in a `MirExpr::Box` (or equivalent MIR operation that allocates and stores the struct, returning a pointer). Check if there is already a box/alloc MIR node; if not, use `MirExpr::RuntimeCall` to `mesh_gc_alloc` and then a store, or change the `err_body_ty` to `MirType::Ptr` and trust the codegen to handle struct-to-ptr conversion.

Actually, the simplest fix that matches existing patterns: when constructing the Err variant of a monomorphized Result with a struct error type, the codegen for variant construction (`compile_constructor_call` in expr.rs) already handles struct values by GEP-ing into the variant payload field. The real issue is that the variant field type in the base Result MIR definition says `Ptr`, so the codegen stores a ptr-sized value, but the actual From conversion returns a struct-sized value.

**Simplest correct fix:**

In `lower_try_result`, when `needs_from_conversion` is true and the target error type is a struct, change the `err_body_ty` to `MirType::Ptr` so the Err variant construction treats the converted error as a pointer. The From conversion function for user-defined types already returns a pointer (all user-defined struct constructors return pointers at the LLVM level due to the mesh_gc_alloc pattern in codegen).

Verify this by:
1. Check how user-defined `From.from()` functions return struct values at the MIR level -- they return `MirType::Struct(name)` but at LLVM level, struct returns are already pointer-based (the codegen allocates and returns a ptr).
2. The Err variant of Result expects a `Ptr` payload -- the MIR type mismatch is the bug. When the From function returns `MirType::Struct("AppError")` but the variant expects `MirType::Ptr`, the codegen may misinterpret the value.

The fix in `lower_try_result` (around line 8162-8177):
```
// When target error is a struct, the From function returns a struct
// that will be a pointer at LLVM level (struct constructor allocates
// via mesh_gc_alloc). Use MirType::Ptr to match the Result variant layout.
let effective_err_ty = match &target_err_ty {
    MirType::Struct(_) => MirType::Ptr,
    other => other.clone(),
};
```

Use `effective_err_ty` instead of `target_err_ty` for `err_body_ty` and the From call return type, so the types align with the Result variant's Ptr layout.

Also verify/fix `compile_constructor_call` in expr.rs to ensure that when constructing an Err variant with a struct value, the value is treated as a pointer correctly.

**Important:** Run the full test suite (`cargo test --workspace`) after each change to ensure zero regressions. The existing 7 From E2E tests and all other tests must continue to pass.
  </action>
  <verify>
    Run `cargo test --workspace` -- all existing tests pass (zero regressions).
    Run `cargo test -p mesh-codegen` -- all codegen tests pass.
  </verify>
  <done>
    MirType for struct error types in From conversion within lower_try_result correctly uses Ptr to match Result variant layout. Codegen compiles without type mismatch. No regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add E2E test for struct error conversion via ? operator</name>
  <files>
    tests/e2e/from_try_struct_error.mpl
    crates/meshc/tests/e2e.rs
  </files>
  <action>
Create the exact success criterion test from VERIFICATION.md's human verification section:

**Create `tests/e2e/from_try_struct_error.mpl`:**
```mesh
# Phase 77 gap closure: ? operator auto-converts String error to AppError struct via From.
# This is the exact success criterion #4 test case.

struct AppError do
  message :: String
end

impl From<String> for AppError do
  fn from(msg :: String) -> AppError do
    AppError { message: msg }
  end
end

fn risky() -> Int!String do
  Err("something failed")
end

fn process() -> Int!AppError do
  let n = risky()?
  Ok(n + 1)
end

fn main() do
  let result = process()
  case result do
    Ok(val) -> println("${val}")
    Err(e) -> println(e.message)
  end
end
```

Expected output: `something failed`

**Add E2E test function in `crates/meshc/tests/e2e.rs`:**
Follow the existing pattern (look at `from_try_error_conversion` test as a template). Add:
```rust
#[test]
fn from_try_struct_error() {
    run_e2e_test("from_try_struct_error", "something failed\n");
}
```

Run the test and confirm it passes with the expected output. If the test fails due to the struct-in-Result runtime issue, work with Task 1's fix to ensure the types align. The test MUST pass end-to-end.

**Also fix the misleading test name noted in VERIFICATION.md:** Rename `from_try_error_conversion` test function in e2e.rs to have a doc comment clarifying it tests chained ? with same error type, not From conversion. (Do NOT rename the file, just add a clarifying comment.)
  </action>
  <verify>
    Run `cargo test -p meshc from_try_struct_error` -- test passes with output "something failed\n".
    Run `cargo test --workspace` -- all tests pass including all 8+ From E2E tests.
  </verify>
  <done>
    E2E test `from_try_struct_error.mpl` compiles and runs successfully. Output is "something failed\n". The ? operator correctly converts String error to AppError struct via From<String> for AppError. Full test suite passes with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with zero regressions
2. `from_try_struct_error` E2E test passes, proving success criterion #4 works end-to-end
3. All 7 existing From E2E tests still pass (from_user_defined, from_float_from_int, from_string_from_int, from_string_from_float, from_string_from_bool, from_try_error_conversion, from_try_same_error)
4. The exact example from the VERIFICATION.md human verification section compiles and runs correctly
</verification>

<success_criteria>
- The ? operator auto-converts error types: a function returning Result<T, AppError> can use ? on Result<T, String> if From<String> for AppError exists
- Struct values in Result Err variants are handled correctly at runtime (no misaligned pointer crashes)
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/77-from-into-conversion/77-03-SUMMARY.md`
</output>
