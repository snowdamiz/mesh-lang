---
phase: 77-from-into-conversion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-typeck/src/traits.rs
  - crates/mesh-typeck/src/builtins.rs
  - crates/mesh-typeck/src/infer.rs
autonomous: true

must_haves:
  truths:
    - "ImplDef has a trait_type_args field that stores parameterized trait type arguments"
    - "find_impl_with_type_args can distinguish From<Int> for String from From<Float> for String"
    - "From<T> and Into<T> traits are registered as compiler-known traits"
    - "Built-in From impls exist for Int->Float, Int->String, Float->String, Bool->String"
    - "Registering a From impl automatically generates a synthetic Into impl"
    - "infer_impl_def extracts GENERIC_ARG_LIST from the trait path and stores trait_type_args"
    - "Float.from(42) and String.from(42) type-check correctly via stdlib_modules"
    - "Duplicate detection for parameterized traits considers trait_type_args"
  artifacts:
    - path: "crates/mesh-typeck/src/traits.rs"
      provides: "trait_type_args on ImplDef, find_impl_with_type_args, has_impl_with_type_args, synthetic Into generation"
    - path: "crates/mesh-typeck/src/builtins.rs"
      provides: "From/Into TraitDef registrations, built-in From impl registrations"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "GENERIC_ARG_LIST extraction in infer_impl_def, from entries in Float/String/Int stdlib_modules"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "infer_impl_def passes trait_type_args to TraitImplDef constructor"
      pattern: "trait_type_args"
    - from: "crates/mesh-typeck/src/builtins.rs"
      to: "crates/mesh-typeck/src/traits.rs"
      via: "register_impl with trait_type_args for built-in From impls"
      pattern: "trait_type_args.*vec!"
---

<objective>
Add parameterized trait type argument support to the trait registry, register From<T> and Into<T> as compiler-known traits with built-in primitive conversions, implement synthetic Into generation from From registrations, and wire up type checking for `Type.from(value)` static calls.

Purpose: Foundation for all From/Into conversion functionality -- subsequent plan builds MIR lowering and ? operator on this infrastructure.
Output: Extended TraitRegistry with parameterized lookup, From/Into traits registered, built-in conversions registered, infer_impl_def extracts trait type args.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-from-into-conversion/77-RESEARCH.md
@crates/mesh-typeck/src/traits.rs
@crates/mesh-typeck/src/builtins.rs
@crates/mesh-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TraitRegistry with parameterized trait support</name>
  <files>crates/mesh-typeck/src/traits.rs</files>
  <action>
Add `trait_type_args: Vec<Ty>` field to `ImplDef` struct (after `trait_name`).

Add two new methods to `TraitRegistry`:

1. `find_impl_with_type_args(&self, trait_name: &str, trait_type_args: &[Ty], impl_ty: &Ty) -> Option<&ImplDef>` -- same as `find_impl` but also checks that the stored `trait_type_args` match the query args via temporary unification. If `trait_type_args` is empty on the query, falls through to standard `find_impl` behavior.

2. `has_impl_with_type_args(&self, trait_name: &str, trait_type_args: &[Ty], impl_ty: &Ty) -> bool` -- wraps `find_impl_with_type_args` returning bool.

Update duplicate detection in `register_impl`: when checking for overlapping impls, also compare `trait_type_args`. Two impls with the same trait name and impl type but DIFFERENT trait_type_args are NOT duplicates (e.g., `From<Int> for String` and `From<Float> for String` are distinct). Only flag DuplicateImpl when trait_type_args also unify.

Add synthetic Into generation in `register_impl`: after storing the impl, if `impl_def.trait_name == "From"` and `impl_def.trait_type_args` is non-empty, automatically synthesize and register `impl Into<B> for A` where A is `trait_type_args[0]` (the source type) and B is `impl_type` (the target type). The Into impl has one method: `into` with `has_self: true`, `param_count: 0`, `return_type: Some(target_type)`. Guard against infinite recursion by NOT triggering synthesis when the trait_name is "Into". Use `impl_type_name` derived from the source type (format the Ty).

Update ALL existing `ImplDef` construction sites across traits.rs (unit tests) to include `trait_type_args: vec![]`.

  </action>
  <verify>
Run `cargo test -p mesh-typeck` -- all existing tests must pass with the new field. No regressions.
  </verify>
  <done>
ImplDef has trait_type_args field. find_impl_with_type_args correctly distinguishes parameterized impls. Synthetic Into generation fires on From registration. Duplicate detection accounts for trait_type_args. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register From/Into traits and built-in impls, wire type checking</name>
  <files>crates/mesh-typeck/src/builtins.rs, crates/mesh-typeck/src/infer.rs</files>
  <action>
**In builtins.rs (`register_compiler_known_traits`):**

Register From<T> trait definition:
```
TraitDef {
    name: "From",
    methods: [TraitMethodSig { name: "from", has_self: false, param_count: 1, return_type: None, has_default_body: false }],
    associated_types: [],
}
```

Register Into<T> trait definition:
```
TraitDef {
    name: "Into",
    methods: [TraitMethodSig { name: "into", has_self: true, param_count: 0, return_type: None, has_default_body: false }],
    associated_types: [],
}
```

Register 4 built-in From impls (each with trait_type_args):
1. `impl From<Int> for Float` -- trait_type_args: [Ty::int()], impl_type: Ty::float(), method "from" with param_count: 1, return_type: Some(Ty::float())
2. `impl From<Int> for String` -- trait_type_args: [Ty::int()], impl_type: Ty::string(), method "from" with param_count: 1, return_type: Some(Ty::string())
3. `impl From<Float> for String` -- trait_type_args: [Ty::float()], impl_type: Ty::string(), method "from" with param_count: 1, return_type: Some(Ty::string())
4. `impl From<Bool> for String` -- trait_type_args: [Ty::bool()], impl_type: Ty::string(), method "from" with param_count: 1, return_type: Some(Ty::string())

The synthetic Into generation from Task 1 will automatically create corresponding Into impls.

Update ALL other existing ImplDef constructions in builtins.rs to include `trait_type_args: vec![]`.

**In infer.rs:**

1. **Extract trait type args in `infer_impl_def`** (around line 2884-2898): After extracting `trait_name` from the first PATH child, also look for a GENERIC_ARG_LIST child node within the IMPL_DEF's children (siblings of the PATH nodes). For each type name token in the GENERIC_ARG_LIST, call `name_to_type()` to convert to a Ty. Store as `trait_type_args: Vec<Ty>`. Pass to the TraitImplDef constructor at line 3038.

   The GENERIC_ARG_LIST is a direct child of IMPL_DEF (not of PATH), containing type tokens between `<` and `>`. Extract IDENT tokens from it, mapping each via `name_to_type()`. For compound types (like List<Int>), look for PATH children within the GENERIC_ARG_LIST.

2. **Add `from` to stdlib_modules** for Float, String, and Int modules:
   - Float module (line 596): add `from` entry with type `Ty::fun(vec![Ty::int()], Ty::float())`
   - String module (line 272): add `from` entries. Since String.from accepts Int, Float, or Bool, add a single `from` with type `Ty::fun(vec![Ty::int()], Ty::string())` (the type checker will accept it; codegen handles dispatch by argument type). Alternatively, just use Int for now -- the most common case. Float.from and Bool.from variants will be handled by the trait dispatch path.
   - Actually, for String.from, add THREE overloaded entries won't work (Mesh doesn't support overloading). Instead, register a single `from` entry for Int argument: `Ty::fun(vec![Ty::int()], Ty::string())`. For Float and Bool arguments, rely on the trait impl resolution path (resolve_trait_callee) which already handles method dispatch.

   Wait -- stdlib_modules entries are for the `Type.method()` static call syntax, and each method can only have one type. For String.from, we need to handle multiple source types. The cleanest approach: register `from` in the Int module (`Int.from` doesn't make sense) and Float module only. For String.from with different argument types, don't add to stdlib_modules -- instead let it be resolved through the user-defined trait impl path. Actually, the success criteria says `Float.from(42)` and `String.from(42)` must work.

   **Revised approach:** Add `from` to Float stdlib module: `Ty::fun(vec![Ty::int()], Ty::float())`. For String.from, we need to accept different argument types. Since this is a static call (String.from(42)), it routes through the STDLIB_MODULES path. Use a polymorphic Scheme: create a fresh TyVar for the input and return String. This way `String.from(42)` infers Int for the input, `String.from(3.14)` infers Float, etc. The codegen will dispatch based on the resolved argument type.

   ```rust
   // In String module section:
   let from_input_var = TyVar(91100);
   string_mod.insert("from".to_string(), Scheme {
       vars: vec![from_input_var],
       ty: Ty::fun(vec![Ty::Var(from_input_var)], Ty::string()),
   });
   ```

   For Float module:
   ```rust
   float_mod.insert("from".to_string(), Scheme::mono(Ty::fun(vec![Ty::int()], Ty::float())));
   ```

3. **Update all existing `TraitImplDef` constructions in infer.rs** (auto-derive impls for Eq, Ord, Display, Debug, Hash at ~lines 2094-2265, plus sum type impls at ~line 2548) to include `trait_type_args: vec![]`.

4. **Add `Iter` module note:** The Iter module entry in STDLIB_MODULE_NAMES (line 844) already exists from Phase 76 -- no changes needed there.
  </action>
  <verify>
Run `cargo test -p mesh-typeck` -- all tests pass. Run `cargo build --workspace` -- entire workspace compiles with no errors.
  </verify>
  <done>
From and Into traits registered. 4 built-in From impls registered with trait_type_args. infer_impl_def extracts GENERIC_ARG_LIST from trait path. Float.from and String.from entries in stdlib_modules. All existing ImplDef constructions updated. Workspace builds clean.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p mesh-typeck` -- all tests pass (existing + new parameterized trait tests)
2. `cargo build --workspace` -- clean build, no errors
3. Manual check: ImplDef struct has `trait_type_args: Vec<Ty>` field
4. Manual check: `find_impl_with_type_args` exists and properly distinguishes parameterized impls
5. Manual check: From/Into traits appear in builtins.rs register_compiler_known_traits
6. Manual check: infer_impl_def extracts GENERIC_ARG_LIST tokens
</verification>

<success_criteria>
- TraitRegistry supports parameterized trait lookups (From<Int> vs From<Float> for same impl type)
- From<T> and Into<T> traits registered with correct method signatures
- Built-in From impls for Int->Float, Int->String, Float->String, Bool->String registered
- Synthetic Into generation works (From<A> for B auto-creates Into<B> for A)
- infer_impl_def correctly extracts trait type arguments from user-written impl blocks
- Float.from and String.from type-check correctly
- Zero regressions: all existing workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/77-from-into-conversion/77-01-SUMMARY.md`
</output>
