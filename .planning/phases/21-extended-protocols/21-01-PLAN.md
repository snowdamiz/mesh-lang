---
phase: 21-extended-protocols
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/hash.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
autonomous: true

must_haves:
  truths:
    - "A struct with Hash impl can be used as a Map key via Map.put and Map.get"
    - "Hash__hash__StructName returns a consistent i64 for the same struct value"
    - "Primitive types (Int, Float, String, Bool) have Hash impls registered"
    - "Non-generic structs auto-derive Hash impls in typeck"
  artifacts:
    - path: "crates/snow-rt/src/hash.rs"
      provides: "FNV-1a hash runtime functions"
      contains: "snow_hash_int"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Hash trait registration with primitive impls"
      contains: "Hash"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Hash__hash auto-generation for structs + Map key hashing at call site"
      contains: "Hash__hash"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/hash.rs"
      via: "MIR Call to snow_hash_int/snow_hash_combine runtime functions"
      pattern: "snow_hash_"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "TraitRegistry lookup for Hash impls during Map key lowering"
      pattern: "has_impl.*Hash"
---

<objective>
Implement the Hash protocol end-to-end: FNV-1a runtime functions, trait registration with primitive impls, auto-derive for non-generic structs, and Map key integration via call-site hashing.

Purpose: Enables user-defined types as Map keys -- the most impactful feature in Phase 21. Without Hash, Maps only support Int and String keys.
Output: Working Hash protocol where `Map.put(map, my_struct, value)` hashes the struct key via FNV-1a and uses the hash as the integer Map key.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-extended-protocols/21-RESEARCH.md
@.planning/phases/20-essential-stdlib-protocols/20-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: FNV-1a runtime + Hash trait registration + auto-derive for structs</name>
  <files>
    crates/snow-rt/src/hash.rs
    crates/snow-rt/src/lib.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
    1. Create `crates/snow-rt/src/hash.rs` with FNV-1a 64-bit hash functions:
       - Constants: `FNV_OFFSET_BASIS = 0xcbf29ce484222325_u64`, `FNV_PRIME = 0x00000100000001B3_u64`
       - Internal helper: `fn fnv1a_bytes(bytes: &[u8]) -> u64` (iterate bytes, XOR then wrapping_mul)
       - `#[no_mangle] pub extern "C" fn snow_hash_int(value: i64) -> i64` -- hash via `fnv1a_bytes(&value.to_le_bytes()) as i64`
       - `#[no_mangle] pub extern "C" fn snow_hash_float(value: f64) -> i64` -- hash via `fnv1a_bytes(&value.to_bits().to_le_bytes()) as i64`
       - `#[no_mangle] pub extern "C" fn snow_hash_bool(value: i8) -> i64` -- hash via `fnv1a_bytes(&[value as u8]) as i64`
       - `#[no_mangle] pub extern "C" fn snow_hash_string(s: *const crate::string::SnowString) -> i64` -- hash via `unsafe { fnv1a_bytes((*s).as_str().as_bytes()) as i64 }`
       - `#[no_mangle] pub extern "C" fn snow_hash_combine(hash_a: i64, hash_b: i64) -> i64` -- feed hash_b's bytes into hash_a state via wrapping_mul chain
       - Total: ~35 lines

    2. Add `pub mod hash;` to `crates/snow-rt/src/lib.rs`

    3. In `crates/snow-typeck/src/builtins.rs`, in `register_compiler_known_traits()`:
       - Register Hash trait with single method: `hash(self) -> Int` (has_self=true, param_count=0, return_type=Some(Ty::int()))
       - Register Hash impls for Int, Float, String, Bool -- follow exact pattern of Display/Eq registration
       - Add test `hash_trait_registered_for_primitives` verifying `has_impl("Hash", &Ty::int())` and `find_method_traits("hash", &Ty::int())` returns `["Hash"]`

    4. In `crates/snow-typeck/src/infer.rs`, in `register_struct_def()`:
       - After the existing auto-registration of Debug (and Eq/Ord from 20-04/20-05), add Hash auto-registration for non-generic structs
       - Follow exact same pattern: create ImplDef with trait_name="Hash", method "hash" with has_self=true, param_count=0, return_type=Some(Ty::int())
       - Use `Ty::Con(TyCon::new(&name))` for impl_type, matching existing pattern

    Note: Do NOT auto-derive Hash for sum types (structs only, per research recommendation -- sum types would need variant tag hashing which is more complex and not required by success criteria).
  </action>
  <verify>
    `cargo test --workspace` passes with zero regressions.
    `cargo test -p snow-typeck -- hash_trait_registered` passes.
    Grep for `snow_hash_int` in hash.rs confirms runtime functions exist.
  </verify>
  <done>
    Hash trait registered in TraitRegistry for all primitive types. Non-generic structs auto-derive Hash impl in typeck. FNV-1a runtime functions compiled in snow-rt.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate Hash__hash MIR for structs + Map key hashing at call site</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
    1. In `crates/snow-codegen/src/codegen/intrinsics.rs`:
       - Declare runtime functions: `snow_hash_int(i64) -> i64`, `snow_hash_float(f64) -> i64`, `snow_hash_bool(i8) -> i64`, `snow_hash_string(*const SnowString) -> i64`, `snow_hash_combine(i64, i64) -> i64`
       - Follow same pattern as existing `snow_int_to_string` etc. declarations

    2. In `crates/snow-codegen/src/mir/lower.rs`, add `generate_hash_struct(name, fields)` function:
       - Creates `Hash__hash__StructName` MirFunction taking `(self: StructType) -> Int`
       - Body: for each field, emit `snow_hash_<field_type>(self.field_name)`, chain results via `snow_hash_combine`
       - First field: `let h0 = snow_hash_int(self.field0)` (or appropriate hash fn based on field type)
       - Subsequent fields: `let hN = snow_hash_combine(h_{N-1}, snow_hash_<type>(self.fieldN))`
       - For struct/sum-type fields: use `Hash__hash__InnerType(self.field)` instead of primitive hash fn
       - Return final combined hash
       - Register in `known_functions`
       - Follow same pattern as `generate_debug_inspect_struct` and `generate_eq_struct`

    3. In `lower_struct_def`, after the existing calls to `generate_eq_struct` and `generate_ord_struct`:
       - Call `generate_hash_struct(name, fields)`

    4. In `lower_call_expr`, add primitive Hash dispatch (same pattern as Display primitive redirects):
       - `Hash__hash__Int` -> emit `Call { func: snow_hash_int, args: [self_arg] }`
       - `Hash__hash__Float` -> emit `Call { func: snow_hash_float, args: [self_arg] }`
       - `Hash__hash__Bool` -> emit `Call { func: snow_hash_bool, args: [self_arg] }`
       - `Hash__hash__String` -> emit `Call { func: snow_hash_string, args: [self_arg] }`

    5. In `lower_call_expr` or `lower_map_literal`, intercept `map_put` and `map_get` calls when key type has a Hash impl:
       - Check if the key argument's type has a Hash impl via `trait_registry.has_impl("Hash", &key_ty)`
       - If yes, wrap the key argument: emit `Hash__hash__TypeName(key_arg)` to produce an i64 hash, then pass that hash as the integer key to `snow_map_put`/`snow_map_get`
       - Also update `infer_map_key_type` (the function that determines key_type tag) to return KEY_TYPE_INT (0) when key type is hashable -- the hash IS an integer key
       - If no Hash impl, leave behavior unchanged (existing Int/String key paths)

    6. Add tests:
       - `hash_struct_generates_mir_function`: verify `Hash__hash__Point` appears in MIR with correct params
       - `hash_struct_field_chaining`: verify combine calls appear in generated body
       - `map_put_with_struct_key_hashes`: verify that map_put with a struct key emits Hash__hash call before snow_map_put

    IMPORTANT: The Map key hashing uses hash-as-integer-key approach (per research). This means struct keys are stored by their FNV-1a hash. Collisions are possible but extremely rare for typical values. Document this as a known v1.3 limitation.
  </action>
  <verify>
    `cargo test --workspace` passes with zero regressions.
    `cargo test -p snow-codegen -- hash_struct` passes.
    `cargo build --workspace` compiles cleanly.
  </verify>
  <done>
    Hash__hash__StructName MIR functions auto-generated for non-generic structs. Map.put/Map.get with struct keys emit hash-then-store calls. Runtime FNV-1a functions declared in codegen intrinsics.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` -- all existing tests pass plus new Hash tests
- `cargo build --workspace` -- clean compilation
- Hash trait registered for primitives and auto-derived for non-generic structs
- Hash MIR functions generated with field-by-field hash chaining
- Map key interception emits Hash dispatch for hashable types
</verification>

<success_criteria>
- FNV-1a runtime functions exist and compile in snow-rt
- Hash trait registered for Int, Float, String, Bool
- Non-generic structs auto-derive Hash in typeck
- Hash__hash__StructName MIR functions generated with snow_hash_combine chaining
- Map.put/Map.get with struct keys emit hash-then-lookup via Hash dispatch
- All tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/21-extended-protocols/21-01-SUMMARY.md`
</output>
