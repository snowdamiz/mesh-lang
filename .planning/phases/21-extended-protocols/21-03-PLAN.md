---
phase: 21-extended-protocols
plan: 03
type: execute
wave: 3
depends_on: ["21-02"]
files_modified:
  - crates/snow-parser/src/parser/items.rs
  - crates/snow-parser/src/ast/item.rs
  - crates/snow-typeck/src/traits.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "An interface method can have an optional do...end body that serves as a default implementation"
    - "An impl block that omits a method with a default body compiles without error"
    - "The default method body executes when no override is provided"
    - "An impl block that provides an override uses the override, not the default"
  artifacts:
    - path: "crates/snow-parser/src/parser/items.rs"
      provides: "Optional do...end body parsing in interface methods"
      contains: "DO_KW"
    - path: "crates/snow-parser/src/ast/item.rs"
      provides: "body() accessor on InterfaceMethod"
      contains: "fn body"
    - path: "crates/snow-typeck/src/traits.rs"
      provides: "has_default_body flag in TraitMethodSig"
      contains: "has_default_body"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Default method body lowering for missing impl methods"
      contains: "default_method"
  key_links:
    - from: "crates/snow-parser/src/parser/items.rs"
      to: "crates/snow-parser/src/ast/item.rs"
      via: "Parser produces INTERFACE_METHOD with optional BLOCK child; AST body() reads it"
      pattern: "INTERFACE_METHOD"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/traits.rs"
      via: "infer_interface_def sets has_default_body on TraitMethodSig"
      pattern: "has_default_body"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-typeck/src/traits.rs"
      via: "Lowerer checks has_default_body when processing impl defs with missing methods"
      pattern: "has_default_body"
---

<objective>
Support default method implementations in interface blocks: parse optional do...end bodies, skip missing-method errors when default exists, and lower default bodies for concrete types that omit the override.

Purpose: Reduces boilerplate in impl blocks. Users only need to implement required methods; methods with defaults are inherited automatically.
Output: Working default method bodies that execute when an impl omits the method, using the concrete type's context.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-extended-protocols/21-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parser + AST support for optional method bodies in interfaces</name>
  <files>
    crates/snow-parser/src/parser/items.rs
    crates/snow-parser/src/ast/item.rs
  </files>
  <action>
    1. In `crates/snow-parser/src/parser/items.rs`, modify `parse_interface_method()` (currently at lines ~515-551):
       - After parsing the return type annotation (the existing `:` type_expr), check for `DO_KW`
       - If `p.at(SyntaxKind::DO_KW)` is true: bump DO_KW, call `parse_block(p)` (reuse the same block parser used by `parse_fn_def`), then expect and bump `END_KW`
       - Close as `INTERFACE_METHOD` regardless of whether body was present
       - This makes the body optional -- methods without do...end remain signature-only

    2. In `crates/snow-parser/src/ast/item.rs`, modify `InterfaceMethod` (currently at lines ~412-429):
       - Add a `pub fn body(&self) -> Option<Block>` method
       - Implementation: look for a child node of kind `BLOCK` in the syntax children, same pattern as `FnDef::body()`
       - Also check if `FnDef::body()` pattern uses `child()` or `children().find()` and match that exactly

    3. Add parser test:
       - `interface_method_with_default_body`: parse `interface Describable do describe(self) -> String do "unknown" end end` and verify the InterfaceMethod has a body
       - `interface_method_without_body`: parse `interface Describable do describe(self) -> String end` and verify body() returns None

    IMPORTANT: The `parse_block` function to reuse is the one that handles the body of `fn` definitions. Look at `parse_fn_def` to see how it calls block parsing after `DO_KW`. The interface method body uses the identical syntax: `do <stmts> end`.
  </action>
  <verify>
    `cargo test --workspace` passes with zero regressions.
    `cargo test -p snow-parser -- interface_method` passes (both new tests).
  </verify>
  <done>
    Parser accepts optional `do...end` bodies in interface methods. AST `InterfaceMethod::body()` returns `Some(Block)` when body present, `None` otherwise.
  </done>
</task>

<task type="auto">
  <name>Task 2: Typeck has_default_body flag + MIR lowering of default method bodies</name>
  <files>
    crates/snow-typeck/src/traits.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
    1. In `crates/snow-typeck/src/traits.rs`:
       - Add `has_default_body: bool` field to `TraitMethodSig` struct
       - Update ALL existing construction sites of `TraitMethodSig` to include `has_default_body: false` (grep for `TraitMethodSig {` to find them all -- in builtins.rs and infer.rs)
       - In `register_impl()` (the method that checks required methods), modify the missing-method check: if a method is missing from the impl BUT `has_default_body` is true for that method in the trait definition, skip the `MissingTraitMethod` error for that method

    2. In `crates/snow-typeck/src/infer.rs`, modify `infer_interface_def()`:
       - For each interface method, check if `method.body().is_some()`
       - If body present: set `has_default_body: true` on the TraitMethodSig
       - Also type-check the default body in its own scope (push a new scope, add self param with a fresh type variable, infer the body, pop scope)
       - Store the default method body's syntax node for the lowerer to access later. Add a field to TypeckResult: `pub default_method_bodies: FxHashMap<(String, String), SyntaxNode>` keyed by `(trait_name, method_name)`. Store the interface method's syntax node (or the FnDef-like block) there.

    3. In `crates/snow-codegen/src/mir/lower.rs`:
       - The Lowerer already has access to TypeckResult (which carries trait_registry and types map)
       - When processing `Item::ImplDef`, after lowering all user-provided methods, check the TraitRegistry for the trait being implemented
       - For each method in the trait definition that is NOT present in the impl's method list:
         - Check `has_default_body` -- if true, look up the default body syntax node from `default_method_bodies`
         - Call `lower_impl_method` (or a similar helper) with the default body, using the concrete impl type and the mangled name `Trait__Method__TypeName`
         - The default body must be lowered in the context of the concrete type (push scope with `self` bound to the impl's concrete type)
       - If `has_default_body` is false and method is missing, this is already caught by typeck's MissingTraitMethod error

    4. Add tests:
       - `default_method_skips_missing_error`: an impl that omits a method with has_default_body=true should compile without error
       - `default_method_body_lowered_for_concrete_type`: verify that when impl Describable for Point omits `describe`, the MIR contains `Describable__describe__Point` function generated from the default body
       - `override_replaces_default`: when impl provides the method, the default is NOT used

    IMPORTANT: The default body is re-lowered per concrete type (monomorphization model). The syntax node must remain accessible. Since Parse owns the syntax tree and lives for the duration of compilation, SyntaxNode references are valid. Store them in TypeckResult for clean data flow.

    IMPORTANT: When updating TraitMethodSig, you MUST update ALL construction sites. Grep for `TraitMethodSig` across the entire workspace to find every one. The builtins.rs file registers ~6 traits with multiple methods each. Every single one needs `has_default_body: false` added.
  </action>
  <verify>
    `cargo test --workspace` passes with zero regressions.
    `cargo test -p snow-codegen -- default_method` passes (all three tests).
    `cargo build --workspace` compiles cleanly.
  </verify>
  <done>
    Interface methods with do...end bodies are flagged as has_default_body. Impls that omit such methods compile without error. Default bodies are lowered for the concrete impl type with correct mangled names.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` -- all existing tests pass plus new default method tests
- `cargo build --workspace` -- clean compilation
- Parser accepts `interface Foo do bar(self) -> Int do 42 end end`
- Typeck allows impl to omit methods that have default bodies
- MIR lowering generates Trait__Method__TypeName for default bodies with concrete type context
- Override in impl replaces default body
</verification>

<success_criteria>
- Interface method bodies parsed as optional do...end blocks
- has_default_body flag propagated through typeck to MIR lowering
- Missing impl methods with defaults compile without error
- Default bodies lowered per concrete type (monomorphization)
- Override in impl takes precedence over default
- All tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/21-extended-protocols/21-03-SUMMARY.md`
</output>
