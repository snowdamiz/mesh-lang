---
phase: 21-extended-protocols
plan: 04
type: execute
wave: 4
depends_on: ["21-03"]
files_modified:
  - crates/snow-rt/src/collections/list.rs
  - crates/snow-rt/src/collections/map.rs
  - crates/snow-rt/src/collections/set.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
autonomous: true

must_haves:
  truths:
    - "to_string([1, 2, 3]) returns \"[1, 2, 3]\""
    - "to_string on a Map returns a readable key-value representation"
    - "to_string on a Set returns a readable set representation"
    - "String interpolation with collections works (e.g., \"items: ${my_list}\")"
  artifacts:
    - path: "crates/snow-rt/src/collections/list.rs"
      provides: "snow_list_to_string runtime helper with element callback"
      contains: "snow_list_to_string"
    - path: "crates/snow-rt/src/collections/map.rs"
      provides: "snow_map_to_string runtime helper with key/value callbacks"
      contains: "snow_map_to_string"
    - path: "crates/snow-rt/src/collections/set.rs"
      provides: "snow_set_to_string runtime helper with element callback"
      contains: "snow_set_to_string"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Collection Display dispatch in wrap_to_string"
      contains: "snow_list_to_string"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "MIR Call to snow_list_to_string with element-to-string function pointer"
      pattern: "snow_list_to_string"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "Typeck Ty::App(Con(List), [elem_ty]) lookup for element type resolution"
      pattern: "Ty::App"
---

<objective>
Implement Display for collection types (List, Map, Set) via runtime callback helpers that accept element-to-string function pointers, with MIR lowering that resolves element types from typeck.

Purpose: Makes collections printable and usable in string interpolation. `to_string([1, 2, 3])` produces `"[1, 2, 3]"` instead of an opaque pointer representation.
Output: Working Display for List, Map, and Set with element-type-aware string conversion.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-extended-protocols/21-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Runtime collection-to-string helpers with callback function pointers</name>
  <files>
    crates/snow-rt/src/collections/list.rs
    crates/snow-rt/src/collections/map.rs
    crates/snow-rt/src/collections/set.rs
  </files>
  <action>
    1. In `crates/snow-rt/src/collections/list.rs`, add `snow_list_to_string`:
       ```
       #[no_mangle]
       pub extern "C" fn snow_list_to_string(
           list: *mut u8,
           elem_to_str: *mut u8,  // fn(u64) -> *mut u8 (returns SnowString ptr)
       ) -> *mut u8
       ```
       - Type-cast `elem_to_str` to `unsafe extern "C" fn(u64) -> *mut u8`
       - Get list length via `snow_list_length(list as *const u8)` (or equivalent internal access)
       - Build result string: start with `"["`, iterate elements via internal list data access (look at existing `snow_list_get` for the element access pattern), call elem_to_str on each element, separate with `", "`, end with `"]"`
       - Use `crate::string::snow_string_new` and `crate::string::snow_string_concat` for string building
       - Return the final SnowString pointer as `*mut u8`

    2. In `crates/snow-rt/src/collections/map.rs`, add `snow_map_to_string`:
       ```
       #[no_mangle]
       pub extern "C" fn snow_map_to_string(
           map: *mut u8,
           key_to_str: *mut u8,   // fn(u64) -> *mut u8
           val_to_str: *mut u8,   // fn(u64) -> *mut u8
       ) -> *mut u8
       ```
       - Iterate over map entries (keys and values). Look at the Map's internal structure to find how entries are stored -- likely a linear array of (key, value) pairs.
       - Build result: `"%{"` + `key_str => val_str, ...` + `"}"` format
       - Use key_to_str for keys, val_to_str for values

    3. In `crates/snow-rt/src/collections/set.rs`, add `snow_set_to_string`:
       ```
       #[no_mangle]
       pub extern "C" fn snow_set_to_string(
           set: *mut u8,
           elem_to_str: *mut u8,  // fn(u64) -> *mut u8
       ) -> *mut u8
       ```
       - Similar to list but with `#{` prefix and `}` suffix: `"#{elem1, elem2, ...}"`
       - Iterate over set elements using internal set data access

    IMPORTANT: These functions receive a bare function pointer, NOT a closure. The MIR lowerer will pass the address of the appropriate `Display__to_string__ElemType` or `snow_int_to_string` function. The env_ptr mentioned in the research is not needed since these are always bare functions (not closures).

    IMPORTANT: Check the internal structure of List, Map, Set carefully before writing iteration code. The `list.rs`, `map.rs`, `set.rs` files have existing functions that iterate -- follow those patterns exactly for element access.
  </action>
  <verify>
    `cargo build -p snow-rt` compiles cleanly.
    Runtime helper functions are `#[no_mangle] pub extern "C"` with correct signatures.
  </verify>
  <done>
    Three runtime helpers (snow_list_to_string, snow_map_to_string, snow_set_to_string) compiled and exported from snow-rt. Each accepts function pointer callbacks for element-to-string conversion.
  </done>
</task>

<task type="auto">
  <name>Task 2: MIR lowering for collection Display dispatch + intrinsics declarations</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
    1. In `crates/snow-codegen/src/codegen/intrinsics.rs`:
       - Declare `snow_list_to_string(list: *mut u8, fn_ptr: *mut u8) -> *mut u8`
       - Declare `snow_map_to_string(map: *mut u8, key_fn: *mut u8, val_fn: *mut u8) -> *mut u8`
       - Declare `snow_set_to_string(set: *mut u8, fn_ptr: *mut u8) -> *mut u8`
       - Follow same declaration pattern as other runtime function declarations

    2. In `crates/snow-codegen/src/mir/lower.rs`, modify `wrap_to_string` (or add `wrap_collection_to_string`):
       - Currently `wrap_to_string` handles primitives and user types. For `MirType::Ptr`, it needs to resolve the original `Ty` from typeck to determine if this is a List, Map, or Set.
       - When the expression is a collection type (determined by looking up the expression's `Ty` from the types map):
         - **List<ElemTy>**: `Ty::App(Con("List"), [elem_ty])` ->
           - Resolve elem_to_str function name: if elem_ty is Int -> `snow_int_to_string`, if String -> `snow_string_to_string` (or identity), if UserStruct -> `Display__to_string__StructName`
           - Emit: `snow_list_to_string(list_expr, elem_to_str_fn_ptr)`
         - **Map<KeyTy, ValTy>**: `Ty::App(Con("Map"), [key_ty, val_ty])` ->
           - Resolve key_to_str and val_to_str function names similarly
           - Emit: `snow_map_to_string(map_expr, key_to_str_fn_ptr, val_to_str_fn_ptr)`
         - **Set<ElemTy>**: `Ty::App(Con("Set"), [elem_ty])` ->
           - Resolve elem_to_str function name
           - Emit: `snow_set_to_string(set_expr, elem_to_str_fn_ptr)`
       - For the function pointer argument, emit a `MirExpr::Var` referencing the to_string function name, then cast/bitcast to `*mut u8` (MirType::Ptr). Check how other function pointer passing works in the existing codebase (e.g., actor spawn passes function pointers).

    3. Handle the Ty lookup challenge:
       - `wrap_to_string` receives a `MirExpr` but may not have access to the original `Ty`. Two approaches:
         a. Pass the `Ty` as an additional parameter to `wrap_to_string` when calling from string interpolation paths
         b. Store a mapping from expression to original Ty during lowering
       - The simplest approach: modify `wrap_to_string` to also accept an `Option<&Ty>`, and pass it from the string interpolation desugaring path where the typeck type is known. For other call sites, pass None (falls through to existing behavior).

    4. Add tests:
       - `list_display_emits_runtime_call`: verify that to_string on a `List<Int>` expression emits `snow_list_to_string` with `snow_int_to_string` callback
       - `map_display_emits_runtime_call`: verify that to_string on a `Map<String, Int>` emits `snow_map_to_string` with correct callbacks

    IMPORTANT: For `List<primitive>` Display, the callback function is a known runtime function (snow_int_to_string etc.). For `List<UserStruct>`, the callback is the mangled `Display__to_string__StructName` function. The MIR must reference these as function pointers.

    IMPORTANT: Nested collections (List<List<Int>>) are a known v1.3 limitation. If the element type is itself a collection, fall back to a placeholder like `"[...]"` or just emit a warning. Focus on List/Map/Set of primitives and user structs.
  </action>
  <verify>
    `cargo test --workspace` passes with zero regressions.
    `cargo test -p snow-codegen -- list_display` passes.
    `cargo build --workspace` compiles cleanly.
  </verify>
  <done>
    Collection Display dispatch works in MIR lowering. to_string on List/Map/Set emits runtime helper calls with appropriate element-to-string function pointer callbacks. Intrinsics declared for codegen.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` -- all existing tests pass plus new collection Display tests
- `cargo build --workspace` -- clean compilation
- Runtime helpers produce correct string format: List -> `[a, b, c]`, Map -> `%{k => v}`, Set -> `#{a, b, c}`
- MIR lowering resolves element types from typeck Ty::App and selects correct callback functions
- String interpolation with collections works via wrap_to_string -> collection dispatch
</verification>

<success_criteria>
- snow_list_to_string, snow_map_to_string, snow_set_to_string exist in snow-rt
- MIR lowering emits runtime calls with function pointer callbacks for element conversion
- Element type resolved from typeck Ty::App(Con("List"), [elem_ty])
- Primitives use runtime to_string functions as callbacks; user types use Display__to_string__TypeName
- All tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/21-extended-protocols/21-04-SUMMARY.md`
</output>
