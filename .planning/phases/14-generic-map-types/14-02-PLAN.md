---
phase: 14-generic-map-types
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - tests/e2e/map_literal.snow
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "Map literal %{\"name\" => \"Alice\", \"age\" => 30} parses without errors"
    - "Map literal type-checks correctly, inferring Map<String, Int> from entries"
    - "Map literal compiles to working native code that produces correct values"
    - "Empty map literal %{} works and produces an empty map"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "MAP_LITERAL and MAP_ENTRY syntax kind variants"
      contains: "MAP_LITERAL"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "parse_map_literal function in lhs() dispatch"
      contains: "parse_map_literal"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "MapLiteral AST node with entries() accessor"
      contains: "MapLiteral"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Type inference for MAP_LITERAL nodes"
      contains: "MAP_LITERAL"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "MIR desugaring of MAP_LITERAL to snow_map_new_typed + snow_map_put chain"
      contains: "MAP_LITERAL"
  key_links:
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "Parser produces MAP_LITERAL/MAP_ENTRY CST nodes"
      pattern: "MAP_LITERAL"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "Type checker walks MapLiteral AST node to infer entry types"
      pattern: "MapLiteral"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/collections/map.rs"
      via: "MIR lowering desugars map literal to snow_map_new_typed + snow_map_put calls"
      pattern: "snow_map_new_typed.*snow_map_put"
---

<objective>
Add map literal syntax `%{key => value, ...}` with full pipeline support: parser production, AST node, type inference, MIR desugaring, and e2e validation.

Purpose: This completes MAP-03 (map literal syntax). Users can write `%{"name" => "Alice", "age" => 30}` as a natural way to construct maps, instead of chaining Map.new() + Map.put() calls.
Output: New parser production, AST node, type inference support, MIR desugaring to map_new_typed + map_put chains, and passing e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-generic-map-types/14-RESEARCH.md
@.planning/phases/14-generic-map-types/14-01-SUMMARY.md

@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/expressions.rs
@crates/snow-parser/src/ast/expr.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parser and AST support for map literal syntax</name>
  <files>
crates/snow-parser/src/syntax_kind.rs
crates/snow-parser/src/parser/expressions.rs
crates/snow-parser/src/ast/expr.rs
  </files>
  <action>
Add map literal parsing: `%{key => value, key => value, ...}`

**A. crates/snow-parser/src/syntax_kind.rs:**

Add two new composite node kinds after `CLOSURE_CLAUSE` (or in the composite node section):
```rust
/// Map literal: `%{key => value, ...}`
MAP_LITERAL,
/// Single entry in a map literal: `key => value`
MAP_ENTRY,
```

Also add them to the `syntax_kind_has_enough_variants` test array in the test at the bottom of the file. Update the count assertion if needed.

**B. crates/snow-parser/src/parser/expressions.rs:**

1. In the `lhs()` function, add a new arm in the match before the `_ =>` fallback:
```rust
SyntaxKind::PERCENT => {
    if p.nth(1) == SyntaxKind::L_BRACE {
        Some(parse_map_literal(p))
    } else {
        // Bare % is not valid in lhs position (modulo is an infix op)
        p.error("expected expression");
        None
    }
}
```

Check that `p.nth(1)` is the correct API to peek one token ahead (look at how the parser peeks in other locations). It may be `p.at_n(1, SyntaxKind::L_BRACE)` or similar -- follow existing patterns.

2. Add the `parse_map_literal` function:
```rust
/// Parse a map literal: %{key1 => value1, key2 => value2, ...}
fn parse_map_literal(p: &mut Parser) -> MarkClosed {
    let m = p.open();
    p.advance(); // consume PERCENT
    p.expect(SyntaxKind::L_BRACE);

    // Handle empty map literal: %{}
    while !p.at(SyntaxKind::R_BRACE) && !p.at_end() {
        let entry = p.open();
        expr_bp(p, 0);                      // key expression
        p.expect(SyntaxKind::FAT_ARROW);     // =>
        expr_bp(p, 0);                      // value expression
        p.close(entry, SyntaxKind::MAP_ENTRY);

        if !p.at(SyntaxKind::R_BRACE) {
            if !p.eat(SyntaxKind::COMMA) {
                // Allow newlines as separators (skip_newlines may handle this)
                // If neither comma nor closing brace, break to avoid infinite loop
                if !p.at(SyntaxKind::NEWLINE) {
                    break;
                }
            }
        }
    }

    p.expect(SyntaxKind::R_BRACE);
    p.close(m, SyntaxKind::MAP_LITERAL)
}
```

Look at how `parse_struct_literal_body` handles comma/newline separation and follow the same pattern for consistency.

**C. crates/snow-parser/src/ast/expr.rs:**

Add an AST node for the map literal. Follow the pattern of existing AST nodes in this file (e.g., how StructLiteral, TupleExpr, etc. are defined). You need:

1. A `MapLiteral` struct wrapping a `SyntaxNode` (or however existing AST nodes are defined).
2. A `MapEntry` struct for individual entries.
3. Methods on `MapLiteral`:
   - `entries(&self) -> Vec<MapEntry>` -- returns child MAP_ENTRY nodes
4. Methods on `MapEntry`:
   - `key(&self)` -- returns the first child expression
   - `value(&self)` -- returns the second child expression (after FAT_ARROW)
5. Wire `MapLiteral` into the `Expr` enum if one exists, or add the appropriate match arm for `MAP_LITERAL` in the expression dispatch.

Check how existing AST nodes like `CallExpr`, `StructLiteral`, etc. are defined and follow the exact same pattern (trait implementations, From conversions, etc.).
  </action>
  <verify>
1. `cargo test -p snow-parser` -- all parser tests pass, new syntax kinds are recognized.
2. Write a quick smoke test: parse `%{"a" => 1, "b" => 2}` and verify the CST contains MAP_LITERAL with two MAP_ENTRY children. If the project has snapshot/parser tests, add one.
  </verify>
  <done>
Parser correctly produces MAP_LITERAL and MAP_ENTRY CST nodes for map literal syntax. AST provides MapLiteral node with entries() accessor. Empty map literals `%{}` parse correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Type inference, MIR desugaring, and e2e tests for map literals</name>
  <files>
crates/snow-typeck/src/infer.rs
crates/snow-codegen/src/mir/lower.rs
tests/e2e/map_literal.snow
crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Wire map literals through type inference and MIR lowering, then validate with e2e tests.

**A. crates/snow-typeck/src/infer.rs -- Type inference for map literals:**

Find where expressions are inferred (the main `infer_expr` or equivalent function that dispatches on expression kind). Add a case for `MAP_LITERAL`:

1. When encountering a `MapLiteral` node:
   - Create fresh type variables for K and V: `let k_ty = self.fresh_var()`, `let v_ty = self.fresh_var()`
   - For each `MapEntry` in the literal:
     - Infer the type of the key expression, unify with `k_ty`
     - Infer the type of the value expression, unify with `v_ty`
   - The result type is `Ty::map(k_ty, v_ty)`
   - Record this type for the MAP_LITERAL node's text range

2. For empty map literals `%{}`:
   - K and V remain as unconstrained type variables (resolved from context, same as `Map.new()`)

Look at how list literals or tuple expressions are inferred (if they exist) and follow the same pattern.

**B. crates/snow-codegen/src/mir/lower.rs -- MIR desugaring:**

Add handling for MAP_LITERAL in the expression lowering. Find the main `lower_expr` dispatch and add:

1. When encountering a `MapLiteral` AST node:
   - Determine key_type_tag from the resolved type: check `self.resolve_range(node.syntax().text_range())`. If the resolved type indicates String keys, use 1; otherwise 0. The resolved type after type inference should be `Ty::App("Map", [K, V])`. Check if K resolves to String.
   - Emit `snow_map_new_typed(key_type_tag)` as the initial value
   - For each entry in order, wrap the result in `snow_map_put(prev_result, key, value)`
   - The final result is the last snow_map_put call (or snow_map_new_typed for empty literals)

```rust
// Pseudocode for the desugaring:
let key_type_tag = if is_string_key_type(resolved_type) { 1 } else { 0 };
let mut result = MirExpr::Call {
    func: "snow_map_new_typed",
    args: vec![MirExpr::IntLit(key_type_tag)],
    ty: MirType::Ptr,
};
for entry in map_lit.entries() {
    let key = self.lower_expr(&entry.key());
    let val = self.lower_expr(&entry.value());
    result = MirExpr::Call {
        func: "snow_map_put",
        args: vec![result, key, val],
        ty: MirType::Ptr,
    };
}
result
```

To determine if the key type is String: extract the resolved Ty for the map literal from `self.types`, pattern match on `Ty::App(con, params)` where `con.name == "Map"` and `params[0]` is `Ty::Con("String")`. If the type is unresolved or Int, default to key_type_tag=0.

**C. E2E tests:**

1. Create `tests/e2e/map_literal.snow`:
```snow
fn main() do
  let m = %{"name" => "Alice", "age" => "30"}
  let name = Map.get(m, "name")
  println(name)
  let age = Map.get(m, "age")
  println(age)
  let sz = Map.size(m)
  println("${sz}")
end
```

Expected output:
```
Alice
30
2
```

Note: Use string values for all entries to keep types uniform (`Map<String, String>`). Mixing `"Alice"` (String) with `30` (Int) would be a type error since V must be consistent.

2. Create a second test for integer-key map literals:
Create `tests/e2e/map_literal_int.snow`:
```snow
fn main() do
  let m = %{1 => 10, 2 => 20, 3 => 30}
  let v = Map.get(m, 2)
  println("${v}")
  let sz = Map.size(m)
  println("${sz}")
end
```

Expected output:
```
20
3
```

3. Add e2e test functions in `crates/snowc/tests/e2e_stdlib.rs`:
```rust
#[test]
fn e2e_map_literal() {
    let output = run_snow_file("tests/e2e/map_literal.snow");
    assert_eq!(output.trim(), "Alice\n30\n2");
}

#[test]
fn e2e_map_literal_int() {
    let output = run_snow_file("tests/e2e/map_literal_int.snow");
    assert_eq!(output.trim(), "20\n3");
}
```

Follow the exact test function pattern used by existing e2e tests.
  </action>
  <verify>
1. `cargo test -p snow-typeck` -- type inference handles map literals correctly.
2. `cargo test -p snow-codegen` -- MIR lowering handles MAP_LITERAL nodes.
3. `cargo test --test e2e_stdlib -- e2e_map_literal` -- both map literal e2e tests pass.
4. `cargo test --test e2e_stdlib -- e2e_map` -- all map tests pass (basic, string_keys, literal, literal_int).
5. `cargo test` -- full suite, zero regressions.
  </verify>
  <done>
Map literal syntax `%{k => v}` works end-to-end: parsing, type inference, MIR desugaring to snow_map_new_typed + snow_map_put chains, and native execution. Both string-key and integer-key map literals produce correct results.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-parser` -- parser recognizes MAP_LITERAL, MAP_ENTRY syntax kinds
2. `cargo test -p snow-typeck` -- type inference for map literals works
3. `cargo test -p snow-codegen` -- MIR lowering desugars map literals correctly
4. `cargo test --test e2e_stdlib -- e2e_map` -- all four map e2e tests pass (basic, string_keys, literal, literal_int)
5. `cargo test` -- full test suite, zero regressions across all 24+ e2e tests and 60+ unit tests
</verification>

<success_criteria>
- `%{"name" => "Alice", "age" => "30"}` parses to MAP_LITERAL with MAP_ENTRY children
- Type inference infers Map<String, String> from string-key/string-value entries
- `%{1 => 10, 2 => 20}` works for integer maps
- Empty `%{}` produces an empty map
- Map literals desugar to snow_map_new_typed + snow_map_put chain in MIR
- All e2e tests pass with correct output
</success_criteria>

<output>
After completion, create `.planning/phases/14-generic-map-types/14-02-SUMMARY.md`
</output>
