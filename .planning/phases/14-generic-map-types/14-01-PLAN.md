---
phase: 14-generic-map-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/collections/map.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
autonomous: true

must_haves:
  truths:
    - "Map<String, Int> and Map<String, String> are valid types that compile without errors"
    - "Map.put(m, \"name\", \"Alice\") and Map.get(m, \"name\") compile and return correct values"
    - "Existing integer-key Map code (e2e_map_basic) continues to work without changes"
    - "Type inference correctly infers Map<K, V> generic parameters from usage"
  artifacts:
    - path: "crates/snow-rt/src/collections/map.rs"
      provides: "String-aware key comparison via key_type tag in map header"
      contains: "snow_map_new_typed"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Polymorphic Map function signatures with type variables K, V"
      contains: "Scheme"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Polymorphic Map builtin function types"
      contains: "Scheme"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Updated known_functions with typed map dispatch"
      contains: "snow_map_new_typed"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declaration for snow_map_new_typed"
      contains: "snow_map_new_typed"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Resolved Ty::App(Map, [K, V]) drives MIR type and runtime function selection"
      pattern: "resolve_range.*Map"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/collections/map.rs"
      via: "MIR lowering emits snow_map_new_typed(key_type_tag) calls"
      pattern: "snow_map_new_typed"
    - from: "crates/snow-rt/src/collections/map.rs"
      to: "crates/snow-rt/src/string.rs"
      via: "find_key dispatches to snow_string_eq for string keys"
      pattern: "snow_string_eq"
---

<objective>
Make the Map type fully generic across the entire compiler pipeline so that Map<String, Int>, Map<String, String>, and other key/value combinations compile and run correctly, while preserving backward compatibility with existing integer-key maps.

Purpose: This is the foundation for MAP-01 (generic Map<K,V>) and MAP-02 (string key support). Without this, maps are hardcoded to Map<Int, Int> and users cannot build maps with string keys.
Output: Runtime with key_type-aware comparison, polymorphic type signatures in typeck, updated MIR lowering and LLVM intrinsics. Existing e2e_map_basic test passes, and new string-key maps work end-to-end.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-generic-map-types/14-RESEARCH.md

@crates/snow-rt/src/collections/map.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/ty.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-rt/src/string.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Runtime key_type tag and string-aware key comparison</name>
  <files>crates/snow-rt/src/collections/map.rs</files>
  <action>
Modify the runtime map to support a key_type tag embedded in the capacity field, enabling string-key comparison:

1. Add constants: `KEY_TYPE_INT: u64 = 0`, `KEY_TYPE_STR: u64 = 1`, `TAG_SHIFT: u64 = 56`, `CAP_MASK: u64 = (1u64 << 56) - 1`. The tag occupies the upper 8 bits of the cap field (second u64 in the header). This gives 2^56 max capacity which is more than sufficient.

2. Add helper functions:
   - `unsafe fn map_key_type(m: *const u8) -> u64` -- extracts `(*((m as *const u64).add(1))) >> TAG_SHIFT`
   - `unsafe fn map_cap_raw(m: *const u8) -> u64` -- extracts `(*((m as *const u64).add(1))) & CAP_MASK`
   - `unsafe fn keys_equal(m: *const u8, a: u64, b: u64) -> bool` -- if `map_key_type(m) == KEY_TYPE_STR`, call `crate::string::snow_string_eq(a as *const crate::string::SnowString, b as *const crate::string::SnowString) != 0`; otherwise `a == b`

3. Update `find_key` to use `keys_equal(m, (*entries.add(i))[0], key)` instead of raw `(*entries.add(i))[0] == key`.

4. Update `alloc_map` to accept a `key_type: u64` parameter: `*((p as *mut u64).add(1)) = (key_type << TAG_SHIFT) | cap;`. The existing `alloc_map(cap)` calls should pass `0` for key_type (integer default). Also update `map_cap` to use `map_cap_raw` (mask off the tag).

5. Add new public function `snow_map_new_typed(key_type: i64) -> *mut u8`:
   ```rust
   #[no_mangle]
   pub extern "C" fn snow_map_new_typed(key_type: i64) -> *mut u8 {
       unsafe { alloc_map(0, key_type as u64) }
   }
   ```

6. Update existing `snow_map_new()` to call `alloc_map(0, KEY_TYPE_INT)` so it defaults to integer keys (backward compat).

7. When `snow_map_put` creates a new map (both the "key exists" and "add new entry" branches), the new map MUST preserve the key_type from the source map. Read `map_key_type(map)` and pass it to `alloc_map`. Same for `snow_map_delete`.

8. Add unit tests:
   - `test_map_string_keys`: create map with `snow_map_new_typed(1)`, put two string key/value pairs using `crate::string::snow_string_new`, verify `snow_map_get` returns correct values, verify `snow_map_has_key` works, verify `snow_map_size` is correct.
   - `test_map_string_key_overwrite`: put same string key twice with different values, verify the latest value is returned and size is 1.
   - Ensure all existing integer-key tests still pass unchanged.
  </action>
  <verify>
`cargo test -p snow-rt -- collections::map` -- all existing tests pass plus new string key tests pass.
  </verify>
  <done>
Runtime map supports key_type tag. Integer maps work as before. String-key maps compare by content via snow_string_eq. snow_map_new_typed is exposed as a C function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Polymorphic Map type signatures in typeck and generic MIR/codegen dispatch</name>
  <files>
crates/snow-typeck/src/infer.rs
crates/snow-typeck/src/builtins.rs
crates/snow-codegen/src/mir/lower.rs
crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
Update all four locations where Map function types are registered, plus add the codegen infrastructure for key-type dispatch:

**A. snow-typeck/src/infer.rs -- stdlib_modules() (lines ~330-340):**

Replace the monomorphic Map module registration with polymorphic Scheme types. Use high-numbered placeholder TyVars (90000, 90001) that `instantiate()` will replace with fresh vars:

```rust
let k_var = TyVar(90000);
let v_var = TyVar(90001);
let k = Ty::Var(k_var);
let v = Ty::Var(v_var);
let map_kv = Ty::map(k.clone(), v.clone());

let mut map_mod = HashMap::new();
map_mod.insert("new".to_string(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![], map_kv.clone()) });
map_mod.insert("put".to_string(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone(), k.clone(), v.clone()], map_kv.clone()) });
map_mod.insert("get".to_string(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone(), k.clone()], v.clone()) });
map_mod.insert("has_key".to_string(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone(), k.clone()], Ty::bool()) });
map_mod.insert("delete".to_string(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone(), k.clone()], map_kv.clone()) });
map_mod.insert("size".to_string(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone()], Ty::int()) });
map_mod.insert("keys".to_string(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone()], list_t.clone()) });
map_mod.insert("values".to_string(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone()], list_t.clone()) });
modules.insert("Map".to_string(), map_mod);
```

Note: `list_t` stays as `Ty::list_untyped()` since List generics are out of scope.

**B. snow-typeck/src/builtins.rs -- register_builtins() (lines ~316-347):**

Same approach for the bare-name builtins (map_new, map_put, map_get, etc.):

```rust
let k_var = TyVar(90000);
let v_var = TyVar(90001);
let k = Ty::Var(k_var);
let v = Ty::Var(v_var);
let map_kv = Ty::map(k.clone(), v.clone());

env.insert("map_new".into(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![], map_kv.clone()) });
env.insert("map_put".into(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone(), k.clone(), v.clone()], map_kv.clone()) });
env.insert("map_get".into(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone(), k.clone()], v.clone()) });
env.insert("map_has_key".into(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone(), k.clone()], Ty::bool()) });
env.insert("map_delete".into(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone(), k.clone()], map_kv.clone()) });
env.insert("map_size".into(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone()], Ty::int()) });
env.insert("map_keys".into(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone()], list_t.clone()) });
env.insert("map_values".into(), Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![map_kv.clone()], list_t.clone()) });
```

Replace the existing `let map_t = Ty::map_untyped();` and `Scheme::mono(...)` calls with the above. Keep `json_encode_map` using the old `map_t = Ty::map_untyped()` since the JSON module still uses untyped maps internally.

**C. snow-codegen/src/mir/lower.rs -- known_functions (lines ~271-278):**

The MIR lowering needs to handle Map.new() calls by dispatching to `snow_map_new_typed` with the correct key_type argument. The approach:

1. Add `snow_map_new_typed` to known_functions: `MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Ptr))`.
2. Keep `snow_map_new` as-is for backward compatibility (integer maps).
3. In the Map.new() lowering path (where `map_new` gets mapped to `snow_map_new`), intercept and check the resolved type. If the resolved Map type has String as key type, emit `snow_map_new_typed(1)` instead of `snow_map_new()`. If Int keys (or unresolved), emit `snow_map_new_typed(0)`.

   Find where `"map_new"` is resolved (in the `runtime_name` function around line 3473). Instead of changing the name mapping, modify the call lowering: when lowering a call to `snow_map_new`, check if we can determine the key type from the resolved type of the call expression (via `self.resolve_range()`). Wrap the call to include the key_type argument.

   Practical approach: In the `lower_call` or `lower_field_access` path where Map.new() is lowered, after resolving to `snow_map_new`, check the resolved MirType. If it resolves to `MirType::Ptr` from a `Ty::App("Map", [String, _])`, inject the key_type=1 argument. This requires checking `self.types` for the call site range. If the resolved Ty contains `Ty::Con("String")` as the first type parameter, use key_type=1; otherwise key_type=0.

   Simplest implementation: Replace `snow_map_new` mapping entirely with `snow_map_new_typed` in the `runtime_name` function. Then in the call lowering, when the target is `snow_map_new_typed` and args is empty, inject `MirExpr::IntLit(key_type_tag, MirType::Int)` as the argument. Determine `key_type_tag` from the resolved type of the call expression.

4. For `snow_map_put` and `snow_map_get`, the key argument type in MIR known_functions should be `MirType::Int` regardless (all values are u64 at runtime). String keys are passed as pointers cast to i64 via ptrtoint. The codegen already handles ptr-to-int casts for function arguments in many places. Verify this works by checking that string values passed to map_put get a `ptrtoint` cast if they are ptr type.

**D. snow-codegen/src/codegen/intrinsics.rs (lines ~247-254):**

Add the `snow_map_new_typed` LLVM declaration:
```rust
module.add_function("snow_map_new_typed", ptr_type.fn_type(&[i64_type.into()], false), Some(inkwell::module::Linkage::External));
```

Keep existing `snow_map_new` declaration for backward compat (JSON module may still call it directly).
  </action>
  <verify>
1. `cargo test -p snow-typeck` -- all type checker tests pass (existing code still infers correctly).
2. `cargo test -p snow-codegen` -- all codegen tests pass.
3. `cargo test --test e2e_stdlib -- e2e_map_basic` -- existing integer-key map e2e test passes.
4. `cargo build` -- full project compiles without errors.
  </verify>
  <done>
Map functions are polymorphic in the type checker. MIR lowering dispatches to snow_map_new_typed with the correct key_type. Existing integer-key maps work unchanged. The compiler can now type-check and compile Map<String, V> code.
  </done>
</task>

<task type="auto">
  <name>Task 3: String-key Map e2e test</name>
  <files>
tests/e2e/stdlib_map_string_keys.snow
crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Create an end-to-end test that proves string-key maps work through the full compiler pipeline:

1. Create `tests/e2e/stdlib_map_string_keys.snow`:
```snow
fn main() do
  let m = Map.new()
  let m = Map.put(m, "name", "Alice")
  let m = Map.put(m, "city", "Portland")
  let name = Map.get(m, "name")
  println(name)
  let sz = Map.size(m)
  println("${sz}")
  let has = Map.has_key(m, "name")
  println("${has}")
  let m = Map.put(m, "name", "Bob")
  let name2 = Map.get(m, "name")
  println(name2)
end
```

Expected output:
```
Alice
2
true
Bob
```

2. Add the e2e test function in `crates/snowc/tests/e2e_stdlib.rs` near the existing `e2e_map_basic` test:
```rust
#[test]
fn e2e_map_string_keys() {
    let output = run_snow_file("tests/e2e/stdlib_map_string_keys.snow");
    assert_eq!(output.trim(), "Alice\n2\ntrue\nBob");
}
```

Follow the exact pattern used by the existing `e2e_map_basic` test (look at how `run_snow_file` is called and what it returns).

3. Also verify the existing `e2e_map_basic` test still passes to confirm no regression.

If the string-key e2e test fails, debug the pipeline:
- Check if the type checker correctly infers Map<String, String> from usage.
- Check if MIR lowering emits snow_map_new_typed(1) for string-key maps.
- Check if codegen properly casts string pointers to i64 for map_put arguments.
- Check if the runtime's find_key uses string comparison for key_type=1 maps.

Fix any issues found during this debugging -- this is the integration validation point.
  </action>
  <verify>
`cargo test --test e2e_stdlib -- e2e_map_string_keys` passes with expected output.
`cargo test --test e2e_stdlib -- e2e_map_basic` still passes (no regression).
  </verify>
  <done>
String-key maps work end-to-end: Snow source -> parse -> typecheck -> MIR -> LLVM -> native binary -> correct output. Both string-key and integer-key maps coexist without regression.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-rt -- collections::map` -- all runtime tests pass (integer + string keys)
2. `cargo test -p snow-typeck` -- all type checker tests pass
3. `cargo test -p snow-codegen` -- all codegen tests pass
4. `cargo test --test e2e_stdlib -- e2e_map` -- both e2e_map_basic and e2e_map_string_keys pass
5. `cargo test` -- full test suite, zero regressions
</verification>

<success_criteria>
- Map<String, Int> and Map<String, String> compile and run correctly
- Map.put/get/has_key/delete/size/keys/values all work with string keys
- Existing integer-key Map code compiles and runs unchanged
- Type inference resolves Map<K, V> parameters from usage without explicit annotations
- Runtime string comparison uses snow_string_eq (content equality, not pointer identity)
</success_criteria>

<output>
After completion, create `.planning/phases/14-generic-map-types/14-01-SUMMARY.md`
</output>
