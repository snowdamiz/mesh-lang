---
phase: 95-react-frontend
plan: 05
type: execute
wave: 3
depends_on: ["95-01", "95-02"]
files_modified:
  - frontend/src/pages/live-stream.tsx
  - frontend/src/components/shared/event-card.tsx
  - frontend/src/pages/dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "Live Stream page shows real-time events as compact cards stacking from the top (newest first)"
    - "Live Stream has a filter bar matching Events page filters (search, level, environment)"
    - "Live Stream filters are sent to the WebSocket server via subscribe message"
    - "Dashboard charts and issue counts auto-update as new events arrive via WebSocket"
    - "WebSocket connection status is visible as a green/red dot in the header"
  artifacts:
    - path: "frontend/src/pages/live-stream.tsx"
      provides: "Real-time event streaming page with cards and filters"
    - path: "frontend/src/components/shared/event-card.tsx"
      provides: "Compact event card component for live stream"
  key_links:
    - from: "frontend/src/pages/live-stream.tsx"
      to: "frontend/src/stores/ws-store.ts"
      via: "WebSocket message subscription"
      pattern: "useWsStore"
    - from: "frontend/src/pages/live-stream.tsx"
      to: "frontend/src/hooks/use-websocket.ts"
      via: "WebSocket send for filter updates"
      pattern: "updateStreamFilters|ws\\.send"
    - from: "frontend/src/pages/dashboard.tsx"
      to: "frontend/src/stores/ws-store.ts"
      via: "Live update of chart data"
      pattern: "useWsStore"
---

<objective>
Build the Live Stream page (UI-05) and wire WebSocket integration into the Dashboard for real-time updates. The Live Stream page shows events as compact cards stacking from the top (newest first) with a filter bar that sends subscribe messages to the WebSocket server. The Dashboard's charts and issue counts auto-update when new events arrive.

Purpose: Real-time streaming is what makes the monitoring platform feel alive. Users can watch events flow in real-time, filter what they see, and the dashboard stays current without manual refresh.
Output: Live Stream page with real-time event cards and Dashboard with live WebSocket-driven updates.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/95-react-frontend/95-RESEARCH.md
@.planning/phases/95-react-frontend/95-01-SUMMARY.md
@.planning/phases/95-react-frontend/95-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build Live Stream page with real-time event cards and filter subscription</name>
  <files>
    frontend/src/pages/live-stream.tsx
    frontend/src/components/shared/event-card.tsx
    frontend/src/hooks/use-websocket.ts
  </files>
  <action>
    **Event Card (`event-card.tsx`):**
    Compact card component for the Live Stream page.
    - Props: `{ event: any (WsMessage event data), onClick?: () => void }`
    - Layout: single card with subtle border, compact padding
      - Top row: level badge (StatusBadge) + issue ID (mono, muted, truncated) + timestamp (relative time, right-aligned)
      - Bottom row: event message text (truncated to 2 lines)
    - Hover: subtle background change `hover:bg-accent`
    - Click: open event detail (via uiStore.openDetail)
    - Animate in: `animate-in fade-in slide-in-from-top-2 duration-200` (Tailwind animation)
    - Clean, minimal styling consistent with Linear aesthetic

    **Live Stream Page (`live-stream.tsx`):**
    Real-time event tail with filter bar at top and scrolling card list.

    State management:
    - `events: Array<WsEventData>` -- accumulate events from WebSocket, max 200 items (drop oldest beyond limit)
    - `filters: { level: string, environment: string, search: string }` -- current filter state
    - `paused: boolean` -- pause/resume button to stop accumulating while reading

    Layout:
    ```
    <div className="flex flex-col h-full">
      <div className="p-6 pb-4 border-b space-y-4">
        <div className="flex items-center justify-between">
          <h1 className="text-2xl font-semibold tracking-tight">Live Stream</h1>
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground">{eventCount} events</span>
            <Button variant="outline" size="sm" onClick={togglePause}>
              {paused ? <Play /> : <Pause />} {paused ? 'Resume' : 'Pause'}
            </Button>
            <Button variant="outline" size="sm" onClick={clearEvents}>
              Clear
            </Button>
          </div>
        </div>
        <FilterBar showSearch showLevel showEnvironment onFilterChange={handleFilterChange} />
      </div>
      <ScrollArea className="flex-1 p-6">
        <div className="space-y-2">
          {events.map(event => <EventCard key={event.id} event={event} />)}
        </div>
        {events.length === 0 && <EmptyState message="Waiting for events..." />}
      </ScrollArea>
    </div>
    ```

    WebSocket filter subscription:
    - When filters change, send a subscribe message to the WebSocket:
      ```typescript
      ws.send(JSON.stringify({
        type: 'subscribe',
        filters: { level: filters.level || '', environment: filters.environment || '' }
      }));
      ```
    - Add a `sendMessage` function to the useWebSocket hook that exposes the WebSocket send method. Update `use-websocket.ts` to return `{ sendMessage: (msg: string) => void }` alongside the store integration.
    - The ws-store needs a new field: `sendMessage: ((msg: string) => void) | null` set when connection opens, cleared on close.

    WebSocket event handling:
    - Subscribe to `useWsStore((s) => s.lastEvent)` with `useEffect`
    - When lastEvent is type 'event': prepend to events array (unless paused), respect 200 item limit
    - Client-side search filter: if search text is set, filter event message/data for matching text before display

    Clicking an event card opens event detail via push panel (if the event has an ID to look up; WS events may only have partial data -- show inline detail card if full API lookup not possible).
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` to verify all components compile.
  </verify>
  <done>
    Live Stream page shows real-time events as compact cards stacking from the top. Filter bar sends subscribe messages to WebSocket for server-side filtering. Pause/Resume button stops event accumulation. Clear button empties the list. Max 200 events in view with oldest dropped. Event cards animate in with fade/slide.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire WebSocket live updates into Dashboard charts and issue counts</name>
  <files>
    frontend/src/pages/dashboard.tsx
    frontend/src/stores/ws-store.ts
  </files>
  <action>
    **Enhance ws-store.ts:**
    Add a message counter and typed dispatch:
    - `eventCount: number` -- total events received in this session
    - `latestEventData: WsEventData | null` -- parsed event data for dashboard
    - `unresolvedCount: number | null` -- updated by issue_count messages
    - Dispatch handler in `onMessage`:
      ```typescript
      onMessage: (msg: WsMessage) => {
        set({ lastEvent: msg });
        switch (msg.type) {
          case 'event':
            set((s) => ({ eventCount: s.eventCount + 1, latestEventData: msg.data }));
            break;
          case 'issue_count':
            set({ unresolvedCount: msg.count });
            break;
          // other types stored for consumers
        }
      }
      ```

    **Enhance Dashboard (`dashboard.tsx`):**
    Wire live updates from ws-store into the dashboard components:

    1. **Health stats auto-update:**
       - Subscribe to `useWsStore((s) => s.unresolvedCount)`
       - When unresolvedCount changes, update the health stats display immediately (without re-fetching API)
       - Subscribe to `useWsStore((s) => s.eventCount)` for a live "events this session" counter

    2. **Volume chart live update:**
       - Subscribe to `useWsStore((s) => s.latestEventData)`
       - When a new event arrives, increment the count of the most recent bucket in the volume chart data
       - This provides immediate visual feedback without waiting for the next API poll
       - Periodically re-fetch from API (every 60 seconds) to correct any drift

    3. **Issue list live update:**
       - Subscribe to `useWsStore((s) => s.lastEvent)`
       - When an `issue` message arrives (action: resolved/archived), update the issue in the list or remove it
       - When an `issue_count` message arrives, update the issues header badge count
       - Periodically re-fetch top issues (every 60 seconds) for full accuracy

    4. **Add periodic refresh:**
       - Set up an interval (60s) to re-fetch all dashboard data
       - Clear interval on unmount
       - Skip refresh if page is not visible (use `document.hidden`)

    Ensure all live updates use React state updates correctly (functional updates to avoid stale closures).
  </action>
  <verify>
    Run `cd frontend && npx tsc --noEmit` to verify Dashboard and store changes compile.
    Run `cd frontend && npm run build` to verify production build succeeds.
  </verify>
  <done>
    Dashboard auto-updates in real-time: health stats reflect new event counts and unresolved issue counts from WebSocket. Volume chart's latest bucket increments on new events. Issue list updates on issue state changes. Periodic 60-second full refresh ensures accuracy. Live Stream page works with real-time cards and WebSocket filter subscription.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` passes
2. `cd frontend && npm run build` succeeds
3. Live Stream page at `/live` shows "Waiting for events..." initially
4. When WS is connected, new events appear as cards stacking from top
5. Pause/Resume and Clear buttons functional
6. Filter bar on Live Stream sends subscribe messages to WebSocket
7. Dashboard health stats update when issue_count messages arrive
8. Dashboard volume chart increments on new events
9. WebSocket status dot in header reflects connection state
</verification>

<success_criteria>
- Live Stream page shows compact event cards, newest first, stacking from top
- Live Stream has full filter bar (search, level, environment) matching Events page
- WebSocket subscribe message sent on filter changes
- Pause/Resume stops event accumulation for reading
- Max 200 events in view, oldest dropped
- Dashboard charts auto-update from WebSocket events
- Dashboard issue counts auto-update from WebSocket issue_count messages
- Periodic 60-second API refresh for data accuracy
- Event cards animate in with subtle animation
</success_criteria>

<output>
After completion, create `.planning/phases/95-react-frontend/95-05-SUMMARY.md`
</output>
