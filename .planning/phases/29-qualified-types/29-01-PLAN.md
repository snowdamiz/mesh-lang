---
phase: 29-qualified-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "apply(show, 42) compiles when show requires Display and Int implements Display"
    - "Constraints propagate through nested higher-order calls: wrap(apply, show, 42) compiles"
    - "apply(say_hello, 42) where Int does NOT implement Greetable produces TraitNotSatisfied"
    - "Pipe case: 42 |> apply(show) works when constraints satisfied (if applicable)"
    - "No regression: existing where-clause tests still pass"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Argument-level constraint check in infer_call and infer_pipe"
      contains: "arg_constraints"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "E2e tests for higher-order constraint propagation"
      contains: "e2e_qualified_type"
  key_links:
    - from: "infer_call argument loop"
      to: "fn_constraints map"
      via: "NameRef detection on arguments"
      pattern: "fn_constraints\\.get"
    - from: "infer_call argument loop"
      to: "trait_registry.check_where_constraints"
      via: "Resolved type args from instantiated function type"
      pattern: "check_where_constraints"
    - from: "infer_pipe argument loop"
      to: "fn_constraints map"
      via: "Mirror of infer_call argument check"
      pattern: "fn_constraints\\.get"
---

<objective>
Add argument-level trait constraint checking to `infer_call` and `infer_pipe` so that constrained functions passed as higher-order arguments have their constraints verified at the outer call site.

Purpose: Closes the last known limitation in Snow's type system -- `apply(show, 42)` silently drops Display constraint on `show` because parameter `f` inside `apply`'s body has no `fn_constraints` entry. The fix checks constraints on function-typed arguments at the OUTER call site, where type variables are connected via unification.

Output: Modified `infer_call` and `infer_pipe` with argument constraint checking, plus e2e tests for QUAL-01, QUAL-02, QUAL-03.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-qualified-types/29-RESEARCH.md
@.planning/phases/25-type-system-soundness/25-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add argument-level constraint check in infer_call and infer_pipe</name>
  <files>crates/snow-typeck/src/infer.rs</files>
  <action>
In `infer_call` (line 2671), after the existing callee-name constraint check block (lines 2713-2750, ending just before `Ok(ret_var)`), add a NEW block that iterates over call arguments to detect constrained-function arguments and check their constraints.

The logic, placed between the closing `}` of the callee-name check (line 2750) and `Ok(ret_var)` (line 2752):

```
// Check constraints on function-typed ARGUMENTS (higher-order case).
// When apply(show, 42) is called, show has fn_constraints but f inside
// apply's body does not. Check show's constraints HERE at the outer call site
// where unification has connected type variables to concrete argument types.
if let Some(arg_list) = call.arg_list() {
    for (arg_idx, arg) in arg_list.args().enumerate() {
        if let Expr::NameRef(ref name_ref) = arg {
            if let Some(arg_fn_name) = name_ref.text() {
                if let Some(arg_constraints) = fn_constraints.get(&arg_fn_name) {
                    if !arg_constraints.where_constraints.is_empty() && arg_idx < arg_types.len() {
                        // Resolve the argument's type (a function type after unification)
                        let resolved_arg_ty = ctx.resolve(arg_types[arg_idx].clone());

                        if let Ty::Fun(ref param_tys, _) = resolved_arg_ty {
                            let mut resolved_type_args: FxHashMap<String, Ty> = FxHashMap::default();

                            // Map parameter positions to type param names, resolve types
                            for (j, tp_name_opt) in arg_constraints.param_type_param_names.iter().enumerate() {
                                if let Some(tp_name) = tp_name_opt {
                                    if j < param_tys.len() {
                                        let resolved = ctx.resolve(param_tys[j].clone());
                                        resolved_type_args.insert(tp_name.clone(), resolved);
                                    }
                                }
                            }

                            // Fallback: definition-time vars (may be connected via unification)
                            for (param_name, param_ty) in &arg_constraints.type_params {
                                if !resolved_type_args.contains_key(param_name) {
                                    let resolved = ctx.resolve(param_ty.clone());
                                    resolved_type_args.insert(param_name.clone(), resolved);
                                }
                            }

                            // Only check constraints where type resolved to concrete (not Ty::Var)
                            let checkable: Vec<(String, String)> = arg_constraints.where_constraints
                                .iter()
                                .filter(|(pn, _)| {
                                    resolved_type_args.get(pn)
                                        .map(|ty| !matches!(ty, Ty::Var(_)))
                                        .unwrap_or(false)
                                })
                                .cloned()
                                .collect();

                            if !checkable.is_empty() {
                                let errors = trait_registry.check_where_constraints(
                                    &checkable,
                                    &resolved_type_args,
                                    origin.clone(),
                                );
                                ctx.errors.extend(errors);
                            }
                        }
                    }
                }
            }
        }
    }
}
```

IMPORTANT notes:
- Use `origin.clone()` since the origin variable is consumed by the callee-name check's `return Err`. Change the callee-name check on line 2740 to use `origin.clone()` instead of `origin` so origin remains available for the argument check below. (Currently the callee check passes `origin` by value to `check_where_constraints` and then `errors.into_iter().next()` may return early. To make `origin` available after that block, clone it where needed.)
- Do NOT return Err on argument constraint failures -- just extend `ctx.errors`. This avoids aborting inference early when multiple arguments have constraint issues. The callee-name check DOES return Err for backward compatibility; the argument check should be softer (errors are collected and reported after inference).
- The `Ty::Var` filter prevents false positives when type params haven't resolved yet.
- Only NameRef arguments are checked (per research: covers all practical cases).

Then mirror the same argument-level check in `infer_pipe` (line 2756). In the pipe's `Expr::CallExpr(call)` arm, after the callee-name constraint check block (around line 2869), add the same argument iteration but over the pipe call's explicit arguments only (NOT the piped lhs -- which is the first argument positionally but is not in `arg_list.args()`). The pipe case is `value |> apply(show)` which desugars to `apply(value, show)`. The explicit args from the call are `[show]`, which maps to `arg_types[0]`. Use `arg_types` (the explicit args) for the iteration, but when resolving the argument's function type, account for the offset: the explicit arg at index 0 in `arg_types` corresponds to positional index 1 in the full arg list (since lhs is at 0). However, the type stored in `arg_types[i]` is already the inferred type of that argument expression, so resolving it gives the correct function type for constraint checking. The position mapping for `param_type_param_names` uses the constrained function's own parameter positions, not the outer function's positions, so no offset is needed for that part.

Apply the same `origin.clone()` fix in `infer_pipe`'s callee-name check block as well.
  </action>
  <verify>
Run `cargo test -p snow-typeck` -- all existing tests pass with zero regressions. No new tests yet (Task 2 adds them), but no existing behavior should break.
  </verify>
  <done>
`infer_call` and `infer_pipe` both contain argument-level constraint checking logic that detects NameRef arguments with fn_constraints entries, resolves their type params from the instantiated function type after unification, filters to concrete types, and calls `check_where_constraints`. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2e tests for higher-order constraint propagation (QUAL-01, QUAL-02, QUAL-03)</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Add e2e tests in the existing test module in `crates/snow-codegen/src/mir/lower.rs`, after the `e2e_where_clause_alias_user_trait` test (line 8228). Follow the exact pattern of existing where-clause tests (parse source, run typeck, check for TraitNotSatisfied presence/absence).

**Test 1: `e2e_qualified_type_higher_order_apply` (QUAL-01 positive)**
Source: Define interface Displayable with `fn display(self) -> String`, impl for Int, define `fn show<T>(x :: T) -> String where T: Displayable do display(x) end`, define `fn apply(f, x) do f(x) end`, call `apply(show, 42)` in main.
Assert: NO TraitNotSatisfied error (Int implements Displayable).

**Test 2: `e2e_qualified_type_higher_order_violation` (QUAL-03)**
Source: Define interface Greetable with `fn greet(self) -> String` (NO impl for Int), define `fn say_hello<T>(x :: T) -> String where T: Greetable do greet(x) end`, define `fn apply(f, x) do f(x) end`, call `apply(say_hello, 42)` in main.
Assert: HAS TraitNotSatisfied error (Int does NOT implement Greetable).

**Test 3: `e2e_qualified_type_nested_higher_order` (QUAL-02)**
Source: Same Displayable/show setup, define `fn apply(f, x) do f(x) end`, define `fn wrap(f, g, x) do f(g, x) end`, call `wrap(apply, show, 42)` in main.
Assert: NO TraitNotSatisfied error (constraints propagate through nested levels).

**Test 4: `e2e_qualified_type_higher_order_conforming` (QUAL-01 positive with impl)**
Source: Define Displayable, impl for Int WITH actual display method, define show with where clause, define apply, call `apply(show, 42)`.
Assert: NO TraitNotSatisfied. This confirms no false positives when constraint IS satisfied.

**Test 5: `e2e_qualified_type_higher_order_let_alias` (QUAL-01 + Phase 25 interaction)**
Source: Same setup, but `let f = show; apply(f, 42)` in main.
Assert: NO TraitNotSatisfied (alias of constrained function passed as higher-order argument, conforming type).

Each test follows the exact pattern:
```rust
#[test]
fn e2e_qualified_type_xxx() {
    let source = r#"..."#;
    let parse = snow_parser::parse(source);
    let typeck = snow_typeck::check(&parse);
    let has_trait_error = typeck.errors.iter().any(|e| {
        matches!(e, snow_typeck::error::TypeError::TraitNotSatisfied { .. })
    });
    assert!(...);
}
```

Run full test suite after adding tests.
  </action>
  <verify>
Run `cargo test -p snow-codegen` -- all new tests pass. Then run `cargo test` for the full suite -- all 1,200+ tests pass with zero regressions.
  </verify>
  <done>
Five e2e tests cover: (1) basic higher-order apply with conforming type, (2) constraint violation error, (3) nested propagation, (4) conforming type positive case, (5) let-alias + higher-order interaction. All tests pass. Full test suite has zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` -- all typeck tests pass (constraint check doesn't break existing inference)
2. `cargo test -p snow-codegen` -- all codegen tests pass including 5 new QUAL tests
3. `cargo test` -- full suite passes (1,200+ tests, zero regressions)
4. Specifically verify the 4 existing where-clause tests still pass:
   - `e2e_where_clause_enforcement`
   - `e2e_where_clause_alias_propagation`
   - `e2e_where_clause_chain_alias`
   - `e2e_where_clause_alias_user_trait`
</verification>

<success_criteria>
- QUAL-01: `apply(show, 42)` compiles when Int implements the required trait (no false TraitNotSatisfied)
- QUAL-02: `wrap(apply, show, 42)` compiles via nested constraint propagation
- QUAL-03: `apply(say_hello, 42)` produces TraitNotSatisfied when Int does NOT implement the required trait
- All existing tests pass with zero regressions
- The fix is entirely within `infer_call` and `infer_pipe` in infer.rs -- no changes to Ty, Scheme, or codegen
</success_criteria>

<output>
After completion, create `.planning/phases/29-qualified-types/29-01-SUMMARY.md`
</output>
