---
phase: 102-mesher-rewrite
plan: 02
type: execute
wave: 2
depends_on: ["102-01"]
files_modified:
  - mesher/storage/queries.mpl
autonomous: true

must_haves:
  truths:
    - "Simple CRUD functions (insert/get/list/update/delete for orgs, projects, users, memberships, sessions, issues, alert rules, alerts) use Repo/Query ORM calls instead of raw Pool.query"
    - "All converted functions preserve their existing signatures (same parameter names/types, same return types)"
    - "PG-function-dependent queries (create_user with crypt, authenticate_user, create_api_key with gen_random_bytes, create_session with gen_random_bytes) remain as raw Pool.query"
    - "Complex analytics/aggregation queries (keyset pagination, GROUP BY, window functions, JSONB extraction) remain as raw Pool.query"
    - "The file compiles and all function exports are intact"
  artifacts:
    - path: "mesher/storage/queries.mpl"
      provides: "ORM-backed CRUD functions + raw SQL for complex queries"
      contains: "Repo.insert"
  key_links:
    - from: "mesher/storage/queries.mpl"
      to: "Repo.insert/get/all/update/delete"
      via: "ORM Repo module calls"
      pattern: "Repo\\."
    - from: "mesher/storage/queries.mpl"
      to: "Query.from/where/order_by"
      via: "ORM Query builder pipe chains"
      pattern: "Query\\."
    - from: "mesher/storage/queries.mpl"
      to: "Organization.__table__()"
      via: "Schema metadata for table names"
      pattern: "__table__"
---

<objective>
Convert approximately 25 simple CRUD functions in storage/queries.mpl from raw Pool.query/Pool.execute to ORM Repo/Query calls. Leave complex analytics, PG-function, and JSONB utility queries as raw SQL.

Purpose: This is the core of requirement MSHR-02 -- reducing 627 lines of raw SQL to approximately 100-150 lines of ORM query code plus raw SQL for complex queries. The conversion validates that the ORM API built in Phases 96-101 handles real-world CRUD patterns.
Output: Rewritten queries.mpl with ORM calls for simple CRUD and preserved raw SQL for complex/analytics queries.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/102-mesher-rewrite/102-RESEARCH.md
@.planning/phases/102-mesher-rewrite/102-01-SUMMARY.md
@mesher/storage/queries.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert organization, project, and API key CRUD to ORM</name>
  <files>mesher/storage/queries.mpl</files>
  <action>
Convert the simple CRUD functions for organizations, projects, and API keys in queries.mpl. Import Schema metadata types at the top of the file and add the RetentionSettings import.

**Add imports at top of file** (alongside existing imports):
```
from Types.Retention import RetentionSettings
```
Note: Organization, Project, ApiKey, User, OrgMembership, Session, Issue, Event, AlertRule, Alert are already imported.

**Organization queries -- convert all 3:**

`insert_org(pool, name, slug)`: Replace Pool.query INSERT with:
```
let fields = %{"name" => name, "slug" => slug}
let row = Repo.insert(pool, Organization.__table__(), fields)?
Ok(Map.get(row, "id"))
```

`get_org(pool, id)`: Replace Pool.query SELECT with:
```
let row = Repo.get(pool, Organization.__table__(), id)?
Ok(Organization { id: Map.get(row, "id"), name: Map.get(row, "name"), slug: Map.get(row, "slug"), created_at: Map.get(row, "created_at") })
```
Note: Repo.get returns Result<Map<String,String>, String> -- it already errors with "not found" style message if row doesn't exist.

`list_orgs(pool)`: Replace Pool.query SELECT with:
```
let q = Query.from(Organization.__table__())
  |> Query.order_by(:name, :asc)
let rows = Repo.all(pool, q)?
Ok(List.map(rows, fn(row) do
  Organization { id: Map.get(row, "id"), name: Map.get(row, "name"), slug: Map.get(row, "slug"), created_at: Map.get(row, "created_at") }
end))
```

**Project queries -- convert 3, keep 1 raw:**

`insert_project(pool, org_id, name, platform)`: Replace with Repo.insert using `Project.__table__()` and `%{"org_id" => org_id, "name" => name, "platform" => platform}`.

`get_project(pool, id)`: Replace with Repo.get using `Project.__table__()` then construct Project struct from Map.

`list_projects_by_org(pool, org_id)`: Replace with Query.from + Query.where + Query.order_by + Repo.all:
```
let q = Query.from(Project.__table__())
  |> Query.where(:org_id, org_id)
  |> Query.order_by(:name, :asc)
let rows = Repo.all(pool, q)?
```
Then map to Project structs.

`get_project_id_by_slug(pool, slug)`: Replace with Repo.get_by:
```
let row = Repo.get_by(pool, Project.__table__(), "slug", slug)?
Ok(Map.get(row, "id"))
```

**API key queries -- convert 2, keep 2 raw:**

`revoke_api_key(pool, key_id)`: Replace with Repo.update:
```
Repo.update(pool, ApiKey.__table__(), key_id, %{"revoked_at" => "now()"})?
```
WAIT -- Repo.update generates `SET revoked_at = $1` with the literal string "now()". This won't work. Keep as raw Pool.execute: `Pool.execute(pool, "UPDATE api_keys SET revoked_at = now() WHERE id = $1::uuid", [key_id])`. The PG `now()` function must be evaluated server-side.

`list_api_keys(pool, project_id)`: Replace with Query.from + Query.where + Query.order_by + Repo.all. BUT this query uses `COALESCE(revoked_at::text, '') AS revoked_at` for null handling. The ORM's Repo.all returns Map<String,String> and missing keys would cause Map.get to return "" anyway. However, the SQL must still handle the COALESCE for null columns. Keep as raw Pool.query since it has COALESCE null handling and cast patterns that the ORM can't replicate.

`create_api_key`: KEEP as raw Pool.query -- uses PG function `'mshr_' || encode(gen_random_bytes(24), 'hex')`.

`get_project_by_api_key`: KEEP as raw Pool.query -- uses JOIN between api_keys and projects with revoked_at IS NULL condition.

**Summary of conversions in this task:**
- CONVERT: insert_org, get_org, list_orgs, insert_project, get_project, list_projects_by_org, get_project_id_by_slug (7 functions)
- KEEP RAW: create_api_key, get_project_by_api_key, revoke_api_key, list_api_keys (4 functions -- PG functions, JOINs, COALESCE null handling)
  </action>
  <verify>
Run `cargo run --release -p meshc -- build mesher/ 2>&1 | tail -30` to verify compilation. All converted functions must compile without errors. Check that the import for RetentionSettings is present.
  </verify>
  <done>
7 organization/project functions converted to ORM Repo/Query calls. 4 API key functions remain as raw SQL (PG functions, JOINs). File compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert user, session, membership, issue management, and alert status queries to ORM</name>
  <files>mesher/storage/queries.mpl</files>
  <action>
Convert the remaining simple CRUD functions for users, sessions, memberships, issue management, and alert status updates.

**User queries -- keep 2 raw, convert 1:**

`create_user`: KEEP raw -- uses `crypt($2, gen_salt('bf', 12))` for PG-side password hashing. Security-critical.

`authenticate_user`: KEEP raw -- uses `crypt($2, password_hash)` for password verification. Security-critical.

`get_user(pool, id)`: Replace with Repo.get:
```
let row = Repo.get(pool, User.__table__(), id)?
Ok(User { id: Map.get(row, "id"), email: Map.get(row, "email"), display_name: Map.get(row, "display_name"), created_at: Map.get(row, "created_at") })
```

**Session queries -- keep 1 raw, convert 1, keep 1 raw:**

`create_session`: KEEP raw -- uses `encode(gen_random_bytes(32), 'hex')` for token generation.

`validate_session`: KEEP raw -- uses `expires_at > now()` time comparison that Query.where can't express.

`delete_session(pool, token)`: Convert to Repo.delete. BUT Session PK is `token`, not `id`. Repo.delete(pool, table, id) generates `WHERE "id" = $1`. Since Session has `primary_key :token`, check if Repo.delete uses the Schema's primary key or always uses "id". Looking at Phase 98: Repo.delete takes `(pool, table, id)` and uses hardcoded "id" column. This means we CANNOT use Repo.delete for sessions. KEEP as raw Pool.execute.

ACTUALLY, looking more carefully at the Phase 98 implementation, `Repo.delete(pool, table, id)` generates `DELETE FROM table WHERE "id" = $1 RETURNING *`. Since Session's PK is `token`, not `id`, this won't work. Keep delete_session as raw `Pool.execute(pool, "DELETE FROM sessions WHERE token = $1", [token])`.

**Membership queries -- convert all 3:**

`add_member(pool, user_id, org_id, role)`: Replace with Repo.insert:
```
let fields = %{"user_id" => user_id, "org_id" => org_id, "role" => role}
let row = Repo.insert(pool, OrgMembership.__table__(), fields)?
Ok(Map.get(row, "id"))
```

`get_members(pool, org_id)`: Replace with Query.from + Query.where + Repo.all, then map to OrgMembership structs.

`get_user_orgs(pool, user_id)`: Replace with Query.from + Query.where + Repo.all, then map to OrgMembership structs.

**Issue management queries -- convert 5, keep 2 raw:**

`resolve_issue(pool, issue_id)`: Keep as raw Pool.execute -- uses `WHERE status != 'resolved'` conditional guard and the ORM doesn't support conditional updates with status guards.

`archive_issue(pool, issue_id)`: Keep as raw Pool.execute -- same conditional update pattern.

`unresolve_issue(pool, issue_id)`: Keep as raw Pool.execute.

`discard_issue(pool, issue_id)`: Keep as raw Pool.execute.

`assign_issue(pool, issue_id, user_id)`: Keep as raw Pool.execute -- has conditional NULL assignment logic.

`delete_issue(pool, issue_id)`: Keep as raw Pool.execute -- multi-table delete (events then issues).

`list_issues_by_status(pool, project_id, status)`: Replace with Query.from + Query.where + Query.order_by + Repo.all:
```
let q = Query.from(Issue.__table__())
  |> Query.where(:project_id, project_id)
  |> Query.where(:status, status)
  |> Query.order_by(:last_seen, :desc)
let rows = Repo.all(pool, q)?
Ok(List.map(rows, fn(row) do
  Issue { id: Map.get(row, "id"), project_id: Map.get(row, "project_id"), fingerprint: Map.get(row, "fingerprint"), title: Map.get(row, "title"), level: Map.get(row, "level"), status: Map.get(row, "status"), event_count: parse_event_count(Map.get(row, "event_count")), first_seen: Map.get(row, "first_seen"), last_seen: Map.get(row, "last_seen"), assigned_to: Map.get(row, "assigned_to") }
end))
```
BUT: The original SQL uses `COALESCE(assigned_to::text, '') as assigned_to` and `event_count::text`. The ORM's Repo.all returns Map<String,String> which may have missing keys for NULL columns. The `event_count` needs `::text` cast. Keep this as raw Pool.query due to the cast and COALESCE requirements.

REVISED: Keep `list_issues_by_status` as raw SQL due to `::text` casts and COALESCE for nullable assigned_to.

**Alert status queries -- convert 2, keep rest raw:**

`toggle_alert_rule(pool, rule_id, enabled_str)`: Keep raw -- uses `$2::boolean` cast.

`delete_alert_rule(pool, rule_id)`: Convert to Repo.delete:
```
Repo.delete(pool, AlertRule.__table__(), rule_id)
```
This works because AlertRule uses default PK "id".

`acknowledge_alert(pool, alert_id)`: Keep raw -- uses `SET acknowledged_at = now()` with status guard `WHERE status = 'active'`.

`resolve_fired_alert(pool, alert_id)`: Keep raw -- uses `SET resolved_at = now()` with `WHERE status IN ('active', 'acknowledged')`.

**Membership management queries (ORG-04) -- convert 1, keep 2 raw:**

`update_member_role(pool, membership_id, new_role)`: Keep raw -- SQL-side role validation `$2 IN ('owner', 'admin', 'member')`.

`remove_member(pool, membership_id)`: Convert to Repo.delete:
```
Repo.delete(pool, OrgMembership.__table__(), membership_id)
```

`get_members_with_users(pool, org_id)`: Keep raw -- uses JOIN between org_memberships and users.

**Retention/settings queries -- convert 2, keep 3 raw:**

`get_all_project_retention(pool)`: Replace with Query.from + Repo.all:
```
let q = Query.from(RetentionSettings.__table__())
  |> Query.select(["id", "retention_days"])
```
BUT RetentionSettings.__table__() returns "projects" and we need `id::text` and `retention_days::text` casts. Keep as raw SQL.

REVISED: Keep `get_all_project_retention` as raw SQL due to `::text` casts.

`get_project_settings(pool, project_id)`: Keep raw -- selects only 2 specific columns with `::text` casts.

`update_project_settings`: Keep raw -- uses `$2::jsonb->>'retention_days'` JSONB extraction.

`delete_expired_events`: Keep raw -- uses `now() - ($2 || ' days')::interval`.

`check_sample_rate`: Keep raw -- uses `random()` and `COALESCE`.

**Summary of conversions in this task:**
- CONVERT: get_user, add_member, get_members, get_user_orgs, delete_alert_rule, remove_member (6 functions)
- KEEP RAW: create_user, authenticate_user, create_session, validate_session, delete_session, resolve_issue, archive_issue, unresolve_issue, discard_issue, assign_issue, delete_issue, list_issues_by_status, toggle_alert_rule, acknowledge_alert, resolve_fired_alert, update_member_role, get_members_with_users, get_all_project_retention, get_project_settings, update_project_settings, delete_expired_events, check_sample_rate (22 functions)
  </action>
  <verify>
Run `cargo run --release -p meshc -- build mesher/ 2>&1 | tail -30` to verify compilation. All converted functions must compile without errors. Verify that the ORM import pattern (Repo.insert, Repo.get, Query.from, etc.) is used in the file.
  </verify>
  <done>
13 total simple CRUD functions converted to ORM calls across both tasks (7 from Task 1 + 6 from Task 2). Approximately 35-40 functions remain as raw SQL (complex queries, PG functions, JSONB extraction, conditional updates, JOINs, casts). File compiles without errors and all function exports preserved.
  </done>
</task>

</tasks>

<verification>
1. `cargo run --release -p meshc -- build mesher/ 2>&1` compiles without errors
2. queries.mpl contains `Repo.insert`, `Repo.get`, `Repo.delete`, `Query.from`, `Query.where`, `Query.order_by` calls
3. queries.mpl still contains raw `Pool.query` and `Pool.execute` for complex queries
4. All 62 original function signatures are preserved (same pub fn names, same parameter types, same return types)
5. No missing imports for ORM modules (Repo, Query are built-in modules, no explicit import needed)
</verification>

<success_criteria>
- ~13 simple CRUD functions use ORM Repo/Query calls instead of raw SQL
- ~49 complex/PG-function/analytics queries remain as raw Pool.query/Pool.execute (intentionally)
- All function signatures preserved -- callers don't need changes
- queries.mpl compiles without errors
- Net reduction from 627 lines to approximately 400-450 lines (ORM calls are more concise than manual Pool.query + row extraction + struct construction)
</success_criteria>

<output>
After completion, create `.planning/phases/102-mesher-rewrite/102-02-SUMMARY.md`
</output>
