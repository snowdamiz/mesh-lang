---
phase: 40-visibility-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/lib.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snowc/src/main.rs
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "A function without `pub` is not included in ExportedSymbols.functions"
    - "A struct without `pub` is not included in ExportedSymbols.struct_defs"
    - "A sum type without `pub` is not included in ExportedSymbols.sum_type_defs"
    - "Trait defs and trait impls remain unconditionally exported (XMOD-05)"
    - "Attempting to import a private item produces a PrivateItem error with 'add pub' suggestion"
    - "Attempting to import a truly nonexistent name still produces ImportNameNotFound"
    - "Existing cross-module e2e tests pass after adding pub to exported items"
  artifacts:
    - path: "crates/snow-typeck/src/lib.rs"
      provides: "Visibility filtering in collect_exports, private_names field on ExportedSymbols"
      contains: "private_names"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "PrivateItem TypeError variant"
      contains: "PrivateItem"
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Diagnostic rendering for PrivateItem with 'add pub' help"
      contains: "PrivateItem"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Private name checking in FromImportDecl import resolution"
      contains: "private_names"
    - path: "crates/snowc/src/main.rs"
      provides: "private_names passed through build_import_context into ModuleExports"
      contains: "private_names"
  key_links:
    - from: "crates/snow-typeck/src/lib.rs"
      to: "ExportedSymbols"
      via: "collect_exports filters by visibility().is_some()"
      pattern: "visibility\\(\\)\\.is_some\\(\\)"
    - from: "crates/snowc/src/main.rs"
      to: "ModuleExports"
      via: "build_import_context passes private_names from ExportedSymbols to ModuleExports"
      pattern: "private_names"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "TypeError::PrivateItem"
      via: "import resolution checks private_names before emitting ImportNameNotFound"
      pattern: "PrivateItem"
---

<objective>
Add visibility enforcement to Snow's module system: filter exports by `pub` in collect_exports, add PrivateItem error type with diagnostic, update import resolution to distinguish private from nonexistent, and fix existing tests.

Purpose: Implements VIS-01 through VIS-05 -- items are private by default, `pub` makes them importable, and private access produces a helpful error.
Output: Working visibility enforcement with correct error messages. All existing tests green.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-visibility-enforcement/40-RESEARCH.md
@.planning/phases/39-cross-module-type-checking/39-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Filter collect_exports by pub, plumb private_names through pipeline</name>
  <files>
    crates/snow-typeck/src/lib.rs
    crates/snowc/src/main.rs
    crates/snowc/tests/e2e.rs
  </files>
  <action>
**1. Add `private_names` to `ExportedSymbols` (crates/snow-typeck/src/lib.rs ~line 91):**

Add a new field to `ExportedSymbols`:
```rust
/// Names of private (non-pub) items, for distinguishing "private" from "nonexistent" in errors.
pub private_names: rustc_hash::FxHashSet<String>,
```
Add `use rustc_hash::FxHashSet;` at the top if not already imported (FxHashMap is already imported from rustc_hash, so the crate is available).

**2. Filter `collect_exports` by visibility (crates/snow-typeck/src/lib.rs ~line 181-278):**

In the `collect_exports` function, modify the FnDef arm (~line 194) to check visibility:
```rust
Item::FnDef(fn_def) => {
    if let Some(name) = fn_def.name().and_then(|n| n.text()) {
        let range = fn_def.syntax().text_range();
        if let Some(ty) = typeck.types.get(&range) {
            if fn_def.visibility().is_some() {
                exports.functions.insert(name, Scheme::mono(ty.clone()));
            } else {
                exports.private_names.insert(name);
            }
        }
    }
}
```

For struct_defs (~line 213): iterate `tree.items()` to find StructDef items, check `struct_def.visibility().is_some()`. Only copy from `typeck.type_registry.struct_defs` if the AST item has visibility. Otherwise insert into `private_names`. The current code copies ALL from type_registry without visibility checks -- change it to iterate AST items and cross-reference:
```rust
// Replace the simple copy loop with AST-aware visibility check
for item in tree.items() {
    if let Item::StructDef(struct_def) = &item {
        if let Some(name) = struct_def.name().and_then(|n| n.text()) {
            if struct_def.visibility().is_some() {
                if let Some(def) = typeck.type_registry.struct_defs.get(&name) {
                    exports.struct_defs.insert(name, def.clone());
                }
            } else {
                exports.private_names.insert(name);
            }
        }
    }
}
```

For sum_type_defs (~line 216): same pattern -- iterate AST items, check `SumTypeDef::visibility().is_some()`, keep the builtin filter:
```rust
let builtin_sum_types = ["Option", "Result", "Ordering"];
for item in tree.items() {
    if let Item::SumTypeDef(sum_def) = &item {
        if let Some(name) = sum_def.name().and_then(|n| n.text()) {
            if !builtin_sum_types.contains(&name.as_str()) {
                if sum_def.visibility().is_some() {
                    if let Some(def) = typeck.type_registry.sum_type_defs.get(&name) {
                        exports.sum_type_defs.insert(name, def.clone());
                    }
                } else {
                    exports.private_names.insert(name);
                }
            }
        }
    }
}
```

For trait defs (~line 223): check `InterfaceDef::visibility().is_some()` before exporting. If NOT pub, insert into `private_names`. But keep trait impls unconditionally exported (XMOD-05):
```rust
for item in tree.items() {
    if let Item::InterfaceDef(iface) = item {
        if let Some(name) = iface.name().and_then(|n| n.text()) {
            if iface.visibility().is_some() {
                if let Some(trait_def) = typeck.trait_registry.get_trait(&name) {
                    exports.trait_defs.push(trait_def.clone());
                }
            } else {
                exports.private_names.insert(name);
            }
        }
    }
}
```

Trait impls (ImplDef) loop (~line 234-275): leave UNCHANGED -- impls are always exported.

**3. Add `private_names` to `ModuleExports` (crates/snow-typeck/src/lib.rs ~line 75):**

Add field:
```rust
/// Names of private items in this module (for "add pub" error messages).
pub private_names: rustc_hash::FxHashSet<String>,
```

**4. Update `build_import_context` to pass private_names (crates/snowc/src/main.rs ~line 425):**

In the `build_import_context` function, where `ModuleExports` is constructed (~line 425-430), add the `private_names` field:
```rust
let mod_exports = ModuleExports {
    module_name: full_name.clone(),
    functions: exports.functions.clone(),
    struct_defs: exports.struct_defs.clone(),
    sum_type_defs: exports.sum_type_defs.clone(),
    private_names: exports.private_names.clone(),
};
```

**5. Update existing Phase 39 e2e tests to add `pub` (crates/snowc/tests/e2e.rs):**

Add `pub` keyword to ALL exported items in cross-module test fixtures. The tests that need updating (non-main module files):

- `e2e_cross_module_qualified_function_call` (~line 1642): math.snow functions `add`, `mul` -> `pub fn add`, `pub fn mul`
- `e2e_cross_module_selective_import` (~line 1668): math.snow functions -> `pub fn add`, `pub fn mul`
- `e2e_cross_module_struct` (~line 1694): point.snow -> `pub struct Point`, `pub fn origin`
- `e2e_cross_module_sum_type` (~line 1721): shapes.snow -> `pub type Shape`, `pub fn area`
- `e2e_import_nonexistent_name_error` (~line 1770): math.snow -> `pub fn add` (it exports add; the test checks for nonexistent `subtract`)
- `e2e_nested_module_qualified_access` (~line 1794): math/vector.snow -> `pub fn dot`
- `e2e_cross_module_struct_via_function` (~line 1816): geometry.snow -> `pub struct Point`, `pub fn make_point`
- `e2e_cross_module_multiple_imports` (~line 1843): math.snow -> `pub fn add`, utils.snow -> `pub fn double`
- `e2e_import_nonexistent_module_error` (~line 1751): Only has main.snow (no exported module), leave unchanged.

Do NOT add `pub` to functions in `main.snow` -- entry module items do not need `pub`.

**Important:** The `e2e_cross_module_sum_type` test has a `type Shape` that needs `pub type Shape` and an `fn area` that needs `pub fn area`. The variant constructors (Circle, Rectangle) do NOT need individual `pub` -- they come with the `pub type`.
  </action>
  <verify>
Run `cargo test -p snowc --test e2e -- e2e_cross_module` to verify all existing cross-module tests pass with `pub` added. Then run `cargo test -p snow-typeck` to verify typeck unit tests still pass. Then run full workspace `cargo test` for zero regressions.
  </verify>
  <done>
All existing cross-module e2e tests pass with `pub` on exported items. collect_exports only exports items with visibility().is_some(). private_names field populated for non-pub items. ModuleExports carries private_names through build_import_context. Full test suite green.
  </done>
</task>

<task type="auto">
  <name>Task 2: PrivateItem TypeError, diagnostic, and import resolution check</name>
  <files>
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/diagnostics.rs
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
**1. Add `PrivateItem` variant to TypeError (crates/snow-typeck/src/error.rs):**

Add after `ImportNameNotFound` (~line 275):
```rust
/// Attempted to import a private (non-pub) item from a module (VIS-03).
PrivateItem {
    module_name: String,
    name: String,
    span: TextRange,
},
```

**2. Add Display impl for PrivateItem (crates/snow-typeck/src/error.rs):**

Add after the `ImportNameNotFound` Display arm (~line 570):
```rust
TypeError::PrivateItem { module_name, name, .. } => {
    write!(f, "`{}` is private in module `{}`; add `pub` to make it accessible", name, module_name)
}
```

**3. Add error code for PrivateItem (crates/snow-typeck/src/diagnostics.rs):**

Add after `ImportNameNotFound` error code (~line 127):
```rust
TypeError::PrivateItem { .. } => "E0035",
```

**4. Add diagnostic rendering for PrivateItem (crates/snow-typeck/src/diagnostics.rs):**

Add after the `ImportNameNotFound` diagnostic rendering block (~line 1479), before the closing `};`:
```rust
TypeError::PrivateItem { module_name, name, span } => {
    let msg = "private item cannot be imported";
    let range = clamp(text_range_to_range(*span));

    Report::build(ReportKind::Error, range.clone())
        .with_code(code)
        .with_message(msg)
        .with_config(config)
        .with_label(
            Label::new(range)
                .with_message(format!("`{}` is private in module `{}`", name, module_name))
                .with_color(Color::Red),
        )
        .with_help(format!("add `pub` to `{}` in module `{}` to make it accessible", name, module_name))
        .finish()
}
```

**5. Update import resolution in infer_item to check private_names (crates/snow-typeck/src/infer.rs):**

In the `FromImportDecl` handling (~line 1530-1543), the `else` block currently emits `ImportNameNotFound`. Before that, check if the name is in `mod_exports.private_names`:

Replace the final `else` block (currently at ~line 1530):
```rust
else {
    // Check if item exists but is private (VIS-03)
    if mod_exports.private_names.contains(&name) {
        ctx.errors.push(TypeError::PrivateItem {
            module_name: full_name.clone(),
            name: name.clone(),
            span: name_node.syntax().text_range(),
        });
    } else {
        // IMPORT-07: Name not found in module
        let available: Vec<String> = mod_exports.functions.keys()
            .chain(mod_exports.struct_defs.keys())
            .chain(mod_exports.sum_type_defs.keys())
            .cloned()
            .collect();
        ctx.errors.push(TypeError::ImportNameNotFound {
            module_name: full_name.clone(),
            name: name.clone(),
            span: name_node.syntax().text_range(),
            available,
        });
    }
}
```

Make sure `TypeError::PrivateItem` is imported or accessible (it should be, since `TypeError` is already used extensively in infer.rs).

**Note:** For `ImportDecl` (qualified import like `import Math`), private items are already excluded from `mod_exports.functions` by the collect_exports filtering. Attempting `Math.private_fn()` will produce a "no such field" or "unbound variable" error, which is acceptable. A specific PrivateItem error for qualified access is a nice-to-have but NOT required by VIS-03 (which specifies "attempting to import a private item").
  </action>
  <verify>
Run `cargo build -p snow-typeck` to verify compilation. Run `cargo test -p snow-typeck` for unit tests. Then write a quick manual check: `cargo test -p snowc --test e2e -- e2e_import_nonexistent_name` to confirm the existing "name not found" test still works (it tests a truly nonexistent name, not a private one).
  </verify>
  <done>
PrivateItem TypeError variant exists with error code E0035. Diagnostic renders with "add pub" help text. Import resolution in FromImportDecl distinguishes private items from nonexistent ones. Compilation succeeds. Existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- full workspace, zero regressions
2. `cargo test -p snowc --test e2e -- e2e_cross_module` -- all 8 cross-module tests pass with `pub`
3. `cargo test -p snowc --test e2e -- e2e_import` -- import error tests pass
4. Verify collect_exports in lib.rs contains `visibility().is_some()` checks for FnDef, StructDef, SumTypeDef, InterfaceDef
5. Verify `private_names` field exists on both ExportedSymbols and ModuleExports
</verification>

<success_criteria>
- collect_exports only exports pub items (fn, struct, sum type, interface)
- Trait impls remain unconditionally exported
- PrivateItem error with E0035 code and "add pub" suggestion exists
- Import resolution checks private_names before falling through to ImportNameNotFound
- All existing e2e tests pass with pub added to exported items
- Full cargo test suite green
</success_criteria>

<output>
After completion, create `.planning/phases/40-visibility-enforcement/40-01-SUMMARY.md`
</output>
