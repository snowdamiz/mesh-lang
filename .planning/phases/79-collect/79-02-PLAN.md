---
phase: 79-collect
plan: 02
type: execute
wave: 2
depends_on: ["79-01"]
files_modified:
  - tests/e2e/collect_list.mpl
  - tests/e2e/collect_map.mpl
  - tests/e2e/collect_set_string.mpl
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "User can write Iter.from(list) |> Iter.map(fn) |> List.collect() and get a new list with transformed elements"
    - "User can write Iter.from(list) |> Iter.enumerate() |> Map.collect() and get a map of index->value"
    - "User can write Iter.from(list) |> Set.collect() and get a deduplicated set"
    - "User can write Iter.from(words) |> String.collect() and get a concatenated string"
    - "Both List.collect(iter) direct-call and iter |> List.collect() pipe syntax work identically"
  artifacts:
    - path: "tests/e2e/collect_list.mpl"
      provides: "E2E tests for List.collect with map, filter, take pipelines and pipe syntax"
    - path: "tests/e2e/collect_map.mpl"
      provides: "E2E tests for Map.collect from enumerate and zip tuple iterators"
    - path: "tests/e2e/collect_set_string.mpl"
      provides: "E2E tests for Set.collect deduplication and String.collect concatenation"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "Test harness entries for 3 new collect E2E tests"
      contains: "e2e_collect_list"
  key_links:
    - from: "tests/e2e/collect_list.mpl"
      to: "crates/mesh-rt/src/iter.rs"
      via: "List.collect() call compiles to mesh_list_collect intrinsic"
      pattern: "List.collect"
    - from: "crates/meshc/tests/e2e.rs"
      to: "tests/e2e/collect_list.mpl"
      via: "read_fixture loads .mpl file, compile_and_run produces output"
      pattern: "collect_list.mpl"
---

<objective>
Add E2E tests verifying all four collect functions work end-to-end through the full compiler pipeline: Mesh source -> parse -> type check -> MIR -> LLVM -> execute -> verify output.

Purpose: Proves COLL-01 through COLL-04 requirements are met. Validates that pipe syntax (`iter |> List.collect()`), direct call syntax (`List.collect(iter)`), and multi-combinator pipelines all produce correct results.

Output: 3 E2E test files (.mpl), 3 test harness entries in e2e.rs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/79-collect/79-RESEARCH.md
@.planning/phases/79-collect/79-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: E2E tests for List.collect and Map.collect</name>
  <files>
    tests/e2e/collect_list.mpl
    tests/e2e/collect_map.mpl
    crates/meshc/tests/e2e.rs
  </files>
  <action>
Create two E2E test files and add their harness entries following the pattern in existing iterator E2E tests (e.g., iter_map_filter.mpl, iter_terminals.mpl).

**tests/e2e/collect_list.mpl (COLL-01):**

Test cases (all on single lines -- parser does not support multi-line pipe continuation):
1. Basic List.collect: `let list = [1, 2, 3]` then `let result = Iter.from(list) |> List.collect()` -- print length, should be 3.
2. Map + collect pipeline: `Iter.from(list) |> Iter.map(fn x -> x * 2 end) |> List.collect()` -- print the list with `to_string()`, expect `[2, 4, 6]`.
3. Filter + collect: `Iter.from([1, 2, 3, 4, 5]) |> Iter.filter(fn x -> x > 3 end) |> List.collect()` -- print with `to_string()`, expect `[4, 5]`.
4. Direct call syntax: `let iter = Iter.from([10, 20, 30])` then `let result = List.collect(iter)` -- print with `to_string()`, expect `[10, 20, 30]`.
5. Empty iterator: `Iter.from([1, 2, 3]) |> Iter.take(0) |> List.collect()` -- print length, expect `0`.

Use `println(result.to_string())` for list output and `println(List.length(result).to_string())` for length output.

Expected output (one per println): `3\n[2, 4, 6]\n[4, 5]\n[10, 20, 30]\n0\n`

**tests/e2e/collect_map.mpl (COLL-02):**

Test cases:
1. Enumerate + Map.collect: `let list = [100, 200, 300]` then `Iter.from(list) |> Iter.enumerate() |> Map.collect()` -- print the map with `to_string()`. Enumerate produces {index, value} tuples. Expected output: `%{0 => 100, 1 => 200, 2 => 300}`.
2. Zip + Map.collect: Create two lists `let keys = [10, 20, 30]` and `let vals = [1, 2, 3]`, then `Iter.from(keys) |> Iter.zip(Iter.from(vals)) |> Map.collect()` -- print with `to_string()`. Expected: `%{10 => 1, 20 => 2, 30 => 3}`.
3. Map size check: From test 1 result, print `Map.size(m).to_string()` -- expect `3`.

Expected output: `%{0 => 100, 1 => 200, 2 => 300}\n%{10 => 1, 20 => 2, 30 => 3}\n3\n`

**crates/meshc/tests/e2e.rs:**

Add two test harness entries following the existing pattern:
```rust
#[test]
fn e2e_collect_list() {
    let source = read_fixture("collect_list.mpl");
    let output = compile_and_run(&source);
    assert_eq!(output, "3\n[2, 4, 6]\n[4, 5]\n[10, 20, 30]\n0\n");
}

#[test]
fn e2e_collect_map() {
    let source = read_fixture("collect_map.mpl");
    let output = compile_and_run(&source);
    assert_eq!(output, "%{0 => 100, 1 => 200, 2 => 300}\n%{10 => 1, 20 => 2, 30 => 3}\n3\n");
}
```

NOTE: Map.to_string() output ordering may vary. If map output is not deterministic, adjust expected string to match actual ordering. Check existing map E2E tests for precedent on map string format.
  </action>
  <verify>
`cargo test -p meshc e2e_collect_list -- --nocapture` passes.
`cargo test -p meshc e2e_collect_map -- --nocapture` passes.
  </verify>
  <done>
List.collect works with map/filter/take pipelines and direct call syntax. Map.collect works with enumerate and zip tuple iterators. Both pipe syntax and direct call syntax produce correct output. Empty iterator collect produces empty list.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E tests for Set.collect and String.collect</name>
  <files>
    tests/e2e/collect_set_string.mpl
    crates/meshc/tests/e2e.rs
  </files>
  <action>
Create one combined E2E test file for Set.collect and String.collect, and add its harness entry.

**tests/e2e/collect_set_string.mpl (COLL-03 + COLL-04):**

Test cases:
1. Set.collect with deduplication: `let list = [1, 2, 2, 3, 3, 3]` then `Iter.from(list) |> Set.collect()` -- print `Set.size(s).to_string()`. Expect `3` (deduplicated).
2. Set.collect from pipeline: `Iter.from([1, 2, 3, 4, 5]) |> Iter.filter(fn x -> x > 2 end) |> Set.collect()` -- print `Set.size(result).to_string()`. Expect `3`.
3. Set.contains check: From test 1 result, check `Set.contains(s, 2)` -- print `to_string()`. Expect `true`.
4. String.collect: `let words = ["hello", " ", "world"]` then `Iter.from(words) |> String.collect()` -- print result. Expect `hello world`.
5. String.collect from map: `Iter.from(["a", "b", "c"]) |> String.collect()` -- print result. Expect `abc`.

Expected output: `3\n3\ntrue\nhello world\nabc\n`

**crates/meshc/tests/e2e.rs:**

Add one test harness entry:
```rust
#[test]
fn e2e_collect_set_string() {
    let source = read_fixture("collect_set_string.mpl");
    let output = compile_and_run(&source);
    assert_eq!(output, "3\n3\ntrue\nhello world\nabc\n");
}
```

After all tests pass, verify the total E2E test count increased by 3 (from 143 to 146).
  </action>
  <verify>
`cargo test -p meshc e2e_collect_set_string -- --nocapture` passes.
`cargo test -p meshc` -- all E2E tests pass (146 total, zero regressions).
`cargo test` -- full workspace test suite passes.
  </verify>
  <done>
Set.collect correctly deduplicates elements and works with filter pipelines. String.collect concatenates string elements from iterator. All four requirements (COLL-01 through COLL-04) have E2E coverage. Total E2E count is 146 (143 + 3 new).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p meshc` -- all 146 E2E tests pass
2. `cargo test` -- full workspace passes
3. Each requirement has at least one test:
   - COLL-01: e2e_collect_list (basic, pipeline, direct call, empty)
   - COLL-02: e2e_collect_map (enumerate, zip)
   - COLL-03: e2e_collect_set_string (dedup, contains, pipeline)
   - COLL-04: e2e_collect_set_string (string concat, multi-element)
</verification>

<success_criteria>
- 3 new E2E test files compile and run successfully
- List.collect handles empty iterators, mapped/filtered pipelines, and direct call syntax
- Map.collect works with enumerate (index->value) and zip (key->value) tuple iterators
- Set.collect deduplicates elements correctly
- String.collect concatenates string elements into single string
- Both pipe syntax (iter |> X.collect()) and direct call syntax (X.collect(iter)) work
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/79-collect/79-02-SUMMARY.md`
</output>
