---
phase: 79-collect
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-rt/src/iter.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
autonomous: true

must_haves:
  truths:
    - "List.collect(iter) materializes an iterator into a List by looping generic_next and collecting into Vec<u64> then mesh_list_from_array"
    - "Map.collect(iter) materializes an iterator of {key, value} tuples into a Map using mesh_map_put"
    - "Set.collect(iter) materializes an iterator into a Set using mesh_set_add"
    - "String.collect(iter) materializes a string iterator into a concatenated String using mesh_string_concat"
    - "All four collect functions are wired through stdlib_modules, map_builtin_name, and intrinsics"
  artifacts:
    - path: "crates/mesh-rt/src/iter.rs"
      provides: "mesh_list_collect, mesh_map_collect, mesh_set_collect, mesh_string_collect extern C functions"
      contains: "mesh_list_collect"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "collect type signatures in List, Map, Set, String stdlib modules"
      contains: "collect"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "list_collect, map_collect, set_collect, string_collect builtin name mappings"
      contains: "list_collect"
    - path: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM extern declarations for mesh_list_collect, mesh_map_collect, mesh_set_collect, mesh_string_collect"
      contains: "mesh_list_collect"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "stdlib module name -> map_builtin_name"
      pattern: "list_collect.*mesh_list_collect"
    - from: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      to: "crates/mesh-rt/src/iter.rs"
      via: "LLVM extern declaration -> runtime extern C function"
      pattern: "mesh_list_collect"
    - from: "crates/mesh-rt/src/iter.rs"
      to: "crates/mesh-rt/src/iter.rs"
      via: "collect functions call mesh_iter_generic_next in loop"
      pattern: "mesh_iter_generic_next"
---

<objective>
Add four collect terminal operations to the runtime (mesh_list_collect, mesh_map_collect, mesh_set_collect, mesh_string_collect) and wire them through the full compiler pipeline (type checker, MIR lowerer, LLVM intrinsics).

Purpose: Enables users to materialize lazy iterator pipelines into concrete collection types via List.collect(iter), Map.collect(iter), Set.collect(iter), and String.collect(iter). This is the final piece of the iterator ecosystem -- the "output" end that converts lazy pipelines back into concrete values.

Output: 4 runtime extern "C" functions, type signatures in 4 stdlib modules, 4 map_builtin_name entries, 4 LLVM intrinsic declarations.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/79-collect/79-RESEARCH.md
@.planning/phases/78-lazy-combinators-terminals/78-01-SUMMARY.md
@.planning/phases/78-lazy-combinators-terminals/78-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add four collect runtime functions to iter.rs</name>
  <files>
    crates/mesh-rt/src/iter.rs
    crates/mesh-rt/src/lib.rs
  </files>
  <action>
Add four new `extern "C"` functions to `crates/mesh-rt/src/iter.rs` following the terminal operation pattern established by `mesh_iter_count` and `mesh_iter_sum`. Each function loops calling `mesh_iter_generic_next` until MeshOption tag==1 (None), accumulating into the target collection.

**mesh_list_collect(iter: *mut u8) -> *mut u8:**
- CRITICAL: Do NOT use mesh_list_builder_new/push -- the builder has NO bounds checking and will corrupt memory for unknown-length iterators.
- Instead: collect all elements into a Rust `Vec<u64>` (safe, growable), then call `crate::collections::list::mesh_list_from_array(vec.as_ptr() as *const u64, vec.len() as i64)` to build the final GC-allocated list in one shot.
- Loop: call `mesh_iter_generic_next(iter)`, check `(*opt_ref).tag == 1` for None, push `(*opt_ref).value as u64` to Vec.

**mesh_map_collect(iter: *mut u8) -> *mut u8:**
- Create map with `crate::collections::map::mesh_map_new()` (integer keys).
- Loop: call `mesh_iter_generic_next(iter)`, extract tuple key at `*((tuple_ptr as *const u64).add(1))` and value at `*((tuple_ptr as *const u64).add(2))` -- same offset pattern as mesh_map_from_list (map.rs line 403-404).
- Call `crate::collections::map::mesh_map_put(map, key, val)` and reassign map (immutable semantics, returns new map).

**mesh_set_collect(iter: *mut u8) -> *mut u8:**
- Create set with `crate::collections::set::mesh_set_new()`.
- Loop: call `mesh_iter_generic_next(iter)`, `mesh_set_add(set, elem)` and reassign set.
- Duplicates handled automatically by mesh_set_add.

**mesh_string_collect(iter: *mut u8) -> *mut u8:**
- Start with empty string: `crate::string::mesh_string_new(std::ptr::null(), 0)`.
- Loop: call `mesh_iter_generic_next(iter)`, cast `(*opt_ref).value` to `*const crate::string::MeshString` (NOT to integer -- these are string pointers), call `crate::string::mesh_string_concat(result, str_ptr)`.
- Return the accumulated string pointer.

Add necessary imports at top of iter.rs for collections::list, collections::map, collections::set, and string modules.

In `crates/mesh-rt/src/lib.rs`, add the four new functions to the existing `pub use iter::{...}` block: `mesh_list_collect, mesh_map_collect, mesh_set_collect, mesh_string_collect`.

Add unit tests in iter.rs `#[cfg(test)]` module:
- test_list_collect: create a ListIterator from [10, 20, 30], call mesh_list_collect, verify length==3 and elements correct via mesh_list_get.
- test_map_collect: create an EnumerateAdapter from [100, 200], call mesh_map_collect, verify map has 2 entries via mesh_map_size.
- test_set_collect: create a ListIterator from [1, 2, 2, 3], call mesh_set_collect, verify size==3 (dedup).
- test_string_collect: skip if MeshString construction in test context is complex; runtime correctness verified by E2E tests.
  </action>
  <verify>
`cargo build -p mesh-rt` compiles without errors.
`cargo test -p mesh-rt` passes all existing tests plus new collect tests.
  </verify>
  <done>
Four extern "C" collect functions exist in iter.rs. mesh_list_collect uses safe Vec intermediary (not list builder). mesh_map_collect extracts tuple fields at correct offsets. mesh_set_collect handles deduplication. mesh_string_collect treats values as string pointers. All exported from lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire collect functions through compiler pipeline</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
Wire the four collect functions through the compiler's 3-layer stdlib resolution path, following the exact pattern used by Phase 78-02 for Iter methods.

**Type checker (crates/mesh-typeck/src/infer.rs, stdlib_modules()):**

In the **List module** section, add:
```
"collect" => Scheme with vars: [t_var], ty: Ty::fun(vec![Ty::Con(TyCon::new("Ptr"))], Ty::list(t.clone()))
```
The input is Ptr (opaque iterator handle -- all iterator types unify with Ptr via iterator_ptr_compatible). The return is List<T> (polymorphic).

In the **Map module** section, add:
```
"collect" => Scheme with vars: [k_var, v_var], ty: Ty::fun(vec![Ty::Con(TyCon::new("Ptr"))], map_kv_type)
```
Use the existing k_var/v_var and map type variables already defined in the Map module section.

In the **Set module** section, add:
```
"collect" => Scheme::mono(Ty::fun(vec![Ty::Con(TyCon::new("Ptr"))], set_type))
```
Use the existing set type variable from the Set module section.

In the **String module** section, add:
```
"collect" => Scheme::mono(Ty::fun(vec![Ty::Con(TyCon::new("Ptr"))], Ty::string()))
```
Input Ptr, output String. Monomorphic (no type vars needed).

**MIR lowerer (crates/mesh-codegen/src/mir/lower.rs, map_builtin_name()):**

Add four entries in the match arm or mapping table:
```
"list_collect" => "mesh_list_collect"
"map_collect" => "mesh_map_collect"
"set_collect" => "mesh_set_collect"
"string_collect" => "mesh_string_collect"
```

**LLVM intrinsics (crates/mesh-codegen/src/codegen/intrinsics.rs):**

Add four extern function declarations. All four have identical signature: fn(ptr) -> ptr.
```
module.add_function("mesh_list_collect", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
module.add_function("mesh_map_collect", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
module.add_function("mesh_set_collect", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
module.add_function("mesh_string_collect", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
```

Add corresponding test assertions in the intrinsics test function:
```
assert!(module.get_function("mesh_list_collect").is_some());
assert!(module.get_function("mesh_map_collect").is_some());
assert!(module.get_function("mesh_set_collect").is_some());
assert!(module.get_function("mesh_string_collect").is_some());
```
  </action>
  <verify>
`cargo build -p mesh-typeck` compiles.
`cargo build -p mesh-codegen` compiles.
`cargo test -p mesh-codegen -- intrinsics` passes (new assertions included).
`cargo test` -- full test suite passes with zero regressions.
  </verify>
  <done>
collect function is available in List, Map, Set, and String stdlib modules with correct type signatures. MIR lowerer maps list_collect/map_collect/set_collect/string_collect to mesh_* runtime names. LLVM intrinsics declared with fn(ptr)->ptr signature. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- full workspace compiles
2. `cargo test` -- all existing tests pass (143+ E2E tests, all unit tests)
3. Grep for all four functions in each layer:
   - `grep "mesh_list_collect" crates/mesh-rt/src/iter.rs` -- runtime function exists
   - `grep "collect" crates/mesh-typeck/src/infer.rs` -- type signatures in List/Map/Set/String modules
   - `grep "list_collect" crates/mesh-codegen/src/mir/lower.rs` -- MIR name mapping exists
   - `grep "mesh_list_collect" crates/mesh-codegen/src/codegen/intrinsics.rs` -- LLVM declaration exists
</verification>

<success_criteria>
- Four collect runtime functions compile and pass unit tests
- Type checker accepts `List.collect(iter)`, `Map.collect(iter)`, `Set.collect(iter)`, `String.collect(iter)` syntax
- MIR lowerer correctly maps all four function names to mesh_* runtime names
- LLVM intrinsics declared with correct fn(ptr)->ptr signature
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/79-collect/79-01-SUMMARY.md`
</output>
