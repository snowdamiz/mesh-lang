---
phase: 94-multi-node-clustering
plan: 02
type: execute
wave: 2
depends_on: ["94-01"]
files_modified:
  - mesher/ingestion/routes.mpl
  - mesher/ingestion/ws_handler.mpl
  - mesher/api/search.mpl
  - mesher/api/dashboard.mpl
  - mesher/api/detail.mpl
  - mesher/api/team.mpl
  - mesher/api/alerts.mpl
  - mesher/api/settings.mpl
  - mesher/api/helpers.mpl
autonomous: true

must_haves:
  truths:
    - "HTTP handlers discover PipelineRegistry via a cluster-aware lookup that works in both standalone and distributed modes"
    - "WebSocket handlers discover PipelineRegistry via the same cluster-aware lookup"
    - "StreamManager lookups remain node-local via Process.whereis (connection handles are local pointers)"
    - "Ws.broadcast calls automatically reach all cluster nodes (already cluster-aware since Phase 69, no code changes needed)"
    - "All existing API endpoints continue to function identically in standalone mode"
  artifacts:
    - path: "mesher/api/helpers.mpl"
      provides: "Shared get_registry() cluster-aware lookup helper"
      contains: "get_registry"
    - path: "mesher/ingestion/routes.mpl"
      provides: "HTTP handlers using cluster-aware registry lookup"
      contains: "get_registry"
    - path: "mesher/ingestion/ws_handler.mpl"
      provides: "WS handlers using cluster-aware registry lookup"
      contains: "get_registry"
  key_links:
    - from: "mesher/api/helpers.mpl"
      to: "Process.whereis + Global.whereis"
      via: "get_registry() tries local first, falls back to global"
      pattern: "Process\\.whereis.*Global\\.whereis"
    - from: "mesher/ingestion/routes.mpl"
      to: "mesher/api/helpers.mpl"
      via: "import get_registry from Api.Helpers"
      pattern: "from Api\\.Helpers import.*get_registry"
---

<objective>
Replace hardcoded `Process.whereis("mesher_registry")` calls across all Mesher HTTP and WS handlers with a cluster-aware `get_registry()` helper that tries local lookup first and falls back to global lookup. This enables cross-node service discovery while maintaining backward compatibility in standalone mode.

Purpose: Satisfies CLUSTER-03 (cross-node event routing via distributed service discovery) and CLUSTER-04 (distributed WebSocket broadcast -- already works since Phase 69; this plan ensures handlers can find the registry on any node). Every handler needs to find the PipelineRegistry to get the pool handle and service PIDs; making this lookup cluster-aware is the key integration point.
Output: Modified helpers.mpl with get_registry() function; all route/API handlers updated to use it.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/94-multi-node-clustering/94-RESEARCH.md
@.planning/phases/94-multi-node-clustering/94-01-SUMMARY.md
@mesher/ingestion/routes.mpl
@mesher/ingestion/ws_handler.mpl
@mesher/api/helpers.mpl
@mesher/api/search.mpl
@mesher/api/dashboard.mpl
@mesher/api/detail.mpl
@mesher/api/team.mpl
@mesher/api/alerts.mpl
@mesher/api/settings.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cluster-aware get_registry() helper to api/helpers.mpl</name>
  <files>mesher/api/helpers.mpl</files>
  <action>
Add a `get_registry()` function to `mesher/api/helpers.mpl` that provides cluster-aware PipelineRegistry lookup. This function tries local lookup first (fastest path -- zero network overhead) and falls back to global lookup when running in a cluster.

Add to `api/helpers.mpl` (define BEFORE existing functions that might use it, or at the top since it has no dependencies on other helpers):

```
# Cluster-aware registry lookup.
# Tries node-local Process.whereis first (zero overhead).
# Falls back to Global.whereis for cross-node discovery in cluster mode.
# In standalone mode, Process.whereis always succeeds (Global.whereis never called).
pub fn get_registry() do
  let local = Process.whereis("mesher_registry")
  if local != 0 do
    local
  else
    Global.whereis("mesher_registry")
  end
end
```

This must be exported (pub) so all API and route modules can import it.

The function must also be added to the export list -- any existing `from Api.Helpers import ...` lines in other files will need `get_registry` added to their import lists.

Key design rationale (from research):
- Every node runs its own PipelineRegistry, so `Process.whereis("mesher_registry")` will almost always succeed locally
- The `Global.whereis` fallback handles the edge case where a node just started and its own registry isn't ready yet, but a peer's is available
- `Process.whereis` returns 0 when name is not found (Pid type, 0 = not found)
- `Global.whereis` returns 0 when name is not found
- Do NOT use this pattern for `stream_manager` -- StreamManager MUST stay node-local
  </action>
  <verify>
Verify `get_registry` function exists in helpers.mpl with `pub fn` prefix. Verify it references both `Process.whereis` and `Global.whereis`.
  </verify>
  <done>
api/helpers.mpl exports a `get_registry()` function that provides cluster-aware PipelineRegistry discovery with local-first, global-fallback semantics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace Process.whereis("mesher_registry") with get_registry() across all handlers</name>
  <files>mesher/ingestion/routes.mpl, mesher/ingestion/ws_handler.mpl, mesher/api/search.mpl, mesher/api/dashboard.mpl, mesher/api/detail.mpl, mesher/api/team.mpl, mesher/api/alerts.mpl, mesher/api/settings.mpl</files>
  <action>
In every file that calls `Process.whereis("mesher_registry")`, replace that call with `get_registry()` and add `get_registry` to the file's import from `Api.Helpers`.

**Step 1: Update import lines** in each file to include `get_registry`:

For files that already import from Api.Helpers (like routes.mpl, search.mpl, etc.), add `get_registry` to the existing import list:
- `from Api.Helpers import require_param` becomes `from Api.Helpers import require_param, get_registry`
- `from Api.Helpers import query_or_default, to_json_array, require_param` becomes `from Api.Helpers import query_or_default, to_json_array, require_param, get_registry`

For files that do NOT import from Api.Helpers (like ws_handler.mpl, dashboard.mpl, detail.mpl, team.mpl, alerts.mpl, settings.mpl), add a new import line:
- `from Api.Helpers import get_registry`

**Step 2: Replace all occurrences** of `let reg_pid = Process.whereis("mesher_registry")` with `let reg_pid = get_registry()` in each file.

Files and expected replacement counts:
- `ingestion/routes.mpl`: ~11 occurrences (handle_event, handle_bulk, broadcast_issue_count, broadcast_event, handle_list_issues, handle_resolve_issue, handle_archive_issue, handle_unresolve_issue, handle_assign_issue, handle_discard_issue, handle_delete_issue)
- `ingestion/ws_handler.mpl`: 2 occurrences (handle_subscribe_update, handle_ingest_message)
- `api/search.mpl`: 4 occurrences
- `api/dashboard.mpl`: 6 occurrences
- `api/detail.mpl`: 1 occurrence
- `api/team.mpl`: 7 occurrences
- `api/alerts.mpl`: 7 occurrences
- `api/settings.mpl`: 3 occurrences

**Step 3: Do NOT replace** `Process.whereis("stream_manager")` calls in ws_handler.mpl. StreamManager MUST remain node-local because WS connection handles are raw pointers that are meaningless on remote nodes (research pitfall 2).

**Step 4: Also do NOT replace** the `Process.whereis("mesher_registry")` call in `ingestion/pipeline.mpl` inside the `health_checker` actor -- that one is intentionally checking the LOCAL registry health. Pipeline.mpl is not modified in this plan.

The mechanical replacement is: find `Process.whereis("mesher_registry")` -> replace with `get_registry()`. This is a safe text substitution because every occurrence follows the same `let reg_pid = Process.whereis("mesher_registry")` pattern.
  </action>
  <verify>
Run `cd /Users/sn0w/Documents/dev/snow && cargo run --bin meshc -- build mesher/ 2>&1` and confirm no NEW compilation errors beyond pre-existing baseline. Grep for remaining `Process.whereis("mesher_registry")` -- should only appear in pipeline.mpl (health_checker). All other files should use `get_registry()`.
  </verify>
  <done>
All HTTP and WS handler files use `get_registry()` for cluster-aware PipelineRegistry lookup. StreamManager lookups remain node-local via Process.whereis("stream_manager"). Pipeline health_checker retains its local-only check. Application compiles and all endpoints work identically in standalone mode.
  </done>
</task>

</tasks>

<verification>
1. `meshc build mesher/` compiles with no new errors beyond pre-existing baseline
2. `grep -r 'Process.whereis("mesher_registry")' mesher/` returns only pipeline.mpl (health_checker)
3. `grep -r 'get_registry()' mesher/` returns hits in all route/API/ws handler files
4. `grep -r 'Process.whereis("stream_manager")' mesher/` remains unchanged in ws_handler.mpl (4 occurrences)
5. `grep 'from Api.Helpers import' mesher/` shows get_registry in all importing files
</verification>

<success_criteria>
- All 41+ Process.whereis("mesher_registry") calls across handler files replaced with get_registry()
- get_registry() function exists in api/helpers.mpl with local-first, global-fallback logic
- StreamManager lookups (stream_manager) untouched -- remain node-local
- health_checker in pipeline.mpl retains local Process.whereis (intentional local health check)
- Application compiles cleanly and works identically in standalone mode
</success_criteria>

<output>
After completion, create `.planning/phases/94-multi-node-clustering/94-02-SUMMARY.md`
</output>
