---
phase: 83-completion-signature-help
plan: 02
type: execute
wave: 2
depends_on: [83-01]
files_modified:
  - crates/mesh-lsp/src/signature_help.rs
  - crates/mesh-lsp/src/server.rs
  - crates/mesh-lsp/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Typing inside function call parentheses shows parameter names and types"
    - "Active parameter highlighting advances as the user types each comma"
    - "Signature help is triggered by ( and , characters"
    - "LSP server advertises signatureHelpProvider capability with trigger characters"
  artifacts:
    - path: "crates/mesh-lsp/src/signature_help.rs"
      provides: "Signature help engine with call detection, parameter extraction, and active parameter tracking"
      contains: "compute_signature_help"
    - path: "crates/mesh-lsp/src/server.rs"
      provides: "signature_help handler and capability advertisement"
      contains: "signature_help_provider"
    - path: "crates/mesh-lsp/src/lib.rs"
      provides: "Module declaration for signature_help"
      contains: "pub mod signature_help"
  key_links:
    - from: "crates/mesh-lsp/src/server.rs"
      to: "crates/mesh-lsp/src/signature_help.rs"
      via: "crate::signature_help::compute_signature_help call from signature_help handler"
      pattern: "signature_help::compute_signature_help"
    - from: "crates/mesh-lsp/src/signature_help.rs"
      to: "crates/mesh-lsp/src/definition.rs"
      via: "source_to_tree_offset for CST coordinate conversion, find_definition for callee resolution"
      pattern: "source_to_tree_offset"
    - from: "crates/mesh-lsp/src/signature_help.rs"
      to: "crates/mesh-typeck/src/ty.rs"
      via: "Ty::Fun pattern match for parameter type extraction"
      pattern: "Ty::Fun"
---

<objective>
Implement LSP textDocument/signatureHelp for the Mesh language server, showing parameter names and types when the cursor is inside function call parentheses, with active parameter highlighting that advances with each comma.

Purpose: Users see parameter info and active parameter highlighting while typing function calls, covering requirements SIG-01 through SIG-03.
Output: signature_help.rs module, updated server.rs with handler and capability, updated lib.rs with module declaration.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/83-completion-signature-help/83-RESEARCH.md
@.planning/phases/83-completion-signature-help/83-01-SUMMARY.md
@crates/mesh-lsp/src/server.rs
@crates/mesh-lsp/src/definition.rs
@crates/mesh-lsp/src/analysis.rs
@crates/mesh-lsp/src/lib.rs
@crates/mesh-lsp/src/completion.rs
@crates/mesh-typeck/src/ty.rs
@crates/mesh-typeck/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create signature_help.rs with call detection and parameter extraction</name>
  <files>crates/mesh-lsp/src/signature_help.rs</files>
  <action>
Create `crates/mesh-lsp/src/signature_help.rs` implementing the signature help engine. The module must provide a single public function:

```rust
pub fn compute_signature_help(
    source: &str,
    analysis: &crate::analysis::AnalysisResult,
    position: &Position,
) -> Option<SignatureHelp>
```

**Step 1 -- Position conversion:**
- Convert LSP position to source byte offset using `crate::analysis::position_to_offset_pub`.
- Convert source byte offset to tree offset using `crate::definition::source_to_tree_offset`.
- If either fails, return None.

**Step 2 -- Find enclosing CALL_EXPR (SIG-01):**
- Use `root.token_at_offset(target).right_biased()` to find the token at the cursor.
- Walk upward from the token's parent, looking for a `SyntaxKind::ARG_LIST` node.
- When an ARG_LIST is found, verify its parent is a `SyntaxKind::CALL_EXPR`.
- Take the **innermost** CALL_EXPR to handle nested calls correctly: `foo(bar(x, |), y)` -- cursor at `|` should show signature for `bar`, not `foo`. The first ARG_LIST found walking upward IS the innermost.
- If no ARG_LIST is found, return None (cursor is not inside call parentheses).

**Step 3 -- Count commas for active parameter (SIG-02):**
- Within the found ARG_LIST node, count COMMA tokens whose `text_range().end()` is `<= tree_offset`.
- `active_parameter = comma_count` (0-indexed: first param = 0, after first comma = 1, etc.)

**Step 4 -- Extract callee name:**
- From the CALL_EXPR node, find the callee. The callee is typically the first child of CALL_EXPR that is NOT the ARG_LIST.
- For simple calls: the first NAME_REF child contains the function name (extract IDENT text).
- For qualified calls (Module.func): the first child is a FIELD_ACCESS containing a NAME_REF (module) and a NAME (function). Extract the function name from the NAME child, and form the full qualified name as "Module.func".
- For method calls (expr.method(args)): the callee is a FIELD_ACCESS where the second child (NAME) is the method name.
- Store the callee name string.

**Step 5 -- Look up function type from TypeckResult (SIG-01):**
- The TypeckResult stores `types: FxHashMap<TextRange, Ty>` using rowan tree-coordinate ranges.
- Strategy A: Look up the callee node's text range directly in `typeck.types`.
- Strategy B: If A fails, search `typeck.types` for the entire CALL_EXPR range -- the return type is stored there, but we need the function type. Instead, iterate over `typeck.types` and find entries where the range matches a NAME_REF/FIELD_ACCESS child of the CALL_EXPR.
- Strategy C: If both fail, iterate all entries in `typeck.types` looking for a `Ty::Fun` whose range overlaps with the callee node's range.
- If no `Ty::Fun` is found, return None.

**Step 6 -- Extract parameter names from CST (SIG-01):**
- For user-defined functions: use the go-to-definition infrastructure. Walk the CST (like `definition.rs`) to find the `FN_DEF` node for the callee. Then extract parameter names from its `PARAM_LIST` -> `PARAM` children (IDENT tokens or NAME children).
- Create a helper `find_fn_def_param_names(root, callee_name) -> Option<Vec<String>>` that searches `SOURCE_FILE` children for a `FN_DEF` with a matching NAME, then collects parameter names.
- For built-in functions (no FN_DEF found): use type-only labels from `Ty::Fun` params.

**Step 7 -- Build SignatureInformation:**
- For each parameter in `Ty::Fun(params, ret)`:
  - If a parameter name was found: label = `"{name}: {type}"`
  - If no name (builtin): label = `"{type}"`
  - Create `ParameterInformation { label: ParameterLabel::Simple(label_str), documentation: None }`
- Build the signature label: `"{callee_name}({param_labels_joined_by_comma}) -> {ret_type}"`
- Create `SignatureInformation { label, documentation: None, parameters: Some(param_infos), active_parameter: None }`
- Return `SignatureHelp { signatures: vec![sig_info], active_signature: Some(0), active_parameter: Some(active_parameter as u32) }`

**Tests (at least 4):**
1. `signature_help_simple_call` -- parse `fn add(a, b) do a + b end\nlet x = add(1, 2)` and verify signature help at cursor inside `add(1, 2)` returns a signature with 2 parameters
2. `signature_help_active_parameter_after_comma` -- parse `fn add(a, b) do a + b end\nlet x = add(1, )` and verify `active_parameter` is 1 when cursor is after the comma
3. `signature_help_no_call` -- parse `let x = 42` and verify signature help at cursor position returns None
4. `signature_help_first_parameter` -- parse `fn greet(name) do name end\nlet x = greet()` and verify `active_parameter` is 0 when cursor is right after `(`

**Edge case handling:**
- If cursor is on the opening `(` token itself, return the signature with active_parameter = 0.
- If the callee cannot be resolved (e.g., unknown function), return None gracefully.
- If typeck has no type for the callee, return None.
  </action>
  <verify>
`cargo build -p mesh-lsp` succeeds with no errors.
`cargo test -p mesh-lsp` passes all existing tests plus the 4+ new signature help tests.
  </verify>
  <done>
signature_help.rs exists with compute_signature_help function that detects CALL_EXPR from cursor position, counts commas for active_parameter, extracts callee type from TypeckResult, and builds SignatureHelp with parameter labels. All 4 new tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire signature help handler into server.rs and register module</name>
  <files>crates/mesh-lsp/src/server.rs, crates/mesh-lsp/src/lib.rs</files>
  <action>
**In lib.rs:**
- Add `pub mod signature_help;` to the module declarations (after `pub mod completion;`).

**In server.rs:**
- Add `signature_help_provider` to the `ServerCapabilities` in the `initialize` method (SIG-03):
  ```rust
  signature_help_provider: Some(SignatureHelpOptions {
      trigger_characters: Some(vec!["(".to_string(), ",".to_string()]),
      retrigger_characters: None,
      work_done_progress_options: Default::default(),
  }),
  ```
- Implement the `signature_help` method on `LanguageServer for MeshBackend`:
  ```rust
  async fn signature_help(
      &self,
      params: SignatureHelpParams,
  ) -> Result<Option<SignatureHelp>> {
      let uri_str = params.text_document_position_params.text_document.uri.to_string();
      let position = params.text_document_position_params.position;

      let docs = self.documents.lock().unwrap();
      let doc = match docs.get(&uri_str) {
          Some(doc) => doc,
          None => return Ok(None),
      };

      Ok(crate::signature_help::compute_signature_help(
          &doc.source,
          &doc.analysis,
          &position,
      ))
  }
  ```
- Update the `server_capabilities` test to assert both completion_provider AND signature_help_provider are Some:
  ```rust
  assert!(caps.completion_provider.is_some());
  assert!(caps.signature_help_provider.is_some());
  ```

**Verify the full integration works** by running `cargo build -p mesh-lsp` and `cargo test -p mesh-lsp`.
  </action>
  <verify>
`cargo build -p mesh-lsp` succeeds.
`cargo test -p mesh-lsp` passes all tests including the updated server_capabilities test.
The signature_help_provider capability is advertised with trigger characters `(` and `,`.
  </verify>
  <done>
server.rs has signature_help handler calling compute_signature_help, signature_help_provider capability advertised with `(` and `,` triggers, lib.rs declares signature_help module, all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p mesh-lsp` -- compiles without errors or warnings
2. `cargo test -p mesh-lsp` -- all tests pass (existing + new from Plan 01 + new from Plan 02)
3. Verify signature_help.rs contains: CALL_EXPR detection, comma counting, Ty::Fun pattern match, parameter name extraction
4. Verify server.rs advertises signature_help_provider with trigger_characters ["(", ","]
5. Verify lib.rs declares `pub mod signature_help`
</verification>

<success_criteria>
- SIG-01: Signature help shows parameter names and types inside function call parentheses
- SIG-02: Active parameter index advances with each comma
- SIG-03: Triggered by `(` and `,` characters (advertised in capability)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/83-completion-signature-help/83-02-SUMMARY.md`
</output>
