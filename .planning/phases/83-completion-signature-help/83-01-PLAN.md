---
phase: 83-completion-signature-help
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-lsp/src/completion.rs
  - crates/mesh-lsp/src/server.rs
  - crates/mesh-lsp/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Typing a partial keyword shows matching keyword completions"
    - "Typing a partial type name shows matching built-in type completions"
    - "Typing 'fn', 'let', 'struct', 'case', 'for', 'while', 'actor', 'interface', 'impl' shows snippet expansions"
    - "Typing inside a function body shows in-scope variable and function names from enclosing scopes"
    - "LSP server advertises completionProvider capability"
  artifacts:
    - path: "crates/mesh-lsp/src/completion.rs"
      provides: "Completion engine with keyword, type, snippet, and scope-aware name collection"
      contains: "compute_completions"
    - path: "crates/mesh-lsp/src/server.rs"
      provides: "completion handler and capability advertisement"
      contains: "completion_provider"
    - path: "crates/mesh-lsp/src/lib.rs"
      provides: "Module declaration for completion"
      contains: "pub mod completion"
  key_links:
    - from: "crates/mesh-lsp/src/server.rs"
      to: "crates/mesh-lsp/src/completion.rs"
      via: "crate::completion::compute_completions call from completion handler"
      pattern: "completion::compute_completions"
    - from: "crates/mesh-lsp/src/completion.rs"
      to: "crates/mesh-lsp/src/definition.rs"
      via: "source_to_tree_offset for CST coordinate conversion"
      pattern: "source_to_tree_offset"
---

<objective>
Implement LSP textDocument/completion for the Mesh language server with four completion tiers: keyword matching, built-in type matching, snippet expansions, and scope-aware variable/function name collection from CST walk.

Purpose: Users get intelligent code suggestions while typing Mesh code, covering all four requirement tiers (COMP-01 through COMP-04).
Output: completion.rs module, updated server.rs with handler and capability, updated lib.rs with module declaration.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/83-completion-signature-help/83-RESEARCH.md
@crates/mesh-lsp/src/server.rs
@crates/mesh-lsp/src/definition.rs
@crates/mesh-lsp/src/analysis.rs
@crates/mesh-lsp/src/lib.rs
@crates/mesh-lsp/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create completion.rs with four-tier completion engine</name>
  <files>crates/mesh-lsp/src/completion.rs</files>
  <action>
Create `crates/mesh-lsp/src/completion.rs` implementing the completion engine. The module must provide a single public function:

```rust
pub fn compute_completions(
    source: &str,
    analysis: &crate::analysis::AnalysisResult,
    position: &Position,
) -> Vec<CompletionItem>
```

**Tier 1 -- Keyword completions (COMP-01):**
- Define a static `KEYWORDS` array with all 48 Mesh keywords: `actor`, `after`, `and`, `break`, `call`, `case`, `cast`, `cond`, `continue`, `def`, `deriving`, `do`, `else`, `end`, `false`, `fn`, `for`, `from`, `if`, `impl`, `import`, `in`, `interface`, `let`, `link`, `match`, `module`, `monitor`, `not`, `or`, `pub`, `receive`, `return`, `self`, `send`, `service`, `spawn`, `struct`, `supervisor`, `terminate`, `trait`, `trap`, `true`, `type`, `when`, `where`, `while`, `with`
- Filter by prefix match. Use `CompletionItemKind::KEYWORD`.
- Set `sort_text` to `"2_{keyword}"` so keywords sort after scope names but before snippets.

**Tier 2 -- Built-in type completions (COMP-02):**
- Define a static `BUILTIN_TYPES` array: `Int`, `Float`, `String`, `Bool`, `List`, `Map`, `Set`, `Option`, `Result`, `Queue`, `Range`, `Pid`
- Filter by prefix match. Use `CompletionItemKind::STRUCT` (or `CLASS` for the generic types).
- Set `sort_text` to `"1_{type}"` so types sort high.

**Tier 3 -- Snippet completions (COMP-03):**
- Use `InsertTextFormat::Snippet` with `CompletionItemKind::SNIPPET`.
- Define these 9 snippets:
  - `fn` -> `fn ${1:name}(${2:params}) do\n  ${0}\nend`
  - `let` -> `let ${1:name} = ${0}`
  - `struct` -> `struct ${1:Name} do\n  ${0}\nend`
  - `case` -> `case ${1:expr} do\n  ${2:pattern} -> ${0}\nend`
  - `for` -> `for ${1:item} in ${2:collection} do\n  ${0}\nend`
  - `while` -> `while ${1:condition} do\n  ${0}\nend`
  - `actor` -> `actor ${1:Name}(${2:state}) do\n  ${0}\nend`
  - `interface` -> `interface ${1:Name} do\n  ${0}\nend`
  - `impl` -> `impl ${1:Trait} for ${2:Type} do\n  ${0}\nend`
- Set `sort_text` to `"3_{label}"` so snippets sort after keywords.
- Only include snippets whose label starts with the current prefix.

**Tier 4 -- Scope-aware name completions (COMP-04):**
- Implement a CST walk adapted from `definition.rs`'s `find_variable_or_function_def` pattern.
- Extract the prefix by scanning the source text backward from the cursor position to the last non-identifier character (avoid tree offset for prefix extraction per research recommendation -- `source_to_tree_offset` returns None inside whitespace).
- Convert the cursor position to a source byte offset using `crate::analysis::position_to_offset_pub`.
- Then convert to tree offset using `crate::definition::source_to_tree_offset` for CST traversal.
- Walk upward from the token at the tree offset:
  - At `BLOCK`/`SOURCE_FILE` nodes: collect names from `LET_BINDING`, `FN_DEF`, `ACTOR_DEF`, `SERVICE_DEF`, `MODULE_DEF`, `STRUCT_DEF`, `SUM_TYPE_DEF`, `INTERFACE_DEF`, `IMPL_DEF` children that appear before the cursor position (or all for `SOURCE_FILE` to handle forward references)
  - At `FN_DEF`/`CLOSURE_EXPR` nodes: collect parameter names from `PARAM_LIST`
- Deduplicate: inner-scope names shadow outer-scope names (skip name if already collected).
- Filter by prefix match.
- Use `CompletionItemKind::VARIABLE` for let bindings and parameters, `CompletionItemKind::FUNCTION` for fn/actor/service defs, `CompletionItemKind::MODULE` for modules, `CompletionItemKind::STRUCT` for struct defs, `CompletionItemKind::ENUM` for sum type defs, `CompletionItemKind::INTERFACE` for interface defs.
- Set `sort_text` to `"0_{name}"` so scope names sort first.

**Prefix extraction:**
- Extract the "word being typed" by scanning backward from the cursor byte offset in the source string, stopping at the first non-identifier character (not alphanumeric and not underscore).
- If cursor is at the start of a line or after whitespace/punctuation, prefix is empty -- return all completions (no filter).
- If prefix is empty and tree offset conversion fails (cursor in whitespace), still return keyword + type + snippet completions (they don't need CST context).

**Edge cases:**
- If `source_to_tree_offset` returns None (cursor in whitespace), skip scope-aware completions but still return keyword/type/snippet tiers.
- If `token_at_offset` returns `Between`, use `right_biased()`.
- Empty prefix returns all items (no prefix filter applied).

**Tests (at least 4):**
1. `keyword_completion_prefix_filter` -- verify "wh" matches "when", "where", "while" but not "fn" or "let"
2. `builtin_type_completion` -- verify "St" matches "String" but not "Int"
3. `scope_completion_finds_let_bindings` -- parse `let x = 1\nlet y = 2\n` and verify both "x" and "y" appear in scope completions at the end
4. `scope_completion_finds_fn_params` -- parse `fn add(a, b) do\n\nend` and verify "a" and "b" appear in scope completions inside the function body
  </action>
  <verify>
`cargo build -p mesh-lsp` succeeds with no errors.
`cargo test -p mesh-lsp` passes all existing tests plus the 4+ new completion tests.
  </verify>
  <done>
completion.rs exists with compute_completions function returning keyword, type, snippet, and scope-aware completions filtered by prefix. All 4 new tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire completion handler into server.rs and register module</name>
  <files>crates/mesh-lsp/src/server.rs, crates/mesh-lsp/src/lib.rs</files>
  <action>
**In lib.rs:**
- Add `pub mod completion;` to the module declarations (after `pub mod definition;`).

**In server.rs:**
- Add `completion_provider` to the `ServerCapabilities` in the `initialize` method:
  ```rust
  completion_provider: Some(CompletionOptions {
      trigger_characters: None, // completions triggered by typing any identifier character
      resolve_provider: Some(false),
      ..Default::default()
  }),
  ```
- Implement the `completion` method on `LanguageServer for MeshBackend`:
  ```rust
  async fn completion(
      &self,
      params: CompletionParams,
  ) -> Result<Option<CompletionResponse>> {
      let uri_str = params.text_document_position.text_document.uri.to_string();
      let position = params.text_document_position.position;

      let docs = self.documents.lock().unwrap();
      let doc = match docs.get(&uri_str) {
          Some(doc) => doc,
          None => return Ok(None),
      };

      let items = crate::completion::compute_completions(
          &doc.source,
          &doc.analysis,
          &position,
      );

      if items.is_empty() {
          Ok(None)
      } else {
          Ok(Some(CompletionResponse::Array(items)))
      }
  }
  ```
- Update the `server_capabilities` test to assert `completion_provider` is Some:
  ```rust
  assert!(caps.completion_provider.is_some());
  ```

**Verify the full integration works** by running `cargo build -p mesh-lsp` and `cargo test -p mesh-lsp`.
  </action>
  <verify>
`cargo build -p mesh-lsp` succeeds.
`cargo test -p mesh-lsp` passes all tests including the updated server_capabilities test.
The completion_provider capability is advertised in initialize response.
  </verify>
  <done>
server.rs has completion handler calling compute_completions, completion_provider capability advertised, lib.rs declares completion module, all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p mesh-lsp` -- compiles without errors or warnings
2. `cargo test -p mesh-lsp` -- all tests pass (existing + new)
3. Verify completion.rs contains: KEYWORDS array, BUILTIN_TYPES array, 9 snippet definitions, scope walk via CST
4. Verify server.rs advertises completion_provider capability
5. Verify lib.rs declares `pub mod completion`
</verification>

<success_criteria>
- COMP-01: Keyword completions filtered by prefix
- COMP-02: Built-in type completions filtered by prefix
- COMP-03: 9 snippet completions (fn, let, struct, case, for, while, actor, interface, impl)
- COMP-04: Scope-aware variable and function name completions from CST walk
- Capability advertised in initialize response
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/83-completion-signature-help/83-01-SUMMARY.md`
</output>
