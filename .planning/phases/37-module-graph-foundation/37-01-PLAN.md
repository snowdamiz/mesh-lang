---
phase: 37-module-graph-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-common/Cargo.toml
  - crates/snow-common/src/lib.rs
  - crates/snow-common/src/module_graph.rs
  - crates/snowc/src/discovery.rs
  - crates/snowc/src/main.rs
autonomous: true

must_haves:
  truths:
    - "ModuleId, ModuleInfo, and ModuleGraph types exist in snow-common and are public"
    - "File math/vector.snow maps to module name Math.Vector"
    - "File utils.snow maps to module name Utils"
    - "File math/linear_algebra.snow maps to module name Math.LinearAlgebra"
    - "main.snow in project root returns None from path_to_module_name (entry point, not a module)"
    - "discover_snow_files returns sorted relative paths for all .snow files in a directory tree"
    - "Hidden directories (starting with '.') are skipped during discovery"
  artifacts:
    - path: "crates/snow-common/src/module_graph.rs"
      provides: "ModuleId, ModuleInfo, ModuleGraph, CycleError types"
      exports: ["ModuleId", "ModuleInfo", "ModuleGraph", "CycleError"]
    - path: "crates/snowc/src/discovery.rs"
      provides: "File discovery and path-to-name mapping"
      exports: ["discover_snow_files", "path_to_module_name", "to_pascal_case"]
  key_links:
    - from: "crates/snowc/src/discovery.rs"
      to: "crates/snow-common/src/module_graph.rs"
      via: "uses ModuleId, ModuleInfo, ModuleGraph types"
      pattern: "use snow_common::module_graph"
---

<objective>
Create the ModuleGraph data structure in snow-common and file discovery + path-to-name mapping in snowc.

Purpose: Establish the foundational types (ModuleId, ModuleInfo, ModuleGraph) that all downstream phases (38-42) will use, plus the filesystem layer that discovers .snow files and converts paths to PascalCase module names.

Output: Two new source files -- `crates/snow-common/src/module_graph.rs` and `crates/snowc/src/discovery.rs` -- with full unit tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-module-graph-foundation/37-RESEARCH.md
@crates/snow-common/src/lib.rs
@crates/snow-common/Cargo.toml
@crates/snowc/src/main.rs
@crates/snowc/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: ModuleGraph types in snow-common</name>
  <files>
    crates/snow-common/Cargo.toml
    crates/snow-common/src/lib.rs
    crates/snow-common/src/module_graph.rs
  </files>
  <action>
1. Add `rustc-hash = { workspace = true }` to snow-common/Cargo.toml dependencies.

2. Add `pub mod module_graph;` to snow-common/src/lib.rs.

3. Create `crates/snow-common/src/module_graph.rs` with:

**ModuleId:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct ModuleId(pub u32);`

**ModuleInfo:**
```
pub struct ModuleInfo {
    pub id: ModuleId,
    pub name: String,          // PascalCase e.g. "Math.Vector"
    pub path: PathBuf,         // Relative to project root e.g. "math/vector.snow"
    pub dependencies: Vec<ModuleId>,
    pub is_entry: bool,        // true for main.snow
}
```

**CycleError:** `pub struct CycleError { pub cycle_path: Vec<String> }` -- derive Debug, Clone. Implement `std::fmt::Display` showing the cycle as `"A -> B -> C -> A"`.

**ModuleGraph:**
```
pub struct ModuleGraph {
    pub modules: Vec<ModuleInfo>,
    name_to_id: FxHashMap<String, ModuleId>,
}
```

Methods on ModuleGraph:
- `new() -> Self`
- `add_module(name: String, path: PathBuf, is_entry: bool) -> ModuleId` -- assigns sequential ID, inserts into name_to_id map
- `resolve(name: &str) -> Option<ModuleId>` -- lookup by PascalCase name
- `add_dependency(from: ModuleId, to: ModuleId)` -- push `to` into `from`'s dependencies
- `module_count() -> usize`
- `get(&self, id: ModuleId) -> &ModuleInfo`

Add unit tests in `#[cfg(test)] mod tests`:
- `test_add_and_resolve`: add two modules, resolve both by name, verify IDs
- `test_resolve_unknown`: returns None for unknown name
- `test_add_dependency`: add dependency edge, verify it appears in module's dependencies
- `test_entry_module`: add module with is_entry=true, verify flag
  </action>
  <verify>
Run `cargo test -p snow-common` -- all tests pass. Run `cargo check -p snow-common` -- no warnings.
  </verify>
  <done>
ModuleId, ModuleInfo, ModuleGraph, and CycleError are public types in snow-common. ModuleGraph supports add_module, resolve, add_dependency. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: File discovery and path-to-name mapping in snowc</name>
  <files>
    crates/snowc/src/discovery.rs
    crates/snowc/src/main.rs
  </files>
  <action>
1. Create `crates/snowc/src/discovery.rs` with two public functions:

**`to_pascal_case(s: &str) -> String`**: Convert snake_case to PascalCase. Split on `_`, capitalize first char of each non-empty part, join. Examples: "vector" -> "Vector", "linear_algebra" -> "LinearAlgebra", "my_cool_lib" -> "MyCoolLib".

**`path_to_module_name(relative_path: &Path) -> Option<String>`**: Convert a relative file path to a PascalCase module name. Returns None for `main.snow` in the project root (entry point). Convention:
- `math/vector.snow` -> `Some("Math.Vector")`
- `utils.snow` -> `Some("Utils")`
- `math/linear_algebra.snow` -> `Some("Math.LinearAlgebra")`
- `a/b/c/d.snow` -> `Some("A.B.C.D")`
- `main.snow` -> `None`

Logic: Check if file_stem is "main" AND parent is empty (or "."). If so, return None. Otherwise, collect directory components via `parent().components()` filtering for `Component::Normal`, convert each to PascalCase. Add file_stem converted to PascalCase. Join with ".".

**`discover_snow_files(project_root: &Path) -> Result<Vec<PathBuf>, String>`**: Recursively walk `project_root`, collect all `.snow` files, skip hidden dirs (names starting with '.'), return paths RELATIVE to project_root, sorted alphabetically for determinism. Adapt the pattern from existing `collect_snow_files_recursive` in main.rs but return relative paths instead of absolute.

2. In `crates/snowc/src/main.rs`, add `mod discovery;` near the top (after the use statements, before the Cli struct).

3. Add unit tests in discovery.rs `#[cfg(test)] mod tests`:
- `test_to_pascal_case`: "vector" -> "Vector", "linear_algebra" -> "LinearAlgebra", "a" -> "A", "already_long_name" -> "AlreadyLongName"
- `test_path_to_module_name_simple`: "utils.snow" -> Some("Utils")
- `test_path_to_module_name_nested`: "math/vector.snow" -> Some("Math.Vector")
- `test_path_to_module_name_snake_case`: "math/linear_algebra.snow" -> Some("Math.LinearAlgebra")
- `test_path_to_module_name_deeply_nested`: "a/b/c/d.snow" -> Some("A.B.C.D")
- `test_path_to_module_name_main`: "main.snow" -> None
- `test_discover_snow_files`: Use `tempfile::tempdir()`, create `main.snow`, `math/vector.snow`, `utils.snow`, `.hidden/secret.snow`. Verify discover returns exactly `["main.snow", "math/vector.snow", "utils.snow"]` (sorted, no hidden dir files). Paths must be relative to the temp dir root.
  </action>
  <verify>
Run `cargo test -p snowc` -- all new tests pass. Run `cargo check -p snowc` -- no warnings. Existing tests still pass.
  </verify>
  <done>
discover_snow_files recursively finds .snow files (skipping hidden dirs) and returns sorted relative paths. path_to_module_name converts paths to PascalCase module names (None for main.snow). All unit tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-common` passes all tests (ModuleGraph types)
2. `cargo test -p snowc` passes all tests (discovery + path-to-name)
3. `cargo check --workspace` compiles cleanly with no warnings
4. `cargo test --workspace` passes (no regressions)
</verification>

<success_criteria>
- ModuleId, ModuleInfo, ModuleGraph, CycleError types exist in snow-common and compile
- ModuleGraph supports add_module, resolve, add_dependency operations
- File discovery finds all .snow files recursively, skips hidden dirs, returns sorted relative paths
- Path-to-module-name handles snake_case -> PascalCase, nested dirs, and main.snow entry point
- All workspace tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/37-module-graph-foundation/37-01-SUMMARY.md`
</output>
