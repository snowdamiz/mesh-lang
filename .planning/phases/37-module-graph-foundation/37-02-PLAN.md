---
phase: 37-module-graph-foundation
plan: 02
type: execute
wave: 2
depends_on: ["37-01"]
files_modified:
  - crates/snow-common/src/module_graph.rs
  - crates/snowc/src/discovery.rs
autonomous: true

must_haves:
  truths:
    - "Import declarations in parsed files produce dependency edges in the ModuleGraph"
    - "Topological sort returns modules in dependency order (leaf modules first, entry module last)"
    - "A circular import chain (A -> B -> C -> A) returns CycleError with the cycle path"
    - "Diamond dependencies (A imports B and C, both import D) are NOT flagged as cycles"
    - "Self-import (module imports itself) produces a specific error before toposort runs"
    - "Deterministic ordering: same project always produces same compilation order regardless of platform"
    - "Unknown imports (stdlib or typos) are silently skipped in graph construction"
  artifacts:
    - path: "crates/snow-common/src/module_graph.rs"
      provides: "topological_sort function with Kahn's algorithm and cycle detection"
      exports: ["topological_sort"]
    - path: "crates/snowc/src/discovery.rs"
      provides: "extract_imports and build_module_graph functions"
      exports: ["extract_imports", "build_module_graph"]
  key_links:
    - from: "crates/snowc/src/discovery.rs"
      to: "snow_parser::parse"
      via: "Parses each .snow file to extract import declarations"
      pattern: "snow_parser::parse"
    - from: "crates/snowc/src/discovery.rs"
      to: "crates/snow-common/src/module_graph.rs"
      via: "build_module_graph constructs ModuleGraph and calls topological_sort"
      pattern: "ModuleGraph::new|add_module|add_dependency|topological_sort"
    - from: "crates/snow-common/src/module_graph.rs"
      to: "std::collections::VecDeque"
      via: "Kahn's BFS algorithm"
      pattern: "VecDeque"
---

<objective>
Implement topological sort (Kahn's algorithm) with cycle detection, import extraction from parsed ASTs, and the full build_module_graph pipeline.

Purpose: Complete the module graph foundation by wiring file discovery and parsing together into a dependency graph with deterministic compilation ordering and cycle detection. This is the core algorithm that Phase 38 will integrate into the build pipeline.

Output: `topological_sort` function in snow-common, `extract_imports` and `build_module_graph` in snowc, with comprehensive tests including cycle detection, diamond deps, and integration tests with real Snow source files.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-module-graph-foundation/37-RESEARCH.md
@.planning/phases/37-module-graph-foundation/37-01-SUMMARY.md
@crates/snow-common/src/module_graph.rs
@crates/snowc/src/discovery.rs
@crates/snow-parser/src/ast/item.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Kahn's topological sort with cycle detection</name>
  <files>
    crates/snow-common/src/module_graph.rs
  </files>
  <action>
Add to `crates/snow-common/src/module_graph.rs`:

**`topological_sort(graph: &ModuleGraph) -> Result<Vec<ModuleId>, CycleError>`**

Kahn's algorithm (BFS-based):
1. Compute in_degree for each module: `in_degree[i] = graph.modules[i].dependencies.len()` -- this is the count of UNRESOLVED dependencies for module i. A module with 0 dependencies compiles first.
2. Seed a VecDeque with all modules where in_degree == 0.
3. Sort the initial queue ALPHABETICALLY by module name for determinism.
4. Process: pop front, add to order. For every OTHER module that has the popped module in its dependencies, decrement that module's in_degree. If it reaches 0, add to a `newly_ready` vec. Sort `newly_ready` alphabetically, extend queue.
5. After loop: if `order.len() == graph.modules.len()`, return `Ok(order)`. Otherwise, call `extract_cycle_path` and return `Err(CycleError { cycle_path })`.

**CRITICAL in-degree direction:** "in_degree" here = number of a module's own dependencies that haven't been processed yet. Modules with NO dependencies (leaf modules, in_degree 0) go first. `main.snow` (which imports everything) goes LAST. This is NOT standard Kahn's incoming-edge count -- it is the count of outgoing dependency edges. The effect is the same as running standard Kahn's on the REVERSED graph.

**`extract_cycle_path(graph: &ModuleGraph, in_degree: &[u32]) -> Vec<String>`**

Find a module with in_degree > 0 (it is in a cycle). Follow dependency edges to other unprocessed modules (also in_degree > 0) until revisiting a node. Return the path as module names ending with the repeated name (e.g., ["A", "B", "C", "A"]).

Add unit tests:
- `test_toposort_linear`: A depends on B, B depends on C. Result: [C, B, A].
- `test_toposort_independent`: A, B, C with no deps. Result: [A, B, C] (alphabetical).
- `test_toposort_diamond`: A deps [B, C], B deps [D], C deps [D]. Result: [D, B, C, A] (D first, then B and C alphabetically, then A).
- `test_toposort_cycle`: A deps [B], B deps [C], C deps [A]. Returns Err with cycle_path containing all three names plus repeated start.
- `test_toposort_self_cycle`: A deps [A]. Returns Err (in_degree never reaches 0).
- `test_toposort_entry_last`: Entry module (is_entry=true, named "Main") depends on Utils and Math. Result: [Math, Utils, Main] -- entry is last.
  </action>
  <verify>
Run `cargo test -p snow-common` -- all tests pass including new toposort tests. Run `cargo check -p snow-common` -- no warnings.
  </verify>
  <done>
topological_sort correctly orders modules (dependencies before dependents, alphabetical tie-breaking). Cycles produce CycleError with the cycle path. Diamond dependencies handled correctly. Entry module sorts last.
  </done>
</task>

<task type="auto">
  <name>Task 2: Import extraction and build_module_graph pipeline</name>
  <files>
    crates/snowc/src/discovery.rs
  </files>
  <action>
Add to `crates/snowc/src/discovery.rs`:

1. Add necessary imports at top: `use snow_parser::ast::item::{SourceFile, Item}; use snow_parser::ast::AstNode;` and `use snow_common::module_graph::{ModuleGraph, ModuleId, CycleError};`.

**`extract_imports(source_file: &SourceFile) -> Vec<String>`**

Walk `source_file.items()`. For each `Item::ImportDecl(decl)`, call `decl.module_path()` then `.segments()` and join with ".". For each `Item::FromImportDecl(decl)`, same thing. Collect into a Vec. These are PascalCase module names like "Math.Vector" because the Snow source code uses PascalCase in import declarations.

**`build_module_graph(project_root: &Path) -> Result<(ModuleGraph, Vec<ModuleId>), String>`**

Full pipeline:
1. Call `discover_snow_files(project_root)` to get sorted relative paths.
2. Create `ModuleGraph::new()`.
3. Phase 1 -- register all modules: For each file, read its source. Determine if it's the entry point (`relative_path == Path::new("main.snow")`). Compute module name: entry -> "Main", others -> `path_to_module_name(relative_path).ok_or_else(...)`. Call `graph.add_module(name, path, is_entry)`. Store `(ModuleId, source_string)` pairs.
4. Phase 2 -- build dependency edges: For each `(id, source)`, parse with `snow_parser::parse(&source)`, get `parse.tree()` (which returns SourceFile), call `extract_imports(&tree)`. For each import name:
   - Call `graph.resolve(&import_name)`. If None, skip silently (stdlib or unknown -- Phase 39 handles errors).
   - If Some(dep_id) and dep_id == id, return `Err(format!("Module '{}' cannot import itself", name))`.
   - Otherwise, `graph.add_dependency(id, dep_id)`.
5. Call `snow_common::module_graph::topological_sort(&graph)`. Map CycleError to a descriptive String: `"Circular dependency: A -> B -> C -> A"`.
6. Return `Ok((graph, compilation_order))`.

Add integration tests using `tempfile::tempdir()`:

- `test_build_module_graph_simple`: Create temp dir with `main.snow` containing `import Utils`, and `utils.snow` containing `fn helper() do 1 end`. Verify graph has 2 modules, compilation order is [Utils, Main].

- `test_build_module_graph_cycle`: Create temp dir with `a.snow` containing `import B`, `b.snow` containing `import A`, and `main.snow` with no imports. Verify returns Err containing "Circular dependency".

- `test_build_module_graph_diamond`: Create temp dir with `main.snow` importing A and B, `a.snow` importing C, `b.snow` importing C, `c.snow` with no imports. Verify Ok result with C first, then A and B (alphabetical), then Main last.

- `test_build_module_graph_unknown_import_skipped`: Create temp dir with `main.snow` containing `import NonExistent` and `import IO` (stdlib). Verify Ok result -- unknown imports silently skipped, graph has only Main.

- `test_build_module_graph_self_import`: Create temp dir with `utils.snow` containing `import Utils` and `main.snow`. Verify returns Err containing "cannot import itself".

- `test_extract_imports_both_forms`: Parse source with both `import Foo.Bar` and `from Baz.Qux import { name1, name2 }`. Verify extract_imports returns ["Foo.Bar", "Baz.Qux"].
  </action>
  <verify>
Run `cargo test -p snowc` -- all tests pass (both new and existing). Run `cargo test --workspace` -- full workspace green. Run `cargo check --workspace` -- no warnings.
  </verify>
  <done>
extract_imports correctly pulls module names from both import and from-import declarations. build_module_graph wires discovery, parsing, and toposort into a complete pipeline. Cycle detection works. Diamond dependencies are fine. Unknown imports are skipped. Self-import produces clear error. All workspace tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-common` passes all tests (ModuleGraph types + topological sort)
2. `cargo test -p snowc` passes all tests (discovery + imports + graph building + cycle detection)
3. `cargo test --workspace` passes (no regressions across all 11 crates)
4. Test coverage of phase success criteria:
   - SC1 (file discovery): test_discover_snow_files, test_build_module_graph_simple
   - SC2 (path naming): test_path_to_module_name_nested, test_path_to_module_name_snake_case
   - SC3 (main.snow entry): test_path_to_module_name_main, test_toposort_entry_last
   - SC4 (deterministic topo order): test_toposort_diamond, test_toposort_independent
   - SC5 (cycle detection): test_toposort_cycle, test_build_module_graph_cycle
</verification>

<success_criteria>
- topological_sort implements Kahn's algorithm with alphabetical tie-breaking for determinism
- Cycle detection returns CycleError with the cycle path as module names
- Diamond dependencies (A->B->D, A->C->D) are handled correctly (NOT flagged as cycles)
- extract_imports handles both `import X.Y` and `from X.Y import { ... }` declarations
- build_module_graph is the complete pipeline: discover -> name -> parse -> graph -> toposort
- Unknown imports (stdlib, typos) are silently skipped
- Self-import produces a specific error ("Module 'X' cannot import itself")
- All workspace tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/37-module-graph-foundation/37-02-SUMMARY.md`
</output>
