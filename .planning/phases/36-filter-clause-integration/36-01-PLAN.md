---
phase: 36-filter-clause-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/mono.rs
  - crates/snow-codegen/src/pattern/compile.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-fmt/src/walker.rs
autonomous: true

must_haves:
  truths:
    - "for x in list when condition do body end parses without error"
    - "Filter expression type-checks as Bool and rejects non-Bool"
    - "Filtered elements are excluded from the collected result list at runtime"
    - "for-in without when clause behaves identically to before (no regression)"
  artifacts:
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "Parse optional when clause between iterable and do"
      contains: "WHEN_KW"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "filter() accessor on ForInExpr"
      contains: "fn filter"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Filter expression inference with Bool unification"
      contains: "filter"
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "filter: Option<Box<MirExpr>> on all 4 ForIn variants"
      contains: "filter"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Filter lowering in all 4 lower_for_in_* methods + collect_free_vars traversal"
      contains: "filter"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "Conditional branch in all 4 codegen_for_in_* methods"
      contains: "forin_do_body"
    - path: "crates/snow-codegen/src/mir/mono.rs"
      provides: "Filter traversal in collect_function_refs"
      contains: "filter"
    - path: "crates/snow-codegen/src/pattern/compile.rs"
      provides: "Filter traversal in compile_expr_patterns"
      contains: "filter"
    - path: "crates/snow-fmt/src/walker.rs"
      provides: "WHEN_KW formatting in walk_for_in_expr"
      contains: "WHEN_KW"
  key_links:
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "Parser emits WHEN_KW token + filter Expr child; AST filter() reads them"
      pattern: "WHEN_KW"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Typeck validates filter is Bool; lowering reads filter() from AST into MIR"
      pattern: "filter"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/expr.rs"
      via: "Lowering produces MirExpr with filter field; codegen emits conditional branch"
      pattern: "filter.*forin_do_body"
---

<objective>
Add the `when` filter clause to for-in loops across all compiler pipeline stages: parser, AST, type checker, MIR, lowering, codegen, monomorphization, pattern compilation, and formatter.

Purpose: Enables `for x in collection when condition do body end` syntax so users can filter elements during iteration, with only matching elements processed and included in the comprehension result list.

Output: Full pipeline support for optional `when` clause on all four for-in variants (Range, List, Map, Set). Existing for-in without `when` continues to work identically.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-filter-clause-integration/36-RESEARCH.md
@.planning/phases/35-for-in-over-collections/35-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add filter clause parsing, AST, typeck, and formatter support</name>
  <files>
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-parser/src/ast/expr.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
**Parser** (`crates/snow-parser/src/parser/expressions.rs`):
In `parse_for_in_expr` (line ~1195), after the iterable expression is parsed (`expr(p)`) and before `p.expect(SyntaxKind::DO_KW)`, add an optional `when` clause check:

```rust
// Optional filter clause: `when condition`
if p.at(SyntaxKind::WHEN_KW) {
    p.advance(); // WHEN_KW
    expr(p);     // filter expression
}
```

This inserts the `when` keyword token and filter expression as direct children of `FOR_IN_EXPR`, between the iterable expr and `DO_KW`. The `WHEN_KW` token already exists in the lexer (`TokenKind::When`) and syntax kind system. Do NOT create a separate CST node for the filter clause.

**AST** (`crates/snow-parser/src/ast/expr.rs`):
Add a `filter()` method to `ForInExpr`:

```rust
/// The filter expression (after `when`), if present.
pub fn filter(&self) -> Option<Expr> {
    let has_when = self.syntax
        .children_with_tokens()
        .any(|it| it.kind() == SyntaxKind::WHEN_KW);
    if has_when {
        // With `when`: first expr = iterable, second expr = filter
        self.syntax.children().filter_map(Expr::cast).nth(1)
    } else {
        None
    }
}
```

Verify that the existing `iterable()` method returns the first `Expr` child (which is correct regardless of filter presence). Verify `body()` returns the `Block` child (also unaffected).

**Type Checker** (`crates/snow-typeck/src/infer.rs`):
In `infer_for_in` (line ~3176), after the loop variable(s) are bound in scope (push_scope + bind) and BEFORE the body is inferred, add filter inference:

```rust
// Infer filter condition if present (FILT-01).
if let Some(filter_expr) = for_in.filter() {
    let filter_ty = infer_expr(ctx, env, &filter_expr, types, type_registry, trait_registry, fn_constraints)?;
    let origin = ConstraintOrigin::BinOp {
        op_span: filter_expr.syntax().text_range(),
    };
    ctx.unify(filter_ty, Ty::bool(), origin)?;
}
```

The order must be: (1) infer iterable, (2) push scope, (3) bind loop vars, (4) infer filter, (5) infer body, (6) exit loop, (7) pop scope. This ensures the filter expression can reference loop variables.

**Formatter** (`crates/snow-fmt/src/walker.rs`):
In `walk_for_in_expr` (line ~451), in the token match arm, add a case for `WHEN_KW`:

```rust
SyntaxKind::WHEN_KW => {
    parts.push(sp());
    parts.push(ir::text("when"));
    parts.push(sp());
}
```

This follows the same pattern as WHEN_KW handling in `walk_fn_def` (line ~200-203) and `walk_closure_clause` (line ~614-616). The filter expression (a child Node) is handled by the existing `_ => walk_node(&n)` fallback for non-BLOCK, non-NAME, non-DESTRUCTURE_BINDING nodes.

**Run:** `cargo test -p snow-parser -p snow-typeck -p snow-fmt` to verify no regressions.
  </action>
  <verify>
1. `cargo test -p snow-parser` -- all parser tests pass
2. `cargo test -p snow-typeck` -- all typeck tests pass
3. `cargo test -p snow-fmt` -- all formatter tests pass
  </verify>
  <done>
Parser accepts `for x in list when x > 0 do body end` without error. AST `filter()` returns the filter expression when present and `None` when absent. Typeck infers filter as Bool and rejects non-Bool. Formatter round-trips `when` clause correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add filter to MIR, lowering, codegen, mono, and pattern compilation</name>
  <files>
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/mir/mono.rs
    crates/snow-codegen/src/pattern/compile.rs
    crates/snow-codegen/src/codegen/expr.rs
  </files>
  <action>
**MIR** (`crates/snow-codegen/src/mir/mod.rs`):
Add `filter: Option<Box<MirExpr>>` field to all four ForIn variants (ForInRange at line ~306, ForInList at ~321, ForInMap at ~332, ForInSet at ~345). Place the `filter` field between the iterable fields and `body`. No changes needed to the `ty()` method since filter doesn't affect the return type.

**MIR Lowering** (`crates/snow-codegen/src/mir/lower.rs`):
In each of the four `lower_for_in_*` methods (lower_for_in_range, lower_for_in_list, lower_for_in_map, lower_for_in_set), after pushing scope and binding loop variables, lower the filter expression:

```rust
let filter = for_in.filter().map(|f| Box::new(self.lower_expr(&f)));
```

Pass `filter` in the MirExpr construction: `filter,` (field shorthand).

Also update `collect_free_vars` (line ~7436-7462). For each of the four ForIn match arms, add traversal of the filter field:

```rust
if let Some(f) = filter {
    collect_free_vars(f, scope, free);
}
```

This must happen AFTER the loop variable(s) are added to `scope` and BEFORE (or alongside) the body traversal. Without this, closures in filter expressions would miss captures.

**Monomorphization** (`crates/snow-codegen/src/mir/mono.rs`):
In `collect_function_refs` (line ~227-243), for each of the four ForIn match arms, add filter traversal:

```rust
if let Some(f) = filter {
    collect_function_refs(f, refs);
}
```

**Pattern Compilation** (`crates/snow-codegen/src/pattern/compile.rs`):
In `compile_expr_patterns` (line ~1251-1267), for each of the four ForIn match arms, add filter traversal:

```rust
if let Some(f) = filter {
    compile_expr_patterns(f, variants, ...);
}
```

**Codegen** (`crates/snow-codegen/src/codegen/expr.rs`):
In each of the four `codegen_for_in_*` methods, after binding the loop variable in `body_bb` and before the body expression codegen + list_builder_push, add the filter conditional branch. The pattern is:

```rust
// If filter present, add conditional branch to skip body+push.
if let Some(filter_expr) = filter {
    let filter_val = self.codegen_expr(filter_expr)?
        .into_int_value();
    let do_body_bb = self.context.append_basic_block(fn_val, "forin_do_body");
    self.builder.build_conditional_branch(filter_val, do_body_bb, latch_bb)
        .map_err(|e| e.to_string())?;
    self.builder.position_at_end(do_body_bb);
}
// ... existing body codegen + push (unchanged) ...
```

When filter is false, execution skips directly to `latch_bb` (counter increment + reduction check), bypassing both the body evaluation and the list_builder_push. When filter is true, execution continues to `do_body_bb` which contains the body codegen and push. When no filter is present, no extra block is created (existing behavior preserved).

Do NOT change `codegen_break` or `codegen_continue`. Break still targets merge_bb, continue still targets latch_bb. The filter block doesn't affect these targets.

Apply this pattern in all four methods:
- `codegen_for_in_range` (line ~1738)
- `codegen_for_in_list` (line ~2842)
- `codegen_for_in_map` (similar location)
- `codegen_for_in_set` (similar location)

**Run:** `cargo test --workspace` to verify no regressions and that existing for-in tests still pass.
  </action>
  <verify>
1. `cargo test --workspace` -- all tests pass (expect ~1300+)
2. Verify existing for-in e2e tests still pass: `cargo test -p snowc --test e2e -- for_in` should show all existing for_in tests passing
  </verify>
  <done>
MIR has filter field on all 4 ForIn variants. Lowering reads filter from AST and produces MIR filter. Codegen emits conditional branch (five-block pattern) when filter present. Mono and pattern compilation traverse filter. All existing tests pass with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (no regressions from filter field additions)
2. Existing for-in e2e tests pass unchanged (for_in_range_*, for_in_list_*, for_in_map_*, for_in_set_*)
3. Grep for `filter` in MIR mod.rs confirms field present on all 4 ForIn variants
4. Grep for `WHEN_KW` in walker.rs confirms formatter handles when clause
5. Grep for `forin_do_body` in codegen expr.rs confirms filter conditional branch exists
</verification>

<success_criteria>
- Parser accepts `for x in [1,2,3] when x > 1 do x end` without error
- Typeck rejects `for x in [1,2,3] when 42 do x end` (non-Bool filter)
- Codegen produces five-block pattern (header/body/do_body/latch/merge) when filter present
- Codegen produces four-block pattern (header/body/latch/merge) when no filter (no regression)
- Formatter outputs `for x in list when x > 0 do` with correct spacing
- All ~1300+ existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/36-filter-clause-integration/36-01-SUMMARY.md`
</output>
