---
phase: 36-filter-clause-integration
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - tests/e2e/for_in_filter.snow
  - crates/snowc/tests/e2e.rs
  - crates/snow-fmt/src/walker.rs
  - crates/snow-parser/tests/parser_tests.rs
autonomous: true

must_haves:
  truths:
    - "for x in [1,2,3,4,5] when x > 2 do x * 10 end produces [30, 40, 50]"
    - "for i in 0..10 when i % 2 == 0 do i end produces [0, 2, 4, 6, 8]"
    - "for {k, v} in map when v > 0 do k end filters map entries correctly"
    - "for x in set when condition do body end filters set elements correctly"
    - "Nested for-in loops with filters at both levels produce correct results"
    - "Closures inside filtered for-in loops capture loop variables correctly"
    - "for-in with filter inside pipe chains works correctly"
    - "break and continue inside filtered for-in loops work correctly"
    - "Formatter round-trips when clause idempotently"
  artifacts:
    - path: "tests/e2e/for_in_filter.snow"
      provides: "Filter test fixture covering range, list, map, set, break, continue, nesting"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E test entries for filter scenarios"
      contains: "for_in_filter"
    - path: "crates/snow-fmt/src/walker.rs"
      provides: "Formatter test for when clause idempotency"
      contains: "for_in_filter"
    - path: "crates/snow-parser/tests/parser_tests.rs"
      provides: "Parser test for for-in with when clause"
      contains: "for_in_when"
  key_links:
    - from: "tests/e2e/for_in_filter.snow"
      to: "crates/snowc/tests/e2e.rs"
      via: "Fixture file referenced by e2e test entries"
      pattern: "for_in_filter"
---

<objective>
Add comprehensive e2e tests, parser tests, and formatter tests for the `when` filter clause, covering all four for-in variants (range, list, map, set), plus integration scenarios: nested loops with filters, closures capturing loop variables, pipe chains, break/continue inside filtered loops.

Purpose: Validates that the filter clause implementation from Plan 01 works correctly across all combinations and that the formatter and parser handle the syntax correctly.

Output: Test fixtures and test entries proving FILT-01 and FILT-02 requirements are satisfied end-to-end.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-filter-clause-integration/36-RESEARCH.md
@.planning/phases/36-filter-clause-integration/36-01-SUMMARY.md
@tests/e2e/for_in_list.snow
@tests/e2e/for_in_map.snow
@tests/e2e/for_in_set.snow
@crates/snowc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: E2E tests for filter clause across all for-in variants</name>
  <files>
    tests/e2e/for_in_filter.snow
    crates/snowc/tests/e2e.rs
  </files>
  <action>
**Create test fixture** `tests/e2e/for_in_filter.snow` with test functions covering:

1. **Range filter**: `for i in 0..10 when i % 2 == 0 do i end` -- produces `[0, 2, 4, 6, 8]`
2. **List filter**: `for x in [1, 2, 3, 4, 5] when x > 2 do x * 10 end` -- produces `[30, 40, 50]`
3. **Map filter with destructuring**: `for {k, v} in map when v > 0 do k end` -- filters entries by value
4. **Set filter**: `for x in set when x > 5 do x end` -- filters set elements
5. **Filter with all-false condition**: `for x in [1, 2, 3] when x > 100 do x end` -- produces empty list `[]`
6. **Break inside filtered loop**: `for x in [1,2,3,4,5] when x % 2 == 1 do if x == 3 then break end; x end` -- partial result
7. **Continue inside filtered loop**: `for x in [1,2,3,4,5] when x > 1 do if x == 3 then continue end; x end` -- skip element 3

Each test function should use `println` to output a deterministic result that the e2e test can match.

Follow the pattern from existing fixture files (for_in_list.snow, for_in_map.snow, for_in_set.snow). Each test is a standalone function called from `main`.

Note: The `[]` empty list literal may cause issues (known pre-existing bug from 35-02-SUMMARY). For the "all false" test, verify the list length is 0 using `List.length` rather than comparing to `[]`.

**Add e2e test entries** to `crates/snowc/tests/e2e.rs`:
Follow the existing pattern (see for_in_list, for_in_map etc. at line ~1155-1309). Each entry specifies the fixture file path and expected output. Add entries for:
- `for_in_filter_range` -- range with even filter
- `for_in_filter_list` -- list with greater-than filter
- `for_in_filter_map` -- map with value filter
- `for_in_filter_set` -- set with element filter
- `for_in_filter_empty_result` -- all-false filter producing empty result
- `for_in_filter_break` -- break inside filtered loop
- `for_in_filter_continue` -- continue inside filtered loop

If the existing test pattern uses a single fixture file with multiple test functions selected by CLI arg or separate fixtures, follow the same pattern.

**Run:** `cargo test -p snowc --test e2e -- for_in_filter` to verify all filter e2e tests pass.
  </action>
  <verify>
1. `cargo test -p snowc --test e2e -- for_in_filter` -- all 7 filter e2e tests pass
2. `cargo test -p snowc --test e2e -- for_in` -- all existing for_in tests still pass (no regression)
  </verify>
  <done>
E2E tests prove: range filter produces correct even numbers, list filter excludes elements and transforms correctly, map filter with destructuring works, set filter works, all-false filter produces empty list, break returns partial filtered result, continue skips element within filtered loop. All existing for_in tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Parser test and formatter test for when clause</name>
  <files>
    crates/snow-parser/tests/parser_tests.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
**Parser test** (`crates/snow-parser/tests/parser_tests.rs`):
Add a test that parses `for x in list when x > 0 do x end` and verifies:
- The parse tree contains a `FOR_IN_EXPR` node
- The `WHEN_KW` token is present as a direct child
- The `ForInExpr::filter()` accessor returns `Some(expr)`
- The `ForInExpr::iterable()` still returns the correct expression
- No parse errors are reported

Follow the existing parser test patterns in this file.

Also add a test for for-in WITHOUT when clause to confirm `filter()` returns `None` (regression test).

**Formatter test** (`crates/snow-fmt/src/walker.rs`):
Add formatter idempotency tests in the `#[cfg(test)]` module at the bottom of walker.rs. Follow the existing pattern from for-in formatter tests (search for `for_in` in the test module). Add tests:

1. `for_in_filter_basic`: Input/expected `for x in list when x > 0 do\n  x\nend` -- verify idempotent round-trip
2. `for_in_filter_range`: Input/expected `for i in 0..10 when i % 2 == 0 do\n  i\nend`
3. `for_in_filter_destructure`: Input/expected `for {k, v} in map when v > 0 do\n  k\nend`

Each test verifies that formatting the input produces the expected output, and formatting the output again produces the same output (idempotency).

**Run:** `cargo test -p snow-parser --test parser_tests` and `cargo test -p snow-fmt` to verify.
  </action>
  <verify>
1. `cargo test -p snow-parser --test parser_tests -- for_in_when` -- parser tests pass
2. `cargo test -p snow-fmt` -- all formatter tests pass including new filter tests
3. `cargo test --workspace` -- full workspace passes
  </verify>
  <done>
Parser test confirms `for x in list when x > 0 do x end` parses with WHEN_KW token, filter() returns Some, iterable() returns correct expr, no errors. Formatter tests confirm `when` clause is round-tripped idempotently for simple, range, and destructuring variants. Full workspace tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snowc --test e2e -- for_in_filter` -- all 7 filter e2e tests pass
2. `cargo test -p snowc --test e2e -- for_in` -- all existing for_in tests pass (no regression)
3. `cargo test -p snow-parser --test parser_tests` -- parser tests pass
4. `cargo test -p snow-fmt` -- formatter tests pass
5. `cargo test --workspace` -- full workspace passes (1300+ tests)
</verification>

<success_criteria>
- 7+ e2e tests pass covering range/list/map/set filter, empty result, break, continue
- Parser test proves WHEN_KW is parsed and filter() accessor works
- Formatter tests prove when clause round-trips idempotently
- All ~1300+ existing tests pass (no regressions)
- Phase 36 success criteria satisfied: filter works, formatter handles it, integration scenarios work
</success_criteria>

<output>
After completion, create `.planning/phases/36-filter-clause-integration/36-02-SUMMARY.md`
</output>
