---
phase: 85-formatting-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-repl/src/jit.rs
autonomous: true

must_haves:
  truths:
    - "REPL can JIT-execute code that uses iterator adapters (map, filter, take, skip, enumerate, zip)"
    - "REPL can JIT-execute code that uses terminal operations (count, sum, any, all, find, reduce)"
    - "REPL can JIT-execute code that uses collect operations (list, map, set, string collect)"
    - "REPL can JIT-execute code that uses collection iterator constructors"
    - "All existing REPL tests continue to pass"
  artifacts:
    - path: "crates/mesh-repl/src/jit.rs"
      provides: "Complete v7.0 runtime symbol registration"
      contains: "mesh_iter_generic_next"
  key_links:
    - from: "crates/mesh-repl/src/jit.rs"
      to: "mesh-rt iter module"
      via: "add_sym calls for all iterator/collect/conversion functions"
      pattern: "mesh_iter_map.*as \\*const"
    - from: "crates/mesh-repl/src/jit.rs"
      to: "mesh-rt collections iter constructors"
      via: "add_sym calls for list/map/set/range iter_new and iter_next"
      pattern: "mesh_list_iter_new.*as \\*const"
---

<objective>
Register all missing v7.0 runtime symbols (iterators, terminal operations, collect, collection iterator constructors) with LLVM's JIT symbol table so that REPL-evaluated code can call these functions without segfaulting.

Purpose: Without these registrations, any REPL expression using iterator pipelines, From/Into conversion, collect, or v7.0 features will fail at JIT execution time with an unresolved symbol error.
Output: Complete JIT symbol table covering all mesh-rt public extern "C" functions.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/85-formatting-audit/85-RESEARCH.md
@crates/mesh-repl/src/jit.rs
@crates/mesh-rt/src/lib.rs
@crates/mesh-rt/src/iter.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Iterator + Collect + Collection Iterator Symbols</name>
  <files>crates/mesh-repl/src/jit.rs</files>
  <action>
In `crates/mesh-repl/src/jit.rs`, add the following symbol registrations to the `register_runtime_symbols()` function. Add them after the existing "Collections -- Range" section (after line 151) and before the "Collections -- Tuple" section.

Add a new section comment and registrations:

```rust
// Iterator protocol -- generic dispatch
add_sym("mesh_iter_generic_next", mesh_rt::mesh_iter_generic_next as *const ());

// Iterator adapters -- constructors
add_sym("mesh_iter_map", mesh_rt::mesh_iter_map as *const ());
add_sym("mesh_iter_filter", mesh_rt::mesh_iter_filter as *const ());
add_sym("mesh_iter_take", mesh_rt::mesh_iter_take as *const ());
add_sym("mesh_iter_skip", mesh_rt::mesh_iter_skip as *const ());
add_sym("mesh_iter_enumerate", mesh_rt::mesh_iter_enumerate as *const ());
add_sym("mesh_iter_zip", mesh_rt::mesh_iter_zip as *const ());

// Iterator adapters -- next functions
add_sym("mesh_iter_map_next", mesh_rt::mesh_iter_map_next as *const ());
add_sym("mesh_iter_filter_next", mesh_rt::mesh_iter_filter_next as *const ());
add_sym("mesh_iter_take_next", mesh_rt::mesh_iter_take_next as *const ());
add_sym("mesh_iter_skip_next", mesh_rt::mesh_iter_skip_next as *const ());
add_sym("mesh_iter_enumerate_next", mesh_rt::mesh_iter_enumerate_next as *const ());
add_sym("mesh_iter_zip_next", mesh_rt::mesh_iter_zip_next as *const ());

// Iterator terminal operations
add_sym("mesh_iter_count", mesh_rt::mesh_iter_count as *const ());
add_sym("mesh_iter_sum", mesh_rt::mesh_iter_sum as *const ());
add_sym("mesh_iter_any", mesh_rt::mesh_iter_any as *const ());
add_sym("mesh_iter_all", mesh_rt::mesh_iter_all as *const ());
add_sym("mesh_iter_find", mesh_rt::mesh_iter_find as *const ());
add_sym("mesh_iter_reduce", mesh_rt::mesh_iter_reduce as *const ());

// Collect operations
add_sym("mesh_list_collect", mesh_rt::mesh_list_collect as *const ());
add_sym("mesh_map_collect", mesh_rt::mesh_map_collect as *const ());
add_sym("mesh_set_collect", mesh_rt::mesh_set_collect as *const ());
add_sym("mesh_string_collect", mesh_rt::mesh_string_collect as *const ());

// Collection iterator constructors + next functions
add_sym("mesh_list_iter_new", mesh_rt::collections::list::mesh_list_iter_new as *const ());
add_sym("mesh_list_iter_next", mesh_rt::collections::list::mesh_list_iter_next as *const ());
add_sym("mesh_map_iter_new", mesh_rt::collections::map::mesh_map_iter_new as *const ());
add_sym("mesh_map_iter_next", mesh_rt::collections::map::mesh_map_iter_next as *const ());
add_sym("mesh_set_iter_new", mesh_rt::collections::set::mesh_set_iter_new as *const ());
add_sym("mesh_set_iter_next", mesh_rt::collections::set::mesh_set_iter_next as *const ());
add_sym("mesh_range_iter_new", mesh_rt::collections::range::mesh_range_iter_new as *const ());
add_sym("mesh_range_iter_next", mesh_rt::collections::range::mesh_range_iter_next as *const ());
```

Note: Collection iterator constructors (mesh_list_iter_new, etc.) are NOT re-exported from mesh_rt::lib.rs, so they must be referenced via the full module path (mesh_rt::collections::list::mesh_list_iter_new, etc.). The `collections` module is `pub mod` so this is accessible.

Also add the `mesh_iter_from` function which is defined in collections/list.rs:
```rust
add_sym("mesh_iter_from", mesh_rt::collections::list::mesh_iter_from as *const ());
```

Note on mesh_int_to_float / mesh_float_to_int: These do NOT exist as runtime functions -- they are codegen intrinsics (LLVM sitofp/fptosi instructions). No registration needed.

Also add missing symbols from other features that may have been added post-v1.0 but not registered:

After the existing "String operations" section, add any missing string functions:
```rust
add_sym("mesh_string_split", mesh_rt::mesh_string_split as *const ());
add_sym("mesh_string_join", mesh_rt::mesh_string_join as *const ());
add_sym("mesh_string_to_int", mesh_rt::mesh_string_to_int as *const ());
add_sym("mesh_string_to_float", mesh_rt::mesh_string_to_float as *const ());
```

After the existing "Collections -- List" section, add missing list functions:
```rust
add_sym("mesh_list_sort", mesh_rt::mesh_list_sort as *const ());
add_sym("mesh_list_find", mesh_rt::mesh_list_find as *const ());
add_sym("mesh_list_any", mesh_rt::mesh_list_any as *const ());
add_sym("mesh_list_all", mesh_rt::mesh_list_all as *const ());
add_sym("mesh_list_contains", mesh_rt::mesh_list_contains as *const ());
add_sym("mesh_list_zip", mesh_rt::mesh_list_zip as *const ());
add_sym("mesh_list_flat_map", mesh_rt::mesh_list_flat_map as *const ());
add_sym("mesh_list_flatten", mesh_rt::mesh_list_flatten as *const ());
add_sym("mesh_list_enumerate", mesh_rt::mesh_list_enumerate as *const ());
add_sym("mesh_list_take", mesh_rt::mesh_list_take as *const ());
add_sym("mesh_list_drop", mesh_rt::mesh_list_drop as *const ());
add_sym("mesh_list_nth", mesh_rt::mesh_list_nth as *const ());
add_sym("mesh_list_last", mesh_rt::mesh_list_last as *const ());
```

After the existing "Collections -- Map" section, add missing map functions:
```rust
add_sym("mesh_map_merge", mesh_rt::mesh_map_merge as *const ());
add_sym("mesh_map_to_list", mesh_rt::mesh_map_to_list as *const ());
add_sym("mesh_map_from_list", mesh_rt::mesh_map_from_list as *const ());
```

After the existing "Collections -- Set" section, add missing set functions:
```rust
add_sym("mesh_set_difference", mesh_rt::mesh_set_difference as *const ());
add_sym("mesh_set_to_list", mesh_rt::mesh_set_to_list as *const ());
add_sym("mesh_set_from_list", mesh_rt::mesh_set_from_list as *const ());
```

After the existing "Hash" section (if missing -- check), add hash functions:
```rust
add_sym("mesh_hash_int", mesh_rt::mesh_hash_int as *const ());
add_sym("mesh_hash_float", mesh_rt::mesh_hash_float as *const ());
add_sym("mesh_hash_string", mesh_rt::mesh_hash_string as *const ());
add_sym("mesh_hash_bool", mesh_rt::mesh_hash_bool as *const ());
add_sym("mesh_hash_combine", mesh_rt::mesh_hash_combine as *const ());
```

Also register actor monitor/timer/dist functions that may be missing:
```rust
add_sym("mesh_timer_sleep", mesh_rt::mesh_timer_sleep as *const ());
add_sym("mesh_timer_send_after", mesh_rt::mesh_timer_send_after as *const ());
add_sym("mesh_process_monitor", mesh_rt::mesh_process_monitor as *const ());
add_sym("mesh_process_demonitor", mesh_rt::mesh_process_demonitor as *const ());
```

The goal is comprehensive coverage: every public `#[no_mangle] extern "C"` function from mesh-rt should be registered. The cost is negligible (just pointer registrations) and prevents future JIT failures.
  </action>
  <verify>
Run `cargo build -p mesh-repl` to verify compilation (all symbol references must resolve). Run `cargo test -p mesh-repl` to verify existing tests still pass. The `test_init_runtime_is_idempotent` test exercises `register_runtime_symbols()` and will catch any symbol reference errors.
  </verify>
  <done>
REPL's JIT symbol table includes all v7.0 iterator functions (6 adapter constructors, 6 adapter next functions, 1 generic dispatch, 6 terminal operations, 4 collect operations, 8 collection iterator constructor/next pairs), plus comprehensive coverage of v1.9-v7.0 stdlib functions (string, list, map, set, hash, timer, monitor). `cargo build -p mesh-repl` and `cargo test -p mesh-repl` pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p mesh-repl` compiles without errors
2. `cargo test -p mesh-repl` -- all existing tests pass
3. `test_init_runtime_is_idempotent` passes (exercises register_runtime_symbols)
4. No unresolved symbol references in the build
</verification>

<success_criteria>
- All ~35+ missing runtime symbols registered with LLVM JIT
- Collection iterator constructors referenced via full module path (mesh_rt::collections::*)
- No compilation errors (all symbol references resolve against mesh-rt public API)
- All existing REPL tests pass
- REPL won't segfault or error when evaluating iterator/collect/conversion expressions
</success_criteria>

<output>
After completion, create `.planning/phases/85-formatting-audit/85-02-SUMMARY.md`
</output>
