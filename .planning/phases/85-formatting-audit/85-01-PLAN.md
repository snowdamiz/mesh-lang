---
phase: 85-formatting-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-lsp/Cargo.toml
  - crates/mesh-lsp/src/server.rs
  - crates/mesh-fmt/src/walker.rs
  - crates/mesh-fmt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "VS Code 'Format Document' command formats .mpl files via LSP"
    - "Map literals %{k => v} are formatted with correct spacing around =>"
    - "List literals [1, 2, 3] are formatted with bracket and comma spacing"
    - "Associated type bindings (type Item = Int) are formatted with space around ="
    - "All new formatter handlers are idempotent (format(format(x)) == format(x))"
  artifacts:
    - path: "crates/mesh-lsp/src/server.rs"
      provides: "textDocument/formatting handler"
      contains: "async fn formatting"
    - path: "crates/mesh-lsp/Cargo.toml"
      provides: "mesh-fmt dependency"
      contains: "mesh-fmt"
    - path: "crates/mesh-fmt/src/walker.rs"
      provides: "Dedicated handlers for MAP_LITERAL, MAP_ENTRY, LIST_LITERAL, ASSOC_TYPE_BINDING"
      contains: "walk_map_literal"
    - path: "crates/mesh-fmt/src/lib.rs"
      provides: "Idempotency tests for new node types"
      contains: "idempotent_map_literal"
  key_links:
    - from: "crates/mesh-lsp/src/server.rs"
      to: "crates/mesh-fmt/src/lib.rs"
      via: "mesh_fmt::format_source call in formatting handler"
      pattern: "mesh_fmt::format_source"
    - from: "crates/mesh-lsp/src/server.rs"
      to: "ServerCapabilities"
      via: "document_formatting_provider capability advertisement"
      pattern: "document_formatting_provider"
    - from: "crates/mesh-fmt/src/walker.rs"
      to: "walk_node match arms"
      via: "SyntaxKind dispatch for MAP_LITERAL, LIST_LITERAL, ASSOC_TYPE_BINDING"
      pattern: "MAP_LITERAL.*walk_map_literal"
---

<objective>
Wire `mesh_fmt::format_source` into the LSP server as a `textDocument/formatting` handler, and add dedicated formatter walker handlers for v5.0-v7.0 CST node types that currently fall through to the generic inline fallback.

Purpose: Enables VS Code "Format Document" for Mesh files and ensures map literals, list literals, and associated type bindings are formatted correctly rather than relying on generic spacing heuristics.
Output: Working LSP formatting, correct dedicated walker handlers, idempotency tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/85-formatting-audit/85-RESEARCH.md
@crates/mesh-lsp/src/server.rs
@crates/mesh-lsp/Cargo.toml
@crates/mesh-fmt/src/walker.rs
@crates/mesh-fmt/src/lib.rs
@crates/mesh-fmt/src/ir.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: LSP Formatting Handler + Capability</name>
  <files>crates/mesh-lsp/Cargo.toml, crates/mesh-lsp/src/server.rs</files>
  <action>
1. Add `mesh-fmt` dependency to `crates/mesh-lsp/Cargo.toml`:
   ```toml
   mesh-fmt = { path = "../mesh-fmt" }
   ```

2. In `crates/mesh-lsp/src/server.rs`, add to the `ServerCapabilities` in `initialize()`:
   ```rust
   document_formatting_provider: Some(OneOf::Left(true)),
   ```
   Place it after `document_symbol_provider`.

3. Implement the `formatting` method on the `LanguageServer` impl for `MeshBackend`:
   ```rust
   async fn formatting(
       &self,
       params: DocumentFormattingParams,
   ) -> Result<Option<Vec<TextEdit>>> {
       let uri_str = params.text_document.uri.to_string();
       let docs = self.documents.lock().unwrap();
       let doc = match docs.get(&uri_str) {
           Some(doc) => doc,
           None => return Ok(None),
       };

       let config = mesh_fmt::FormatConfig {
           indent_size: params.options.tab_size as usize,
           ..Default::default()
       };
       let formatted = mesh_fmt::format_source(&doc.source, &config);

       if formatted == doc.source {
           return Ok(None);
       }

       // Full-document replacement: single TextEdit covering entire document.
       let line_count = doc.source.lines().count() as u32;
       let last_line_len = doc.source.lines().last().map_or(0, |l| l.len()) as u32;
       Ok(Some(vec![TextEdit {
           range: Range::new(
               Position::new(0, 0),
               Position::new(line_count, last_line_len),
           ),
           new_text: formatted,
       }]))
   }
   ```
   Place this method after `signature_help` in the impl block.

4. Update the `server_capabilities` test to assert `document_formatting_provider`:
   ```rust
   assert!(caps.document_formatting_provider.is_some());
   ```

Note: Use `params.options.tab_size` per LSP standard (research recommendation). Users who want canonical Mesh style (indent=2) set tab_size=2 in their editor.
  </action>
  <verify>
Run `cargo build -p mesh-lsp` to verify compilation. Run `cargo test -p mesh-lsp` to verify the capability test passes including the new `document_formatting_provider` assertion.
  </verify>
  <done>
LSP server compiles with formatting handler, advertises `document_formatting_provider` capability, test passes asserting the capability is present.
  </done>
</task>

<task type="auto">
  <name>Task 2: Formatter Walker Handlers + Idempotency Tests</name>
  <files>crates/mesh-fmt/src/walker.rs, crates/mesh-fmt/src/lib.rs</files>
  <action>
1. In `crates/mesh-fmt/src/walker.rs`, add dedicated dispatch entries in `walk_node()`. Replace the `_ => walk_tokens_inline(node)` fallback section. Add these BEFORE the existing `_ => walk_tokens_inline(node)` fallback, inserting into the explicit match arms around line 84 (after `STRUCT_LITERAL` and `TRY_EXPR`):

   ```rust
   SyntaxKind::MAP_LITERAL => walk_map_literal(node),
   SyntaxKind::MAP_ENTRY => walk_map_entry(node),
   SyntaxKind::LIST_LITERAL => walk_list_literal(node),
   SyntaxKind::ASSOC_TYPE_BINDING => walk_assoc_type_binding(node),
   ```

   Also add to the `walk_tokens_inline` list (simple nodes that are fine inline):
   ```rust
   SyntaxKind::ASSOC_TYPE_DEF  // simple "type Item" is fine inline
   SyntaxKind::FUN_TYPE        // already handled well by inline
   SyntaxKind::CONS_PAT        // "head :: tail" already has :: spacing
   ```

2. Implement `walk_map_literal` handler:
   ```rust
   fn walk_map_literal(node: &SyntaxNode) -> FormatIR {
       let mut parts = Vec::new();
       for child in node.children_with_tokens() {
           match child {
               NodeOrToken::Token(tok) => match tok.kind() {
                   SyntaxKind::PERCENT => parts.push(ir::text("%")),
                   SyntaxKind::L_BRACE => {
                       parts.push(ir::text("{"));
                   }
                   SyntaxKind::R_BRACE => {
                       parts.push(ir::text("}"));
                   }
                   SyntaxKind::COMMA => {
                       parts.push(ir::text(","));
                       parts.push(sp());
                   }
                   SyntaxKind::NEWLINE => {}
                   _ => {
                       add_token_with_context(&tok, &mut parts);
                   }
               },
               NodeOrToken::Node(n) => {
                   parts.push(walk_node(&n));
               }
           }
       }
       ir::group(ir::concat(parts))
   }
   ```

3. Implement `walk_map_entry` handler:
   ```rust
   fn walk_map_entry(node: &SyntaxNode) -> FormatIR {
       let mut parts = Vec::new();
       for child in node.children_with_tokens() {
           match child {
               NodeOrToken::Token(tok) => match tok.kind() {
                   SyntaxKind::FAT_ARROW => {
                       parts.push(sp());
                       parts.push(ir::text("=>"));
                       parts.push(sp());
                   }
                   SyntaxKind::NEWLINE => {}
                   _ => {
                       add_token_with_context(&tok, &mut parts);
                   }
               },
               NodeOrToken::Node(n) => {
                   parts.push(walk_node(&n));
               }
           }
       }
       ir::concat(parts)
   }
   ```

4. Implement `walk_list_literal` handler:
   ```rust
   fn walk_list_literal(node: &SyntaxNode) -> FormatIR {
       let mut parts = Vec::new();
       for child in node.children_with_tokens() {
           match child {
               NodeOrToken::Token(tok) => match tok.kind() {
                   SyntaxKind::L_BRACKET => parts.push(ir::text("[")),
                   SyntaxKind::R_BRACKET => parts.push(ir::text("]")),
                   SyntaxKind::COMMA => {
                       parts.push(ir::text(","));
                       parts.push(sp());
                   }
                   SyntaxKind::NEWLINE => {}
                   _ => {
                       add_token_with_context(&tok, &mut parts);
                   }
               },
               NodeOrToken::Node(n) => {
                   parts.push(walk_node(&n));
               }
           }
       }
       ir::group(ir::concat(parts))
   }
   ```

5. Implement `walk_assoc_type_binding` handler:
   ```rust
   fn walk_assoc_type_binding(node: &SyntaxNode) -> FormatIR {
       let mut parts = Vec::new();
       for child in node.children_with_tokens() {
           match child {
               NodeOrToken::Token(tok) => match tok.kind() {
                   SyntaxKind::TYPE_KW => {
                       parts.push(ir::text("type"));
                       parts.push(sp());
                   }
                   SyntaxKind::EQ => {
                       parts.push(sp());
                       parts.push(ir::text("="));
                       parts.push(sp());
                   }
                   SyntaxKind::NEWLINE => {}
                   _ => {
                       parts.push(ir::text(tok.text()));
                   }
               },
               NodeOrToken::Node(n) => {
                   parts.push(walk_node(&n));
               }
           }
       }
       ir::concat(parts)
   }
   ```

6. Add walker tests in `walker.rs` mod tests section (at the end, before the closing `}`):
   ```rust
   #[test]
   fn map_literal_formatting() {
       let result = fmt("%{\"a\" => 1, \"b\" => 2}");
       assert!(result.contains("=>"), "Result: {:?}", result);
       assert!(result.contains("%{"), "Result: {:?}", result);
   }

   #[test]
   fn list_literal_formatting() {
       let result = fmt("[1, 2, 3]");
       assert_eq!(result, "[1, 2, 3]\n");
   }

   #[test]
   fn empty_list_literal() {
       let result = fmt("[]");
       assert_eq!(result, "[]\n");
   }

   #[test]
   fn empty_map_literal() {
       let result = fmt("%{}");
       assert_eq!(result, "%{}\n");
   }
   ```

7. Add idempotency tests in `lib.rs` idempotency_tests module:
   ```rust
   #[test]
   fn idempotent_list_literal() {
       assert_idempotent("list literal", "[1, 2, 3]");
   }

   #[test]
   fn idempotent_map_literal() {
       assert_idempotent("map literal", "let m = %{\"a\" => 1, \"b\" => 2}");
   }

   #[test]
   fn idempotent_nested_list() {
       assert_idempotent("nested list", "let xs = [[1, 2], [3, 4]]");
   }

   #[test]
   fn idempotent_assoc_type_binding() {
       assert_idempotent(
           "assoc type binding in impl",
           "impl Iterator for MyIter do\ntype Item = Int\nfn next(self) do\nNone\nend\nend",
       );
   }
   ```
  </action>
  <verify>
Run `cargo test -p mesh-fmt` to verify all existing tests still pass and new tests pass. Specifically check that all idempotency tests pass (format(format(x)) == format(x) for map literals, list literals, and associated type bindings).
  </verify>
  <done>
Formatter has dedicated handlers for MAP_LITERAL, MAP_ENTRY, LIST_LITERAL, and ASSOC_TYPE_BINDING. All existing tests pass. New tests verify correct formatting and idempotency for map literals (%{k => v}), list literals ([1, 2, 3]), and associated type bindings (type Item = Int).
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p mesh-lsp` compiles without errors
2. `cargo test -p mesh-lsp` -- capability test passes with document_formatting_provider
3. `cargo test -p mesh-fmt` -- all existing + new tests pass
4. Idempotency verified for all new node types
</verification>

<success_criteria>
- LSP server advertises `document_formatting_provider` capability
- Formatting handler returns correct TextEdit for unformatted documents
- Formatting handler returns None for already-formatted documents
- Map literals formatted as `%{"key" => value}` with spaces around `=>`
- List literals formatted as `[1, 2, 3]` with comma-space separation
- Associated type bindings formatted as `type Item = Int` with spaces around `=`
- All formatting is idempotent
</success_criteria>

<output>
After completion, create `.planning/phases/85-formatting-audit/85-01-SUMMARY.md`
</output>
