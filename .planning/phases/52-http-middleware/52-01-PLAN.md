---
phase: 52-http-middleware
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/http/router.rs
  - crates/snow-rt/src/http/server.rs
  - crates/snow-rt/src/http/mod.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/infer.rs
autonomous: true

must_haves:
  truths:
    - "HTTP.use(router, middleware_fn) compiles and returns a new router with the middleware registered"
    - "Middleware function receives request and a callable next function, can call next(request) to proceed"
    - "Multiple middleware compose in registration order (first added = outermost)"
    - "Middleware chain wraps the matched route handler at request dispatch time"
    - "When no route matches, middleware still runs (wrapping a 404 handler)"
  artifacts:
    - path: "crates/snow-rt/src/http/router.rs"
      provides: "MiddlewareEntry struct, middlewares Vec on SnowRouter, snow_http_use_middleware"
      contains: "snow_http_use_middleware"
    - path: "crates/snow-rt/src/http/server.rs"
      provides: "Middleware chain execution, chain_next trampoline, build_snow_closure, call_handler, call_middleware"
      contains: "chain_next"
    - path: "crates/snow-rt/src/http/mod.rs"
      provides: "Re-export of snow_http_use_middleware"
      contains: "snow_http_use_middleware"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declaration of snow_http_use_middleware"
      contains: "snow_http_use_middleware"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "known_functions entry and map_builtin_name for http_use -> snow_http_use_middleware"
      contains: "snow_http_use_middleware"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Type registration for http_use"
      contains: "http_use"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "HTTP module 'use' entry"
      contains: "\"use\""
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "Both register http_use type with same signature"
      pattern: "http_use"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "map_builtin_name maps http_use to snow_http_use_middleware which must be declared"
      pattern: "snow_http_use_middleware"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/http/router.rs"
      via: "handle_request reads router.middlewares to build chain"
      pattern: "router\\.middlewares"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/http/server.rs"
      via: "chain_next trampoline builds Snow closure via build_snow_closure"
      pattern: "build_snow_closure"
---

<objective>
Implement HTTP middleware runtime support and full compiler pipeline wiring for `HTTP.use(router, middleware_fn)`.

Purpose: Enable composable request/response processing (logging, auth, cross-cutting concerns) via middleware functions that receive a request and a `next` function, following the onion model pattern.

Output: Working runtime middleware registration and chain execution, plus all compiler pipeline wiring (intrinsics, typeck, MIR lowering) so `HTTP.use(router, fn)` compiles end-to-end.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-http-middleware/52-RESEARCH.md
@.planning/phases/51-http-path-parameters/51-01-SUMMARY.md
@crates/snow-rt/src/http/router.rs
@crates/snow-rt/src/http/server.rs
@crates/snow-rt/src/http/mod.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Runtime -- middleware storage, registration, and chain execution</name>
  <files>
    crates/snow-rt/src/http/router.rs
    crates/snow-rt/src/http/server.rs
    crates/snow-rt/src/http/mod.rs
  </files>
  <action>
**router.rs changes:**

1. Add `MiddlewareEntry` struct (same pattern as `RouteEntry`):
```rust
pub struct MiddlewareEntry {
    pub fn_ptr: *mut u8,
    pub env_ptr: *mut u8,
}
```

2. Add `middlewares: Vec<MiddlewareEntry>` field to `SnowRouter`.

3. Update `snow_http_router()` to initialize `middlewares: Vec::new()`.

4. Update `route_with_method()` to copy middlewares from old router to new router (same pattern as copying routes). The new router must preserve existing middleware.

5. Add `snow_http_use_middleware` extern "C" function:
```rust
#[no_mangle]
pub extern "C" fn snow_http_use_middleware(
    router: *mut u8,
    middleware_fn: *mut u8,
) -> *mut u8
```
This creates a NEW SnowRouter, copying all existing routes AND middlewares from the old router, then appending the new middleware with `fn_ptr = middleware_fn, env_ptr = null`. Returns the new router pointer. Follow the EXACT same immutable-copy pattern as `route_with_method`.

6. Update the router unit tests that construct SnowRouter directly to include `middlewares: Vec::new()` or `middlewares: vec![]` (since SnowRouter now has an additional field).

**server.rs changes:**

1. Add `ChainState` struct for middleware chain trampoline state:
```rust
struct ChainState {
    middlewares: Vec<MiddlewareEntry>,
    index: usize,
    handler_fn: *mut u8,
    handler_env: *mut u8,
}
```
(Note: MiddlewareEntry must derive/impl Clone, or use a raw copy approach for the Vec. Simplest: implement Clone for MiddlewareEntry since it only contains Copy types.)

2. Add `chain_next` trampoline function with signature `extern "C" fn(env_ptr: *mut u8, request_ptr: *mut u8) -> *mut u8`. This is what Snow calls when middleware invokes `next(request)`. Logic:
   - Cast `env_ptr` to `*const ChainState`
   - If `state.index >= state.middlewares.len()`: call the route handler via `call_handler(state.handler_fn, state.handler_env, request_ptr)`
   - Otherwise: get current middleware at `state.middlewares[state.index]`, create a new ChainState with `index + 1`, build a Snow closure for the new "next" function via `build_snow_closure`, then call the current middleware via `call_middleware`

3. Add `build_snow_closure` helper:
```rust
fn build_snow_closure(fn_ptr: *mut u8, env_ptr: *mut u8) -> *mut u8 {
    unsafe {
        let closure = snow_gc_alloc_actor(16, 8) as *mut *mut u8;
        *closure = fn_ptr;
        *closure.add(1) = env_ptr;
        closure as *mut u8
    }
}
```
This allocates a 16-byte GC-managed struct with fn_ptr at offset 0 and env_ptr at offset 8, matching Snow's closure layout `{ fn_ptr, env_ptr }`.

4. Add `call_handler` helper:
```rust
fn call_handler(fn_ptr: *mut u8, env_ptr: *mut u8, request: *mut u8) -> *mut u8
```
If env_ptr is null: transmute fn_ptr to `fn(*mut u8) -> *mut u8` and call with request. If non-null: transmute to `fn(*mut u8, *mut u8) -> *mut u8` and call with (env_ptr, request). This extracts the existing handler-call pattern from handle_request.

5. Add `call_middleware` helper:
```rust
fn call_middleware(fn_ptr: *mut u8, env_ptr: *mut u8, request: *mut u8, next_closure: *mut u8) -> *mut u8
```
If env_ptr is null: transmute fn_ptr to `fn(*mut u8, *mut u8) -> *mut u8` and call with (request, next_closure). If non-null: transmute to `fn(*mut u8, *mut u8, *mut u8) -> *mut u8` and call with (env_ptr, request, next_closure). Middleware functions are bare functions taking (request, next) where next is a closure pointer.

6. Update `handle_request` to execute middleware chain. Replace the existing direct handler call block with:
   - If `router.middlewares.is_empty()`: use the existing direct call pattern (fast path, no overhead for apps without middleware)
   - Otherwise: create a `ChainState { middlewares: router.middlewares (cloned), index: 0, handler_fn, handler_env }`, then call `chain_next(Box::into_raw(Box::new(state)) as *mut u8, req_ptr)` to start the chain
   - IMPORTANT: For the 404 case (no route match), if middleware is non-empty, create a synthetic 404 handler and wrap it in the middleware chain too. The synthetic handler should return `snow_http_response_new(404, snow_string_new("Not Found", 9))`. If middleware is empty, use the existing 404 response directly. This ensures SC-1 compliance ("runs on every request").

7. Clone derive for MiddlewareEntry: Add `#[derive(Clone)]` or manually implement Clone (both fn_ptr and env_ptr are `*mut u8` which is Copy but not auto-Clone on structs).

**mod.rs changes:**

Add `snow_http_use_middleware` to the router re-exports:
```rust
pub use router::{
    snow_http_route, snow_http_route_delete, snow_http_route_get, snow_http_route_post,
    snow_http_route_put, snow_http_router, snow_http_use_middleware,
};
```
  </action>
  <verify>
Run `cargo test -p snow-rt` -- all existing router and server tests pass, plus middleware-related code compiles. Run `cargo build -p snow-rt --release` to rebuild the release static library.
  </verify>
  <done>
SnowRouter has a middlewares field. snow_http_use_middleware creates a new router with the middleware appended. handle_request builds and executes the middleware chain when middleware is present. The chain_next trampoline correctly constructs Snow-compatible closure structs for the next function. Direct handler calls still work for routers with no middleware (fast path). Middleware runs even on 404 responses when middleware is registered. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline -- intrinsics, type checker, and MIR lowering for HTTP.use</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
Follow the EXACT same pattern as Phase 51's method-specific routing additions.

**intrinsics.rs:**

Add after the Phase 51 method-specific routing block (after the `snow_http_request_param` declaration):
```rust
// Phase 52: Middleware
// snow_http_use_middleware(router: ptr, middleware_fn: ptr) -> ptr
module.add_function("snow_http_use_middleware",
    ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));
```
Note: Only 2 args (router ptr + middleware fn ptr), not 3. The middleware function is passed as a single ptr (MirType::Ptr), NOT as a closure split. This matches the existing handler pattern where the codegen does NOT split the closure because known_functions types it as Ptr.

Add an assertion in the test function:
```rust
assert!(module.get_function("snow_http_use_middleware").is_some());
```

**lower.rs (known_functions):**

Add after the Phase 51 entries:
```rust
// Phase 52: Middleware
self.known_functions.insert("snow_http_use_middleware".to_string(),
    MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr)));
```
Note: The middleware function arg is `MirType::Ptr` (not Closure). This means NO closure splitting in codegen -- the middleware is passed as a single function pointer. This is the SAME pattern as HTTP.route handler.

**lower.rs (map_builtin_name):**

Add to the match block, after the Phase 51 entries:
```rust
// Phase 52: Middleware
"http_use" => "snow_http_use_middleware".to_string(),
```

**builtins.rs:**

Add after the Phase 51 method-specific routing block:
```rust
// Phase 52: HTTP.use(Router, Fn(Request, Fn(Request) -> Response) -> Response) -> Router
env.insert(
    "http_use".into(),
    Scheme::mono(Ty::fun(
        vec![
            router_t.clone(),
            Ty::fun(
                vec![request_t.clone(), Ty::fun(vec![request_t.clone()], response_t.clone())],
                response_t.clone(),
            ),
        ],
        router_t.clone(),
    )),
);
```
The middleware type is `Fn(Request, Fn(Request) -> Response) -> Response`. The outer function takes two args: the request and the `next` callback. The `next` callback type is `Fn(Request) -> Response`.

Add assertion in test:
```rust
assert!(env.lookup("http_use").is_some());
```

**infer.rs:**

Add to the `http_mod` HashMap, after the Phase 51 entries (before `modules.insert("HTTP", http_mod)`):
```rust
// Phase 52: Middleware
http_mod.insert("use".to_string(), Scheme::mono(Ty::fun(
    vec![
        router_t.clone(),
        Ty::fun(
            vec![request_t.clone(), Ty::fun(vec![request_t.clone()], response_t.clone())],
            response_t.clone(),
        ),
    ],
    router_t.clone(),
)));
```
This must exactly match the builtins.rs type signature.
  </action>
  <verify>
Run `cargo test -p snow-codegen` and `cargo test -p snow-typeck` -- all existing tests pass plus new assertions for snow_http_use_middleware and http_use. Then run `cargo build -p snowc --release` to ensure the full compiler builds.
  </verify>
  <done>
`snow_http_use_middleware` is declared in LLVM intrinsics with the correct (ptr, ptr) -> ptr signature. known_functions and map_builtin_name wire `http_use` to `snow_http_use_middleware`. builtins.rs and infer.rs both register the type `(Router, Fn(Request, Fn(Request) -> Response) -> Response) -> Router`. The complete pipeline compiles: Snow `HTTP.use(r, mw)` -> typeck validates types -> MIR lowers to `snow_http_use_middleware` call -> codegen emits LLVM call with correct args.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-rt` -- all existing HTTP tests pass (router matching, request accessors, response creation)
2. `cargo test -p snow-codegen` -- intrinsic declaration test passes for snow_http_use_middleware
3. `cargo test -p snow-typeck` -- builtin registration test passes for http_use
4. `cargo build -p snowc --release` -- full compiler builds with no errors
5. `cargo build -p snow-rt --release` -- runtime library builds with middleware support
</verification>

<success_criteria>
- snow_http_use_middleware runtime function creates a new router with middleware appended
- handle_request builds and executes middleware chain (trampoline + Snow closure construction)
- Middleware runs on every request including 404s (when middleware is registered)
- Full compiler pipeline wired: HTTP.use compiles from Snow source to LLVM call
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/52-http-middleware/52-01-SUMMARY.md`
</output>
