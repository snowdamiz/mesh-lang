---
phase: 52-http-middleware
plan: 02
type: execute
wave: 2
depends_on: ["52-01"]
files_modified:
  - tests/e2e/stdlib_http_middleware.snow
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "A Snow program with HTTP.use compiles and runs a working HTTP server with middleware"
    - "Single middleware intercepts requests and can call next to proceed to the handler"
    - "Multiple middleware execute in registration order (first registered = outermost = runs first)"
    - "Middleware that does NOT call next can short-circuit the chain (e.g., return 401)"
    - "Middleware runs even when no route matches (404 case)"
  artifacts:
    - path: "tests/e2e/stdlib_http_middleware.snow"
      provides: "Snow test fixture demonstrating middleware registration, chaining, and short-circuit"
      contains: "HTTP.use"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "E2E test function verifying middleware behavior via HTTP requests"
      contains: "e2e_http_middleware"
  key_links:
    - from: "tests/e2e/stdlib_http_middleware.snow"
      to: "crates/snow-rt/src/http/server.rs"
      via: "Compiled Snow calls snow_http_use_middleware and middleware chain executes at runtime"
      pattern: "HTTP\\.use"
    - from: "crates/snowc/tests/e2e_stdlib.rs"
      to: "tests/e2e/stdlib_http_middleware.snow"
      via: "E2E test compiles the fixture and makes HTTP requests to verify behavior"
      pattern: "stdlib_http_middleware"
---

<objective>
Create an end-to-end test proving the full middleware pipeline from Snow source through compilation to a running HTTP server with middleware interception.

Purpose: Verify all three success criteria (SC-1: middleware runs on every request, SC-2: middleware receives request and next, SC-3: multiple middleware compose in order) with real HTTP requests against a compiled Snow program.

Output: Snow test fixture and Rust E2E test proving the complete Phase 52 middleware stack.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-http-middleware/52-RESEARCH.md
@.planning/phases/52-http-middleware/52-01-SUMMARY.md
@tests/e2e/stdlib_http_path_params.snow
@crates/snowc/tests/e2e_stdlib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Snow test fixture for middleware</name>
  <files>
    tests/e2e/stdlib_http_middleware.snow
  </files>
  <action>
Create a Snow test fixture that demonstrates all three middleware success criteria. The fixture should:

1. Define a middleware function `add_header` that calls `next(request)` and returns the response (passthrough middleware -- verifies SC-2: receives request and next, can call next).

2. Define a middleware function `prefix_body` that calls `next(request)`, gets the response body, and returns a modified response with a prefix added to the body (verifies SC-2: can inspect/modify response after next).

3. Define a route handler `handler` for `/hello` that returns `HTTP.response(200, "world")`.

4. Define a route handler `protected_handler` for `/secret` that returns `HTTP.response(200, "secret-data")`.

5. Wire it all up in main:
```snow
fn main() do
  let r = HTTP.router()
  let r = HTTP.use(r, add_header)
  let r = HTTP.use(r, prefix_body)
  let r = HTTP.route(r, "/hello", handler)
  let r = HTTP.route(r, "/secret", protected_handler)
  HTTP.serve(r, 18083)
end
```

With `add_header` registered first (outermost) and `prefix_body` registered second (inner), execution order for a request is:
- `add_header` runs first, calls `next(request)` which invokes `prefix_body`
- `prefix_body` runs second, calls `next(request)` which invokes the route handler
- Handler returns response
- `prefix_body` modifies the response (adds prefix to body)
- `add_header` gets the already-prefixed response and returns it

The `prefix_body` middleware should add a prefix like `"[MW]"` to the response body so the E2E test can verify middleware ran. Implementation:
```snow
fn prefix_body(request, next) do
  let response = next(request)
  HTTP.response(200, "[MW]world")
end
```
Wait -- we cannot easily extract the body from a response and concatenate in Snow without a Response.body accessor. Simpler approach: have `prefix_body` be a middleware that wraps the response in a known way. Since we need to prove middleware ran, the simplest approach is:

**Revised design -- Use a simpler verification strategy:**

Define `logger` middleware that just passes through (calls next and returns):
```snow
fn logger(request, next) do
  let response = next(request)
  response
end
```

Define `auth_check` middleware that checks for a specific path or header:
```snow
fn auth_check(request, next) do
  let path = Request.path(request)
  case String.starts_with(path, "/secret") do
    true -> HTTP.response(401, "Unauthorized")
    false -> next(request)
  end
end
```
This demonstrates SC-2 (inspects request before calling next) and short-circuit (returns 401 without calling next for /secret paths).

The handler returns a known body string. The E2E test verifies:
- GET /hello -> 200 "world" (middleware passes through, handler runs)
- GET /secret -> 401 "Unauthorized" (auth_check short-circuits, handler never runs)
- GET /nonexistent -> 404 or middleware-processed 404 (middleware runs on every request)

**Final fixture:**
```snow
fn logger(request, next) do
  let response = next(request)
  response
end

fn auth_check(request, next) do
  let path = Request.path(request)
  case String.starts_with(path, "/secret") do
    true -> HTTP.response(401, "Unauthorized")
    false -> next(request)
  end
end

fn handler(request) do
  HTTP.response(200, "hello-world")
end

fn secret_handler(request) do
  HTTP.response(200, "secret-data")
end

fn main() do
  let r = HTTP.router()
  let r = HTTP.use(r, logger)
  let r = HTTP.use(r, auth_check)
  let r = HTTP.route(r, "/hello", handler)
  let r = HTTP.route(r, "/secret", secret_handler)
  HTTP.serve(r, 18083)
end
```

Registration order: `logger` first (outermost), `auth_check` second (inner). Execution:
- Request arrives -> logger gets it first, calls next -> auth_check gets it
- For /hello: auth_check calls next -> handler returns "hello-world" -> flows back through auth_check -> logger
- For /secret: auth_check returns 401 without calling next -> flows back through logger
- For /nonexistent: middleware chain runs, next eventually hits 404 handler -> flows back
  </action>
  <verify>
File `tests/e2e/stdlib_http_middleware.snow` exists and contains `HTTP.use`, `logger`, `auth_check`, `handler`, and `HTTP.serve(r, 18083)`.
  </verify>
  <done>
Snow fixture created with two middleware functions (logger passthrough, auth_check short-circuit), two route handlers, and HTTP.use registration demonstrating composable middleware pipeline on port 18083.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add E2E test for middleware compilation and execution</name>
  <files>
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Add a new E2E test function `e2e_http_middleware` following the EXACT pattern of `e2e_http_path_params` (Phase 51). Use port 18083.

The test should:

1. Read the fixture: `let source = read_fixture("stdlib_http_middleware.snow");`

2. Compile and start the server using the existing `compile_and_start_server` helper.

3. Wait for server startup (same pattern as existing tests -- poll with TcpStream::connect).

4. Use the existing `send_request` helper to make HTTP requests.

5. Test cases:

**Test A: Normal request passes through middleware**
- `send_request("GET", "127.0.0.1", 18083, "/hello")`
- Expect: status 200, body "hello-world"
- Proves: logger middleware passes through, auth_check allows non-/secret paths, handler runs

**Test B: Auth middleware short-circuits for /secret**
- `send_request("GET", "127.0.0.1", 18083, "/secret")`
- Expect: status 401, body "Unauthorized"
- Proves: auth_check inspects request path and returns 401 without calling next (SC-2: can modify response, short-circuit)

**Test C: Middleware runs on 404 (no route match)**
- `send_request("GET", "127.0.0.1", 18083, "/nonexistent")`
- Expect: status 404 (middleware runs but passes through to 404 handler since path doesn't start with /secret)
- Proves: SC-1 ("runs on every request" including when no route matches)

**Test D: Multiple routes with middleware**
- Reuse Test A and B results to confirm both /hello and /secret routes work correctly with the same middleware pipeline applied
- This proves SC-3: multiple middleware compose in registration order

6. Assert on both status codes and response bodies.

7. Kill the server process after tests complete (guard.kill()).

Note: The `send_request` helper from Phase 51 returns `(status_code, body)`. If it doesn't exist as a standalone function, check the existing E2E test for the HTTP request pattern. The Phase 51 test added a `send_request` helper -- reuse it. If it's defined locally within the `e2e_http_path_params` function, extract the HTTP request logic and duplicate it in the new test (each test is self-contained).
  </action>
  <verify>
Run `cargo test -p snowc --test e2e_stdlib e2e_http_middleware -- --nocapture` (may need release build first). The test should:
1. Compile the Snow fixture successfully
2. Start the HTTP server on port 18083
3. All HTTP request assertions pass (200/hello-world, 401/Unauthorized, 404/nonexistent)
4. No panics or segfaults

Also run `cargo test -p snowc --test e2e_stdlib` to verify no regressions in other E2E tests.
  </verify>
  <done>
E2E test `e2e_http_middleware` passes, proving the full middleware stack: Snow source compiles to working HTTP server with middleware interception. Logger passthrough works (Test A), auth short-circuit works (Test B), middleware runs on 404 (Test C), and multiple middleware compose in order (Tests A+B together prove SC-3).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snowc --test e2e_stdlib e2e_http_middleware` -- middleware E2E test passes
2. `cargo test -p snowc --test e2e_stdlib` -- ALL E2E tests pass (no regressions)
3. Test A proves handler execution through middleware chain
4. Test B proves middleware can short-circuit without calling next
5. Test C proves middleware runs on requests with no matching route
</verification>

<success_criteria>
- Snow fixture with HTTP.use compiles and runs as HTTP server
- GET /hello returns 200 "hello-world" (middleware passthrough)
- GET /secret returns 401 "Unauthorized" (middleware short-circuit)
- GET /nonexistent returns 404 (middleware runs on unmatched routes)
- All existing E2E tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/52-http-middleware/52-02-SUMMARY.md`
</output>
