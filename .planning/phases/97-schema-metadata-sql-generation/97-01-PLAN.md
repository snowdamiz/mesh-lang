---
phase: 097-schema-metadata-sql-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-parser/src/syntax_kind.rs
  - crates/mesh-parser/src/parser/items.rs
  - crates/mesh-parser/src/ast/item.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "struct with deriving(Schema) and `table \"custom_name\"` option uses the custom table name instead of naive pluralization"
    - "struct with `primary_key :custom_pk` option uses the specified primary key instead of default \"id\""
    - "struct with `timestamps true` option has inserted_at and updated_at in __fields__() and __field_types__() output"
    - "__field_types__() returns List<String> with \"field_name:SQL_TYPE\" entries mapping each field to its PostgreSQL type"
    - "User.__name_col__() returns \"name\" as a String for type-safe column references"
  artifacts:
    - path: "crates/mesh-parser/src/parser/items.rs"
      provides: "Schema option parsing (table, primary_key, timestamps)"
      contains: "parse_schema_option"
    - path: "crates/mesh-parser/src/ast/item.rs"
      provides: "SchemaOption AST node with accessors"
      contains: "SchemaOption"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Type registration for __field_types__ and column accessors"
      contains: "__field_types__"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Enhanced generate_schema_metadata with field types, column accessors, timestamps, configurable table/PK"
      contains: "mir_type_to_sql_type"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "E2E tests for all new Schema metadata functions"
      contains: "e2e_schema_field_types"
  key_links:
    - from: "crates/mesh-parser/src/parser/items.rs"
      to: "crates/mesh-parser/src/ast/item.rs"
      via: "SCHEMA_OPTION node kind parsed and wrapped as SchemaOption AST type"
      pattern: "SCHEMA_OPTION"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-typeck/src/infer.rs"
      via: "MIR functions match type signatures registered in typeck"
      pattern: "__field_types__|__.*_col__"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-parser/src/ast/item.rs"
      via: "lower_struct_def reads schema options from AST to configure metadata generation"
      pattern: "schema_options|timestamps|table_option"
---

<objective>
Extend deriving(Schema) to produce complete compile-time metadata: configurable table name and primary key via schema options, field-to-SQL-type mappings, automatic timestamp field injection, and per-field column accessor functions.

Purpose: Phase 97 builds on the Phase 96-04 Schema derive foundation to produce the full metadata that the runtime SQL generation (Plan 97-02) and the Phase 98 Query Builder need. Without field type mappings, the SQL builders cannot generate type-correct parameterized queries. Without schema options, developers cannot configure table names or primary keys. Without column accessors, queries require raw strings instead of type-safe references.

Output: Enhanced deriving(Schema) codegen producing __field_types__(), configurable __table__()/__primary_key__(), timestamp field injection, and per-field __*_col__() accessors. Validated by e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/097-schema-metadata-sql-generation/97-RESEARCH.md
@.planning/phases/96-compiler-additions/96-04-SUMMARY.md
@crates/mesh-parser/src/parser/items.rs
@crates/mesh-parser/src/ast/item.rs
@crates/mesh-parser/src/syntax_kind.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parse schema options and extend AST/typeck for new metadata functions</name>
  <files>
    crates/mesh-parser/src/syntax_kind.rs
    crates/mesh-parser/src/parser/items.rs
    crates/mesh-parser/src/ast/item.rs
    crates/mesh-typeck/src/infer.rs
  </files>
  <action>
**Parser: Add SCHEMA_OPTION node kind and parse schema options in struct bodies.**

In `crates/mesh-parser/src/syntax_kind.rs`, add `SCHEMA_OPTION` to the composite node kinds (alongside `RELATIONSHIP_DECL`).

In `crates/mesh-parser/src/parser/items.rs`, in the struct body parsing loop (around line 283 where `belongs_to`, `has_many`, `has_one` are checked), add schema option detection BEFORE the relationship check. Schema options are: `table`, `primary_key`, `timestamps`. These are contextual identifiers (not keywords) following the same pattern as relationship declarations.

Add this check before the relationship check:
```
if text == "table" || text == "primary_key" || text == "timestamps" {
    parse_schema_option(p);
    if p.has_error() { break; }
    continue;
}
```

Implement `parse_schema_option(p: &mut Parser)`:
- Open a SCHEMA_OPTION node marker
- Advance past the option name IDENT token
- For `table`: expect a STRING_LITERAL token (the custom table name)
- For `primary_key`: expect an ATOM_LITERAL token (e.g., `:custom_id`)
- For `timestamps`: expect an IDENT token with text "true" or "false"
- Close the marker as SCHEMA_OPTION
- Skip optional NEWLINE after the option

Schema options MUST come before field declarations in struct bodies. This is naturally enforced because the parser tries schema options first, then relationships, then falls through to field parsing. No explicit ordering enforcement needed beyond the check order.

**AST: Add SchemaOption typed wrapper.**

In `crates/mesh-parser/src/ast/item.rs`:
- Add `SchemaOption` AST node using `ast_node!(SchemaOption, SCHEMA_OPTION)` pattern (same as RelationshipDecl).
- Add accessors:
  - `option_name() -> Option<String>`: returns the first IDENT token text ("table", "primary_key", "timestamps")
  - `string_value() -> Option<String>`: returns STRING_LITERAL token text (for `table` option), stripping quotes
  - `atom_value() -> Option<String>`: returns ATOM_LITERAL token text (for `primary_key` option), stripping leading colon
  - `bool_value() -> Option<bool>`: returns true/false from IDENT text (for `timestamps` option)
- Add `schema_options() -> Vec<SchemaOption>` accessor on `StructDef` that collects all SCHEMA_OPTION children.

**Type checker: Register new metadata function signatures.**

In `crates/mesh-typeck/src/infer.rs`, in the `deriving(Schema)` block (around line 2315), add registrations for the new functions:

```rust
// __field_types__ :: () -> List<String>
let ft_fn_name = format!("{}.__field_types__", name);
env.insert(ft_fn_name, Scheme::mono(Ty::fun(vec![], Ty::list(Ty::string()))));
```

Also register per-field column accessor functions. The type checker has access to the struct's fields (they are being processed in this same block). For each field in the struct:
```rust
// __{field}_col__ :: () -> String
let col_fn_name = format!("{}.__{}_col__", name, field_name);
env.insert(col_fn_name, Scheme::mono(Ty::fun(vec![], Ty::string())));
```

To get the field names in the type checker, iterate over the StructDef's fields (the struct_def is available from the AST node being processed). Use `struct_def.fields()` to get field names.

Also update the field access resolution in the type checker (around line 5628) to handle the new function names. The existing check matches `__table__`, `__fields__`, `__primary_key__`, `__relationships__`. Extend this to also match `__field_types__` and any name matching the pattern `__*_col__`:
```rust
if field_name == "__table__" || field_name == "__fields__"
    || field_name == "__primary_key__" || field_name == "__relationships__"
    || field_name == "__field_types__"
    || field_name.starts_with("__") && field_name.ends_with("_col__")
```
  </action>
  <verify>
Run `cargo build -p mesh-parser -p mesh-typeck 2>&1` to confirm both crates compile cleanly. Then run a quick grep to confirm the new SCHEMA_OPTION kind exists and parse_schema_option function is defined:
```
grep -n "SCHEMA_OPTION" crates/mesh-parser/src/syntax_kind.rs
grep -n "parse_schema_option" crates/mesh-parser/src/parser/items.rs
grep -n "__field_types__" crates/mesh-typeck/src/infer.rs
```
  </verify>
  <done>
SCHEMA_OPTION node kind exists in syntax_kind.rs. Schema options (table, primary_key, timestamps) parse inside struct bodies. SchemaOption AST wrapper provides option_name/string_value/atom_value/bool_value accessors. StructDef.schema_options() collects all schema options. Type checker registers __field_types__ and per-field __*_col__ function signatures. Both crates compile with zero errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend MIR codegen for field types, column accessors, schema options, timestamps + e2e tests</name>
  <files>
    crates/mesh-codegen/src/mir/lower.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
**MIR lowering: Add mir_type_to_sql_type helper.**

Add a standalone function (or method) in `lower.rs`:
```rust
fn mir_type_to_sql_type(ty: &MirType) -> &'static str {
    match ty {
        MirType::Int => "BIGINT",
        MirType::Float => "DOUBLE PRECISION",
        MirType::Bool => "BOOLEAN",
        MirType::String => "TEXT",
        _ => "TEXT",  // Default fallback for Ptr and other types
    }
}
```

**MIR lowering: Extend generate_schema_metadata signature.**

Change `generate_schema_metadata` to accept schema options:
```rust
fn generate_schema_metadata(
    &mut self,
    name: &str,
    fields: &[(String, MirType)],
    relationships: &[RelationshipDecl],
    custom_table: Option<String>,
    custom_pk: Option<String>,
    has_timestamps: bool,
)
```

**MIR lowering: Inject timestamp fields before generating metadata.**

In `lower_struct_def()`, at the Schema derive branch (line 1795):
1. Read schema options from the struct AST: call `struct_def.schema_options()` and extract `table`, `primary_key`, `timestamps` values.
2. If `timestamps` is true, append `("inserted_at", MirType::String)` and `("updated_at", MirType::String)` to a cloned fields vector BEFORE calling `generate_schema_metadata`.
3. Also push these fields into the `MirStructDef` fields list (line 1801: `self.structs.push(MirStructDef { name, fields })`). Clone fields before the struct push, inject timestamps, and use the extended fields for both the metadata and the struct def.
4. Pass `custom_table`, `custom_pk`, `has_timestamps` to `generate_schema_metadata`.

**MIR lowering: Use custom table name and primary key.**

In `generate_schema_metadata`:
- For `__table__()`: if `custom_table` is `Some(t)`, use `t` instead of `format!("{}s", name.to_lowercase())`.
- For `__primary_key__()`: if `custom_pk` is `Some(pk)`, use `pk` instead of `"id"`.

**MIR lowering: Add __field_types__() function generation.**

After the existing `__fields__()` generation, add:
```rust
// __ __field_types__() __
// Returns List<String> where each entry is "field_name:SQL_TYPE"
let field_type_elements: Vec<MirExpr> = fields.iter()
    .map(|(fname, fty)| {
        let sql_type = mir_type_to_sql_type(fty);
        MirExpr::StringLit(format!("{}:{}", fname, sql_type), MirType::String)
    })
    .collect();
let ft_fn_name = format!("{}____field_types__", name);
self.functions.push(MirFunction {
    name: ft_fn_name.clone(),
    params: vec![],
    return_type: MirType::Ptr,
    body: MirExpr::ListLit { elements: field_type_elements, ty: MirType::Ptr },
    is_closure_fn: false,
    captures: vec![],
    has_tail_calls: false,
});
self.known_functions.insert(ft_fn_name, MirType::FnPtr(vec![], Box::new(MirType::Ptr)));
```

**MIR lowering: Add per-field column accessor functions.**

After __field_types__() generation:
```rust
// Per-field column accessors: User.__name_col__() -> "name"
for (fname, _fty) in fields {
    let col_fn_name = format!("{}____{}_col__", name, fname);
    self.functions.push(MirFunction {
        name: col_fn_name.clone(),
        params: vec![],
        return_type: MirType::String,
        body: MirExpr::StringLit(fname.clone(), MirType::String),
        is_closure_fn: false,
        captures: vec![],
        has_tail_calls: false,
    });
    self.known_functions.insert(col_fn_name, MirType::FnPtr(vec![], Box::new(MirType::String)));
}
```

**MIR lowering: Update field access resolution for new functions.**

At line 6246, extend the check that matches `__table__`, `__fields__`, `__primary_key__`, `__relationships__` to also match `__field_types__` and any `__*_col__` pattern:
```rust
if field == "__table__" || field == "__fields__"
    || field == "__primary_key__" || field == "__relationships__"
    || field == "__field_types__"
    || (field.starts_with("__") && field.ends_with("_col__"))
{
```

**E2E tests: Add comprehensive tests.**

Add the following e2e tests in `crates/meshc/tests/e2e.rs`:

1. `e2e_schema_field_types` -- Verify `User.__field_types__()` returns correct SQL type mappings:
```mesh
struct User do
  id :: String
  name :: String
  age :: Int
  active :: Bool
  score :: Float
end deriving(Schema)

fn main() do
  let types = User.__field_types__()
  println(List.get(types, 0))
  println(List.get(types, 2))
  println(List.get(types, 3))
  println(List.get(types, 4))
end
```
Expected output: `id:TEXT\nage:BIGINT\nactive:BOOLEAN\nscore:DOUBLE PRECISION\n`

2. `e2e_schema_column_accessor` -- Verify `User.__name_col__()` returns "name":
```mesh
struct User do
  id :: String
  name :: String
  email :: String
end deriving(Schema)

fn main() do
  println(User.__name_col__())
  println(User.__email_col__())
  println(User.__id_col__())
end
```
Expected output: `name\nemail\nid\n`

3. `e2e_schema_custom_table_name` -- Verify `table "people"` overrides default:
```mesh
struct User do
  table "people"
  id :: String
  name :: String
end deriving(Schema)

fn main() do
  println(User.__table__())
end
```
Expected output: `people\n`

4. `e2e_schema_custom_primary_key` -- Verify `primary_key :uuid` overrides default "id":
```mesh
struct User do
  primary_key :uuid
  uuid :: String
  name :: String
end deriving(Schema)

fn main() do
  println(User.__primary_key__())
end
```
Expected output: `uuid\n`

5. `e2e_schema_timestamps` -- Verify `timestamps true` injects inserted_at/updated_at:
```mesh
struct User do
  timestamps true
  id :: String
  name :: String
end deriving(Schema)

fn main() do
  let fields = User.__fields__()
  let types = User.__field_types__()
  let n = List.length(fields)
  println(Int.to_string(n))
  println(List.get(fields, 2))
  println(List.get(fields, 3))
  println(List.get(types, 2))
end
```
Expected output: `4\ninserted_at\nupdated_at\ninserted_at:TEXT\n`

6. `e2e_schema_defaults_unchanged` -- Verify existing behavior without options is unchanged:
```mesh
struct Post do
  id :: String
  title :: String
end deriving(Schema)

fn main() do
  println(Post.__table__())
  println(Post.__primary_key__())
end
```
Expected output: `posts\nid\n`

Run ALL existing e2e tests to confirm zero regressions: `cargo test -p meshc --test e2e 2>&1 | tail -5`
  </action>
  <verify>
Run `cargo test -p meshc --test e2e 2>&1 | tail -20` to confirm all tests pass including the 6 new ones. Also run `cargo build --workspace 2>&1 | tail -5` to confirm full workspace build succeeds.
  </verify>
  <done>
generate_schema_metadata accepts schema options (custom_table, custom_pk, has_timestamps). mir_type_to_sql_type maps MirType to SQL type strings. __field_types__() returns "field:SQL_TYPE" encoded strings. Per-field __*_col__() accessors return column name strings. Timestamp fields injected into struct layout and metadata when timestamps true. Custom table/PK override defaults. All 6 new e2e tests pass. All existing e2e tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p meshc --test e2e` passes all tests (existing + 6 new)
- `cargo build --workspace` succeeds with no errors
- Schema options parse correctly: `table "name"`, `primary_key :pk`, `timestamps true`
- `User.__field_types__()` returns correct SQL type mappings for Int/Float/Bool/String
- `User.__name_col__()` returns the column name string
- Custom table name overrides naive pluralization
- Custom primary key overrides default "id"
- Timestamps injects inserted_at/updated_at into field list and field types
</verification>

<success_criteria>
All 5 SCHM requirements addressed: SCHM-01 (table name with configurable override), SCHM-02 (field metadata with SQL type mapping), SCHM-03 (configurable primary key), SCHM-04 (timestamps support), SCHM-05 (column accessor functions). All e2e tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/097-schema-metadata-sql-generation/97-01-SUMMARY.md`
</output>
