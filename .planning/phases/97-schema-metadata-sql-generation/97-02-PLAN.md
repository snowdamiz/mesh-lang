---
phase: 097-schema-metadata-sql-generation
plan: 02
type: execute
wave: 2
depends_on: ["97-01"]
files_modified:
  - crates/mesh-rt/src/db/orm.rs
  - crates/mesh-rt/src/db/mod.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-repl/src/jit.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "mesh_orm_build_select produces a parameterized SELECT query with $1, $2 placeholders and double-quoted identifiers"
    - "mesh_orm_build_insert produces INSERT INTO with $1, $2 placeholders and RETURNING clause"
    - "mesh_orm_build_update produces UPDATE with SET clause using $1, $2 placeholders and WHERE condition"
    - "mesh_orm_build_delete produces DELETE FROM with WHERE condition using $1 placeholder"
    - "All SQL builders return both the SQL string and a parameter count for caller coordination"
  artifacts:
    - path: "crates/mesh-rt/src/db/orm.rs"
      provides: "Runtime SQL generation functions"
      contains: "mesh_orm_build_select"
    - path: "crates/mesh-rt/src/db/mod.rs"
      provides: "orm module registration"
      contains: "pub mod orm"
    - path: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for ORM runtime functions"
      contains: "mesh_orm_build_select"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "E2E tests for SQL generation"
      contains: "e2e_orm_build_select"
  key_links:
    - from: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      to: "crates/mesh-rt/src/db/orm.rs"
      via: "LLVM intrinsic declarations match extern C function signatures"
      pattern: "mesh_orm_build_select"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      via: "known_functions registered for ORM module resolution"
      pattern: "Orm\\.build_select|mesh_orm_build"
---

<objective>
Create the runtime SQL generation module providing four parameterized query builder functions (SELECT, INSERT, UPDATE, DELETE) that produce correctly quoted, parameterized PostgreSQL SQL from structured inputs.

Purpose: Phase 98's Query Builder calls these runtime functions to produce actual SQL strings. Without these, the ORM cannot generate queries. The functions are "string template engines" -- they handle SQL syntax, identifier quoting, and parameter numbering, while query composition logic lives in Phase 98's Mesh code.

Output: New `crates/mesh-rt/src/db/orm.rs` module with four `extern "C"` functions, LLVM intrinsic declarations, known_functions registrations, and e2e tests proving correct SQL generation.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/097-schema-metadata-sql-generation/97-RESEARCH.md
@.planning/phases/097-schema-metadata-sql-generation/97-01-SUMMARY.md
@crates/mesh-rt/src/db/pg.rs
@crates/mesh-rt/src/db/pool.rs
@crates/mesh-rt/src/db/mod.rs
@crates/mesh-rt/src/string.rs
@crates/mesh-codegen/src/codegen/intrinsics.rs
@crates/mesh-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement runtime SQL builder functions in mesh-rt</name>
  <files>
    crates/mesh-rt/src/db/orm.rs
    crates/mesh-rt/src/db/mod.rs
    crates/mesh-rt/src/lib.rs
  </files>
  <action>
**Create `crates/mesh-rt/src/db/orm.rs` with four SQL builder functions.**

All functions follow the established `extern "C"` pattern from `pg.rs` and `pool.rs`. They accept Mesh runtime types (MeshString pointers, List pointers) and return MeshString pointers.

**Helper function: `quote_ident`**
```rust
/// Quote a SQL identifier with double quotes (PostgreSQL convention).
/// Escapes embedded double quotes by doubling them.
fn quote_ident(name: &str) -> String {
    format!("\"{}\"", name.replace('"', "\"\""))
}
```

**Helper function: extracting strings from a Mesh List<String>**

Use the existing runtime list functions to read list elements. Import from crate:
```rust
use crate::collections::list::{mesh_list_get, mesh_list_length};
use crate::string::{mesh_string_new, MeshString};
```

Create a helper to extract a `Vec<String>` from a Mesh `List<String>` pointer:
```rust
unsafe fn list_to_strings(list_ptr: *mut u8) -> Vec<String> {
    let len = mesh_list_length(list_ptr);
    let mut result = Vec::with_capacity(len as usize);
    for i in 0..len {
        let elem = mesh_list_get(list_ptr, i) as *const MeshString;
        if !elem.is_null() {
            result.push((*elem).as_str().to_string());
        }
    }
    result
}
```

**Helper: creating a Mesh string from a Rust String**
```rust
unsafe fn rust_string_to_mesh(s: &str) -> *mut u8 {
    mesh_string_new(s.as_ptr(), s.len() as u64) as *mut u8
}
```

**Function 1: `mesh_orm_build_select`**

Signature: `(table: *const MeshString, columns: *mut u8, where_clauses: *mut u8, order_by: *mut u8, limit: i64, offset: i64) -> *mut u8`

- `table`: table name string
- `columns`: List<String> of column names (empty list = SELECT *)
- `where_clauses`: List<String> where each entry is "column_name=op" (e.g., "name==", "age=>"). The operator is the last character(s) after the field name. Each clause gets a `$N` parameter. If the entry ends with just a column name (no operator suffix), default to `=`.
- `order_by`: List<String> where each entry is "column_name direction" (e.g., "name ASC", "age DESC")
- `limit`: -1 means no limit, otherwise adds LIMIT clause
- `offset`: -1 means no offset, otherwise adds OFFSET clause

Build the SQL string:
```sql
SELECT "col1", "col2" FROM "table" WHERE "name" = $1 AND "age" > $2 ORDER BY "name" ASC LIMIT 10 OFFSET 20
```

Use sequential `$N` parameter numbering starting at 1. Return the SQL string as a MeshString pointer.

For the where clause parsing, split each entry on the operator. Supported operators: `=`, `!=`, `>`, `<`, `>=`, `<=`, `LIKE`, `ILIKE`, `IS NULL`, `IS NOT NULL`. The simplest approach: each where_clause entry is formatted as `"column op"` (e.g., `"name ="`, `"age >"`, `"status !="`) -- space-separated column name and operator. The value is always a parameterized `$N`.

Special cases for `IS NULL` and `IS NOT NULL`: these don't consume a parameter.

```rust
#[no_mangle]
pub extern "C" fn mesh_orm_build_select(
    table: *const MeshString,
    columns: *mut u8,
    where_clauses: *mut u8,
    order_by: *mut u8,
    limit: i64,
    offset: i64,
) -> *mut u8 {
    unsafe {
        let table_name = (*table).as_str();
        let cols = list_to_strings(columns);
        let wheres = list_to_strings(where_clauses);
        let orders = list_to_strings(order_by);

        let mut sql = String::new();

        // SELECT clause
        sql.push_str("SELECT ");
        if cols.is_empty() {
            sql.push('*');
        } else {
            let quoted: Vec<String> = cols.iter().map(|c| quote_ident(c)).collect();
            sql.push_str(&quoted.join(", "));
        }

        // FROM clause
        sql.push_str(" FROM ");
        sql.push_str(&quote_ident(table_name));

        // WHERE clause
        let mut param_idx = 1;
        if !wheres.is_empty() {
            sql.push_str(" WHERE ");
            let mut conditions = Vec::new();
            for w in &wheres {
                // Format: "column op" e.g. "name =" or "age >" or "status IS NULL"
                if let Some(space_pos) = w.find(' ') {
                    let col = &w[..space_pos];
                    let op = w[space_pos + 1..].trim();
                    if op == "IS NULL" || op == "IS NOT NULL" {
                        conditions.push(format!("{} {}", quote_ident(col), op));
                    } else {
                        conditions.push(format!("{} {} ${}", quote_ident(col), op, param_idx));
                        param_idx += 1;
                    }
                } else {
                    // Just a column name, default to = operator
                    conditions.push(format!("{} = ${}", quote_ident(w), param_idx));
                    param_idx += 1;
                }
            }
            sql.push_str(&conditions.join(" AND "));
        }

        // ORDER BY clause
        if !orders.is_empty() {
            sql.push_str(" ORDER BY ");
            let order_parts: Vec<String> = orders.iter().map(|o| {
                if let Some(space_pos) = o.rfind(' ') {
                    let col = &o[..space_pos];
                    let dir = &o[space_pos + 1..];
                    format!("{} {}", quote_ident(col), dir.to_uppercase())
                } else {
                    format!("{} ASC", quote_ident(o))
                }
            }).collect();
            sql.push_str(&order_parts.join(", "));
        }

        // LIMIT
        if limit >= 0 {
            sql.push_str(&format!(" LIMIT {}", limit));
        }

        // OFFSET
        if offset >= 0 {
            sql.push_str(&format!(" OFFSET {}", offset));
        }

        rust_string_to_mesh(&sql)
    }
}
```

**Function 2: `mesh_orm_build_insert`**

Signature: `(table: *const MeshString, columns: *mut u8, returning: *mut u8) -> *mut u8`

- `columns`: List<String> of column names for the VALUES clause
- `returning`: List<String> of column names for RETURNING clause (empty = no RETURNING)

Build: `INSERT INTO "table" ("col1", "col2") VALUES ($1, $2) RETURNING "id", "name"`

Parameter indices correspond to column positions (1-indexed).

```rust
#[no_mangle]
pub extern "C" fn mesh_orm_build_insert(
    table: *const MeshString,
    columns: *mut u8,
    returning: *mut u8,
) -> *mut u8
```

**Function 3: `mesh_orm_build_update`**

Signature: `(table: *const MeshString, set_columns: *mut u8, where_clauses: *mut u8, returning: *mut u8) -> *mut u8`

- `set_columns`: List<String> of column names for the SET clause. Each gets `$N` starting at 1.
- `where_clauses`: List<String> of "column op" entries. Parameters continue from where SET left off.
- `returning`: List<String> for RETURNING clause.

Build: `UPDATE "table" SET "name" = $1, "email" = $2 WHERE "id" = $3 RETURNING "id", "name"`

```rust
#[no_mangle]
pub extern "C" fn mesh_orm_build_update(
    table: *const MeshString,
    set_columns: *mut u8,
    where_clauses: *mut u8,
    returning: *mut u8,
) -> *mut u8
```

**Function 4: `mesh_orm_build_delete`**

Signature: `(table: *const MeshString, where_clauses: *mut u8, returning: *mut u8) -> *mut u8`

Build: `DELETE FROM "table" WHERE "id" = $1 RETURNING "id"`

```rust
#[no_mangle]
pub extern "C" fn mesh_orm_build_delete(
    table: *const MeshString,
    where_clauses: *mut u8,
    returning: *mut u8,
) -> *mut u8
```

**Register the module.**

In `crates/mesh-rt/src/db/mod.rs`, add: `pub mod orm;`

In `crates/mesh-rt/src/lib.rs`, add the four functions to the use statement from `db::orm`.

**Add Rust unit tests** in `orm.rs` itself (behind `#[cfg(test)]` module):
- Test `quote_ident("users")` produces `"\"users\""`
- Test `quote_ident("table")` produces `"\"table\""` (reserved word)
- Test `quote_ident("my\"col")` produces `"\"my\"\"col\""` (escaped double quote)
- Integration tests for each builder verifying correct SQL output (these can call the functions directly with mock Mesh lists, or test the string building logic through internal helpers)

Since unit testing requires Mesh runtime GC initialization for mesh_string_new/mesh_list operations, create separate helper functions that work on pure Rust types (`build_select_sql`, `build_insert_sql`, `build_update_sql`, `build_delete_sql`) that the extern C functions call. Unit test the pure Rust helpers directly. This avoids needing GC setup in tests.

For example:
```rust
fn build_select_sql(table: &str, columns: &[String], wheres: &[String], orders: &[String], limit: i64, offset: i64) -> String {
    // ... pure string building logic ...
}

#[no_mangle]
pub extern "C" fn mesh_orm_build_select(...) -> *mut u8 {
    unsafe {
        let table_name = (*table).as_str();
        let cols = list_to_strings(columns);
        let wheres = list_to_strings(where_clauses);
        let orders = list_to_strings(order_by);
        let sql = build_select_sql(table_name, &cols, &wheres, &orders, limit, offset);
        rust_string_to_mesh(&sql)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_select_all() {
        let sql = build_select_sql("users", &[], &[], &[], -1, -1);
        assert_eq!(sql, "SELECT * FROM \"users\"");
    }

    #[test]
    fn test_select_with_columns() {
        let sql = build_select_sql("users", &["id".into(), "name".into()], &[], &[], -1, -1);
        assert_eq!(sql, "SELECT \"id\", \"name\" FROM \"users\"");
    }

    #[test]
    fn test_select_with_where() {
        let sql = build_select_sql("users", &[], &["name =".into(), "age >".into()], &[], -1, -1);
        assert_eq!(sql, "SELECT * FROM \"users\" WHERE \"name\" = $1 AND \"age\" > $2");
    }

    #[test]
    fn test_select_full() {
        let sql = build_select_sql("users", &["id".into(), "name".into()], &["name =".into()], &["name ASC".into()], 10, 20);
        assert_eq!(sql, "SELECT \"id\", \"name\" FROM \"users\" WHERE \"name\" = $1 ORDER BY \"name\" ASC LIMIT 10 OFFSET 20");
    }

    #[test]
    fn test_insert() {
        let sql = build_insert_sql("users", &["name".into(), "email".into()], &["id".into(), "name".into()]);
        assert_eq!(sql, "INSERT INTO \"users\" (\"name\", \"email\") VALUES ($1, $2) RETURNING \"id\", \"name\"");
    }

    #[test]
    fn test_update() {
        let sql = build_update_sql("users", &["name".into(), "email".into()], &["id =".into()], &["id".into()]);
        assert_eq!(sql, "UPDATE \"users\" SET \"name\" = $1, \"email\" = $2 WHERE \"id\" = $3 RETURNING \"id\"");
    }

    #[test]
    fn test_delete() {
        let sql = build_delete_sql("users", &["id =".into()], &[]);
        assert_eq!(sql, "DELETE FROM \"users\" WHERE \"id\" = $1");
    }
}
```
  </action>
  <verify>
Run `cargo test -p mesh-rt -- orm 2>&1` to confirm all unit tests pass. Run `cargo build -p mesh-rt 2>&1 | tail -5` to confirm the crate builds cleanly.
  </verify>
  <done>
Four SQL builder functions implemented in orm.rs with correct parameterized SQL generation. quote_ident handles identifier escaping. Pure Rust helper functions are unit-tested. Module registered in db/mod.rs and re-exported from lib.rs. mesh-rt builds cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Declare intrinsics, register known functions, and add e2e tests</name>
  <files>
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-repl/src/jit.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
**Declare LLVM intrinsics for the four ORM functions.**

In `crates/mesh-codegen/src/codegen/intrinsics.rs`, add declarations after the existing Phase 58 (row/query_as) section. Add a comment block: `// Phase 97: ORM SQL Generation`.

```rust
// Phase 97: ORM SQL Generation

// mesh_orm_build_select(table: ptr, columns: ptr, where_clauses: ptr, order_by: ptr, limit: i64, offset: i64) -> ptr
module.add_function("mesh_orm_build_select",
    ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into(), i64_type.into(), i64_type.into()], false),
    Some(inkwell::module::Linkage::External));

// mesh_orm_build_insert(table: ptr, columns: ptr, returning: ptr) -> ptr
module.add_function("mesh_orm_build_insert",
    ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));

// mesh_orm_build_update(table: ptr, set_columns: ptr, where_clauses: ptr, returning: ptr) -> ptr
module.add_function("mesh_orm_build_update",
    ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));

// mesh_orm_build_delete(table: ptr, where_clauses: ptr, returning: ptr) -> ptr
module.add_function("mesh_orm_build_delete",
    ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));
```

Also add assertions in the intrinsics test at the bottom:
```rust
// Phase 97: ORM SQL Generation
assert!(module.get_function("mesh_orm_build_select").is_some());
assert!(module.get_function("mesh_orm_build_insert").is_some());
assert!(module.get_function("mesh_orm_build_update").is_some());
assert!(module.get_function("mesh_orm_build_delete").is_some());
```

**Register in known_functions for the Orm module.**

In `crates/mesh-codegen/src/mir/lower.rs`, register the four functions so they can be called from Mesh code via `Orm.build_select(...)` etc. Find the section where builtin module functions are registered (search for where `Pg.query` or `Pool.query` are mapped). Add:

```rust
// Orm module functions (Phase 97)
"Orm" => match method {
    "build_select" => Some("mesh_orm_build_select"),
    "build_insert" => Some("mesh_orm_build_insert"),
    "build_update" => Some("mesh_orm_build_update"),
    "build_delete" => Some("mesh_orm_build_delete"),
    _ => None,
}
```

Also register in the type checker if needed. Check how `Pg.query` and `Pool.query` are typed in `infer.rs`. The ORM functions need similar treatment: register `Orm.build_select` etc. with appropriate signatures:
- `Orm.build_select :: (String, List<String>, List<String>, List<String>, Int, Int) -> String`
- `Orm.build_insert :: (String, List<String>, List<String>) -> String`
- `Orm.build_update :: (String, List<String>, List<String>, List<String>) -> String`
- `Orm.build_delete :: (String, List<String>, List<String>) -> String`

Find the stdlib/module function registration section in `infer.rs` (search for "Pg.query" or "Pool.query") and add Orm functions similarly.

**Register JIT symbols for REPL.**

In `crates/mesh-repl/src/jit.rs`, add the four ORM function symbols following the existing pattern:
```rust
ee.add_global_mapping(&find_fn("mesh_orm_build_select"), mesh_orm_build_select as usize);
ee.add_global_mapping(&find_fn("mesh_orm_build_insert"), mesh_orm_build_insert as usize);
ee.add_global_mapping(&find_fn("mesh_orm_build_update"), mesh_orm_build_update as usize);
ee.add_global_mapping(&find_fn("mesh_orm_build_delete"), mesh_orm_build_delete as usize);
```

Add the imports at the top of the JIT file from `mesh_rt::db::orm`.

**E2E tests.**

Add tests in `crates/meshc/tests/e2e.rs` that call the ORM functions from Mesh code:

1. `e2e_orm_build_select_simple`:
```mesh
fn main() do
  let cols = ["id", "name"]
  let wheres = ["name ="]
  let orders = ["name ASC"]
  let sql = Orm.build_select("users", cols, wheres, orders, 10, -1)
  println(sql)
end
```
Expected: `SELECT "id", "name" FROM "users" WHERE "name" = $1 ORDER BY "name" ASC LIMIT 10\n`

2. `e2e_orm_build_select_all`:
```mesh
fn main() do
  let sql = Orm.build_select("users", [], [], [], -1, -1)
  println(sql)
end
```
Expected: `SELECT * FROM "users"\n`

3. `e2e_orm_build_insert`:
```mesh
fn main() do
  let cols = ["name", "email"]
  let returning = ["id"]
  let sql = Orm.build_insert("users", cols, returning)
  println(sql)
end
```
Expected: `INSERT INTO "users" ("name", "email") VALUES ($1, $2) RETURNING "id"\n`

4. `e2e_orm_build_update`:
```mesh
fn main() do
  let set_cols = ["name", "email"]
  let wheres = ["id ="]
  let returning = ["id", "name"]
  let sql = Orm.build_update("users", set_cols, wheres, returning)
  println(sql)
end
```
Expected: `UPDATE "users" SET "name" = $1, "email" = $2 WHERE "id" = $3 RETURNING "id", "name"\n`

5. `e2e_orm_build_delete`:
```mesh
fn main() do
  let wheres = ["id ="]
  let sql = Orm.build_delete("users", wheres, [])
  println(sql)
end
```
Expected: `DELETE FROM "users" WHERE "id" = $1\n`

Run ALL existing e2e tests to confirm zero regressions.
  </action>
  <verify>
Run `cargo test -p meshc --test e2e 2>&1 | tail -20` to confirm all tests pass. Run `cargo test -p mesh-codegen -- intrinsics 2>&1` to confirm intrinsic declarations pass. Run `cargo build --workspace 2>&1 | tail -5` to confirm full workspace builds.
  </verify>
  <done>
Four ORM runtime functions declared as LLVM intrinsics. Orm.build_select/insert/update/delete callable from Mesh code. JIT symbols registered for REPL. 5 e2e tests verify correct parameterized SQL generation for SELECT (with columns, where, order, limit), INSERT (with RETURNING), UPDATE (with SET + WHERE), and DELETE. All existing tests pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p mesh-rt -- orm` passes all unit tests for SQL builders
- `cargo test -p mesh-codegen -- intrinsics` passes with new ORM function assertions
- `cargo test -p meshc --test e2e` passes all tests (existing + 5 new ORM tests)
- `cargo build --workspace` succeeds with no errors
- SELECT produces correct parameterized SQL with WHERE/ORDER BY/LIMIT/OFFSET
- INSERT produces correct parameterized SQL with RETURNING clause
- UPDATE produces correct SET + WHERE with continuous parameter numbering
- DELETE produces correct parameterized SQL
- All identifiers are double-quoted in generated SQL
</verification>

<success_criteria>
Phase 97 success criterion #4 met: Runtime Rust functions (mesh_orm_build_select, mesh_orm_build_insert, mesh_orm_build_update, mesh_orm_build_delete) produce correctly parameterized SQL with $1, $2 placeholders and proper identifier quoting. Functions are callable from Mesh code via Orm module.
</success_criteria>

<output>
After completion, create `.planning/phases/097-schema-metadata-sql-generation/97-02-SUMMARY.md`
</output>
