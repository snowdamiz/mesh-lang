---
phase: 50-json-serde-sum-types-generics
plan: 02
type: execute
wave: 2
depends_on: ["50-01"]
files_modified:
  - tests/e2e/deriving_json_sum_type.snow
  - tests/e2e/deriving_json_generic.snow
  - tests/e2e/deriving_json_nested_sum.snow
  - tests/compile_fail/deriving_json_sum_non_serializable.snow
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "Sum type values encode as tagged JSON objects and decode back to the correct variant"
    - "Generic structs like Wrapper<Int> and Wrapper<String> both derive Json correctly"
    - "Nested combinations (sum type containing a generic struct containing a list) round-trip through JSON"
    - "Compiler emits error for deriving(Json) on sum type with non-serializable variant field"
  artifacts:
    - path: "tests/e2e/deriving_json_sum_type.snow"
      provides: "Sum type JSON encode/decode E2E test"
      contains: "deriving(Json)"
    - path: "tests/e2e/deriving_json_generic.snow"
      provides: "Generic struct JSON encode/decode E2E test"
      contains: "Wrapper"
    - path: "tests/e2e/deriving_json_nested_sum.snow"
      provides: "Nested sum type + struct + list combination E2E test"
      contains: "deriving(Json)"
    - path: "tests/compile_fail/deriving_json_sum_non_serializable.snow"
      provides: "Compile-fail test for non-serializable variant field"
      contains: "deriving(Json)"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "Rust test harness entries for all new E2E tests"
      contains: "deriving_json_sum_type"
  key_links:
    - from: "tests/e2e/deriving_json_sum_type.snow"
      to: "crates/snowc/tests/e2e_stdlib.rs"
      via: "Rust test entry runs Snow compiler and validates output"
      pattern: "deriving_json_sum_type"
    - from: "tests/e2e/deriving_json_generic.snow"
      to: "crates/snowc/tests/e2e_stdlib.rs"
      via: "Rust test entry runs Snow compiler and validates output"
      pattern: "deriving_json_generic"
---

<objective>
E2E test suite for sum type JSON and generic struct JSON: verify encode/decode for sum types with variants (nullary, unary, multi-field), generic struct monomorphization, nested combinations, and compile-fail for non-serializable variant fields.

Purpose: Validate that JSON-08 (sum types as tagged unions) and JSON-09 (generic structs via monomorphization) work end-to-end through the full compiler pipeline.
Output: 3 passing E2E tests + 1 compile-fail test covering all Phase 50 success criteria.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-json-serde-sum-types-generics/50-RESEARCH.md
@.planning/phases/49-json-serde-structs/49-03-SUMMARY.md
@crates/snowc/tests/e2e_stdlib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sum type and generic struct E2E tests</name>
  <files>tests/e2e/deriving_json_sum_type.snow, tests/e2e/deriving_json_generic.snow, crates/snowc/tests/e2e_stdlib.rs</files>
  <action>
  **A. Sum type encode/decode test** (`tests/e2e/deriving_json_sum_type.snow`)

  Create a Snow test file testing sum type JSON:
  ```snow
  type Shape do
    Circle(Float)
    Rectangle(Float, Float)
    Point
  end deriving(Json)
  ```

  Test encoding:
  - `Json.encode(Circle(3.14))` -- expect output containing `"tag":"Circle"` and `"fields":[3.14]`
  - `Json.encode(Rectangle(2.0, 5.0))` -- expect output containing `"tag":"Rectangle"` and `"fields":[2.0,5.0]`
  - `Json.encode(Point)` -- expect output containing `"tag":"Point"` and `"fields":[]`

  Test decoding (round-trip):
  - Encode a Circle, decode with `Shape.from_json(json)`, verify the decoded value re-encodes to the same JSON
  - Use helper functions for case arm bodies (Snow case arms are single expressions)
  - Use unique variable names for Err bindings across case blocks (avoid LLVM domination errors)
  - Use field-by-field verification approach (avoid struct == after from_json, per Phase 49 lesson)

  Print results so the Rust harness can validate output lines.

  **B. Generic struct encode/decode test** (`tests/e2e/deriving_json_generic.snow`)

  Create a Snow test file testing generic struct JSON:
  ```snow
  struct Wrapper<T> do
    value :: T
  end deriving(Json)
  ```

  Test encoding:
  - `Json.encode(Wrapper { value: 42 })` -- expect `{"value":42}` (JSON object order may vary)
  - `Json.encode(Wrapper { value: "hello" })` -- expect `{"value":"hello"}`

  Test decoding (if possible -- from_json on generic structs requires knowing the concrete type):
  - This may require `Wrapper_Int.from_json(json)` or similar mangled name resolution
  - If from_json on generic instantiations is not supported yet, just test encode and note the limitation

  **C. Rust test harness entries** (`crates/snowc/tests/e2e_stdlib.rs`)

  Add test entries for each new test file. Follow the existing pattern (e.g., `deriving_json_basic` test):
  - `deriving_json_sum_type` -- run and validate output lines
  - `deriving_json_generic` -- run and validate output lines
  - For JSON output validation, use `serde_json::Value` parsing and field checks (since JSON key order is non-deterministic)
  </action>
  <verify>
  `cargo test -p snowc deriving_json_sum_type` passes.
  `cargo test -p snowc deriving_json_generic` passes.
  Full suite: `cargo test` passes with zero regressions.
  </verify>
  <done>
  Sum type values (Circle, Rectangle, Point) encode as tagged JSON objects with correct "tag" and "fields". At least one variant decodes back correctly via from_json. Generic structs Wrapper<Int> and Wrapper<String> both encode to correct JSON.
  </done>
</task>

<task type="auto">
  <name>Task 2: Nested combination test and compile-fail test</name>
  <files>tests/e2e/deriving_json_nested_sum.snow, tests/compile_fail/deriving_json_sum_non_serializable.snow, crates/snowc/tests/e2e_stdlib.rs</files>
  <action>
  **A. Nested combination E2E test** (`tests/e2e/deriving_json_nested_sum.snow`)

  This is the key success criterion: "Nested combinations (sum type containing a generic struct containing a list) round-trip through JSON."

  Create a Snow test with:
  ```snow
  type Shape do
    Circle(Float)
    Point
  end deriving(Json)

  struct Drawing do
    shapes :: List<Shape>
    name :: String
  end deriving(Json)
  ```

  Test:
  - Create a Drawing with a list of shapes: `[Circle(1.0), Point, Circle(2.5)]`
  - Encode with `Json.encode(drawing)` -- validates that struct with List<SumType> field encodes correctly
  - Print the JSON so Rust harness can validate structure
  - If decode works: decode and verify field values using helper functions

  This tests the full nested chain: struct (Drawing) -> List<Shape> (collection) -> SumType (Shape) -> each variant fields.

  **B. Compile-fail test** (`tests/compile_fail/deriving_json_sum_non_serializable.snow`)

  Create a Snow fixture that should fail compilation:
  ```snow
  type BadSum do
    HasPid(Pid)
  end deriving(Json)

  fn main() do
    0
  end
  ```

  This should produce E0038 NonSerializableField error since Pid is not JSON-serializable.

  **C. Rust test harness entries** (`crates/snowc/tests/e2e_stdlib.rs`)

  - `deriving_json_nested_sum` -- run and validate output
  - `deriving_json_sum_non_serializable` -- compile_only(), assert error output contains "E0038" or "not JSON-serializable"
  </action>
  <verify>
  `cargo test -p snowc deriving_json_nested_sum` passes.
  `cargo test -p snowc deriving_json_sum_non_serializable` passes (compile-fail expected).
  Full suite: `cargo test` passes with zero regressions.
  </verify>
  <done>
  Nested combination (struct containing List<SumType>) encodes to correct JSON. Compile-fail test confirms E0038 for non-serializable variant field type. All Phase 50 success criteria verified through E2E tests.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p snowc deriving_json_sum_type` -- sum type encode/decode
- `cargo test -p snowc deriving_json_generic` -- generic struct encode/decode
- `cargo test -p snowc deriving_json_nested_sum` -- nested combination
- `cargo test -p snowc deriving_json_sum_non_serializable` -- compile-fail
- `cargo test` -- full suite, zero regressions
</verification>

<success_criteria>
- Sum type values encode as tagged JSON objects (`{"tag":"Variant","fields":[...]}`) and decode back to the correct variant
- Generic structs like `Wrapper<Int>` and `Wrapper<String>` both derive Json correctly via monomorphization
- Nested combinations (sum type containing a generic struct containing a list) round-trip through JSON
- Compiler emits clear error when deriving(Json) is used on a sum type with non-serializable variant field
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/50-json-serde-sum-types-generics/50-02-SUMMARY.md`
</output>
