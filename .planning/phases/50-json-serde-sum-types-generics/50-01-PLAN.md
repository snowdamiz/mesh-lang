---
phase: 50-json-serde-sum-types-generics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/json.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-typeck/src/infer.rs
autonomous: true

must_haves:
  truths:
    - "Sum type with deriving(Json) compiles without errors"
    - "Json.encode(sum_val) dispatches to generated ToJson__to_json__SumName function"
    - "SumTypeName.from_json(json_str) resolves in typeck and MIR"
    - "Generic struct with deriving(Json) compiles without NonSerializableField error for type params"
    - "emit_to_json_for_type handles MirType::SumType for non-Option sum types"
    - "emit_from_json_for_type handles MirType::SumType for non-Option sum types"
  artifacts:
    - path: "crates/snow-rt/src/json.rs"
      provides: "snow_json_array_get runtime function"
      contains: "snow_json_array_get"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declaration for snow_json_array_get"
      contains: "snow_json_array_get"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "generate_to_json_sum_type, generate_from_json_sum_type, sum type dispatch wiring"
      contains: "generate_to_json_sum_type"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "ToJson/FromJson impl registration for sum types, is_json_serializable generic param fix"
      contains: "ToJson"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "ToJson/FromJson trait impl registration enables MIR generation"
      pattern: "has_impl.*ToJson"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/json.rs"
      via: "Generated MIR calls snow_json_array_get for from_json field extraction"
      pattern: "snow_json_array_get"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "known_functions entry matches LLVM declaration"
      pattern: "snow_json_array_get"
---

<objective>
Sum type JSON codegen and generic struct fix: runtime array access function, typeck registration for sum type ToJson/FromJson, MIR generation for to_json (Match-based) and from_json (If-chain tag matching), dispatch wiring for Json.encode and SumTypeName.from_json, emit_to/from_json_for_type SumType branches, and is_json_serializable fix for generic type params.

Purpose: Enable deriving(Json) on sum types and generic structs so that all Snow data types can round-trip through JSON.
Output: Compiler supports deriving(Json) on sum types and generic structs. All production code for JSON-08 and JSON-09.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-json-serde-sum-types-generics/50-RESEARCH.md
@.planning/phases/49-json-serde-structs/49-02-SUMMARY.md
@.planning/phases/49-json-serde-structs/49-03-SUMMARY.md
@crates/snow-rt/src/json.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Runtime + LLVM registration for snow_json_array_get</name>
  <files>crates/snow-rt/src/json.rs, crates/snow-codegen/src/codegen/intrinsics.rs, crates/snow-codegen/src/mir/lower.rs</files>
  <action>
  1. In `crates/snow-rt/src/json.rs`, add `snow_json_array_get(json_arr: *mut u8, index: i64) -> *mut u8`:
     - Cast json_arr to `*mut SnowJson`, check tag == JSON_ARRAY
     - If not array, return `err_result("expected Array")`
     - Get inner list pointer from `(*j).value`, check bounds via `snow_list_length`
     - If out of bounds, return `err_result(&format!("array index {} out of bounds (length {})", index, len))`
     - Otherwise return `alloc_result(0, snow_list_get(inner_list, index as u64) as *mut u8)`
     - Add unit test(s) for this function (valid access, out of bounds, wrong type)

  2. In `crates/snow-codegen/src/codegen/intrinsics.rs`, add LLVM declaration for `snow_json_array_get`:
     - Signature: `(ptr, i64) -> ptr` (two params: json array pointer and index)
     - Follow the pattern of other json functions (e.g., `snow_json_object_get`)

  3. In `crates/snow-codegen/src/mir/lower.rs`, add `snow_json_array_get` to `known_functions`:
     - Type: `FnPtr(vec![MirType::Ptr, MirType::Int], Box::new(MirType::Ptr))`
     - Follow the pattern of other json function registrations
  </action>
  <verify>
  `cargo test -p snow-rt -- json::tests` passes including new array_get tests.
  `cargo build -p snow-codegen` compiles (intrinsics + known_functions registration correct).
  </verify>
  <done>snow_json_array_get is available as a runtime function with three-point registration (runtime, LLVM declaration, known_functions).</done>
</task>

<task type="auto">
  <name>Task 2: Typeck registration + MIR generation + dispatch wiring for sum type Json</name>
  <files>crates/snow-typeck/src/infer.rs, crates/snow-codegen/src/mir/lower.rs</files>
  <action>
  This is the core task. Six dispatch points need updating, plus two new generator functions.

  **A. Typeck: Sum type deriving(Json) registration** (`crates/snow-typeck/src/infer.rs`)

  In `register_sum_type_def`, after the Display/Debug deriving block (around line 2282-2299), add a Json deriving block:
  - Check `derive_list.iter().any(|t| t == "Json")`
  - Validate all variant field types are JSON-serializable using `is_json_serializable`
  - For error messages, format field identifier as `"VariantName::field_N"` (e.g., `"Circle::0"`)
  - Reuse `NonSerializableField` error variant with `struct_name` set to the sum type name
  - If valid, register ToJson impl: `trait_registry.register_impl("ToJson", typeck_ty.clone())`
  - Register FromJson impl: `trait_registry.register_impl("FromJson", typeck_ty.clone())`

  **B. Typeck: is_json_serializable fix for generic type params** (`crates/snow-typeck/src/infer.rs`)

  In `is_json_serializable` (around line 1978-2013), add handling for generic type parameters:
  - If `ty` is a `Ty::Con(TyCon(name))` where the name matches a single uppercase letter or is a known generic param pattern, treat it as serializable
  - Simpler approach: accept the function's context (or just add a check for type variables). Look at how the function is called from struct/sum type registration -- the struct's `generic_params` list is available. Pass it in and skip the check for any field type whose name matches a generic param.
  - If modifying the signature is too invasive, a simpler heuristic: in `is_json_serializable`, when `Ty::Con(TyCon(name))` is not found in type_registry and not a known primitive, check if the name is a single uppercase letter (T, U, V, K, V, A, B) -- these are conventionally generic params. Return true for these. Add a comment noting that invalid instantiations fail at link time.

  **C. Typeck: SumTypeName.from_json resolution** (`crates/snow-typeck/src/infer.rs`)

  In the field access resolution (around line 4687-4699 where struct from_json is resolved), add a check for sum types:
  - If `field_name == "from_json"` and the type name resolves via `lookup_sum_type`, check if the sum type has FromJson impl
  - If so, resolve the call type as `Fn(String) -> Result<SumType, String>`
  - Follow the exact pattern used for struct from_json resolution

  **D. MIR: generate_to_json_sum_type** (`crates/snow-codegen/src/mir/lower.rs`)

  Add a new function `generate_to_json_sum_type(&mut self, name: &str, variants: &[MirVariantDef])`:
  - Follow the `generate_hash_sum_type` pattern (Match on self, per-variant arms)
  - Function signature: `ToJson__to_json__{name}(self: SumType(name)) -> Ptr`
  - Each arm: create JSON array for fields, push each field via `emit_to_json_for_type`, create JSON object with "tag" (variant name as string) and "fields" (the array)
  - For nullary variants (no fields): "fields" is an empty array `snow_json_array_new()`
  - Register in `known_functions` with type `FnPtr(vec![SumType(name)], Box::new(Ptr))`
  - See RESEARCH.md Pattern 1 for full MIR structure

  **E. MIR: generate_from_json_sum_type** (`crates/snow-codegen/src/mir/lower.rs`)

  Add a new function `generate_from_json_sum_type(&mut self, name: &str, variants: &[MirVariantDef])`:
  - Function signature: `FromJson__from_json__{name}(json: Ptr) -> Ptr` (returns SnowResult)
  - Extract "tag" via `snow_json_object_get(json, "tag")` + `snow_json_as_string(tag_json)`
  - Use If-chain (NOT Match) for tag comparison using `snow_string_eq` (consistent with Phase 49 pattern)
  - For each variant: compare tag_str with variant name, if match extract "fields" array, decode each field using `snow_json_array_get(fields_arr, i)` + `emit_from_json_for_type`
  - For nullary variants: skip field extraction, just construct the variant
  - Use `MirExpr::ConstructVariant` with `MirType::SumType(name)` for the variant value
  - Wrap in `snow_alloc_result(0, variant_val)` for Ok return
  - For unknown tags: return error result `err_result("unknown variant: ...")`
  - Use unique variable names per variant to avoid LLVM domination errors (e.g., `fields_arr_Circle`, `f0_json_Circle`)
  - Also generate the string wrapper `__json_decode__{name}` that chains `snow_json_parse` + `FromJson__from_json__{name}` (follow `generate_from_json_string_wrapper` pattern)
  - Register both functions in `known_functions`
  - See RESEARCH.md Pattern 2 for full MIR structure

  **F. MIR: Wire sum type into lower_sum_type_def** (`crates/snow-codegen/src/mir/lower.rs`)

  In `lower_sum_type_def` (around line 1724-1783), after the Hash generation block, add:
  - Check `has_json` on the sum type def
  - If true, call `generate_to_json_sum_type(name, &variants)`
  - Call `generate_from_json_sum_type(name, &variants)`
  - Follow the pattern of existing derive calls (has_eq -> generate_eq_sum_type, etc.)

  **G. MIR: emit_to_json_for_type SumType branch** (`crates/snow-codegen/src/mir/lower.rs`)

  In `emit_to_json_for_type` (around line 2914-2967), add a branch for general `MirType::SumType(sum_name)` that is NOT Option:
  - Before the existing Option special case (or as an else branch after it)
  - Call `ToJson__to_json__{sum_name}(field_val)`
  - Mirror the `MirType::Struct(inner_name)` branch pattern

  **H. MIR: emit_from_json_for_type SumType branch** (`crates/snow-codegen/src/mir/lower.rs`)

  In `emit_from_json_for_type` (find the corresponding function), add a branch for general `MirType::SumType(sum_name)` that is NOT Option:
  - Call `FromJson__from_json__{sum_name}(json_val)` which returns a SnowResult
  - Use If-based unwrapping (same pattern as struct from_json fields)
  - Mirror the `MirType::Struct(inner_name)` branch pattern

  **I. MIR: Json.encode sum type dispatch** (`crates/snow-codegen/src/mir/lower.rs`)

  In `lower_call_expr` (around line 4685-4706), add sum type dispatch:
  - After the existing `MirType::Struct` check for Json.encode
  - Add `MirType::SumType(ref sum_name)` check
  - Look up `ToJson__to_json__{sum_name}` in known_functions
  - Follow the exact struct dispatch pattern

  **J. MIR: SumTypeName.from_json dispatch** (`crates/snow-codegen/src/mir/lower.rs`)

  In the from_json MIR dispatch (around line 4843-4856), add sum type check:
  - After the existing struct_defs check
  - Check `sum_type_defs` for the type name
  - Look up `__json_decode__{sum_name}` in known_functions
  - Follow the exact struct dispatch pattern
  </action>
  <verify>
  `cargo build` compiles cleanly (all crates).
  `cargo test -p snow-rt` passes (no regressions).
  `cargo test -p snow-codegen` passes (no regressions).
  `cargo test -p snow-typeck` passes (no regressions).
  Full test suite: `cargo test` passes with zero regressions.
  </verify>
  <done>
  Sum types with deriving(Json) compile. Json.encode dispatches for sum type values. SumTypeName.from_json resolves. Generic structs with deriving(Json) compile without NonSerializableField errors for type params. emit_to/from_json_for_type handle MirType::SumType for non-Option sum types.
  </done>
</task>

</tasks>

<verification>
- `cargo build` compiles cleanly
- `cargo test` passes with zero regressions (all existing 1000+ tests green)
- `cargo test -p snow-rt -- json` includes snow_json_array_get tests
- Manual inspection: `generate_to_json_sum_type` and `generate_from_json_sum_type` exist in lower.rs
- Manual inspection: `is_json_serializable` accepts generic type params
</verification>

<success_criteria>
- snow_json_array_get runtime function exists with three-point registration
- Sum types with deriving(Json) get ToJson/FromJson trait impls in typeck
- generate_to_json_sum_type produces Match-based MIR with tagged JSON objects
- generate_from_json_sum_type produces If-chain MIR for tag matching and field decoding
- Json.encode dispatches for sum type arguments
- SumTypeName.from_json resolves in typeck and MIR
- emit_to_json_for_type and emit_from_json_for_type handle non-Option SumType
- is_json_serializable accepts generic type parameters
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/50-json-serde-sum-types-generics/50-01-SUMMARY.md`
</output>
