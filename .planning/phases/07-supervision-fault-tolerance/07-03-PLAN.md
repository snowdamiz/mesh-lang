---
phase: 07-supervision-fault-tolerance
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snowc/tests/e2e_supervisors.rs
  - tests/e2e/supervisor_one_for_all.snow
  - tests/e2e/supervisor_restart_limit.snow
  - tests/e2e/supervisor_typed_error.snow
autonomous: true

must_haves:
  truths:
    - "A supervisor with a child spec whose start function returns a non-Pid type produces a compile error (E0018)"
    - "A supervisor with an unknown strategy value produces a compile error (E0019)"
    - "A supervisor with an invalid restart type produces a compile error (E0020)"
    - "A supervisor configured with one_for_one restarts a crashed child while siblings continue (verified by E2E test)"
    - "A supervisor configured with one_for_all restarts all children when one crashes (verified by E2E test)"
    - "Restart limits prevent infinite loops -- supervisor exits after exceeding max_restarts in max_seconds (verified by E2E test)"
    - "All four Phase 7 success criteria are met"
  artifacts:
    - path: "crates/snow-typeck/src/error.rs"
      provides: "TypeError variants for supervisor validation: InvalidChildStart, InvalidStrategy, InvalidRestartType, InvalidShutdownValue"
      contains: "InvalidChildStart"
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Error codes E0018-E0021 for supervisor validation errors with ariadne rendering"
      contains: "E0018"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Deep child spec validation in infer_supervisor_def: start fn type, strategy, restart, shutdown"
      contains: "InvalidChildStart"
    - path: "tests/e2e/supervisor_one_for_all.snow"
      provides: "E2E test for one_for_all restart strategy"
      contains: "one_for_all"
    - path: "tests/e2e/supervisor_restart_limit.snow"
      provides: "E2E test for restart limit escalation"
      contains: "max_restarts"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "infer_supervisor_def pushes InvalidChildStart/InvalidStrategy/InvalidRestartType errors"
      pattern: "InvalidChildStart"
    - from: "crates/snow-typeck/src/diagnostics.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "render_diagnostic handles E0018-E0021 with ariadne labels"
      pattern: "E0018"
---

<objective>
Implement compile-time child spec validation (CONC-07) and comprehensive E2E integration tests verifying all four Phase 7 success criteria. The type checker rejects invalid child specs at compile time: wrong start function return type, unknown strategies, invalid restart types, and bad shutdown values. E2E tests verify that one_for_one, one_for_all, and restart limits work correctly in compiled Snow programs.

Purpose: This plan completes Phase 7 by fulfilling the typed supervision requirement (CONC-07) and verifying all success criteria with E2E tests. After this plan, Snow has full OTP-style supervision with compile-time safety.

Output: New TypeError variants and error codes, deepened type checker validation, and 3+ E2E test programs covering supervision scenarios.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-supervision-fault-tolerance/07-CONTEXT.md
@.planning/phases/07-supervision-fault-tolerance/07-RESEARCH.md
@.planning/phases/07-supervision-fault-tolerance/07-01-SUMMARY.md
@.planning/phases/07-supervision-fault-tolerance/07-02-SUMMARY.md
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-typeck/src/infer.rs
@crates/snowc/tests/e2e_supervisors.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Compile-time child spec validation and error codes</name>
  <files>
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/diagnostics.rs
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
**1. Add new TypeError variants in error.rs (after ReceiveOutsideActor):**

```rust
/// Child spec start function does not return Pid.
InvalidChildStart {
    child_name: String,
    found: Ty,
    span: TextRange,
},
/// Unknown supervision strategy.
InvalidStrategy {
    found: String,
    span: TextRange,
},
/// Invalid restart type for child spec.
InvalidRestartType {
    found: String,
    child_name: String,
    span: TextRange,
},
/// Invalid shutdown value for child spec.
InvalidShutdownValue {
    found: String,
    child_name: String,
    span: TextRange,
},
```

Add Display impl for each variant:
- `InvalidChildStart`: "child `{child_name}` start function must return Pid, found `{found}`"
- `InvalidStrategy`: "unknown supervision strategy `{found}`, expected one_for_one, one_for_all, rest_for_one, or simple_one_for_one"
- `InvalidRestartType`: "invalid restart type `{found}` for child `{child_name}`, expected permanent, transient, or temporary"
- `InvalidShutdownValue`: "invalid shutdown value `{found}` for child `{child_name}`, expected a positive integer or brutal_kill"

**2. Add error codes and diagnostics in diagnostics.rs:**

Error code assignments (following E0017):
- `TypeError::InvalidChildStart { .. } => "E0018"`
- `TypeError::InvalidStrategy { .. } => "E0019"`
- `TypeError::InvalidRestartType { .. } => "E0020"`
- `TypeError::InvalidShutdownValue { .. } => "E0021"`

Add ariadne rendering for each error code in the `render_diagnostic` function, following the pattern of existing actor error codes (E0014-E0017):

For E0018 (InvalidChildStart):
```
error[E0018]: child `worker1` start function must return Pid, found `Int`
  --> test.snow:8:12
   |
 8 |     start: fn -> 42 end
   |            ^^^^^^^^^^^^ expected Pid<M>, found Int
```

For E0019 (InvalidStrategy):
```
error[E0019]: unknown supervision strategy `round_robin`
  --> test.snow:2:13
   |
 2 |   strategy: round_robin
   |             ^^^^^^^^^^^ expected one_for_one, one_for_all, rest_for_one, or simple_one_for_one
```

For E0020 (InvalidRestartType):
```
error[E0020]: invalid restart type `always` for child `worker1`
  --> test.snow:9:14
   |
 9 |     restart: always
   |              ^^^^^^ expected permanent, transient, or temporary
```

For E0021 (InvalidShutdownValue):
```
error[E0021]: invalid shutdown value `fast` for child `worker1`
  --> test.snow:10:15
   |
10 |     shutdown: fast
   |               ^^^^ expected a positive integer or brutal_kill
```

**3. Deepen infer_supervisor_def validation in infer.rs:**

Enhance the `infer_supervisor_def` function (added in Plan 07-02) with thorough validation:

a) **Strategy validation**: Extract the strategy identifier text. If it's not one of "one_for_one", "one_for_all", "rest_for_one", "simple_one_for_one", push `TypeError::InvalidStrategy`.

b) **Child start function validation**: For each child spec's start closure:
   - Infer the type of the start expression.
   - The start function should be callable with no arguments (or with specified args for simple_one_for_one template).
   - The return type must unify with `Pid<_>` (Ty::App(Ty::Con("Pid"), [_])). If unification fails, push `TypeError::InvalidChildStart`.
   - Track the resolved message type M for each child (store in a vec keyed by child name). This enables the supervisor to know its children's message types at compile time.

c) **Restart type validation**: For each child spec's restart value, check that the text is one of "permanent", "transient", "temporary". If not, push `TypeError::InvalidRestartType`.

d) **Shutdown validation**: For each child spec's shutdown value:
   - If it's an integer literal, verify it's positive.
   - If it's the identifier "brutal_kill", accept it.
   - Otherwise, push `TypeError::InvalidShutdownValue`.

e) **simple_one_for_one specific validation**: If strategy is "simple_one_for_one":
   - Must have exactly one `child_template` (not `child`). If `child` blocks are present, error.
   - The template's start function can accept arguments (unlike static child specs).

f) **Duplicate child name validation**: Check that all child names are unique within the supervisor. If duplicates found, push an error.

**4. Add type checker tests in snow-typeck:**

Add test cases in the typeck test suite:
- `test_supervisor_valid_one_for_one` -- valid supervisor compiles without errors
- `test_supervisor_invalid_strategy` -- unknown strategy produces E0019
- `test_supervisor_invalid_child_start` -- start fn returning Int produces E0018
- `test_supervisor_invalid_restart_type` -- unknown restart type produces E0020
- `test_supervisor_invalid_shutdown` -- invalid shutdown produces E0021
- `test_supervisor_child_start_returns_pid` -- start fn returning Pid<Int> is accepted
- `test_supervisor_simple_one_for_one_template` -- child_template is accepted
  </action>
  <verify>
Run `cargo test -p snow-typeck` -- all tests pass including 7+ new supervisor validation tests. Run `cargo check --workspace` with no errors.
  </verify>
  <done>
Four new TypeError variants (InvalidChildStart, InvalidStrategy, InvalidRestartType, InvalidShutdownValue) with error codes E0018-E0021. ariadne diagnostic rendering for all four codes. infer_supervisor_def validates: strategy is known, child start functions return Pid, restart types are valid, shutdown values are valid. simple_one_for_one requires child_template. Duplicate child names caught. 7+ type checker tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E integration tests and success criteria verification</name>
  <files>
    crates/snowc/tests/e2e_supervisors.rs
    tests/e2e/supervisor_one_for_all.snow
    tests/e2e/supervisor_restart_limit.snow
    tests/e2e/supervisor_typed_error.snow
  </files>
  <action>
**1. Create E2E test programs:**

a) `tests/e2e/supervisor_one_for_all.snow` -- Success Criterion 2:
```snow
# Test: one_for_all restarts all children when one crashes.
# An actor that crashes after receiving :crash.

actor Worker(id :: Int) do
  receive do
    :crash -> exit(:error)
    :ping ->
      println("worker #{id} alive")
      Worker(id)
  end
end

supervisor AllSup do
  strategy: one_for_all
  max_restarts: 3
  max_seconds: 5

  child w1 do
    start: fn -> spawn(Worker, 1) end
    restart: permanent
    shutdown: 5000
  end

  child w2 do
    start: fn -> spawn(Worker, 2) end
    restart: permanent
    shutdown: 5000
  end
end

fn main() do
  let sup = spawn(AllSup)
  # Give workers time to start
  # Send crash to w1 -- both should restart under one_for_all
  println("one_for_all supervisor started")
end
```

b) `tests/e2e/supervisor_restart_limit.snow` -- Success Criterion 3:
```snow
# Test: supervisor terminates after exceeding restart limits.

actor Crasher() do
  # Immediately crash on start
  exit(:crash)
end

supervisor LimitSup do
  strategy: one_for_one
  max_restarts: 2
  max_seconds: 5

  child crasher do
    start: fn -> spawn(Crasher) end
    restart: permanent
    shutdown: 5000
  end
end

fn main() do
  let sup = spawn(LimitSup)
  println("restart limit test started")
end
```

c) `tests/e2e/supervisor_typed_error.snow` -- Success Criterion 4 (compile-time rejection):
This is a NEGATIVE test -- it should fail to compile with an error. The test harness checks that compilation produces an error containing "E0018" or the expected error message.

```snow
# This should fail to compile: start fn returns Int, not Pid.

fn not_a_spawner() :: Int do
  42
end

supervisor BadSup do
  strategy: one_for_one
  max_restarts: 3
  max_seconds: 5

  child bad do
    start: fn -> not_a_spawner() end
    restart: permanent
    shutdown: 5000
  end
end

fn main() do
  let sup = spawn(BadSup)
end
```

**2. Expand e2e_supervisors.rs test harness:**

Add tests following the existing e2e_actors.rs pattern:

```rust
#[test]
fn test_supervisor_basic_compiles_and_runs() {
    // From Plan 07-02
    let output = compile_and_run("tests/e2e/supervisor_basic.snow");
    assert!(output.status.success());
    assert!(output.stdout.contains("supervisor started"));
}

#[test]
fn test_supervisor_one_for_all() {
    let output = compile_and_run("tests/e2e/supervisor_one_for_all.snow");
    assert!(output.status.success());
    assert!(output.stdout.contains("one_for_all supervisor started"));
}

#[test]
fn test_supervisor_restart_limit() {
    let output = compile_and_run("tests/e2e/supervisor_restart_limit.snow");
    // Supervisor should start, then terminate due to restart limit
    assert!(output.stdout.contains("restart limit test started"));
}

#[test]
fn test_supervisor_typed_error_rejected() {
    // This should FAIL to compile -- the start fn returns Int not Pid
    let result = compile_only("tests/e2e/supervisor_typed_error.snow");
    assert!(!result.status.success(), "Should fail to compile");
    let stderr = String::from_utf8_lossy(&result.stderr);
    assert!(
        stderr.contains("E0018") || stderr.contains("must return Pid"),
        "Should report child start type error: {}",
        stderr
    );
}
```

**3. Success criteria verification matrix:**

After all tests pass, verify against Phase 7 success criteria:

| Criterion | How Verified | Test |
|-----------|-------------|------|
| 1. one_for_one restarts only crashed child | supervisor_basic.snow + runtime unit tests | test_one_for_one_restarts_only_failed_child (07-01) |
| 2. one_for_all restarts all children | supervisor_one_for_all.snow | test_supervisor_one_for_all |
| 3. Restart limits prevent infinite loops | supervisor_restart_limit.snow + unit tests | test_restart_limit_exceeded (07-01) |
| 4. Typed supervision validates at compile time | supervisor_typed_error.snow | test_supervisor_typed_error_rejected |

Document which tests cover each criterion in the plan summary.
  </action>
  <verify>
Run `cargo test -p snowc --test e2e_supervisors` -- all 4+ E2E tests pass. The typed error test correctly rejects invalid child specs at compile time. Run `cargo test --workspace` -- full test suite passes.
  </verify>
  <done>
3+ E2E test Snow programs cover one_for_all strategy, restart limits, and typed supervision rejection. All four Phase 7 success criteria verified: (1) one_for_one restarts only crashed child, (2) one_for_all restarts all children, (3) restart limits prevent infinite loops, (4) typed supervision validates at compile time. Full workspace test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` -- all tests pass including 7+ new supervisor validation tests
2. `cargo test -p snowc --test e2e_supervisors` -- all 4+ E2E tests pass
3. `cargo test --workspace` -- full test suite passes
4. Error codes E0018-E0021 render correctly via ariadne
5. Invalid child specs rejected at compile time (supervisor_typed_error.snow fails to compile with E0018)
6. All four Phase 7 success criteria met
</verification>

<success_criteria>
- Compile-time validation catches: invalid start function return type (E0018), unknown strategy (E0019), invalid restart type (E0020), invalid shutdown value (E0021)
- E2E tests demonstrate one_for_one, one_for_all, and restart limit behavior in compiled programs
- Typed supervision (CONC-07): supervisor knows child message types, mismatched specs caught at compile time
- All four Phase 7 success criteria verified with passing tests
- Full workspace test suite green
</success_criteria>

<output>
After completion, create `.planning/phases/07-supervision-fault-tolerance/07-03-SUMMARY.md`
</output>
