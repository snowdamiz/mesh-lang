---
phase: 07-supervision-fault-tolerance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/actor/supervisor.rs
  - crates/snow-rt/src/actor/child_spec.rs
  - crates/snow-rt/src/actor/process.rs
  - crates/snow-rt/src/actor/link.rs
  - crates/snow-rt/src/actor/scheduler.rs
  - crates/snow-rt/src/actor/mod.rs
autonomous: true

must_haves:
  truths:
    - "A supervisor actor with one_for_one strategy restarts only the crashed child while siblings continue running"
    - "A supervisor actor with one_for_all strategy terminates and restarts all children when any one crashes"
    - "A supervisor actor with rest_for_one strategy terminates and restarts the crashed child and all children started after it"
    - "Restart limits prevent infinite crash loops -- supervisor terminates after exceeding max_restarts in max_seconds"
    - "Children start sequentially in declared order; if one fails to start, remaining are not started and supervisor fails"
    - "Ordered shutdown terminates children in reverse start order with per-child timeout or brutal_kill"
    - "ExitReason has Shutdown and Custom(String) variants that encode/decode correctly"
  artifacts:
    - path: "crates/snow-rt/src/actor/supervisor.rs"
      provides: "SupervisorState, Strategy enum, supervisor_entry loop, strategy dispatch, restart logic, ordered shutdown"
      contains: "SupervisorState"
    - path: "crates/snow-rt/src/actor/child_spec.rs"
      provides: "ChildSpec, ChildState, RestartType, ShutdownType, ChildType structs"
      contains: "ChildSpec"
    - path: "crates/snow-rt/src/actor/process.rs"
      provides: "ExitReason with Shutdown and Custom variants"
      contains: "Shutdown"
    - path: "crates/snow-rt/src/actor/link.rs"
      provides: "decode_exit_signal function, updated encode for Shutdown/Custom"
      contains: "decode_exit_signal"
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "snow_supervisor_start, snow_supervisor_start_child, snow_supervisor_terminate_child, snow_actor_trap_exit, snow_actor_exit extern C functions"
      contains: "snow_supervisor_start"
  key_links:
    - from: "crates/snow-rt/src/actor/supervisor.rs"
      to: "crates/snow-rt/src/actor/link.rs"
      via: "decode_exit_signal for processing exit signals in supervisor loop"
      pattern: "decode_exit_signal"
    - from: "crates/snow-rt/src/actor/supervisor.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "extern C functions delegate to supervisor module"
      pattern: "snow_supervisor_start"
    - from: "crates/snow-rt/src/actor/supervisor.rs"
      to: "crates/snow-rt/src/actor/scheduler.rs"
      via: "supervisor spawns children via scheduler, process table lookups"
      pattern: "Scheduler::spawn"
---

<objective>
Implement the complete supervisor runtime in snow-rt: the SupervisorState struct, all four OTP restart strategies (one_for_one, one_for_all, rest_for_one, simple_one_for_one), child spec types, restart limit tracking via sliding window, ordered shutdown with timeout/brutal_kill, ExitReason expansion (Shutdown, Custom), exit signal decode, and all extern "C" ABI functions for supervisor operations.

Purpose: The supervisor runtime is the foundation for Phase 7. All supervision behavior must work at the Rust level before compiler integration (same pattern as Phase 6 where 06-01 built the scheduler before compiler integration). This plan delivers the complete runtime that Plans 07-02 and 07-03 will call from compiled Snow programs.

Output: Two new files (supervisor.rs, child_spec.rs), modifications to process.rs, link.rs, scheduler.rs, and mod.rs, all with comprehensive Rust unit tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-supervision-fault-tolerance/07-CONTEXT.md
@.planning/phases/07-supervision-fault-tolerance/07-RESEARCH.md
@crates/snow-rt/src/actor/mod.rs
@crates/snow-rt/src/actor/process.rs
@crates/snow-rt/src/actor/link.rs
@crates/snow-rt/src/actor/scheduler.rs
@crates/snow-rt/src/actor/registry.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ExitReason expansion, exit signal encode/decode, and child spec types</name>
  <files>
    crates/snow-rt/src/actor/process.rs
    crates/snow-rt/src/actor/link.rs
    crates/snow-rt/src/actor/child_spec.rs
    crates/snow-rt/src/actor/mod.rs
  </files>
  <action>
**1. Expand ExitReason in process.rs (line 74):**

Add two new variants to the existing enum:
```rust
pub enum ExitReason {
    Normal,
    Shutdown,                        // NEW: clean supervisor-initiated shutdown
    Error(String),
    Killed,
    Linked(ProcessId, Box<ExitReason>),
    Custom(String),                  // NEW: user-defined exit reasons
}
```

Update ALL match arms on ExitReason throughout the codebase (process.rs, link.rs, scheduler.rs) to handle the new variants:
- `Shutdown` behaves like `Normal` for exit propagation purposes (delivers as message, does not crash linked processes)
- `Custom(msg)` behaves like `Error(msg)` for exit propagation purposes (crashes linked processes unless trap_exit)

**2. Update exit signal encoding in link.rs:**

Extend `encode_reason()` (line 71) with new reason tags:
- reason_tag 4 = Shutdown
- reason_tag 5 = Custom (followed by UTF-8 string with u64 length prefix, same format as Error)

Add a public `decode_exit_signal()` function in link.rs that parses the encoded bytes back into `(ProcessId, ExitReason)`:
```rust
pub fn decode_exit_signal(data: &[u8]) -> Option<(ProcessId, ExitReason)> {
    if data.len() < 9 { return None; }
    let pid = ProcessId(u64::from_le_bytes(data[0..8].try_into().ok()?));
    let reason = decode_reason(&data[8..])?;
    Some((pid, reason))
}

fn decode_reason(data: &[u8]) -> Option<ExitReason> {
    // Match on first byte (reason_tag), parse accordingly
    // 0 -> Normal, 1 -> Error(string), 2 -> Killed, 3 -> Linked(pid, nested),
    // 4 -> Shutdown, 5 -> Custom(string)
}
```

Add round-trip tests: encode then decode for each ExitReason variant, verifying equality.

**3. Update `invoke_terminate_callback` in scheduler.rs (line 519):**

Add reason_tag mappings for the new variants:
- `ExitReason::Shutdown => 4`
- `ExitReason::Custom(_) => 5`

**4. Update `propagate_exit` in link.rs:**

In the `is_normal` check (line 126), also treat `Shutdown` as non-crashing:
```rust
let is_non_crashing = matches!(reason, ExitReason::Normal | ExitReason::Shutdown);
```

**5. Create child_spec.rs with types:**

```rust
use super::process::ProcessId;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Strategy {
    OneForOne,
    OneForAll,
    RestForOne,
    SimpleOneForOne,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RestartType {
    Permanent,   // Always restart
    Transient,   // Restart on abnormal exit only
    Temporary,   // Never restart
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ShutdownType {
    BrutalKill,
    Timeout(u64),  // milliseconds
}

impl Default for ShutdownType {
    fn default() -> Self { ShutdownType::Timeout(5000) }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChildType {
    Worker,
    Supervisor,
}

/// Specification for a child actor under supervision.
#[derive(Debug, Clone)]
pub struct ChildSpec {
    pub id: String,
    pub start_fn: *const u8,       // Function pointer to the spawn function
    pub start_args_ptr: *const u8,  // Pointer to serialized initial arguments
    pub start_args_size: u64,       // Size of the arguments in bytes
    pub restart_type: RestartType,
    pub shutdown: ShutdownType,
    pub child_type: ChildType,
}

// Safety: ChildSpec's fn ptrs are owned by the runtime and valid for the supervisor lifetime
unsafe impl Send for ChildSpec {}
unsafe impl Sync for ChildSpec {}

/// Runtime state of a supervised child.
#[derive(Debug, Clone)]
pub struct ChildState {
    pub spec: ChildSpec,
    pub pid: Option<ProcessId>,
    pub running: bool,
}
```

**6. Register new modules in mod.rs:**

Add `pub mod child_spec;` and `pub mod supervisor;` (supervisor module will be empty initially, populated in Task 2). Add child_spec re-exports.
  </action>
  <verify>
Run `cargo test -p snow-rt` -- all existing tests still pass plus new decode/encode round-trip tests pass. Run `cargo check -p snow-rt` with no errors.
  </verify>
  <done>
ExitReason has Shutdown and Custom variants. encode_exit_signal handles all 6 variants. decode_exit_signal round-trips correctly for all variants. propagate_exit treats Shutdown as non-crashing. ChildSpec, RestartType, ShutdownType, Strategy enums exist. invoke_terminate_callback handles new reason tags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Supervisor state machine, strategy dispatch, restart limits, ordered shutdown, and extern "C" ABI</name>
  <files>
    crates/snow-rt/src/actor/supervisor.rs
    crates/snow-rt/src/actor/mod.rs
    crates/snow-rt/src/actor/scheduler.rs
  </files>
  <action>
**1. Create supervisor.rs with the complete supervisor implementation:**

The supervisor is an actor that traps exits and manages child lifecycles. Key components:

**SupervisorState struct:**
```rust
use std::collections::VecDeque;
use std::time::Instant;
use super::child_spec::{ChildSpec, ChildState, ChildType, RestartType, ShutdownType, Strategy};
use super::process::{ExitReason, ProcessId, ProcessState};

pub struct SupervisorState {
    pub strategy: Strategy,
    pub max_restarts: u32,
    pub max_seconds: u64,
    pub children: Vec<ChildState>,
    pub restart_history: VecDeque<Instant>,
    /// For simple_one_for_one: the template child spec
    pub child_template: Option<ChildSpec>,
}
```

**SupervisorConfig struct (for serialization from compiled code):**
```rust
pub struct SupervisorConfig {
    pub strategy: Strategy,
    pub max_restarts: u32,
    pub max_seconds: u64,
    pub child_specs: Vec<ChildSpec>,
}
```

**Core functions to implement:**

a) `start_children(state: &mut SupervisorState, scheduler: &Scheduler) -> Result<(), String>`:
   - Iterate children in order. For each, call `start_single_child`.
   - If any fails, call `terminate_started_children` on those already started (reverse order), then return Err.
   - Per locked decision: sequential start in declared order.

b) `start_single_child(child: &mut ChildState, scheduler: &Scheduler, sup_pid: ProcessId) -> Result<ProcessId, String>`:
   - Call `scheduler.spawn(child.spec.start_fn, child.spec.start_args_ptr, child.spec.start_args_size, 1)` to create the child process.
   - Link the supervisor to the child: look up both processes in the process table and call `link::link()`.
   - Update `child.pid = Some(new_pid)`, `child.running = true`.
   - Return the new PID.

c) `handle_child_exit(state: &mut SupervisorState, child_pid: ProcessId, reason: ExitReason, scheduler: &Scheduler, sup_pid: ProcessId)`:
   - Find the child by PID in `state.children`.
   - If not found (unknown child), ignore.
   - Mark child as not running: `child.running = false`, `child.pid = None`.
   - Check restart policy based on `child.spec.restart_type` and `reason`:
     - `Permanent`: always restart
     - `Transient`: restart only if reason is NOT Normal and NOT Shutdown
     - `Temporary`: never restart, remove from children list
   - If restart is needed, call `check_restart_limit`. If limit exceeded, terminate all children and return an error (supervisor should exit).
   - If within limit, call `apply_strategy`.

d) `check_restart_limit(state: &mut SupervisorState) -> bool`:
   - Sliding window: remove timestamps older than `now - max_seconds` from front of `restart_history`.
   - If `restart_history.len() >= max_restarts`, return false (limit exceeded).
   - Otherwise push `now` and return true.

e) `apply_strategy(state: &mut SupervisorState, failed_child_idx: usize, scheduler: &Scheduler, sup_pid: ProcessId) -> Result<(), String>`:
   - `OneForOne`: restart only the failed child at `failed_child_idx`.
   - `OneForAll`: terminate all children in reverse order, then start all children in forward order.
   - `RestForOne`: terminate children from `failed_child_idx..end` in reverse order, then start from `failed_child_idx..end` in forward order.
   - `SimpleOneForOne`: same as OneForOne (restart only the failed child).

f) `terminate_all_children(state: &mut SupervisorState, scheduler: &Scheduler)`:
   - Iterate children in REVERSE order. For each running child, call `terminate_single_child`.

g) `terminate_single_child(child: &mut ChildState, scheduler: &Scheduler, sup_pid: ProcessId)`:
   - Based on `child.spec.shutdown`:
     - `BrutalKill`: immediately mark the child process as `Exited(Killed)` in the process table.
     - `Timeout(ms)`: send a Shutdown exit signal to the child (via `snow_actor_exit` logic -- encode ExitReason::Shutdown and deliver to mailbox as EXIT_SIGNAL_TAG). Then poll/wait up to `ms` milliseconds for the child to exit. If timeout, force-kill.
   - Unlink the supervisor from the child.
   - Mark `child.running = false`, `child.pid = None`.

h) `terminate_children_from(state: &mut SupervisorState, from_idx: usize, scheduler: &Scheduler, sup_pid: ProcessId)`:
   - Terminate children from `from_idx..end` in reverse order.

i) `start_children_from(state: &mut SupervisorState, from_idx: usize, scheduler: &Scheduler, sup_pid: ProcessId) -> Result<(), String>`:
   - Start children from `from_idx..end` in forward order.

**2. Add extern "C" ABI functions in mod.rs:**

a) `snow_supervisor_start(config_ptr: *const u8, config_size: u64) -> u64`:
   - Deserialize the SupervisorConfig from the raw bytes (define a simple binary format: strategy as u8, max_restarts as u32, max_seconds as u64, then child specs).
   - Spawn the supervisor as a regular actor (via `global_scheduler().spawn()`), where the entry function is a supervisor receive loop.
   - Set `trap_exit = true` on the supervisor process immediately after spawn.
   - Start all children sequentially.
   - Return the supervisor PID.

   **IMPORTANT design decision:** The supervisor entry function runs as a coroutine. Since we can't easily pass complex state into the coroutine entry (which takes `*const u8`), use a global or thread-local map to store SupervisorState keyed by PID. The entry function retrieves its state from this map after spawn.

   Use a static `Mutex<HashMap<ProcessId, SupervisorState>>` for the supervisor state registry. The supervisor_entry function looks up its state, starts children, then enters the exit-signal receive loop.

b) `snow_supervisor_start_child(sup_pid: u64, args_ptr: *const u8, args_size: u64) -> u64`:
   - For simple_one_for_one: send a message to the supervisor telling it to spawn a new child with the given args.
   - The supervisor's receive loop handles this message type (use a reserved type_tag, e.g., `u64::MAX - 1` for supervisor control messages).
   - For now, implement synchronously: look up the supervisor state, clone the template spec with new args, spawn the child, link it, return the PID.

c) `snow_supervisor_terminate_child(sup_pid: u64, child_pid: u64) -> u64`:
   - Look up the supervisor state, find the child by PID, terminate it, return 0 on success / 1 on failure.

d) `snow_supervisor_count_children(sup_pid: u64) -> u64`:
   - Return the count of running children.

e) `snow_actor_trap_exit()`:
   - Set `trap_exit = true` on the current process (look up via `stack::get_current_pid()`).

f) `snow_actor_exit(target_pid: u64, reason_tag: u8)`:
   - Send an exit signal to the target process. Encode the reason (0=Normal, 1=Error, 2=Killed, 4=Shutdown) and deliver to the target's mailbox as EXIT_SIGNAL_TAG message.
   - If reason is Killed (tag 2), immediately mark the process as Exited(Killed) -- untrappable kill.

**3. Add comprehensive unit tests to supervisor.rs:**

Test each strategy independently:
- `test_one_for_one_restarts_only_failed_child`: Create supervisor with 3 children. Simulate one child exit. Verify only that child was restarted, siblings untouched.
- `test_one_for_all_restarts_all_children`: Simulate one child exit. Verify all children were terminated and restarted.
- `test_rest_for_one_restarts_subsequent`: Simulate middle child exit. Verify children after it (and the failed one) were restarted, children before it untouched.
- `test_simple_one_for_one_dynamic_child`: Add dynamic children, crash one, verify it restarts.
- `test_restart_limit_exceeded`: Set max_restarts=2, max_seconds=5. Trigger 3 restarts. Verify supervisor terminates.
- `test_restart_limit_sliding_window`: Verify old restarts outside the window don't count.
- `test_permanent_restarts_on_normal`: Permanent child exits normally -> gets restarted.
- `test_transient_no_restart_on_normal`: Transient child exits normally -> NOT restarted.
- `test_transient_restarts_on_error`: Transient child exits with error -> gets restarted.
- `test_transient_no_restart_on_shutdown`: Transient child exits with Shutdown -> NOT restarted.
- `test_temporary_never_restarts`: Temporary child exits -> removed, never restarted.
- `test_ordered_shutdown_reverse_order`: Verify children are terminated in reverse start order.
- `test_sequential_start_order`: Verify children start in declared order.
- `test_start_failure_stops_remaining`: If child 2 of 3 fails to start, child 3 is never started and child 1 is terminated.

Use the existing test helper pattern from mod.rs tests (create processes in a Scheduler, manipulate state directly).
  </action>
  <verify>
Run `cargo test -p snow-rt` -- all tests pass including the new supervisor tests. Run `cargo check -p snow-rt` with no errors. Verify at minimum 14+ new tests pass covering all four strategies, restart limits, restart types, and shutdown ordering.
  </verify>
  <done>
SupervisorState, SupervisorConfig fully implemented. All four strategies (one_for_one, one_for_all, rest_for_one, simple_one_for_one) dispatch correctly. Restart limits use sliding window with configurable max_restarts/max_seconds (defaults: 3/5). Ordered shutdown terminates in reverse start order with timeout/brutal_kill. All extern "C" ABI functions exist (snow_supervisor_start, snow_supervisor_start_child, snow_supervisor_terminate_child, snow_supervisor_count_children, snow_actor_trap_exit, snow_actor_exit). 14+ unit tests pass covering all strategies, restart types, restart limits, and shutdown ordering.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-rt` -- ALL tests pass (existing + new supervisor tests)
2. `cargo check -p snow-rt` -- no compilation errors or warnings
3. New files exist: `crates/snow-rt/src/actor/supervisor.rs`, `crates/snow-rt/src/actor/child_spec.rs`
4. ExitReason has Shutdown and Custom(String) variants
5. decode_exit_signal round-trips with encode_exit_signal for all 6 variants
6. All 6 extern "C" functions are declared and callable
</verification>

<success_criteria>
- SupervisorState with all four strategies implemented and unit-tested
- Restart limit tracking prevents infinite crash loops (sliding window, verified by test)
- Ordered shutdown terminates children in reverse start order (verified by test)
- All three restart types (permanent/transient/temporary) follow Erlang semantics (verified by tests)
- ExitReason expanded with Shutdown and Custom variants, encode/decode round-trips
- All extern "C" ABI functions exist for compiler integration in Plan 07-02
</success_criteria>

<output>
After completion, create `.planning/phases/07-supervision-fault-tolerance/07-01-SUMMARY.md`
</output>
