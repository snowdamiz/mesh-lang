---
phase: 07-supervision-fault-tolerance
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/mod.rs
  - crates/snow-parser/src/parser/items.rs
  - crates/snow-parser/src/ast/item.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/mono.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/pattern/compile.rs
  - crates/snowc/tests/e2e_supervisors.rs
  - tests/e2e/supervisor_basic.snow
autonomous: true

must_haves:
  truths:
    - "A supervisor block parses into a SUPERVISOR_DEF CST node with strategy, limits, and child specs"
    - "The type checker validates supervisor definitions and infers child spawn function types"
    - "Supervisor blocks lower to MIR SupervisorStart nodes that emit calls to snow_supervisor_start"
    - "An E2E test compiles a Snow supervisor program to a native binary that runs and demonstrates one_for_one restart"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "SUPERVISOR_DEF, CHILD_SPEC_DEF, STRATEGY_CLAUSE SyntaxKind variants"
      contains: "SUPERVISOR_DEF"
    - path: "crates/snow-parser/src/parser/items.rs"
      provides: "parse_supervisor_def function"
      contains: "parse_supervisor_def"
    - path: "crates/snow-parser/src/ast/item.rs"
      provides: "SupervisorDef AST wrapper"
      contains: "SupervisorDef"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "infer_supervisor_def function"
      contains: "infer_supervisor_def"
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "MirExpr::SupervisorStart variant"
      contains: "SupervisorStart"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "Supervisor runtime function declarations"
      contains: "snow_supervisor_start"
    - path: "crates/snowc/tests/e2e_supervisors.rs"
      provides: "E2E test for supervisor compilation and execution"
      contains: "supervisor_basic"
  key_links:
    - from: "crates/snow-parser/src/parser/items.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "parse_supervisor_def produces SUPERVISOR_DEF nodes"
      pattern: "SUPERVISOR_DEF"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/item.rs"
      via: "infer_supervisor_def takes SupervisorDef AST node"
      pattern: "SupervisorDef"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "codegen_supervisor_start calls declared intrinsics"
      pattern: "snow_supervisor_start"
---

<objective>
Implement the full compiler pipeline for supervisor blocks: parser (parse_supervisor_def), SyntaxKind additions, AST SupervisorDef wrapper, type checker (infer_supervisor_def), MIR SupervisorStart node, MIR lowering, LLVM codegen emitting calls to the runtime functions from Plan 07-01, intrinsic declarations, and an E2E test that compiles and runs a Snow supervisor program.

Purpose: This plan bridges the runtime (07-01) and the Snow language surface. After this plan, users can write `supervisor Name do ... end` blocks in Snow and compile them to native binaries with working supervision.

Output: Modifications across all compiler crates (parser, typeck, codegen) plus an E2E integration test.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-supervision-fault-tolerance/07-CONTEXT.md
@.planning/phases/07-supervision-fault-tolerance/07-RESEARCH.md
@.planning/phases/07-supervision-fault-tolerance/07-01-SUMMARY.md
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/mod.rs
@crates/snow-parser/src/parser/items.rs
@crates/snow-parser/src/ast/item.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/mod.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parser and AST for supervisor blocks</name>
  <files>
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/parser/mod.rs
    crates/snow-parser/src/parser/items.rs
    crates/snow-parser/src/ast/item.rs
  </files>
  <action>
**1. Add SyntaxKind variants in syntax_kind.rs:**

Add these new node kinds (near ACTOR_DEF at line 261):
```rust
SUPERVISOR_DEF,    // supervisor Name do ... end
CHILD_SPEC_DEF,    // child Name do ... end (inside supervisor)
STRATEGY_CLAUSE,   // strategy: one_for_one
RESTART_LIMIT,     // max_restarts: 3
SECONDS_LIMIT,     // max_seconds: 5
CHILD_TEMPLATE,    // child_template do ... end (for simple_one_for_one)
```

Also add display name mappings in the `impl SyntaxKind` display method, following the existing pattern.

**2. Add SUPERVISOR_KW dispatch in parser/mod.rs (line 605):**

After the `SyntaxKind::ACTOR_KW => items::parse_actor_def(p),` line, add:
```rust
SyntaxKind::SUPERVISOR_KW => items::parse_supervisor_def(p),
```

Also add the same dispatch in the `pub` visibility handling match (around line 569-602), so `pub supervisor Name do ... end` works.

**3. Implement parse_supervisor_def in parser/items.rs:**

Following the pattern of `parse_actor_def` (line 841), implement:

```rust
pub(crate) fn parse_supervisor_def(p: &mut Parser) {
    let m = p.open();
    p.advance(); // SUPERVISOR_KW

    // Supervisor name.
    if p.at(SyntaxKind::IDENT) {
        let name = p.open();
        p.advance();
        p.close(name, SyntaxKind::NAME);
    } else {
        p.error("expected supervisor name");
        p.close(m, SyntaxKind::SUPERVISOR_DEF);
        return;
    }

    // Expect `do`.
    let do_span = p.current_span();
    p.expect(SyntaxKind::DO_KW);

    // Parse supervisor body.
    if !p.has_error() {
        parse_supervisor_body(p);
    }

    // Expect `end`.
    if !p.at(SyntaxKind::END_KW) {
        p.error_with_related(
            "expected `end` to close supervisor body",
            do_span,
            "`do` block started here",
        );
    } else {
        p.advance();
    }

    p.close(m, SyntaxKind::SUPERVISOR_DEF);
}
```

**parse_supervisor_body** parses the interior:
- `strategy:` followed by an identifier (one_for_one, one_for_all, rest_for_one, simple_one_for_one) -> STRATEGY_CLAUSE
- `max_restarts:` followed by an integer literal -> RESTART_LIMIT
- `max_seconds:` followed by an integer literal -> SECONDS_LIMIT
- `child Name do ... end` blocks -> CHILD_SPEC_DEF
- `child_template do ... end` block -> CHILD_TEMPLATE (for simple_one_for_one)

Each `child` block interior parses:
- `start:` followed by a closure expression (fn -> ... end)
- `restart:` followed by an identifier (permanent, transient, temporary)
- `shutdown:` followed by an integer literal or `brutal_kill` identifier

Use the same key-value parsing pattern: check for IDENT text matching known keys, eat COLON, parse value. This is similar to how struct literals are parsed.

**4. Add SupervisorDef AST wrapper in ast/item.rs:**

Following the ActorDef pattern (line 474):
```rust
ast_node!(SupervisorDef, SUPERVISOR_DEF);

impl SupervisorDef {
    pub fn name(&self) -> Option<Name> {
        child_node(&self.syntax)
    }

    pub fn strategy(&self) -> Option<SyntaxNode> {
        self.syntax.children().find(|c| c.kind() == SyntaxKind::STRATEGY_CLAUSE)
    }

    pub fn max_restarts(&self) -> Option<SyntaxNode> {
        self.syntax.children().find(|c| c.kind() == SyntaxKind::RESTART_LIMIT)
    }

    pub fn max_seconds(&self) -> Option<SyntaxNode> {
        self.syntax.children().find(|c| c.kind() == SyntaxKind::SECONDS_LIMIT)
    }

    pub fn child_specs(&self) -> Vec<SyntaxNode> {
        self.syntax.children().filter(|c| c.kind() == SyntaxKind::CHILD_SPEC_DEF).collect()
    }

    pub fn child_template(&self) -> Option<SyntaxNode> {
        self.syntax.children().find(|c| c.kind() == SyntaxKind::CHILD_TEMPLATE)
    }
}
```

Add to the Item enum:
```rust
SupervisorDef(SupervisorDef),
```

And in the `Item::cast` method:
```rust
SyntaxKind::SUPERVISOR_DEF => Some(Item::SupervisorDef(SupervisorDef { syntax: node })),
```

**5. Add parser snapshot tests:**

Add snapshot tests for supervisor parsing:
- Basic supervisor with strategy, limits, and one child
- Supervisor with multiple children
- Supervisor with child_template (simple_one_for_one)
- Error case: missing strategy
- Error case: unknown strategy value
  </action>
  <verify>
Run `cargo test -p snow-parser` -- all tests pass including new supervisor parsing snapshots. Run `cargo check --workspace` with no errors.
  </verify>
  <done>
SUPERVISOR_DEF and related SyntaxKinds exist. parse_supervisor_def correctly parses supervisor blocks with strategy, limits, and child specs into a CST. SupervisorDef AST wrapper provides typed access. Parser dispatch routes SUPERVISOR_KW to parse_supervisor_def. Snapshot tests verify correct parsing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Type checker, MIR, LLVM codegen, intrinsics, and E2E test</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/mir/mono.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/pattern/compile.rs
    crates/snowc/tests/e2e_supervisors.rs
    tests/e2e/supervisor_basic.snow
  </files>
  <action>
**1. Add infer_supervisor_def in snow-typeck/src/infer.rs:**

Following the pattern of `infer_actor_def` (line 2709), add type checking for supervisor definitions.

In the main `Item` dispatch (line 457), add:
```rust
Item::SupervisorDef(sup_def) => {
    infer_supervisor_def(ctx, env, sup_def, types, type_registry, trait_registry, fn_constraints).ok()
}
```

Implement `infer_supervisor_def`:
- Extract the supervisor name from the AST.
- For each child spec, find the `start:` closure and type-check it:
  - The start closure should be callable (it's a `fn -> spawn(Actor, args) end`).
  - The return type should be `Pid<M>` for some message type M (or just `Pid` for untyped).
  - Record the child name and inferred message type for compile-time validation (Plan 07-03 will deepen this).
- Validate strategy is one of the four known values (one_for_one, one_for_all, rest_for_one, simple_one_for_one).
- Validate restart is one of (permanent, transient, temporary).
- Validate shutdown is a positive integer or brutal_kill.
- Register the supervisor as a function-like entity in the environment (so `spawn(MySupervisor)` works), returning `Pid<Unit>` (supervisors don't receive user messages).

**2. Add MirExpr::SupervisorStart in mir/mod.rs:**

Add a new MIR node:
```rust
/// Start a supervisor with configured strategy, limits, and child specs.
SupervisorStart {
    /// Supervisor name (for registration and debugging).
    name: String,
    /// Strategy enum value.
    strategy: u8,  // 0=one_for_one, 1=one_for_all, 2=rest_for_one, 3=simple_one_for_one
    /// Max restarts.
    max_restarts: u32,
    /// Max seconds.
    max_seconds: u64,
    /// Child specs as MIR-level representations.
    children: Vec<MirChildSpec>,
    /// Result type (always Pid).
    ty: MirType,
},
```

Add `MirChildSpec` struct:
```rust
pub struct MirChildSpec {
    pub id: String,
    pub start_fn: String,       // Name of the start function in MIR
    pub start_args: Vec<MirExpr>,
    pub restart_type: u8,       // 0=permanent, 1=transient, 2=temporary
    pub shutdown: MirShutdown,
    pub child_type: u8,         // 0=worker, 1=supervisor
}

pub enum MirShutdown {
    BrutalKill,
    Timeout(u64),
}
```

Add `SupervisorStart` to the `ty()` method and all match exhaustiveness sites.

**3. Implement lower_supervisor_def in mir/lower.rs:**

Following the pattern of `lower_actor_def` (line 1219):
- Extract strategy, limits, and child specs from the SupervisorDef AST.
- For each child spec, lower the start closure to a MIR function.
- Construct `MirExpr::SupervisorStart` with all the configuration.
- The supervisor definition generates a MIR function (similar to actor entry functions) that the runtime calls.

Add the `Item::SupervisorDef(sup_def) => self.lower_supervisor_def(&sup_def),` dispatch in the lowering item match.

**4. Handle SupervisorStart in monomorphization (mir/mono.rs):**

Add a case for `MirExpr::SupervisorStart` that recurses into child start function expressions, similar to the `ActorSpawn` handler.

**5. Handle SupervisorStart in pattern compilation (pattern/compile.rs):**

Add a case for `MirExpr::SupervisorStart` that recurses into any nested expressions (similar to `ActorSpawn`).

**6. Add intrinsic declarations in codegen/intrinsics.rs:**

Declare the supervisor runtime functions as LLVM external functions:
```rust
// snow_supervisor_start(config_ptr: ptr, config_size: i64) -> i64 (PID)
let sup_start_ty = i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false);
module.add_function("snow_supervisor_start", sup_start_ty, Some(Linkage::External));

// snow_supervisor_start_child(sup_pid: i64, args_ptr: ptr, args_size: i64) -> i64
let sup_start_child_ty = i64_type.fn_type(&[i64_type.into(), ptr_type.into(), i64_type.into()], false);
module.add_function("snow_supervisor_start_child", sup_start_child_ty, Some(Linkage::External));

// snow_supervisor_terminate_child(sup_pid: i64, child_pid: i64) -> i64
let sup_term_child_ty = i64_type.fn_type(&[i64_type.into(), i64_type.into()], false);
module.add_function("snow_supervisor_terminate_child", sup_term_child_ty, Some(Linkage::External));

// snow_supervisor_count_children(sup_pid: i64) -> i64
let sup_count_ty = i64_type.fn_type(&[i64_type.into()], false);
module.add_function("snow_supervisor_count_children", sup_count_ty, Some(Linkage::External));

// snow_actor_trap_exit() -> void
let trap_exit_ty = void_type.fn_type(&[], false);
module.add_function("snow_actor_trap_exit", trap_exit_ty, Some(Linkage::External));

// snow_actor_exit(target_pid: i64, reason_tag: i8) -> void
let actor_exit_ty = void_type.fn_type(&[i64_type.into(), i8_type.into()], false);
module.add_function("snow_actor_exit", actor_exit_ty, Some(Linkage::External));
```

Add assertions in the intrinsics test.

**7. Implement codegen for SupervisorStart in codegen/expr.rs:**

Following the ActorSpawn codegen pattern (around line 112):
- Serialize the supervisor config (strategy, limits, child specs) into a byte buffer.
- Store the serialized config as a global constant in the LLVM module.
- Emit a call to `snow_supervisor_start(config_ptr, config_size)` which returns the supervisor PID (i64).
- The child spec serialization format: encode strategy(u8), max_restarts(u32), max_seconds(u64), child_count(u32), then for each child: id_len(u32) + id_bytes, fn_ptr(ptr), args_ptr(ptr), args_size(u64), restart_type(u8), shutdown_type(u8), shutdown_timeout(u64), child_type(u8).

For each child's start function, the codegen emits a wrapper function that calls the lowered start closure and returns the spawned PID. The function pointer is stored in the serialized config.

**8. Create E2E test:**

Create `tests/e2e/supervisor_basic.snow`:
```snow
actor Counter(count :: Int) do
  receive do
    :increment -> Counter(count + 1)
  end
end

supervisor CounterSup do
  strategy: one_for_one
  max_restarts: 3
  max_seconds: 5

  child counter1 do
    start: fn -> spawn(Counter, 0) end
    restart: permanent
    shutdown: 5000
  end
end

fn main() do
  let sup = spawn(CounterSup)
  println("supervisor started")
end
```

Create `crates/snowc/tests/e2e_supervisors.rs` following the pattern of `crates/snowc/tests/e2e_actors.rs`:
- Test that the supervisor program compiles without errors.
- Test that the compiled binary runs and prints "supervisor started".
- This is a basic smoke test; more complex supervision tests come in Plan 07-03.
  </action>
  <verify>
Run `cargo test --workspace` -- all tests pass. Run `cargo test -p snowc --test e2e_supervisors` -- E2E supervisor test passes. The compiled Snow program with a supervisor block produces a working binary.
  </verify>
  <done>
Supervisor blocks parse correctly into SUPERVISOR_DEF CST nodes. Type checker validates supervisor definitions. MIR SupervisorStart lowers to LLVM codegen calling snow_supervisor_start. All intrinsics declared. E2E test compiles and runs a Snow supervisor program successfully.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-parser` -- all tests pass including supervisor parsing snapshots
2. `cargo test -p snow-typeck` -- all tests pass including supervisor type checking
3. `cargo test -p snow-codegen` -- all tests pass including supervisor MIR/codegen
4. `cargo test -p snowc --test e2e_supervisors` -- E2E test compiles and runs supervisor program
5. `cargo check --workspace` -- no errors or warnings
</verification>

<success_criteria>
- `supervisor Name do ... end` syntax parses correctly with strategy, limits, and child specs
- Type checker validates supervisor definitions and child start functions
- MIR SupervisorStart node lowers to LLVM codegen calling runtime functions
- All supervisor runtime intrinsics declared in LLVM module
- E2E test: Snow program with supervisor block compiles to native binary and runs
</success_criteria>

<output>
After completion, create `.planning/phases/07-supervision-fault-tolerance/07-02-SUMMARY.md`
</output>
