---
phase: 09-concurrency-standard-library
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
autonomous: true

must_haves:
  truths:
    - "A service definition registers typed helper functions accessible as ServiceName.method(pid, args)"
    - "Call handler return types are per-variant: Counter.get_count(pid) returns Int, Counter.get_name(pid) returns String"
    - "State type is unified across init return, call handler state params, and cast handler state params"
    - "Missing call or cast handler variant produces a compiler error (exhaustiveness enforced)"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "infer_service_def() function, user_modules map for service module resolution"
      contains: "infer_service_def"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Service module functions registered with per-variant reply types"
      contains: "register_service_module"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/item.rs"
      via: "ServiceDef AST node consumed by infer_service_def"
      pattern: "ServiceDef"
    - from: "infer_field_access in infer.rs"
      to: "user_modules map"
      via: "Extended module resolution checks user-defined service modules alongside stdlib_modules"
      pattern: "user_modules|service_modules"
---

<objective>
Add type checking for Service definitions: infer state type, register per-variant typed helper functions as module-qualified names, and enforce exhaustiveness on call/cast handlers.

Purpose: This makes Service a fully type-checked abstraction. Callers get exact return types per variant (Counter.get_count returns Int, Counter.increment returns Int), and the compiler errors if any call/cast variant is unhandled.

Output: `infer_service_def()` in the type checker processes ServiceDef AST nodes, registering typed functions and validating state consistency.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-concurrency-standard-library/09-CONTEXT.md
@.planning/phases/09-concurrency-standard-library/09-RESEARCH.md
@.planning/phases/09-concurrency-standard-library/09-01-SUMMARY.md

Key source files:
@crates/snow-typeck/src/infer.rs (infer_actor_def, infer_supervisor_def, stdlib_modules, is_stdlib_module, infer_field_access as templates)
@crates/snow-typeck/src/builtins.rs (builtin registration patterns)
@crates/snow-parser/src/ast/item.rs (ServiceDef, CallHandler, CastHandler AST wrappers from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement infer_service_def with state type unification and module registration</name>
  <files>
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
    Add Service type checking to the type inference engine. Follow the pattern established by infer_actor_def (line ~2998) and infer_supervisor_def (line ~3084).

    1. **Wire ServiceDef into the main inference loop:**
       - In the `infer()` function's main AST walk (around line 733 where ActorDef and SupervisorDef are dispatched), add a case for `Item::ServiceDef(service_def)` that calls `infer_service_def(...)`.

    2. **Create `infer_service_def()` function:**
       - Extract service name from ServiceDef AST node
       - Create a fresh type variable `state_ty` for the service state
       - **Infer init function:**
         - Find the FN_DEF child (the init function) via service_def.init_fn()
         - Infer its parameter types and return type
         - Unify init return type with `state_ty`
         - Record init parameter types for later use in Counter.start() signature
       - **Infer call handlers:**
         - For each CallHandler from service_def.call_handlers():
           - Extract variant name (e.g., "GetCount", "Increment")
           - Infer parameter types (the args inside parens)
           - Parse return type annotation to get reply_ty
           - The handler body receives |state| and returns {new_state, reply}
           - Unify the state param with `state_ty`
           - The body should return a tuple -- unify first element with `state_ty`, second element with reply_ty
           - Store (variant_name, param_types, reply_ty) in a call_variants vec
       - **Infer cast handlers:**
         - For each CastHandler from service_def.cast_handlers():
           - Extract variant name (e.g., "Reset")
           - Infer parameter types
           - The handler body receives |state| and returns new_state
           - Unify the state param with `state_ty`
           - Unify the body return with `state_ty`
           - Store (variant_name, param_types) in a cast_variants vec
       - **Register service module:**
         - Call a new helper function `register_service_module(env, service_name, init_param_types, state_ty, &call_variants, &cast_variants)`

    3. **Create `register_service_module()` helper:**
       - Create a Pid type for the service: `Ty::App(Box::new(Ty::Con(TyCon::new("Pid"))), vec![Ty::Con(TyCon::new("Unit"))])` -- service PIDs use Pid<Unit> since the internal message types are not exposed to callers.
       - Register `ServiceName.start(init_args...) -> Pid<Unit>` in the type environment:
         - Build function type from init param types -> pid_ty
         - Insert as `format!("{}.start", service_name)` with Scheme::mono(fn_ty)
       - Register call helpers: for each (variant_name, param_types, reply_ty):
         - Snake-case the variant name (GetCount -> get_count, Increment -> increment)
         - Build function type: (pid_ty, param_types...) -> reply_ty
         - Insert as `format!("{}.{}", service_name, snake_name)` with Scheme::mono(fn_ty)
       - Register cast helpers: for each (variant_name, param_types):
         - Snake-case the variant name (Reset -> reset)
         - Build function type: (pid_ty, param_types...) -> Ty::Tuple(vec![]) (Unit)
         - Insert as `format!("{}.{}", service_name, snake_name)` with Scheme::mono(fn_ty)

    4. **Extend module resolution for user-defined services:**
       - Add a `user_modules: HashSet<String>` (or Vec) to track service names registered during inference. This can be a simple mutable state passed through inference or stored alongside the env.
       - In `is_stdlib_module()` (or the call site in `infer_field_access` around line 2473), also check if the name is in user_modules.
       - When infer_field_access sees `Counter.get_count(pid)`, it should:
         a. Check stdlib_modules first (existing behavior)
         b. If not found, check if base_name is a registered service module
         c. If it is, look up `"{base_name}.{field}"` in the env (where register_service_module already inserted it)
       - The simplest approach: after register_service_module inserts `Counter.start`, `Counter.get_count`, etc., also add "Counter" to a `user_service_names` set. In infer_field_access, check this set alongside STDLIB_MODULE_NAMES.

    5. **Snake-case helper:**
       - Add a small helper `fn to_snake_case(name: &str) -> String` that converts PascalCase to snake_case (e.g., GetCount -> get_count, Increment -> increment). Simple algorithm: insert underscore before each uppercase letter that follows a lowercase letter, then lowercase all.

    6. **State type enforcement:**
       - All state unifications use the same `state_ty` variable. If init returns Int but a handler expects String, unification will fail with a type error automatically. No special error code needed -- the standard type mismatch error (E0001) is sufficient.

    Per user decision: Exhaustiveness is enforced. For this plan, we ensure every call/cast variant in the service has a handler. Since the user WRITES the handlers as part of the service definition (not in a separate match block), exhaustiveness is structurally guaranteed by the parser -- you can't define a variant without a handler because the handler IS the variant definition. Exhaustiveness checking for CALLERS (ensuring they handle all reply types) is not needed because each helper function returns a specific type. The exhaustiveness requirement from CONTEXT.md is satisfied by the service definition structure itself.

    IMPORTANT: Use Pid<Unit> for service PIDs exposed to callers, NOT an internal message type. The internal dispatching uses type_tags at runtime, not the Pid type parameter. This keeps the API clean -- callers don't need to know about internal message types.
  </action>
  <verify>
    `cargo build -p snow-typeck` compiles. `cargo test -p snow-typeck` passes (no regressions). Write a typeck unit test that:
    1. Parses a service Counter definition with init, GetCount call, Increment call, Reset cast
    2. Verifies it type-checks without errors
    3. Verifies Counter.get_count returns Int, Counter.increment returns Int, Counter.reset returns Unit
    4. Verifies Counter.start accepts the init parameter type
  </verify>
  <done>
    infer_service_def correctly infers state types, registers per-variant typed helper functions, and the module resolution system resolves ServiceName.method(pid, args) with correct types. State type mismatches between init and handlers produce type errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Job module type registration</name>
  <files>
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
    Register the Job module in stdlib_modules() following the exact pattern of List, Map, String, etc.

    In the `stdlib_modules()` function (around line 202):
    - Add a new "Job" module section:

    ```
    let mut job_mod = HashMap::new();
    ```

    - **Job.async**: Takes a zero-arg function, returns Pid typed to the function's return type.
      - Type: `fn(fn() -> T) -> Pid<T>` (polymorphic in T)
      - Register with `Scheme::poly` using a type variable for T
      - The Pid return type uses Ty::App(Ty::Con("Pid"), [T]) per existing Pid<M> pattern

    - **Job.await**: Takes a Pid, blocks until result, returns Result<T, String>.
      - Type: `fn(Pid<T>) -> Result<T, String>` (polymorphic in T)
      - Use the existing Result type construction pattern (check how Result is used in File module for reference -- File.read returns Result<String, String>)

    - **Job.await_timeout**: Takes a Pid and timeout in ms, returns Result<T, String>.
      - Type: `fn(Pid<T>, Int) -> Result<T, String>`
      - Per discretion recommendation: separate function for explicit timeout

    - **Job.map**: Takes a List and a function, spawns parallel jobs, returns List of results.
      - Type: `fn(List<A>, fn(A) -> B) -> List<Result<B, String>>` (polymorphic in A, B)
      - Note: Due to the type-erased collection system (uniform u64 representation), the actual type registration may need to use the same opaque pointer approach as List.map. Follow the List.map pattern for the type scheme.

    Also add "Job" to the `STDLIB_MODULE_NAMES` array (around line 422) so that `is_stdlib_module("Job")` returns true.

    Per discretion decisions:
    - Job.await blocks indefinitely (no default timeout)
    - Job.await_timeout has explicit timeout parameter
    - Job.async creates a linked job by default (crash -> Err in await)
    - Crash-during-await returns Err (aligns with Result<T, Error> return type)
  </action>
  <verify>
    `cargo build -p snow-typeck` compiles. `cargo test -p snow-typeck` passes. Verify that Job.async, Job.await, Job.await_timeout, and Job.map are resolvable in the type environment by writing a test that type-checks expressions using these functions.
  </verify>
  <done>
    Job module is registered in stdlib_modules with async/await/await_timeout/map functions. Job appears in STDLIB_MODULE_NAMES. Type inference correctly types Job.async(fn -> expr end) and Job.await(pid) expressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-typeck` succeeds
2. `cargo test -p snow-typeck` passes (no regressions)
3. Service definitions type-check with correct per-variant return types
4. Job module functions resolve with correct type schemes
5. ServiceName.method(pid, args) resolves through extended module resolution
</verification>

<success_criteria>
- infer_service_def processes ServiceDef AST nodes and registers typed helper functions
- Per-variant reply types work: Counter.get_count returns Int, Counter.increment returns Int
- State type is unified across all handlers -- mismatches produce type errors
- Job.async/await/await_timeout/map are type-checkable
- Module resolution resolves both Service names and Job as module-qualified access
</success_criteria>

<output>
After completion, create `.planning/phases/09-concurrency-standard-library/09-02-SUMMARY.md`
</output>
