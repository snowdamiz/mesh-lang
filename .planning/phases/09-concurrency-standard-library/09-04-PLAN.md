---
phase: 09-concurrency-standard-library
plan: 04
type: execute
wave: 4
depends_on: ["09-03"]
files_modified:
  - crates/snow-rt/src/actor/job.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
autonomous: true

must_haves:
  truths:
    - "Job.async(fn -> expr end) spawns a linked actor that runs the function and sends its result back"
    - "Job.await(pid) blocks until the job completes and returns Result<T, String>"
    - "If a job crashes, Job.await returns Err with the crash reason"
    - "Job.map(list, fn) spawns parallel jobs and collects results in order"
  artifacts:
    - path: "crates/snow-rt/src/actor/job.rs"
      provides: "snow_job_async, snow_job_await, snow_job_await_timeout, snow_job_map runtime functions"
      contains: "snow_job_async"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for Job runtime functions"
      contains: "snow_job_async"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Job module-qualified access resolves to runtime functions via map_builtin_name"
      contains: "job_async"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/actor/job.rs"
      via: "map_builtin_name maps job_async -> snow_job_async for LLVM linkage"
      pattern: "job_async.*snow_job_async"
    - from: "crates/snow-rt/src/actor/job.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "Job functions use existing actor primitives (spawn, send, receive, link)"
      pattern: "snow_actor_spawn|snow_actor_send|snow_actor_receive"
---

<objective>
Implement the Job (async task) abstraction: runtime functions for async spawn, await, timeout await, and parallel map, plus codegen wiring.

Purpose: Job provides a simple async computation pattern. Users spawn work with Job.async, get results with Job.await (returning Result<T, String>), and can parallelize list operations with Job.map.

Output: Job.async/await/await_timeout/map compile and execute correctly. A spawned job runs concurrently, and its result is collected via await.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-concurrency-standard-library/09-CONTEXT.md
@.planning/phases/09-concurrency-standard-library/09-RESEARCH.md
@.planning/phases/09-concurrency-standard-library/09-03-SUMMARY.md

Key source files:
@crates/snow-rt/src/actor/mod.rs (snow_actor_spawn, snow_actor_send, snow_actor_receive, snow_actor_link, snow_actor_self)
@crates/snow-rt/src/actor/link.rs (EXIT_SIGNAL_TAG, exit signal handling)
@crates/snow-rt/src/actor/service.rs (snow_service_call pattern from Plan 03)
@crates/snow-codegen/src/mir/lower.rs (STDLIB_MODULES, map_builtin_name -- Job entries added in Plan 03)
@crates/snow-codegen/src/codegen/intrinsics.rs (runtime function declarations)
@crates/snow-codegen/src/codegen/expr.rs (existing codegen for function calls)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Job runtime functions</name>
  <files>
    crates/snow-rt/src/actor/job.rs
    crates/snow-rt/src/actor/mod.rs
  </files>
  <action>
    Create the runtime implementation for Job (async task) abstraction.

    1. **Create `crates/snow-rt/src/actor/job.rs`:**

       Use a dedicated JOB_RESULT_TAG constant (e.g., `u64::MAX - 1`) to distinguish job result messages from regular messages and exit signals (EXIT_SIGNAL_TAG = u64::MAX). This avoids interference with normal actor messaging per RESEARCH.md Pitfall 4.

       - **`snow_job_async(fn_ptr: *const u8, env_ptr: *const u8) -> u64`** (extern "C", #[no_mangle]):
         - Get caller PID (the "parent" that will await the result)
         - Spawn a new actor that:
           a. Links itself to the caller (so crash propagates as exit signal)
           b. Calls the provided function (fn_ptr with env_ptr for closure support)
           c. Sends the result back to the parent PID using JOB_RESULT_TAG
           d. Exits normally
         - Implementation: The "job actor" is a wrapper function. Since the Snow codegen represents closures as {fn_ptr, env_ptr} structs, snow_job_async receives these two pointers. It spawns a coroutine that:
           1. Calls `snow_actor_link(parent_pid)` to link to parent
           2. Invokes the function: call fn_ptr(env_ptr) if env_ptr is non-null, or fn_ptr() if null
           3. Sends result to parent: build message [u64 JOB_RESULT_TAG][u64 result_value] and send to parent_pid
           4. Returns (actor exits normally)
         - Returns the spawned PID (as u64/i64)

         IMPORTANT: The spawn mechanism must use the existing snow_actor_spawn infrastructure. However, snow_actor_spawn expects a function pointer and serialized args. For Job.async, the "function" is a runtime-created wrapper that captures fn_ptr, env_ptr, and parent_pid.

         Simpler approach: Have the codegen generate a small wrapper function at compile time for each Job.async call site. The MIR lowerer (in lower_field_access for Job.async) generates a wrapper actor function that:
         - Takes (parent_pid, fn_ptr, env_ptr) as actor params
         - Links to parent_pid
         - Calls the closure
         - Sends result back to parent_pid
         Then spawns this wrapper with (caller_pid, fn_ptr, env_ptr) as args.

         Even simpler: Have a single runtime-level job runner function that the codegen calls. The runtime function:
         - snow_job_async(fn_ptr, env_ptr) is called from compiled code
         - It creates a SpawnRequest with a built-in job runner coroutine
         - The job runner coroutine calls the function and sends the result back
         - This requires the runtime to create a coroutine that captures the function pointers

         Use the approach that fits best with the existing spawn infrastructure. The existing snow_actor_spawn takes (fn_ptr, args_ptr, args_size) and creates a coroutine. So snow_job_async can:
         1. Get parent_pid from current actor context
         2. Build args: [u64 parent_pid][u64 fn_ptr_as_u64][u64 env_ptr_as_u64]
         3. Spawn an actor using a built-in `__snow_job_runner` function that is registered in the runtime
         4. Return the spawned PID

         The `__snow_job_runner` entry point (also in job.rs):
         - Receives (parent_pid, fn_ptr, env_ptr) from args
         - Links to parent_pid
         - Calls fn_ptr(env_ptr) or fn_ptr() depending on env_ptr
         - Sends [JOB_RESULT_TAG][result] to parent_pid
         - Returns (normal exit)

         This may be tricky because the runtime needs to call an arbitrary function pointer. Use the same calling convention as closure HOFs in the collections runtime (see snow_list_map for reference -- it calls fn_ptr(env_ptr, element)).

       - **`snow_job_await(job_pid: u64) -> *const u8`** (extern "C", #[no_mangle]):
         - Block on receive (snow_actor_receive) waiting for a message from the job
         - Check the received message:
           a. If type_tag == JOB_RESULT_TAG: extract the result value, wrap in Ok(value), return as Result pointer
           b. If type_tag == EXIT_SIGNAL_TAG: extract the exit reason, wrap in Err(reason), return as Result pointer
         - For constructing Result values: use the existing SnowResult runtime type (from snow-rt, used by File module). Allocate a SnowResult with tag=0 (Ok) or tag=1 (Err) and the value.
         - Return pointer to the SnowResult

       - **`snow_job_await_timeout(job_pid: u64, timeout_ms: i64) -> *const u8`** (extern "C", #[no_mangle]):
         - Same as snow_job_await but with timeout_ms parameter
         - If timeout expires (receive returns null/timeout indicator): return Err("timeout")
         - Otherwise same Ok/Err logic as snow_job_await

       - **`snow_job_map(list_ptr: *const u8, fn_ptr: *const u8, env_ptr: *const u8) -> *const u8`** (extern "C", #[no_mangle]):
         - Get the input list from list_ptr (use existing list runtime to iterate)
         - For each element in the list:
           a. Spawn a job via snow_job_async-like logic (call fn on element)
           b. Track (index, job_pid) pairs
         - Await all jobs in order, collecting results
         - Build a result list of Result values
         - Return pointer to the result list

         Note: Job.map is more complex because it needs to spawn per-element. The simplest implementation: iterate the list, for each element spawn a linked actor that calls fn(element) and sends result with its index. Then receive N results, sort by index, build list.

         Simpler MVP: process sequentially but each in its own actor for fault isolation. Or truly parallel: spawn all, then await all in order. Since jobs run concurrently via the scheduler, spawning all first then awaiting in order achieves parallelism.

    2. **Update `crates/snow-rt/src/actor/mod.rs`:**
       - Add `pub mod job;`

    Per discretion decisions from CONTEXT.md:
    - Job.async creates linked jobs (crash -> exit signal to caller)
    - Job.await blocks indefinitely (no default timeout)
    - Job.await_timeout has explicit timeout
    - Crash during await returns Err (aligned with Result<T, Error> return type)
  </action>
  <verify>
    `cargo build -p snow-rt` compiles. `cargo test -p snow-rt` passes. The job.rs file exists with all four extern "C" functions.
  </verify>
  <done>
    snow_job_async spawns a linked job actor that runs a function and sends its result back. snow_job_await blocks for the result and returns Ok/Err as a SnowResult. snow_job_await_timeout adds timeout. snow_job_map spawns parallel jobs per list element.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Job runtime into LLVM codegen</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
    Wire Job runtime functions into the LLVM codegen pipeline so Job.async/await/await_timeout/map resolve to the correct runtime calls.

    1. **LLVM Intrinsic Declarations (`crates/snow-codegen/src/codegen/intrinsics.rs`):**
       Add declarations for:
       - `snow_job_async`: fn(ptr, ptr) -> i64  [fn_ptr, env_ptr -> job_pid]
       - `snow_job_await`: fn(i64) -> ptr  [job_pid -> result_ptr]
       - `snow_job_await_timeout`: fn(i64, i64) -> ptr  [job_pid, timeout_ms -> result_ptr]
       - `snow_job_map`: fn(ptr, ptr, ptr) -> ptr  [list_ptr, fn_ptr, env_ptr -> result_list_ptr]
       Follow the exact pattern used for other runtime function declarations (snow_actor_spawn, snow_list_map, etc.).

    2. **MIR Lower Name Mapping (`crates/snow-codegen/src/mir/lower.rs`):**
       Verify that Plan 03's additions to map_builtin_name are in place:
       - "job_async" -> "snow_job_async"
       - "job_await" -> "snow_job_await"
       - "job_await_timeout" -> "snow_job_await_timeout"
       - "job_map" -> "snow_job_map"
       If not already added, add them now.

       Also verify "Job" is in STDLIB_MODULES (added in Plan 03). If not, add it.

       The MIR lowering for `Job.async(fn -> expr end)` follows the standard stdlib module path:
       - `Job.async` in source -> FieldAccess(base="Job", field="async") in AST
       - lower_field_access sees "Job" in STDLIB_MODULES -> produces MirExpr::Var("job_async", type)
       - At call site, produces MirExpr::Call { func: "job_async", args: [fn_ptr, env_ptr] }
       - map_builtin_name converts "job_async" to "snow_job_async"
       - Codegen emits call to the LLVM function `snow_job_async`

       IMPORTANT for Job.async: The argument is a closure (fn -> expr end). The codegen represents closures as {fn_ptr, env_ptr} structs. The MIR lowerer for Job.async needs to ensure the closure is split into its fn_ptr and env_ptr components before passing to snow_job_async. This follows the same pattern as closure splitting for List.map (established in 08-06). The MIR lowerer should recognize Job.async as a HOF that needs closure struct splitting.

       If Job.async doesn't automatically get closure struct splitting, add it to the HOF recognition logic in the MIR lowerer or codegen. Check how `snow_list_map` handles closure arguments -- Job.async should follow the same pattern.

    3. **Verify Job.await return type codegen:**
       Job.await returns Result<T, String>. The codegen must handle the SnowResult pointer correctly:
       - The runtime returns a pointer to a SnowResult struct ({tag: i8, _pad: [u8;7], value: ptr} or similar aligned layout)
       - The caller's let binding must load the result from this pointer
       - This follows the same pattern as File.read which also returns Result<String, String>
       - The existing sum type codegen for runtime-returned Results should handle this (established in 08-03)
  </action>
  <verify>
    `cargo build` (full workspace) compiles. `cargo test` passes. Write a minimal E2E test that compiles and runs:
    ```
    let job = Job.async(fn -> 42 end)
    let result = Job.await(job)
    case result do
      Ok(val) -> println(val)
      Err(msg) -> println(msg)
    end
    ```
    Expected output: "42"
  </verify>
  <done>
    Job.async/await/await_timeout/map compile through the full pipeline. Closure arguments are correctly split for runtime. Job.await returns a Result that can be pattern-matched. Job.map compiles as a list -> list transformation.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` (full workspace) succeeds
2. `cargo test` (full workspace) passes
3. Job.async spawns an async computation and returns a Pid
4. Job.await blocks and returns Ok(value) on success
5. Job.await returns Err on job crash
6. Job.map processes a list in parallel
</verification>

<success_criteria>
- Job.async(fn -> expr end) spawns a linked job actor
- Job.await(pid) returns Result<T, String> -- Ok on success, Err on crash
- Job.await_timeout(pid, ms) adds timeout behavior
- Job.map(list, fn) spawns parallel jobs per element and collects ordered results
- All Job functions compile through the full pipeline and execute correctly
</success_criteria>

<output>
After completion, create `.planning/phases/09-concurrency-standard-library/09-04-SUMMARY.md`
</output>
