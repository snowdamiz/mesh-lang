---
phase: 09-concurrency-standard-library
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-common/src/token.rs
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/items.rs
  - crates/snow-parser/src/ast/item.rs
autonomous: true

must_haves:
  truths:
    - "A `service Counter do ... end` block parses into a SERVICE_DEF CST node"
    - "`call GetCount() :: Int do |state| ... end` parses into a CALL_HANDLER node inside SERVICE_DEF"
    - "`cast Reset() do |state| ... end` parses into a CAST_HANDLER node inside SERVICE_DEF"
    - "`fn init(start_val :: Int) :: Int do ... end` parses as a regular FN_DEF inside SERVICE_DEF"
  artifacts:
    - path: "crates/snow-common/src/token.rs"
      provides: "TokenKind::Service, TokenKind::Call, TokenKind::Cast keywords"
      contains: "Service"
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "SERVICE_KW, CALL_KW, CAST_KW, SERVICE_DEF, CALL_HANDLER, CAST_HANDLER syntax kinds"
      contains: "SERVICE_DEF"
    - path: "crates/snow-parser/src/parser/items.rs"
      provides: "parse_service_def() function with call/cast handler body parsing"
      contains: "parse_service_def"
    - path: "crates/snow-parser/src/ast/item.rs"
      provides: "ServiceDef AST wrapper with accessors for name, init fn, call handlers, cast handlers"
      contains: "ServiceDef"
  key_links:
    - from: "crates/snow-parser/src/syntax_kind.rs"
      to: "crates/snow-common/src/token.rs"
      via: "TokenKind to SyntaxKind mapping in token_kind_to_syntax_kind()"
      pattern: "TokenKind::Service => SyntaxKind::SERVICE_KW"
    - from: "crates/snow-parser/src/parser/items.rs"
      to: "crates/snow-parser/src/parser/mod.rs"
      via: "parse_item_or_stmt dispatches SERVICE_KW to parse_service_def"
      pattern: "SERVICE_KW.*parse_service_def"
---

<objective>
Add Service definition syntax to the Snow compiler frontend: lexer keywords, parser, and AST wrappers.

Purpose: Service (Snow's GenServer equivalent) needs a new `service Name do ... end` top-level item with `call` and `cast` handler blocks. This plan adds the parsing infrastructure so later plans can add type checking and code generation.

Output: A Snow program containing `service Counter do fn init(...) ... end call GetCount() :: Int do |state| ... end cast Reset() do |state| ... end end` parses into a well-formed CST/AST.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-concurrency-standard-library/09-CONTEXT.md
@.planning/phases/09-concurrency-standard-library/09-RESEARCH.md

Key source files to reference for patterns:
@crates/snow-common/src/token.rs (TokenKind enum, keyword_from_str function)
@crates/snow-parser/src/syntax_kind.rs (SyntaxKind enum, token_kind_to_syntax_kind mapping)
@crates/snow-parser/src/parser/items.rs (parse_actor_def, parse_supervisor_def as templates)
@crates/snow-parser/src/parser/mod.rs (parse_item_or_stmt dispatch)
@crates/snow-parser/src/ast/item.rs (ActorDef, SupervisorDef AST wrappers as templates)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Service/Call/Cast tokens and SyntaxKinds</name>
  <files>
    crates/snow-common/src/token.rs
    crates/snow-parser/src/syntax_kind.rs
  </files>
  <action>
    Add three new keywords to the Snow lexer and parser:

    1. In `crates/snow-common/src/token.rs`:
       - Add `Service` variant to `TokenKind` enum (alongside existing Actor, Supervisor)
       - Add `Call` variant to `TokenKind` enum
       - Add `Cast` variant to `TokenKind` enum
       - Add keyword mappings in `keyword_from_str()`: "service" => Some(TokenKind::Service), "call" => Some(TokenKind::Call), "cast" => Some(TokenKind::Cast)
       - Add to the ALL_KEYWORDS array: ("service", TokenKind::Service), ("call", TokenKind::Call), ("cast", TokenKind::Cast)

    2. In `crates/snow-parser/src/syntax_kind.rs`:
       - Add `SERVICE_KW`, `CALL_KW`, `CAST_KW` to the SyntaxKind enum (alongside ACTOR_KW, SUPERVISOR_KW)
       - Add `SERVICE_DEF`, `CALL_HANDLER`, `CAST_HANDLER` to SyntaxKind (alongside ACTOR_DEF, SUPERVISOR_DEF)
       - Add token-to-syntax mappings: TokenKind::Service => SyntaxKind::SERVICE_KW, TokenKind::Call => SyntaxKind::CALL_KW, TokenKind::Cast => SyntaxKind::CAST_KW

    Note: `call` and `cast` are contextual keywords -- they are only meaningful inside a service block. However, registering them as keywords is fine since they are unlikely to collide with user identifiers, and the same approach is used for `spawn`, `send`, `receive`, etc.
  </action>
  <verify>
    `cargo build -p snow-common -p snow-parser` compiles without errors. Grep for SERVICE_KW, CALL_KW, CAST_KW in syntax_kind.rs to confirm they exist.
  </verify>
  <done>
    TokenKind::Service/Call/Cast exist. SyntaxKind::SERVICE_KW/CALL_KW/CAST_KW/SERVICE_DEF/CALL_HANDLER/CAST_HANDLER exist. Token-to-syntax mapping connects them.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Service parser and AST wrappers</name>
  <files>
    crates/snow-parser/src/parser/items.rs
    crates/snow-parser/src/parser/mod.rs
    crates/snow-parser/src/ast/item.rs
  </files>
  <action>
    Add service definition parsing and AST wrappers, following the actor/supervisor patterns exactly.

    1. In `crates/snow-parser/src/parser/mod.rs`:
       - In the `parse_item_or_stmt` function (or wherever ACTOR_KW dispatches to parse_actor_def), add: `SyntaxKind::SERVICE_KW => items::parse_service_def(p)`

    2. In `crates/snow-parser/src/parser/items.rs`:
       - Add `pub(crate) fn parse_service_def(p: &mut Parser)` following the pattern of `parse_supervisor_def`:
         - Advance past SERVICE_KW
         - Parse service name (IDENT -> NAME node)
         - Expect DO_KW
         - Parse service body via `parse_service_body(p)`
         - Expect END_KW
         - Close with SERVICE_DEF

       - Add `fn parse_service_body(p: &mut Parser)` following the pattern of `parse_supervisor_body`:
         - Loop eating newlines/semicolons
         - Match on current token:
           - `FN_KW` -> call `super::parse_item_or_stmt(p)` to parse `fn init(...)` as a regular FN_DEF
           - `CALL_KW` -> call `parse_call_handler(p)`
           - `CAST_KW` -> call `parse_cast_handler(p)`
           - `END_KW | EOF` -> break
           - `_` -> error "expected `fn`, `call`, `cast`, or `end` in service body"

       - Add `fn parse_call_handler(p: &mut Parser)`:
         - Open marker, advance past CALL_KW
         - Parse variant name: expect IDENT, wrap in NAME node
         - Parse optional parameter list in parens (field names with type annotations). Use existing `parse_param_list(p)` for the arguments. Example: `call Increment(amount :: Int) :: Int`
         - Parse return type annotation: expect `::` (COLON COLON) then call `parse_type(p)` for the reply type
         - Expect DO_KW
         - Parse handler body: expect `|` (BAR), parse a single IDENT for state param (wrap in NAME or PARAM node), expect `|` (BAR), then parse the body as expressions/statements until END_KW. Use the same approach as closure body parsing or actor body parsing.
         - Expect END_KW
         - Close with CALL_HANDLER

       - Add `fn parse_cast_handler(p: &mut Parser)`:
         - Same as call_handler but:
           - Uses CAST_KW instead of CALL_KW
           - No return type annotation (cast is fire-and-forget, returns Unit)
           - Close with CAST_HANDLER

    3. In `crates/snow-parser/src/ast/item.rs`:
       - Add `ServiceDef(ServiceDef)` variant to the `Item` enum
       - Add `SyntaxKind::SERVICE_DEF => Some(Item::ServiceDef(ServiceDef { syntax: node }))` in Item::cast
       - Add `ast_node!(ServiceDef, SERVICE_DEF);`
       - Add `impl ServiceDef` with accessor methods:
         - `fn name(&self) -> Option<Name>` -- returns the service name
         - `fn init_fn(&self) -> Option<FnDef>` -- finds the FN_DEF child (the init function)
         - `fn call_handlers(&self) -> Vec<CallHandler>` -- finds all CALL_HANDLER children
         - `fn cast_handlers(&self) -> Vec<CastHandler>` -- finds all CAST_HANDLER children
       - Add `ast_node!(CallHandler, CALL_HANDLER);`
       - Add `impl CallHandler` with accessors:
         - `fn name(&self) -> Option<Name>` -- variant name (e.g., "GetCount")
         - `fn params(&self) -> Option<ParamList>` -- parameters after variant name
         - `fn return_type(&self) -> Option<TypeAnnotation>` -- the :: Type annotation
         - `fn state_param_name(&self) -> Option<String>` -- the |state| parameter name
         - `fn body(&self) -> impl Iterator<Item = Expr>` -- body expressions
       - Add `ast_node!(CastHandler, CAST_HANDLER);`
       - Add `impl CastHandler` with same accessors as CallHandler minus return_type

    The handler body syntax is: `call VariantName(args :: types) :: ReturnType do |state| body_expr end`
    The state parameter uses the existing bar-delimited pattern: `|state|` similar to closures.
    The body should return a tuple `{new_state, reply}` for call handlers, or just the new state for cast handlers.

    IMPORTANT: For the state parameter parsing inside call/cast handlers, parse `|ident|` by: expect BAR, expect IDENT (wrap in NAME), expect BAR. This is simpler than full closure param parsing and avoids ambiguity. The state param is always a single identifier.
  </action>
  <verify>
    `cargo build -p snow-parser` compiles without errors. Write a small unit test or use the existing parse test infrastructure to parse:
    ```
    service Counter do
      fn init(start_val :: Int) :: Int do
        start_val
      end

      call GetCount() :: Int do |state|
        {state, state}
      end

      call Increment(amount :: Int) :: Int do |state|
        {state + amount, state + amount}
      end

      cast Reset() do |state|
        0
      end
    end
    ```
    and verify it produces a SERVICE_DEF node with FN_DEF, CALL_HANDLER, CALL_HANDLER, CAST_HANDLER children. Run `cargo test -p snow-parser` to confirm no regressions.
  </verify>
  <done>
    `service Counter do ... end` with init fn, call handlers, and cast handlers parses into a well-formed SERVICE_DEF CST node. ServiceDef AST wrapper provides typed access to all parts. All existing parser tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-common -p snow-parser` succeeds
2. `cargo test -p snow-parser` passes (no regressions)
3. SERVICE_DEF, CALL_HANDLER, CAST_HANDLER nodes appear in parse output for service definitions
4. ServiceDef AST wrapper can extract name, init fn, call handlers, cast handlers
</verification>

<success_criteria>
- Service definition syntax is parseable by the Snow compiler
- Three new keywords (service, call, cast) are recognized by the lexer
- Parser produces correct CST structure for service blocks with init, call, and cast handlers
- AST wrappers provide typed accessors for downstream type checker consumption
</success_criteria>

<output>
After completion, create `.planning/phases/09-concurrency-standard-library/09-01-SUMMARY.md`
</output>
