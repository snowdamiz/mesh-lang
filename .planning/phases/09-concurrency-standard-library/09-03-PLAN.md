---
phase: 09-concurrency-standard-library
plan: 03
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - crates/snow-rt/src/actor/service.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/codegen/expr.rs
autonomous: true

must_haves:
  truths:
    - "A Service definition compiles to a working actor with a receive loop that dispatches on type_tag"
    - "Counter.start(0) spawns the service actor and returns its Pid"
    - "Counter.get_count(pid) sends a synchronous call message and blocks until the reply arrives"
    - "Counter.reset(pid) sends an asynchronous cast message (fire-and-forget)"
    - "The runtime snow_service_call function handles send+block-for-reply atomically"
  artifacts:
    - path: "crates/snow-rt/src/actor/service.rs"
      provides: "snow_service_call and snow_service_reply runtime functions"
      contains: "snow_service_call"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "lower_service_def() that desugars service into actor MIR nodes"
      contains: "lower_service_def"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for snow_service_call, snow_service_reply"
      contains: "snow_service_call"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "Service desugars to existing ActorSpawn/ActorSend/ActorReceive MIR nodes"
      pattern: "ActorSpawn|ActorReceive"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-rt/src/actor/service.rs"
      via: "Generated code calls snow_service_call/snow_service_reply at runtime"
      pattern: "snow_service_call"
    - from: "lower_service_def in lower.rs"
      to: "ServiceDef AST"
      via: "Consumes ServiceDef from parser, produces MIR functions"
      pattern: "ServiceDef|lower_service_def"
---

<objective>
Add runtime support and code generation for Service definitions: runtime call/reply functions, MIR lowering that desugars service into actor primitives, and LLVM codegen wiring.

Purpose: This makes Service definitions actually compile and run. A `service Counter do...end` compiles to a working actor with a receive loop, and `Counter.start(0)`, `Counter.get_count(pid)`, `Counter.reset(pid)` generate correct runtime calls.

Output: A Snow program defining a Counter service can be compiled to a native binary that starts the service, makes synchronous calls, and receives correct replies.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-concurrency-standard-library/09-CONTEXT.md
@.planning/phases/09-concurrency-standard-library/09-RESEARCH.md
@.planning/phases/09-concurrency-standard-library/09-01-SUMMARY.md
@.planning/phases/09-concurrency-standard-library/09-02-SUMMARY.md

Key source files:
@crates/snow-rt/src/actor/mod.rs (snow_actor_send, snow_actor_receive, snow_actor_spawn patterns)
@crates/snow-rt/src/actor/scheduler.rs (scheduler context, current_pid)
@crates/snow-rt/src/actor/stack.rs (get_current_pid)
@crates/snow-codegen/src/mir/lower.rs (lower_actor_def, lower_supervisor_def, STDLIB_MODULES, map_builtin_name as templates)
@crates/snow-codegen/src/mir/mod.rs (MirExpr::ActorSpawn, ActorSend, ActorReceive, SupervisorStart)
@crates/snow-codegen/src/codegen/intrinsics.rs (declare_runtime_functions pattern)
@crates/snow-codegen/src/codegen/expr.rs (codegen for ActorSpawn, ActorSend, ActorReceive)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Service runtime functions (snow_service_call, snow_service_reply)</name>
  <files>
    crates/snow-rt/src/actor/service.rs
    crates/snow-rt/src/actor/mod.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
    Create the runtime support for synchronous service calls.

    1. **Create `crates/snow-rt/src/actor/service.rs`:**

       - **`snow_service_call(target_pid: u64, msg_tag: u64, payload_ptr: *const u8, payload_size: u64) -> *const u8`** (extern "C", #[no_mangle]):
         - Get caller's PID via the stack module (snow_actor_self pattern)
         - Build call message bytes: [u64 msg_tag][u64 caller_pid][payload bytes]
           - Allocate a Vec with capacity 16 + payload_size
           - Write msg_tag as 8 little-endian bytes
           - Write caller_pid as 8 little-endian bytes
           - Copy payload_size bytes from payload_ptr (if non-null and size > 0)
         - Send message to target_pid using snow_actor_send (or the internal send helper)
         - Block for reply: call snow_actor_receive(-1) to block indefinitely
           - This returns a pointer to the received message on the caller's heap
           - The message contains [u64 reply_tag][u64 data_len][reply data]
           - Return the pointer to the reply data (caller extracts the value)
         - Return the raw pointer from receive

       - **`snow_service_reply(caller_pid: u64, reply_ptr: *const u8, reply_size: u64)`** (extern "C", #[no_mangle]):
         - Send the reply data back to caller_pid using snow_actor_send (the internal send function)
         - The reply is raw bytes that the caller's receive will pick up
         - Message sent: just the reply bytes (the caller is already blocking on receive and will get the next message)

       Design note per RESEARCH.md anti-patterns: Service is a compiler abstraction. The runtime does NOT know about "services." These are general-purpose call/reply primitives. The send uses the existing snow_actor_send mechanism. The receive uses existing snow_actor_receive.

       IMPORTANT: For the receive-reply in snow_service_call, we reuse the existing snow_actor_receive mechanism. The caller enters a blocking receive. Since the caller is blocked waiting for the reply, no other code runs that could consume the message. The reply arrives as the next message in the caller's mailbox.

       IMPORTANT: The caller must be inside an actor context (have a PID) for service calls to work. This is the same constraint as send/receive -- you need to be an actor to send/receive messages.

    2. **Update `crates/snow-rt/src/actor/mod.rs`:**
       - Add `pub mod service;`
       - Ensure the service module's functions are visible

    3. **Update `crates/snow-rt/src/lib.rs`:**
       - If needed, re-export the service functions or ensure they're available for linking

    The message format:
    - Call message TO service: [u64 type_tag] [u64 caller_pid] [u64 payload_size] [payload_bytes...]
      Wait -- actually follow the existing message format. Looking at snow_actor_send, messages are sent as raw bytes with (ptr, size). The type_tag is the first 8 bytes of the data. So for service calls:
      - Bytes sent: [u64 type_tag][u64 caller_pid][remaining payload if any]
      - Total size: 16 + payload_size

    - Reply message TO caller: [u64 reply_value] (just the raw value bytes)
      Since the caller is blocked on receive and expecting exactly one reply, the reply can be minimal -- just the value. Use the same snow_actor_send to send raw bytes representing the reply value.

    For simple scalar replies (Int, Bool), the reply is just an i64 (8 bytes). For pointer-based replies (String, structs), it's a pointer value (i64). This matches how all values are represented as i64 in Snow's LLVM codegen.
  </action>
  <verify>
    `cargo build -p snow-rt` compiles. The new service.rs file exists with snow_service_call and snow_service_reply functions. Run `cargo test -p snow-rt` to confirm no regressions.
  </verify>
  <done>
    snow_service_call sends a tagged message with caller_pid, blocks for reply, and returns the reply pointer. snow_service_reply sends a reply back to the caller PID. Both are extern "C" #[no_mangle] for LLVM linkage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add MIR lowering and LLVM codegen for Service</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/codegen/expr.rs
  </files>
  <action>
    Add code generation for Service definitions. The key insight from RESEARCH.md: Service desugars to existing actor primitives at MIR level. No new MIR node types needed for the service loop -- use existing ActorSpawn, ActorSend, ActorReceive.

    1. **MIR Lowering (`crates/snow-codegen/src/mir/lower.rs`):**

       Add `fn lower_service_def(&mut self, service_def: &ServiceDef)` that generates multiple MIR functions:

       a. **Service loop function** (`__service_{name}_loop`):
          - Params: (state: state_mir_type)
          - Body: MirExpr::ActorReceive with arms that dispatch on type_tag:
            - For each call handler: receive message, extract caller_pid and payload args from the message bytes, run handler body, call snow_service_reply with (caller_pid, reply_value), tail-call loop with new_state
            - For each cast handler: receive message, extract payload args, run handler body, tail-call loop with new_state
          - The receive arms pattern-match on the message type_tag (integer match)
          - Use compiler-assigned type_tags: hash of "{ServiceName}::{VariantName}" truncated to u64, or simple sequential integers (0, 1, 2, ...) per service. Sequential integers are simpler and collision-free within a single service.
          - Each arm extracts values from the received message pointer:
            - For call: offset 0 = type_tag (already matched), offset 8 = caller_pid, offset 16+ = payload
            - For cast: offset 0 = type_tag (already matched), offset 8+ = payload

       b. **Start function** (`__service_{name}_start`):
          - Params: (init_params...)
          - Body: Call init function to get initial state, then ActorSpawn the loop function with initial state
          - Returns the spawned PID

       c. **Call helper functions** (`__service_{name}_call_{variant_snake}`):
          - Params: (pid, variant_args...)
          - Body: Build message bytes [type_tag | caller_pid_placeholder | args], call snow_service_call(pid, tag, payload_ptr, payload_size), return the reply value
          - The call to snow_service_call is a direct function call, not an ActorSend MIR node
          - Use MirExpr::Call to invoke snow_service_call

       d. **Cast helper functions** (`__service_{name}_cast_{variant_snake}`):
          - Params: (pid, variant_args...)
          - Body: Build message bytes [type_tag | args], call snow_actor_send(pid, msg_ptr, msg_size)
          - Returns Unit

       **Extend the STDLIB_MODULES array** (around line 1821) to NOT include service names statically. Instead, add a dynamic check: maintain a `known_service_modules: HashSet<String>` during lowering. In `lower_field_access`, after checking STDLIB_MODULES, also check known_service_modules. If matched, resolve `Counter.get_count` to `__service_counter_call_get_count`.

       **Wire into the main lowering dispatch:** In the main item lowering loop (where ActorDef and SupervisorDef are handled), add a case for ServiceDef that calls lower_service_def.

    2. **LLVM Intrinsic Declarations (`crates/snow-codegen/src/codegen/intrinsics.rs`):**

       Declare the new runtime functions:
       - `snow_service_call`: fn(i64, i64, ptr, i64) -> ptr  [target_pid, msg_tag, payload_ptr, payload_size -> reply_ptr]
       - `snow_service_reply`: fn(i64, ptr, i64) -> void  [caller_pid, reply_ptr, reply_size]

       Follow the exact pattern used for snow_actor_send, snow_actor_receive declarations.

    3. **LLVM Codegen (`crates/snow-codegen/src/codegen/expr.rs`):**

       The generated MIR functions use existing MirExpr variants (Call, ActorSpawn, ActorReceive, Var, Let, etc.), so the existing codegen should handle most of the work. The key additions:

       - Ensure the generated `__service_*` functions are emitted as LLVM functions (they appear as MirFunction entries from the lowerer)
       - The call/cast helper functions call snow_service_call/snow_actor_send -- these resolve through the existing intrinsic lookup
       - For message byte construction in helpers: allocate stack space with alloca, store type_tag and args as i64 values at appropriate offsets, pass pointer to snow_service_call/snow_actor_send

       For the service loop function's receive:
       - The MIR receive arms dispatch on integer type_tags (0, 1, 2...)
       - Each arm extracts values from the message pointer using GEP/load at known offsets
       - This is similar to how existing actor receive works, but with structured message layout

       IMPORTANT: The service loop function is an actor function -- it runs inside an actor context. It uses ActorReceive which yields to the scheduler when no messages are available. This is the same mechanism as regular actor receive.

    4. **Add "Job" to STDLIB_MODULES** (the MIR-level module list around line 1821):
       - Add "Job" to the STDLIB_MODULES array alongside "String", "IO", etc.
       - Add Job function mappings in map_builtin_name: "job_async" -> "snow_job_async", "job_await" -> "snow_job_await", "job_await_timeout" -> "snow_job_await_timeout", "job_map" -> "snow_job_map"
       - This prepares for Plan 04 (Job runtime) but the name mappings can be added now since they are just string mappings.

    The type_tag assignment scheme: Use sequential integers starting from 0 for each service. Call handlers get tags 0, 1, 2, ... (in definition order). Cast handlers continue from where calls left off. This is deterministic, collision-free within a service, and trivially simple. Example for Counter: GetCount = 0, Increment = 1, Reset = 2.
  </action>
  <verify>
    `cargo build -p snow-codegen` compiles. `cargo test -p snow-codegen` passes. Write a small E2E test (or add to existing e2e test file) that compiles and runs:
    ```
    service Counter do
      fn init(start :: Int) :: Int do
        start
      end
      call GetCount() :: Int do |state|
        {state, state}
      end
      cast Reset() do |state|
        0
      end
    end

    let pid = Counter.start(42)
    let val = Counter.get_count(pid)
    println(val)
    ```
    Expected output: "42". This proves the full pipeline works: parse -> typecheck -> MIR lower -> LLVM codegen -> runtime call/reply.
  </verify>
  <done>
    Service definitions compile to native binaries. The receive loop dispatches on type_tags. Counter.start spawns the service. Counter.get_count makes a synchronous call and gets the correct reply. Counter.reset sends an asynchronous cast. Job module is registered in STDLIB_MODULES for Plan 04.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` (full workspace) succeeds
2. `cargo test` (full workspace) passes
3. A Counter service compiles and runs, producing correct output for start + get_count
4. snow_service_call and snow_service_reply are linked and called at runtime
5. The service loop correctly dispatches call and cast messages by type_tag
</verification>

<success_criteria>
- Service definitions compile through the full pipeline (parse -> typecheck -> MIR -> LLVM -> native)
- Synchronous calls block and receive the correct typed reply
- Asynchronous casts are fire-and-forget
- The service loop runs as an actor with cooperative scheduling (yields on receive)
- Runtime functions for call/reply work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/09-concurrency-standard-library/09-03-SUMMARY.md`
</output>
