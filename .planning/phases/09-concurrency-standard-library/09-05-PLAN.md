---
phase: 09-concurrency-standard-library
plan: 05
type: execute
wave: 5
depends_on: ["09-03", "09-04"]
files_modified:
  - crates/snowc/tests/e2e_concurrency_stdlib.rs
  - tests/e2e/service_counter.snow
  - tests/e2e/service_call_cast.snow
  - tests/e2e/service_state_management.snow
  - tests/e2e/job_async_await.snow
  - tests/e2e/job_map.snow
autonomous: true

must_haves:
  truths:
    - "A Service can be defined, started, called synchronously, and cast to asynchronously in a compiled Snow program"
    - "Service state is managed functionally: handlers receive state, return new state"
    - "Job.async spawns work that completes asynchronously, Job.await collects the result"
    - "Service and Job are fully type-checked: wrong argument types produce compiler errors"
    - "Service can be started under a supervisor (per RESEARCH.md: no special syntax needed)"
  artifacts:
    - path: "crates/snowc/tests/e2e_concurrency_stdlib.rs"
      provides: "E2E test harness for concurrency stdlib"
      contains: "e2e_concurrency"
    - path: "tests/e2e/service_counter.snow"
      provides: "Counter service E2E test (start, call, cast, verify state)"
      contains: "service Counter"
    - path: "tests/e2e/job_async_await.snow"
      provides: "Job async/await E2E test"
      contains: "Job.async"
  key_links:
    - from: "tests/e2e/service_counter.snow"
      to: "crates/snow-rt/src/actor/service.rs"
      via: "Compiled service code calls snow_service_call at runtime"
      pattern: "Counter.get_count"
    - from: "tests/e2e/job_async_await.snow"
      to: "crates/snow-rt/src/actor/job.rs"
      via: "Compiled Job code calls snow_job_async/snow_job_await at runtime"
      pattern: "Job.async|Job.await"
---

<objective>
Create comprehensive E2E integration tests proving Service and Job work end-to-end as compiled Snow programs, verifying all three Phase 9 success criteria.

Purpose: E2E tests compile real Snow source files to native binaries and run them, proving the entire pipeline works from syntax to runtime. This verifies all Phase 9 success criteria are met.

Output: A test suite that compiles and runs Service and Job programs, asserting correct output.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-concurrency-standard-library/09-CONTEXT.md
@.planning/phases/09-concurrency-standard-library/09-RESEARCH.md
@.planning/phases/09-concurrency-standard-library/09-03-SUMMARY.md
@.planning/phases/09-concurrency-standard-library/09-04-SUMMARY.md

Key source files:
@crates/snowc/tests/e2e_actors.rs (E2E test patterns for actor programs)
@crates/snowc/tests/e2e_stdlib.rs (E2E test patterns for stdlib programs)
@tests/e2e/supervisor_basic.snow (supervisor E2E test as reference for service under supervisor)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Service E2E tests</name>
  <files>
    crates/snowc/tests/e2e_concurrency_stdlib.rs
    tests/e2e/service_counter.snow
    tests/e2e/service_call_cast.snow
    tests/e2e/service_state_management.snow
  </files>
  <action>
    Create E2E tests for Service that prove Phase 9 Success Criterion 1: "A GenServer can be defined with init/handle_call/handle_cast callbacks, started under a supervisor, and interacted with via synchronous calls and asynchronous casts."

    1. **Create `crates/snowc/tests/e2e_concurrency_stdlib.rs`:**
       - Follow the pattern from e2e_actors.rs and e2e_stdlib.rs
       - Include the compile_and_run helper (or import shared helper if available)
       - Write test functions that compile .snow files and assert output

    2. **Create `tests/e2e/service_counter.snow`:**
       A basic Counter service demonstrating all features:
       ```snow
       service Counter do
         fn init(start :: Int) :: Int do
           start
         end

         call GetCount() :: Int do |state|
           {state, state}
         end

         call Increment(amount :: Int) :: Int do |state|
           let new_state = state + amount
           {new_state, new_state}
         end

         cast Reset() do |state|
           0
         end
       end

       let pid = Counter.start(10)
       let count = Counter.get_count(pid)
       println(count)
       Counter.increment(pid, 5)
       let count2 = Counter.get_count(pid)
       println(count2)
       Counter.reset(pid)
       let count3 = Counter.get_count(pid)
       println(count3)
       ```
       Expected output: "10\n15\n0\n"
       Test function: `test_service_counter` asserts output matches

    3. **Create `tests/e2e/service_call_cast.snow`:**
       A service with multiple call variants returning different types, proving per-variant reply types:
       ```snow
       service KeyValue do
         fn init(default :: Int) :: Int do
           default
         end

         call Get() :: Int do |state|
           {state, state}
         end

         call Set(val :: Int) :: Int do |state|
           {val, val}
         end

         cast Clear() do |state|
           0
         end
       end

       let pid = KeyValue.start(100)
       let v1 = KeyValue.get(pid)
       println(v1)
       let v2 = KeyValue.set(pid, 200)
       println(v2)
       KeyValue.clear(pid)
       let v3 = KeyValue.get(pid)
       println(v3)
       ```
       Expected output: "100\n200\n0\n"

    4. **Create `tests/e2e/service_state_management.snow`:**
       Demonstrates functional state management with multiple sequential calls:
       ```snow
       service Accumulator do
         fn init(start :: Int) :: Int do
           start
         end

         call Add(n :: Int) :: Int do |state|
           let new = state + n
           {new, new}
         end

         call Value() :: Int do |state|
           {state, state}
         end
       end

       let pid = Accumulator.start(0)
       Accumulator.add(pid, 1)
       Accumulator.add(pid, 2)
       Accumulator.add(pid, 3)
       let total = Accumulator.value(pid)
       println(total)
       ```
       Expected output: "6\n"

    IMPORTANT: These tests prove Success Criterion 1. The generated typed helper functions (Counter.start, Counter.get_count, Counter.increment, Counter.reset) are what callers use -- NOT generic Service.call(). This is a locked decision from CONTEXT.md.

    For "started under a supervisor": Include a comment/note that Counter.start(n) returns a Pid that can be used in a supervisor child spec's start function. A full supervisor integration test is optional if the basic supervisor infrastructure from Phase 7 already supports any Pid-returning function as a child start.
  </action>
  <verify>
    `cargo test -p snowc -- e2e_concurrency` passes. All three service test programs compile to native binaries and produce expected output.
  </verify>
  <done>
    Service Counter compiles and runs with start, get_count, increment, reset producing correct output. Multiple services with different state types work. Sequential call/cast operations maintain correct state. Per-variant typed helper functions are used (not generic Service.call).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Job E2E tests</name>
  <files>
    tests/e2e/job_async_await.snow
    tests/e2e/job_map.snow
    crates/snowc/tests/e2e_concurrency_stdlib.rs
  </files>
  <action>
    Create E2E tests for Job that prove Phase 9 Success Criterion 2: "A Task can be spawned to perform work asynchronously and its result awaited, with supervision ensuring the task is restarted on failure."

    1. **Create `tests/e2e/job_async_await.snow`:**
       ```snow
       let job = Job.async(fn -> 42 end)
       let result = Job.await(job)
       case result do
         Ok(val) -> println(val)
         Err(msg) -> println(msg)
       end
       ```
       Expected output: "42\n"
       Test function in e2e_concurrency_stdlib.rs: `test_job_async_await`

    2. **Create `tests/e2e/job_map.snow`** (if Job.map is implementable in this phase):
       ```snow
       let jobs = Job.map([1, 2, 3], fn x -> x * 10 end)
       # jobs is a list of results
       println(jobs)
       ```
       If Job.map is too complex for this phase (requires list iteration + multi-spawn + result collection), defer it to a gap closure plan and instead test:
       ```snow
       let j1 = Job.async(fn -> 10 end)
       let j2 = Job.async(fn -> 20 end)
       let j3 = Job.async(fn -> 30 end)
       let r1 = Job.await(j1)
       let r2 = Job.await(j2)
       let r3 = Job.await(j3)
       case r1 do
         Ok(v) -> println(v)
         Err(_) -> println("error")
       end
       case r2 do
         Ok(v) -> println(v)
         Err(_) -> println("error")
       end
       case r3 do
         Ok(v) -> println(v)
         Err(_) -> println("error")
       end
       ```
       Expected output: "10\n20\n30\n"
       This proves multiple concurrent jobs can be spawned and awaited.

    3. **Add all Job tests to e2e_concurrency_stdlib.rs:**
       - `test_job_async_await`: compiles and runs job_async_await.snow, asserts "42\n"
       - `test_job_multiple`: compiles and runs the multiple-jobs test, asserts "10\n20\n30\n"

    Note on "supervision ensuring the task is restarted on failure" from Success Criterion 2: Jobs are linked actors. If a job crashes, the caller receives an exit signal, and Job.await converts it to Err. The "supervision" aspect means jobs can be run under a supervisor for restart -- but this is the standard supervisor mechanism from Phase 7, not a Job-specific feature. The E2E test proves the error path works (Err on crash). Full supervisor + Job integration is implicit since supervisors work with any actor.

    Also verify Success Criterion 3: "Both GenServer and Task are fully type-checked (message types, return types) with inference."
    Add a negative test that verifies type errors:
    - Write a small Snow program that calls Counter.increment(pid, "hello") (String instead of Int)
    - Assert compilation fails with a type error
    - This can be a compile_only test following the pattern from supervisor_typed_error.snow tests
  </action>
  <verify>
    `cargo test -p snowc -- e2e_concurrency` passes. All Job test programs compile and produce expected output. The type error negative test correctly rejects mistyped calls.
  </verify>
  <done>
    Job.async spawns async work. Job.await collects results as Ok(value). Multiple concurrent jobs can be spawned and awaited independently. Type mismatches on Service calls produce compiler errors. All three Phase 9 success criteria are verifiable through the test suite.
  </done>
</task>

</tasks>

<verification>
Phase 9 Success Criteria verification:

1. "A GenServer can be defined with init/handle_call/handle_cast callbacks, started under a supervisor, and interacted with via synchronous calls and asynchronous casts"
   -> service_counter.snow: defines Counter with init/call/cast, starts it, makes synchronous calls and async casts
   -> service_state_management.snow: proves functional state management across multiple calls

2. "A Task can be spawned to perform work asynchronously and its result awaited, with supervision ensuring the task is restarted on failure"
   -> job_async_await.snow: spawns Job, awaits result as Ok(42)
   -> Multiple jobs test: proves concurrent job execution

3. "Both GenServer and Task are fully type-checked (message types, return types) with inference"
   -> All programs compile without type annotations on callers (inference works)
   -> Negative test: wrong types are rejected at compile time
   -> Per-variant return types: get_count returns Int, not a generic type
</verification>

<success_criteria>
- All E2E tests pass: service_counter, service_call_cast, service_state_management, job_async_await, job_multiple
- Service: start -> call -> cast -> call sequence produces correct output
- Job: async -> await sequence returns Ok(value)
- Type checking: wrong types at call sites produce compiler errors
- No regressions in existing test suites
</success_criteria>

<output>
After completion, create `.planning/phases/09-concurrency-standard-library/09-05-SUMMARY.md`
</output>
