---
phase: 46-core-collection-operations
plan: 02
type: execute
wave: 2
depends_on: ["46-01"]
files_modified:
  - crates/snow-rt/src/string.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snowc/tests/e2e_stdlib.rs
  - tests/e2e/stdlib_string_split_join.snow
  - tests/e2e/stdlib_string_parse.snow
autonomous: true

must_haves:
  truths:
    - "User can split a string with String.split(s, delim) and get a List<String>"
    - "User can join a list of strings with String.join(list, sep) and get a String"
    - "User can parse a string to int with String.to_int(s) returning Some(n) or None"
    - "User can parse a string to float with String.to_float(s) returning Some(f) or None"
  artifacts:
    - path: "crates/snow-rt/src/string.rs"
      provides: "Runtime implementations for split, join, to_int, to_float"
      contains: "snow_string_split"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "String module type signatures for split, join, to_int, to_float"
      contains: "split"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Flat-prefixed type signatures for string_split, string_join, etc."
      contains: "string_split"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "map_builtin_name and known_functions entries for all 4 string operations"
      contains: "snow_string_split"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM external declarations for snow_string_split/join/to_int/to_float"
      contains: "snow_string_split"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "matching type signatures for module-qualified and flat-prefixed access"
      pattern: "string_split.*string_join.*string_to_int.*string_to_float"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "known_functions MIR types match LLVM external declarations"
      pattern: "snow_string_split"
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/string.rs"
      via: "LLVM external linkage to runtime C-ABI functions"
      pattern: "snow_string_split"
    - from: "crates/snow-rt/src/string.rs"
      to: "crates/snow-rt/src/option.rs"
      via: "to_int/to_float use alloc_option for Option return"
      pattern: "alloc_option"
    - from: "crates/snow-rt/src/string.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "split uses list_builder_new/push, join reads list elements"
      pattern: "snow_list_builder_new"
---

<objective>
Implement String.split, String.join, String.to_int, and String.to_float across the 4-layer stdlib pattern (typeck, MIR, codegen, runtime).

Purpose: Gives users essential string manipulation -- splitting/joining strings and parsing strings to numbers with safe Option returns.
Output: 4 working string operations with e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-core-collection-operations/46-RESEARCH.md
@.planning/phases/46-core-collection-operations/46-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement String runtime functions (split, join, to_int, to_float)</name>
  <files>
    crates/snow-rt/src/string.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
    Add `use crate::option::alloc_option;` and `use crate::collections::list::{snow_list_builder_new, snow_list_builder_push};` at the top of `string.rs`. Also need list helpers for reading list data in join -- check if `list_len` and `list_data` are pub. If not, use the same raw pointer arithmetic pattern (length at offset 0, data at offset 8+).

    Implement 4 runtime functions in `crates/snow-rt/src/string.rs`:

    a. `snow_string_split(s: *const SnowString, delim: *const SnowString) -> *mut u8`:
       - Get `text = (*s).as_str()` and `delimiter = (*delim).as_str()`
       - Split: `text.split(delimiter).collect::<Vec<&str>>()`
       - Allocate list: `snow_list_builder_new(parts.len() as i64)`
       - For each part: `snow_string_new(part.as_ptr(), part.len() as u64)` then `snow_list_builder_push(list, snow_str as u64)`
       - Return list pointer
       - Note: `snow_list_builder_new` and `snow_list_builder_push` are in `collections::list` -- verify they're public (`pub extern "C"`) so they can be called from string.rs

    b. `snow_string_join(list: *mut u8, sep: *const SnowString) -> *mut u8`:
       - Get separator: `(*sep).as_str()`
       - Read list length and data pointer (list layout: u64 length at offset 0, u64 elements starting at offset 8)
       - For each element in the list: cast u64 to `*const SnowString`, get `.as_str()`
       - Join: collect all &str into Vec, then `parts.join(separator)`
       - Allocate result: `snow_string_new(result.as_ptr(), result.len() as u64)`
       - Return as `*mut u8`

    c. `snow_string_to_int(s: *const SnowString) -> *mut u8`:
       - Get `text = (*s).as_str().trim()`
       - Parse: `text.parse::<i64>()`
       - On Ok(val): `alloc_option(0, val as u64 as *mut u8) as *mut u8` (Some)
       - On Err: `alloc_option(1, std::ptr::null_mut()) as *mut u8` (None)

    d. `snow_string_to_float(s: *const SnowString) -> *mut u8`:
       - Get `text = (*s).as_str().trim()`
       - Parse: `text.parse::<f64>()`
       - On Ok(val): `alloc_option(0, f64::to_bits(val) as *mut u8) as *mut u8` (Some)
         CRITICAL: Must use `f64::to_bits()` to store the float as its bit pattern in the u64 value field
       - On Err: `alloc_option(1, std::ptr::null_mut()) as *mut u8` (None)

    Add `pub use` re-exports for all 4 new functions in `crates/snow-rt/src/lib.rs` under the string section.

    Verify `cargo check -p snow-rt` passes.
  </action>
  <verify>Run `cargo check -p snow-rt` from the workspace root. Must compile with zero errors.</verify>
  <done>All 4 string runtime functions compile. split returns List<String> via list builder, join reads list elements as SnowString pointers, to_int/to_float return SnowOption with correct value encoding.</done>
</task>

<task type="auto">
  <name>Task 2: Register String operations in typeck, MIR lowering, and codegen</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
    **Layer 1 -- Typeck Module Map** (`infer.rs::stdlib_modules()`):
    In the String module section (where existing entries like "length", "slice", "contains" are):

    ```
    string_mod.insert("split".to_string(), Scheme::mono(
        Ty::fun(vec![Ty::string(), Ty::string()], Ty::list(Ty::string()))
    ));
    string_mod.insert("join".to_string(), Scheme::mono(
        Ty::fun(vec![Ty::list(Ty::string()), Ty::string()], Ty::string())
    ));
    string_mod.insert("to_int".to_string(), Scheme::mono(
        Ty::fun(vec![Ty::string()], Ty::option(Ty::int()))
    ));
    string_mod.insert("to_float".to_string(), Scheme::mono(
        Ty::fun(vec![Ty::string()], Ty::option(Ty::float()))
    ));
    ```

    These are all monomorphic (no type variables needed) -- String functions operate on concrete types.

    **Layer 2 -- Typeck Flat Env** (`builtins.rs::register_builtins()`):
    In the String functions section, add matching entries:
    ```
    env.insert("string_split".into(), Scheme::mono(Ty::fun(vec![Ty::string(), Ty::string()], Ty::list(Ty::string()))));
    env.insert("string_join".into(), Scheme::mono(Ty::fun(vec![Ty::list(Ty::string()), Ty::string()], Ty::string())));
    env.insert("string_to_int".into(), Scheme::mono(Ty::fun(vec![Ty::string()], Ty::option(Ty::int()))));
    env.insert("string_to_float".into(), Scheme::mono(Ty::fun(vec![Ty::string()], Ty::option(Ty::float()))));
    ```

    **Layer 3a -- MIR Name Mapping** (`lower.rs::map_builtin_name()`):
    ```
    "string_split" => "snow_string_split".to_string(),
    "string_join" => "snow_string_join".to_string(),
    "string_to_int" => "snow_string_to_int".to_string(),
    "string_to_float" => "snow_string_to_float".to_string(),
    ```

    **Layer 3b -- MIR Known Functions** (`lower.rs::new()` known_functions):
    All 4 functions take pointer args and return pointers (no closures involved):
    - split: `MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr))` -- (string, delim) -> list
    - join: `MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr))` -- (list, sep) -> string
    - to_int: `MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr))` -- (string) -> option
    - to_float: `MirType::FnPtr(vec![MirType::Ptr], Box::new(MirType::Ptr))` -- (string) -> option

    **Layer 4a -- LLVM Intrinsic Declarations** (`intrinsics.rs`):
    Add alongside existing string function declarations:
    - `snow_string_split`: `ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false)` -> returns ptr
    - `snow_string_join`: `ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false)` -> returns ptr
    - `snow_string_to_int`: `ptr_type.fn_type(&[ptr_type.into()], false)` -> returns ptr
    - `snow_string_to_float`: `ptr_type.fn_type(&[ptr_type.into()], false)` -> returns ptr

    Verify `cargo check` passes for the full workspace.
  </action>
  <verify>Run `cargo check` from the workspace root. Must compile with zero errors across all crates.</verify>
  <done>All 4 string operations registered across all 4 layers. No closure parameters (all are simple pointer-in pointer-out). Type signatures match between typeck module map, flat env, MIR known_functions, and LLVM declarations.</done>
</task>

<task type="auto">
  <name>Task 3: Add e2e tests for String split, join, to_int, to_float</name>
  <files>
    crates/snowc/tests/e2e_stdlib.rs
    tests/e2e/stdlib_string_split_join.snow
    tests/e2e/stdlib_string_parse.snow
  </files>
  <action>
    Create Snow test programs and e2e test functions.

    1. `tests/e2e/stdlib_string_split_join.snow`:
       ```snow
       let parts = String.split("hello,world,foo", ",")
       println("${List.length(parts)}")
       println(List.head(parts))
       let joined = String.join(parts, " - ")
       println(joined)
       let words = String.split("one two three", " ")
       let back = String.join(words, ",")
       println(back)
       ```
       Expected output: `3\nhello\nhello - world - foo\none,two,three`

    2. `tests/e2e/stdlib_string_parse.snow`:
       ```snow
       let a = String.to_int("42")
       let b = String.to_int("not a number")
       let c = String.to_float("3.14")
       let d = String.to_float("bad")
       case a do
         Some(n) -> println("${n}")
       | None -> println("none")
       end
       case b do
         Some(n) -> println("${n}")
       | None -> println("none")
       end
       case c do
         Some(f) -> println("${f}")
       | None -> println("none")
       end
       case d do
         Some(f) -> println("${f}")
       | None -> println("none")
       end
       let e = String.to_int("-100")
       case e do
         Some(n) -> println("${n}")
       | None -> println("none")
       end
       ```
       Expected output: `42\nnone\n3.14\nnone\n-100`
       Note: The Float display for 3.14 must match whatever Snow's existing float-to-string formatting produces. Check existing tests to see if Snow prints "3.14" or "3.140000" etc. Adjust expected output accordingly.

    3. Add e2e test functions in `crates/snowc/tests/e2e_stdlib.rs`:
       ```rust
       #[test]
       fn test_string_split_join() {
           run_snow_test("tests/e2e/stdlib_string_split_join.snow", "3\nhello\nhello - world - foo\none,two,three\n");
       }
       #[test]
       fn test_string_parse() {
           run_snow_test("tests/e2e/stdlib_string_parse.snow", "42\nnone\n3.14\nnone\n-100\n");
       }
       ```

    Adjust the float output format in expected results based on what Snow actually produces for float display. Run the test, check actual output, and fix expected string if needed.

    Run the full e2e test suite to confirm all new tests pass and no regressions.
  </action>
  <verify>Run `cargo test -p snowc --test e2e_stdlib` from the workspace root. All new string tests pass. All existing stdlib tests still pass (zero regressions).</verify>
  <done>2 e2e Snow test programs created. 2 Rust e2e test functions added. String.split/join roundtrip correctly. String.to_int/to_float parse valid input to Some and invalid input to None. Float bit-pattern encoding works correctly through Option unwrap.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes for full workspace (all 4 layers consistent)
2. `cargo test -p snowc --test e2e_stdlib` passes (all e2e tests including new ones)
3. No regressions in existing test suite
4. String.split -> String.join roundtrip preserves data
5. String.to_int/to_float return None for invalid input, Some for valid input
</verification>

<success_criteria>
- String.split("a,b,c", ",") produces a 3-element list of strings
- String.join(["a", "b"], ",") produces "a,b"
- String.to_int("42") returns Some(42), String.to_int("bad") returns None
- String.to_float("3.14") returns Some(3.14), String.to_float("bad") returns None
- Float values correctly use f64::to_bits for SnowOption storage
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/46-core-collection-operations/46-02-SUMMARY.md`
</output>
