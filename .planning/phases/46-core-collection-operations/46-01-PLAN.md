---
phase: 46-core-collection-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/option.rs
  - crates/snow-rt/src/env.rs
  - crates/snow-rt/src/lib.rs
  - crates/snow-rt/src/collections/list.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snowc/tests/e2e_stdlib.rs
  - tests/e2e/stdlib_list_sort.snow
  - tests/e2e/stdlib_list_find.snow
  - tests/e2e/stdlib_list_any_all.snow
  - tests/e2e/stdlib_list_contains.snow
autonomous: true

must_haves:
  truths:
    - "User can sort a list with List.sort(list, cmp_fn) and get a correctly ordered new list"
    - "User can find an element with List.find(list, pred) and get Some(elem) or None"
    - "User can test with List.any(list, pred) and List.all(list, pred) getting Bool results"
    - "User can test membership with List.contains(list, elem) getting Bool result"
  artifacts:
    - path: "crates/snow-rt/src/option.rs"
      provides: "Shared SnowOption struct and alloc_option helper"
      contains: "pub fn alloc_option"
    - path: "crates/snow-rt/src/collections/list.rs"
      provides: "Runtime implementations for sort, find, any, all, contains"
      contains: "snow_list_sort"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "List module type signatures for sort, find, any, all, contains"
      contains: "sort"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Flat-prefixed type signatures for list_sort, list_find, etc."
      contains: "list_sort"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "map_builtin_name and known_functions entries for all 5 list operations"
      contains: "snow_list_sort"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM external declarations for snow_list_sort/find/any/all/contains"
      contains: "snow_list_sort"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "matching type signatures for module-qualified and flat-prefixed access"
      pattern: "list_sort.*list_find.*list_any.*list_all.*list_contains"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "known_functions MIR types match LLVM external declarations"
      pattern: "snow_list_sort"
    - from: "crates/snow-codegen/src/codegen/intrinsics.rs"
      to: "crates/snow-rt/src/collections/list.rs"
      via: "LLVM external linkage to runtime C-ABI functions"
      pattern: "snow_list_sort"
    - from: "crates/snow-rt/src/collections/list.rs"
      to: "crates/snow-rt/src/option.rs"
      via: "list_find uses alloc_option for Option<T> return"
      pattern: "alloc_option"
---

<objective>
Implement List.sort, List.find, List.any, List.all, and List.contains across the 4-layer stdlib pattern (typeck, MIR, codegen, runtime), including extracting SnowOption to a shared module.

Purpose: Gives users essential list manipulation operations -- sorting with custom comparators, searching/filtering with predicates, and membership testing.
Output: 5 working list operations with e2e tests, shared SnowOption module.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-core-collection-operations/46-RESEARCH.md
@.planning/phases/43-math-stdlib/43-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract SnowOption to shared module and implement List runtime functions</name>
  <files>
    crates/snow-rt/src/option.rs
    crates/snow-rt/src/env.rs
    crates/snow-rt/src/lib.rs
    crates/snow-rt/src/collections/list.rs
    crates/snow-rt/src/http/server.rs
  </files>
  <action>
    1. Create `crates/snow-rt/src/option.rs` with the `SnowOption` struct and `alloc_option` function extracted from `env.rs`:
       - `#[repr(C)] pub struct SnowOption { pub tag: u8, pub value: *mut u8 }`
       - `pub fn alloc_option(tag: u8, value: *mut u8) -> *mut SnowOption` using `snow_gc_alloc_actor`
       - Import `snow_gc_alloc_actor` from `crate::gc`

    2. Update `crates/snow-rt/src/env.rs` to remove the local `SnowOption` and `alloc_option`, replacing with `use crate::option::{SnowOption, alloc_option};`

    3. Update `crates/snow-rt/src/http/server.rs` to import from `crate::option` instead of its local `alloc_option` copy. Remove the local `alloc_option` function.

    4. Update `crates/snow-rt/src/lib.rs`:
       - Add `pub mod option;`
       - Add `pub use option::{SnowOption, alloc_option};`

    5. Implement 5 runtime functions in `crates/snow-rt/src/collections/list.rs`:
       - Add `use crate::option::alloc_option;` at the top

       a. `snow_list_sort(list: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> *mut u8`:
          - Copy elements to Vec, sort_by using comparator (BareFn if env_ptr is null, ClosureFn otherwise)
          - BareFn: `unsafe extern "C" fn(u64, u64) -> i64`
          - ClosureFn: `unsafe extern "C" fn(*mut u8, u64, u64) -> i64`
          - Convert i64 result to Ordering (< 0 = Less, 0 = Equal, > 0 = Greater)
          - Allocate new list with sorted elements via alloc_list, return it
          - If len <= 1, return a copy (not the original, to preserve immutability semantics)

       b. `snow_list_find(list: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> *mut u8`:
          - Linear scan calling predicate (BareFn: `fn(u64) -> u64`, ClosureFn: `fn(*mut u8, u64) -> u64`)
          - On first nonzero result: return `alloc_option(0, elem as *mut u8) as *mut u8` (Some)
          - If no match: return `alloc_option(1, std::ptr::null_mut()) as *mut u8` (None)

       c. `snow_list_any(list: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> i8`:
          - Linear scan calling predicate, return 1 (true) on first nonzero, 0 (false) if none match
          - Same BareFn/ClosureFn pattern as find

       d. `snow_list_all(list: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> i8`:
          - Linear scan calling predicate, return 0 (false) on first zero, 1 (true) if all match

       e. `snow_list_contains(list: *mut u8, elem: u64) -> i8`:
          - NO closure parameter. Simple linear scan comparing each element with raw u64 equality
          - Return 1 if found, 0 if not

    6. Add `pub use` re-exports for all 5 new functions in `crates/snow-rt/src/lib.rs`.

    Verify `cargo check -p snow-rt` passes after all changes.
  </action>
  <verify>Run `cargo check -p snow-rt` from the workspace root. Must compile with zero errors.</verify>
  <done>SnowOption extracted to shared module. All 5 list runtime functions compile. Existing code in env.rs and http/server.rs still compiles using shared SnowOption.</done>
</task>

<task type="auto">
  <name>Task 2: Register List operations in typeck, MIR lowering, and codegen</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
    **Layer 1 -- Typeck Module Map** (`infer.rs::stdlib_modules()`):
    In the List module section (where existing entries like "map", "filter", "reduce" are):

    ```
    // Comparator: fn(T, T) -> Int
    let t_t_to_int = Ty::fun(vec![t.clone(), t.clone()], Ty::int());
    // Predicate: fn(T) -> Bool  (reuse existing t_to_bool if available, or create)
    let t_to_bool = Ty::fun(vec![t.clone()], Ty::bool());

    list_mod.insert("sort".to_string(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t_t_to_int], list_t.clone()) });
    list_mod.insert("find".to_string(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t_to_bool.clone()], Ty::option(t.clone())) });
    list_mod.insert("any".to_string(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t_to_bool.clone()], Ty::bool()) });
    list_mod.insert("all".to_string(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t_to_bool.clone()], Ty::bool()) });
    list_mod.insert("contains".to_string(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t.clone()], Ty::bool()) });
    ```

    Use the existing `t_var` (TyVar(91000)) and `t`, `list_t` variables already defined in the List module section.

    **Layer 2 -- Typeck Flat Env** (`builtins.rs::register_builtins()`):
    In the List functions section, add matching entries with same types as above:
    ```
    env.insert("list_sort".into(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t_t_to_int], list_t.clone()) });
    env.insert("list_find".into(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t_to_bool.clone()], Ty::option(t.clone())) });
    env.insert("list_any".into(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t_to_bool.clone()], Ty::bool()) });
    env.insert("list_all".into(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t_to_bool.clone()], Ty::bool()) });
    env.insert("list_contains".into(), Scheme { vars: vec![t_var], ty: Ty::fun(vec![list_t.clone(), t.clone()], Ty::bool()) });
    ```

    Create the helper types (t_t_to_int, t_to_bool) using the same t_var/t/list_t variables already in scope in builtins.rs's List section.

    **Layer 3a -- MIR Name Mapping** (`lower.rs::map_builtin_name()`):
    ```
    "list_sort" => "snow_list_sort".to_string(),
    "list_find" => "snow_list_find".to_string(),
    "list_any" => "snow_list_any".to_string(),
    "list_all" => "snow_list_all".to_string(),
    "list_contains" => "snow_list_contains".to_string(),
    ```

    **Layer 3b -- MIR Known Functions** (`lower.rs::new()` known_functions):
    - sort: closure param (fn_ptr + env_ptr split) -> returns Ptr
      `MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr))`
    - find: closure param -> returns Ptr (SnowOption)
      `MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::Ptr))`
    - any: closure param -> returns I8 (Bool)
      `MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::I8))`
    - all: closure param -> returns I8 (Bool)
      `MirType::FnPtr(vec![MirType::Ptr, MirType::Ptr, MirType::Ptr], Box::new(MirType::I8))`
    - contains: NO closure, just (list, elem) -> returns I8 (Bool)
      `MirType::FnPtr(vec![MirType::Ptr, MirType::I64], Box::new(MirType::I8))`

    **Layer 4a -- LLVM Intrinsic Declarations** (`intrinsics.rs`):
    Add alongside existing list function declarations:
    - `snow_list_sort`: `ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false)` -> returns ptr
    - `snow_list_find`: `ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false)` -> returns ptr
    - `snow_list_any`: `i8_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false)` -> returns i8
    - `snow_list_all`: `i8_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false)` -> returns i8
    - `snow_list_contains`: `i8_type.fn_type(&[ptr_type.into(), i64_type.into()], false)` -> returns i8

    For any/all/contains that return i8: check what `i8_type` variable is available in intrinsics.rs. If not, use `context.i8_type()`.

    Verify `cargo check` passes for the full workspace after all changes.
  </action>
  <verify>Run `cargo check` from the workspace root. Must compile with zero errors across all crates.</verify>
  <done>All 5 list operations registered across all 4 layers. Type signatures match between typeck module map, flat env, MIR known_functions, and LLVM declarations. Closure params correctly split into (fn_ptr, env_ptr) in MIR/LLVM layers.</done>
</task>

<task type="auto">
  <name>Task 3: Add e2e tests for all List collection operations</name>
  <files>
    crates/snowc/tests/e2e_stdlib.rs
    tests/e2e/stdlib_list_sort.snow
    tests/e2e/stdlib_list_find.snow
    tests/e2e/stdlib_list_any_all.snow
    tests/e2e/stdlib_list_contains.snow
  </files>
  <action>
    Create Snow test programs and e2e test functions following the established pattern from existing stdlib tests.

    **Important Snow syntax reminders:**
    - Functions use `fn name(args) do ... end` or `fn name(args) -> expr end`
    - Lambdas use `fn(args) -> expr end`
    - Print with `println(...)`
    - String interpolation: `"${expr}"`
    - No semicolons, no curly braces for blocks
    - Pattern matching: `case expr do Some(x) -> ... | None -> ... end`

    1. `tests/e2e/stdlib_list_sort.snow`:
       ```snow
       let nums = [3, 1, 4, 1, 5, 9, 2, 6]
       let sorted = List.sort(nums, fn(a, b) -> a - b end)
       let first = List.head(sorted)
       let last_sorted = List.sort(nums, fn(a, b) -> b - a end)
       let first_desc = List.head(last_sorted)
       println("${first}")
       println("${first_desc}")
       println("${List.length(sorted)}")
       ```
       Expected output: `1\n9\n8` (ascending first=1, descending first=9, length preserved=8)

    2. `tests/e2e/stdlib_list_find.snow`:
       ```snow
       let nums = [1, 2, 3, 4, 5]
       let found = List.find(nums, fn(x) -> x > 3 end)
       let not_found = List.find(nums, fn(x) -> x > 10 end)
       case found do
         Some(v) -> println("found ${v}")
       | None -> println("none")
       end
       case not_found do
         Some(v) -> println("found ${v}")
       | None -> println("none")
       end
       ```
       Expected output: `found 4\nnone`

    3. `tests/e2e/stdlib_list_any_all.snow`:
       ```snow
       let nums = [1, 2, 3, 4, 5]
       let has_even = List.any(nums, fn(x) -> x % 2 == 0 end)
       let all_pos = List.all(nums, fn(x) -> x > 0 end)
       let all_even = List.all(nums, fn(x) -> x % 2 == 0 end)
       let none_neg = List.any(nums, fn(x) -> x < 0 end)
       println("${has_even}")
       println("${all_pos}")
       println("${all_even}")
       println("${none_neg}")
       ```
       Expected output: `true\ntrue\nfalse\nfalse`

    4. `tests/e2e/stdlib_list_contains.snow`:
       ```snow
       let nums = [10, 20, 30, 40]
       println("${List.contains(nums, 20)}")
       println("${List.contains(nums, 50)}")
       let empty = []
       println("${List.contains(empty, 1)}")
       ```
       Expected output: `true\nfalse\nfalse`

    5. Add e2e test functions in `crates/snowc/tests/e2e_stdlib.rs` following the existing pattern:
       ```rust
       #[test]
       fn test_list_sort() {
           run_snow_test("tests/e2e/stdlib_list_sort.snow", "1\n9\n8\n");
       }
       #[test]
       fn test_list_find() {
           run_snow_test("tests/e2e/stdlib_list_find.snow", "found 4\nnone\n");
       }
       #[test]
       fn test_list_any_all() {
           run_snow_test("tests/e2e/stdlib_list_any_all.snow", "true\ntrue\nfalse\nfalse\n");
       }
       #[test]
       fn test_list_contains() {
           run_snow_test("tests/e2e/stdlib_list_contains.snow", "true\nfalse\nfalse\n");
       }
       ```

    Check the existing test helper function name in e2e_stdlib.rs -- it may be `run_snow_test`, `run_test`, or something else. Use whatever is already established.

    Run the full e2e test suite to confirm all new tests pass and no regressions.
  </action>
  <verify>Run `cargo test -p snowc --test e2e_stdlib` from the workspace root. All new list tests pass. All existing stdlib tests still pass (zero regressions).</verify>
  <done>4 e2e Snow test programs created. 4 Rust e2e test functions added. All List.sort, List.find, List.any/all, List.contains operations work end-to-end from Snow source through compilation to correct output.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes for full workspace (all 4 layers consistent)
2. `cargo test -p snow-rt` passes (runtime unit tests, if any exist for new functions)
3. `cargo test -p snowc --test e2e_stdlib` passes (all e2e tests including new ones)
4. No regressions in existing test suite
</verification>

<success_criteria>
- List.sort correctly sorts with ascending and descending comparators
- List.find returns Some(first_match) or None
- List.any returns true on first predicate match, false otherwise
- List.all returns false on first predicate failure, true otherwise
- List.contains returns true/false for raw element equality
- SnowOption is shared across list.rs, env.rs, and http/server.rs
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/46-core-collection-operations/46-01-SUMMARY.md`
</output>
