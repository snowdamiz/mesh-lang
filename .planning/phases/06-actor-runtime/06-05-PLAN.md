---
phase: 06-actor-runtime
plan: 05
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03", "06-04"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/types.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-codegen/src/codegen/types.rs
autonomous: true

must_haves:
  truths:
    - "Actor blocks lower to MIR as recursive loop functions with receive"
    - "spawn/send/receive/self/link expressions generate correct LLVM IR calling runtime extern C functions"
    - "The compiler inserts reduction check calls at function call sites and loop back-edges"
    - "Pid is represented as i64 at the LLVM level (u64 at runtime, types are compile-time only)"
    - "Actor terminate callbacks compile to function pointers and are registered on the process at spawn time"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "AST-to-MIR lowering for actor expressions including terminate callback"
      contains: "ActorSpawn\\|ActorSend\\|ActorReceive\\|terminate_callback"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "LLVM IR generation for actor MIR nodes including terminate callback registration"
      contains: "ActorSpawn\\|ActorSend\\|snow_actor\\|terminate"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "Runtime function declarations for actor operations including snow_actor_set_terminate"
      contains: "snow_actor_spawn\\|snow_actor_send\\|snow_actor_receive\\|snow_reduction_check\\|snow_actor_set_terminate"
  key_links:
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "Actor codegen calls declared runtime intrinsics"
      pattern: "snow_actor_spawn\\|snow_actor_send\\|snow_actor_set_terminate"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "Generated LLVM IR calls extern C runtime functions at link time"
      pattern: "snow_actor"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "Lowering produces ActorSpawn/Send/Receive/Self/Link MIR nodes with terminate callback"
      pattern: "MirExpr::Actor"
---

<objective>
Implement the full code generation pipeline for actor operations: AST-to-MIR lowering for actor constructs (including terminate callbacks), LLVM IR generation that calls the snow-rt extern "C" functions, and compiler instrumentation for reduction counting (yield point insertion at function calls and loop back-edges).

Purpose: This is the critical integration plan that connects the compiler frontend (Plan 02, 04) with the runtime backend (Plan 01, 03). After this plan, the compiler can emit native code that spawns actors, sends messages, performs receive with pattern matching, and registers terminate callbacks for cleanup before termination.

Output: Complete codegen for actor primitives including terminate callback registration. Reduction check insertion. A Snow program with actors compiles to LLVM IR that calls the runtime.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@.planning/phases/06-actor-runtime/06-01-SUMMARY.md
@.planning/phases/06-actor-runtime/06-02-SUMMARY.md
@.planning/phases/06-actor-runtime/06-03-SUMMARY.md
@.planning/phases/06-actor-runtime/06-04-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/types.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-codegen/src/codegen/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: AST-to-MIR lowering for actor constructs, terminate callback, and Pid type resolution</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/mir/types.rs
  </files>
  <action>
**MIR lowering (lower.rs):**

Add lowering for each actor AST node to its MIR equivalent:

1. **ActorDef -> MirFunction**: Lower an actor block to a MIR function:
   - The actor function takes state parameters and runs a loop: receive message, pattern match, recursive self-call with new state.
   - The name is the actor's identifier (e.g., "CounterActor")
   - Lower the receive block inside the actor body to MirExpr::ActorReceive
   - The recursive call (actor calling itself with new state) lowers to a normal MirExpr::Call (tail call to self with updated state -- effectively an infinite loop)
   - The actor function should be registered in the MIR module's function list
   - **Terminate callback (per user locked decision):** If the actor block contains a TERMINATE_CLAUSE (via `ActorDef::terminate_clause()`), lower it to a separate MIR function. This function takes two parameters: `state_ptr: *const u8` (the actor's current state) and `reason_ptr: *const u8` (serialized exit reason). The terminate function body is the lowered contents of the terminate clause. Store a reference to this MIR function in the ActorSpawn's `terminate_callback` field.

2. **SpawnExpr -> MirExpr::ActorSpawn**: Lower spawn(fn, args):
   - `func`: Lower the function reference to MirExpr
   - `args`: Lower each argument to MirExpr
   - `priority`: Extract from syntax (default 0 = Normal). If syntax provides `:high` -> 1, `:low` -> 2.
   - `terminate_callback`: If the actor being spawned has a terminate clause (resolved from the ActorDef), include a reference to the terminate callback MIR function. Otherwise None.
   - `ty`: MirType::Pid(Some(Box::new(message_type))) where message_type comes from the type checker's inferred type for the Pid

3. **SendExpr -> MirExpr::ActorSend**: Lower send(pid, msg):
   - `target`: Lower pid expression
   - `message`: Lower message expression
   - `ty`: MirType::Unit (fire-and-forget)

4. **ReceiveExpr -> MirExpr::ActorReceive**: Lower receive block:
   - `arms`: Lower each receive arm's pattern and body to MirMatchArm (reuse existing pattern lowering from Phase 5)
   - `timeout_ms`: If after clause present, lower timeout expression
   - `timeout_body`: If after clause present, lower timeout body expression
   - `ty`: The shared return type of all arms

5. **SelfExpr -> MirExpr::ActorSelf**: Lower self():
   - `ty`: MirType::Pid(Some(Box::new(message_type))) from type checker

6. **LinkExpr -> MirExpr::ActorLink**: Lower link(pid):
   - `target`: Lower pid expression
   - `ty`: MirType::Unit

**Type resolution (types.rs):**

Update `resolve_type()` to handle Pid:
- `Ty::Con(TyCon { name: "Pid" })` (untyped) -> `MirType::Pid(None)`
- `Ty::App(Ty::Con(TyCon { name: "Pid" }), [M])` -> `MirType::Pid(Some(Box::new(resolve_type(M))))`

Add MirType::Pid to the Display impl and any other trait impls that match on MirType.
  </action>
  <verify>
`cargo build -p snow-codegen` compiles.
`cargo test -p snow-codegen` passes (existing MIR lowering tests still work).
Write a test that lowers a simple actor program AST (with and without terminate clause) to MIR and verifies the MIR contains ActorSpawn/ActorSend/ActorReceive nodes, and that terminate_callback is Some when the actor has a terminate clause.
  </verify>
  <done>Actor AST nodes lower to MIR correctly. Actor blocks become MIR functions with receive. Terminate clauses lower to separate MIR callback functions referenced by ActorSpawn. Pid type resolves to MirType::Pid. All existing MIR lowering tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: LLVM codegen for actor primitives, terminate callback registration, and reduction check instrumentation</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-codegen/src/codegen/types.rs
  </files>
  <action>
**Intrinsics (intrinsics.rs):**

Declare the actor runtime functions as LLVM external function declarations:

```rust
// void snow_rt_init_actor(i32 num_schedulers)
fn declare_snow_rt_init_actor(...)

// i64 snow_actor_spawn(i8* fn_ptr, i8* args, i64 args_size, i8 priority)
fn declare_snow_actor_spawn(...)

// void snow_actor_send(i64 target_pid, i8* msg, i64 msg_size)
fn declare_snow_actor_send(...)

// i8* snow_actor_receive(i64 timeout_ms)
fn declare_snow_actor_receive(...)

// i64 snow_actor_self()
fn declare_snow_actor_self(...)

// void snow_actor_link(i64 other_pid)
fn declare_snow_actor_link(...)

// void snow_reduction_check()
fn declare_snow_reduction_check(...)

// void snow_actor_set_terminate(i64 pid, i8* callback_fn_ptr)
// Per user locked decision: registers a terminate callback on a process.
// Called immediately after spawn when the actor has a terminate clause.
fn declare_snow_actor_set_terminate(...)
```

Follow the existing pattern in intrinsics.rs for declaring runtime functions (snow_gc_alloc, snow_print, etc.).

**Types (codegen/types.rs):**

Update `llvm_type()` to handle MirType::Pid:
- `MirType::Pid(_)` -> `i64` (Pid is u64/i64 at runtime, type parameter is compile-time only per research decision)

**Expression codegen (expr.rs):**

Add codegen for each actor MIR expression:

1. **MirExpr::ActorSpawn**: Generate LLVM IR to call `snow_actor_spawn`:
   - Compile the function argument to get a function pointer (bitcast to i8*)
   - Serialize the args: allocate a buffer on the stack, write arg values into it (for now: a simple layout of raw bytes)
   - Call `snow_actor_spawn(fn_ptr, args_ptr, args_size, priority)`
   - Result is i64 (the PID)
   - **Terminate callback registration (per user locked decision):** If `terminate_callback` is Some, immediately after spawn:
     1. Compile the terminate callback MIR function reference to get a function pointer
     2. Call `snow_actor_set_terminate(pid, callback_fn_ptr)` where pid is the return value from snow_actor_spawn
     This registers the cleanup function on the process so the runtime invokes it before exit.

2. **MirExpr::ActorSend**: Generate LLVM IR to call `snow_actor_send`:
   - Compile target expression (must produce i64 PID)
   - Compile message expression, serialize to bytes (alloca buffer, write value)
   - Call `snow_actor_send(target_pid, msg_ptr, msg_size)`
   - Returns void (Unit)

3. **MirExpr::ActorReceive**: Generate LLVM IR for receive:
   - Call `snow_actor_receive(timeout_ms)` to get a message pointer
   - If null and timeout: jump to timeout body block
   - If non-null: deserialize message from bytes, then use the existing pattern match codegen to dispatch to the matching arm
   - The receive pattern match reuses the decision tree infrastructure from Phase 5 Plan 03/04

4. **MirExpr::ActorSelf**: Generate LLVM IR to call `snow_actor_self()`:
   - Call `snow_actor_self()`, returns i64

5. **MirExpr::ActorLink**: Generate LLVM IR to call `snow_actor_link(target_pid)`:
   - Compile target to i64
   - Call `snow_actor_link(target_pid)`

**Reduction check instrumentation:**

This is critical for preemptive scheduling (per user locked decision: reduction counting BEAM-style).

In the expression codegen, insert calls to `snow_reduction_check()` at:

1. **Every function call site**: After generating the call instruction for MirExpr::Call and MirExpr::ClosureCall, emit a call to `snow_reduction_check()`. This matches the BEAM's approach of counting reductions at call sites.

2. **Loop back-edges**: Since Snow doesn't have explicit loops (it's functional), loops happen through recursive function calls. The function call instrumentation above handles this. However, if there are any explicit loop constructs in MIR (like the actor's receive-loop), insert a reduction check at the loop back-edge.

The `snow_reduction_check()` call is lightweight (decrement counter, branch on zero), so inserting it at every call site has minimal overhead. LLVM's optimizer can inline it.

**Main function wrapping:**

Update the main function codegen to:
1. Call `snow_rt_init_actor(0)` at the start (0 = auto-detect thread count)
2. The main function body runs as the "init" actor (per research: snow_main runs as the init actor)
3. This means the existing `snow_rt_init()` call should be replaced (or augmented) with `snow_rt_init_actor()` which also initializes the GC

Write tests:
- Compile a simple program with spawn and verify LLVM IR contains call to @snow_actor_spawn
- Compile a program with send and verify call to @snow_actor_send
- Compile an actor with terminate clause and verify LLVM IR contains call to @snow_actor_set_terminate after @snow_actor_spawn
- Verify reduction_check calls appear in LLVM IR at function call sites
- Verify MirType::Pid maps to i64 in LLVM
  </action>
  <verify>
`cargo test -p snow-codegen` passes all tests.
`cargo test --workspace` passes.
Verify via LLVM IR dump that actor programs produce correct extern function calls.
Verify that an actor with a terminate clause generates a snow_actor_set_terminate call in the IR.
  </verify>
  <done>LLVM codegen generates correct calls to snow_actor_spawn/send/receive/self/link. Terminate callbacks compile to function pointers and are registered via snow_actor_set_terminate after spawn. Reduction checks inserted at every function call site. Pid maps to i64 at LLVM level. Main function initializes actor runtime. All tests pass.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-codegen` passes all tests
- `cargo test --workspace` passes (no regressions)
- LLVM IR dump of an actor program shows correct runtime function calls
- LLVM IR dump of an actor with terminate clause shows snow_actor_set_terminate call
- Reduction check calls appear at function call sites in generated IR
- Pid is i64 in LLVM IR
</verification>

<success_criteria>
1. Actor blocks lower to MIR functions with ActorReceive
2. Terminate clauses lower to separate callback functions and are referenced by ActorSpawn
3. spawn/send/receive/self/link generate correct LLVM IR calls to runtime
4. snow_actor_set_terminate() called after spawn for actors with terminate clauses
5. snow_reduction_check() inserted at every function call site for preemptive scheduling
6. Main function wraps with snow_rt_init_actor() call
7. Pid type maps to i64 at LLVM level
8. Existing sequential programs still compile correctly (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-05-SUMMARY.md`
</output>
