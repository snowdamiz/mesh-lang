---
phase: 06-actor-runtime
plan: 05
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03", "06-04"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/types.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-codegen/src/codegen/types.rs
autonomous: true

must_haves:
  truths:
    - "Actor blocks lower to MIR as recursive loop functions with receive"
    - "spawn/send/receive/self/link expressions generate correct LLVM IR calling runtime extern C functions"
    - "The compiler inserts reduction check calls at function call sites and loop back-edges"
    - "Pid is represented as i64 at the LLVM level (u64 at runtime, types are compile-time only)"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "AST-to-MIR lowering for actor expressions"
      contains: "ActorSpawn\\|ActorSend\\|ActorReceive"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "LLVM IR generation for actor MIR nodes"
      contains: "ActorSpawn\\|ActorSend\\|snow_actor"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "Runtime function declarations for actor operations"
      contains: "snow_actor_spawn\\|snow_actor_send\\|snow_actor_receive\\|snow_reduction_check"
  key_links:
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "Actor codegen calls declared runtime intrinsics"
      pattern: "snow_actor_spawn\\|snow_actor_send"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-rt/src/actor/mod.rs"
      via: "Generated LLVM IR calls extern C runtime functions at link time"
      pattern: "snow_actor"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "Lowering produces ActorSpawn/Send/Receive/Self/Link MIR nodes"
      pattern: "MirExpr::Actor"
---

<objective>
Implement the full code generation pipeline for actor operations: AST-to-MIR lowering for actor constructs, LLVM IR generation that calls the snow-rt extern "C" functions, and compiler instrumentation for reduction counting (yield point insertion at function calls and loop back-edges).

Purpose: This is the critical integration plan that connects the compiler frontend (Plan 02, 04) with the runtime backend (Plan 01, 03). After this plan, the compiler can emit native code that spawns actors, sends messages, and performs receive with pattern matching.

Output: Complete codegen for actor primitives. Reduction check insertion. A Snow program with actors compiles to LLVM IR that calls the runtime.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@.planning/phases/06-actor-runtime/06-01-SUMMARY.md
@.planning/phases/06-actor-runtime/06-02-SUMMARY.md
@.planning/phases/06-actor-runtime/06-03-SUMMARY.md
@.planning/phases/06-actor-runtime/06-04-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/types.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-codegen/src/codegen/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: AST-to-MIR lowering for actor constructs and Pid type resolution</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/mir/types.rs
  </files>
  <action>
**MIR lowering (lower.rs):**

Add lowering for each actor AST node to its MIR equivalent:

1. **ActorDef -> MirFunction**: Lower an actor block to a MIR function:
   - The actor function takes state parameters and runs a loop: receive message, pattern match, recursive self-call with new state.
   - The name is the actor's identifier (e.g., "CounterActor")
   - Lower the receive block inside the actor body to MirExpr::ActorReceive
   - The recursive call (actor calling itself with new state) lowers to a normal MirExpr::Call (tail call to self with updated state -- effectively an infinite loop)
   - The actor function should be registered in the MIR module's function list

2. **SpawnExpr -> MirExpr::ActorSpawn**: Lower spawn(fn, args):
   - `func`: Lower the function reference to MirExpr
   - `args`: Lower each argument to MirExpr
   - `priority`: Extract from syntax (default 0 = Normal). If syntax provides `:high` -> 1, `:low` -> 2.
   - `ty`: MirType::Pid(Some(Box::new(message_type))) where message_type comes from the type checker's inferred type for the Pid

3. **SendExpr -> MirExpr::ActorSend**: Lower send(pid, msg):
   - `target`: Lower pid expression
   - `message`: Lower message expression
   - `ty`: MirType::Unit (fire-and-forget)

4. **ReceiveExpr -> MirExpr::ActorReceive**: Lower receive block:
   - `arms`: Lower each receive arm's pattern and body to MirMatchArm (reuse existing pattern lowering from Phase 5)
   - `timeout_ms`: If after clause present, lower timeout expression
   - `timeout_body`: If after clause present, lower timeout body expression
   - `ty`: The shared return type of all arms

5. **SelfExpr -> MirExpr::ActorSelf**: Lower self():
   - `ty`: MirType::Pid(Some(Box::new(message_type))) from type checker

6. **LinkExpr -> MirExpr::ActorLink**: Lower link(pid):
   - `target`: Lower pid expression
   - `ty`: MirType::Unit

**Type resolution (types.rs):**

Update `resolve_type()` to handle Pid:
- `Ty::Con(TyCon { name: "Pid" })` (untyped) -> `MirType::Pid(None)`
- `Ty::App(Ty::Con(TyCon { name: "Pid" }), [M])` -> `MirType::Pid(Some(Box::new(resolve_type(M))))`

Add MirType::Pid to the Display impl and any other trait impls that match on MirType.
  </action>
  <verify>
`cargo build -p snow-codegen` compiles.
`cargo test -p snow-codegen` passes (existing MIR lowering tests still work).
Write a test that lowers a simple actor program AST to MIR and verifies the MIR contains ActorSpawn/ActorSend/ActorReceive nodes.
  </verify>
  <done>Actor AST nodes lower to MIR correctly. Actor blocks become MIR functions with receive. Pid type resolves to MirType::Pid. All existing MIR lowering tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: LLVM codegen for actor primitives and reduction check instrumentation</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-codegen/src/codegen/types.rs
  </files>
  <action>
**Intrinsics (intrinsics.rs):**

Declare the actor runtime functions as LLVM external function declarations:

```rust
// void snow_rt_init_actor(i32 num_schedulers)
fn declare_snow_rt_init_actor(...)

// i64 snow_actor_spawn(i8* fn_ptr, i8* args, i64 args_size, i8 priority)
fn declare_snow_actor_spawn(...)

// void snow_actor_send(i64 target_pid, i8* msg, i64 msg_size)
fn declare_snow_actor_send(...)

// i8* snow_actor_receive(i64 timeout_ms)
fn declare_snow_actor_receive(...)

// i64 snow_actor_self()
fn declare_snow_actor_self(...)

// void snow_actor_link(i64 other_pid)
fn declare_snow_actor_link(...)

// void snow_reduction_check()
fn declare_snow_reduction_check(...)
```

Follow the existing pattern in intrinsics.rs for declaring runtime functions (snow_gc_alloc, snow_print, etc.).

**Types (codegen/types.rs):**

Update `llvm_type()` to handle MirType::Pid:
- `MirType::Pid(_)` -> `i64` (Pid is u64/i64 at runtime, type parameter is compile-time only per research decision)

**Expression codegen (expr.rs):**

Add codegen for each actor MIR expression:

1. **MirExpr::ActorSpawn**: Generate LLVM IR to call `snow_actor_spawn`:
   - Compile the function argument to get a function pointer (bitcast to i8*)
   - Serialize the args: allocate a buffer on the stack, write arg values into it (for now: a simple layout of raw bytes)
   - Call `snow_actor_spawn(fn_ptr, args_ptr, args_size, priority)`
   - Result is i64 (the PID)

2. **MirExpr::ActorSend**: Generate LLVM IR to call `snow_actor_send`:
   - Compile target expression (must produce i64 PID)
   - Compile message expression, serialize to bytes (alloca buffer, write value)
   - Call `snow_actor_send(target_pid, msg_ptr, msg_size)`
   - Returns void (Unit)

3. **MirExpr::ActorReceive**: Generate LLVM IR for receive:
   - Call `snow_actor_receive(timeout_ms)` to get a message pointer
   - If null and timeout: jump to timeout body block
   - If non-null: deserialize message from bytes, then use the existing pattern match codegen to dispatch to the matching arm
   - The receive pattern match reuses the decision tree infrastructure from Phase 5 Plan 03/04

4. **MirExpr::ActorSelf**: Generate LLVM IR to call `snow_actor_self()`:
   - Call `snow_actor_self()`, returns i64

5. **MirExpr::ActorLink**: Generate LLVM IR to call `snow_actor_link(target_pid)`:
   - Compile target to i64
   - Call `snow_actor_link(target_pid)`

**Reduction check instrumentation:**

This is critical for preemptive scheduling (per user locked decision: reduction counting BEAM-style).

In the expression codegen, insert calls to `snow_reduction_check()` at:

1. **Every function call site**: After generating the call instruction for MirExpr::Call and MirExpr::ClosureCall, emit a call to `snow_reduction_check()`. This matches the BEAM's approach of counting reductions at call sites.

2. **Loop back-edges**: Since Snow doesn't have explicit loops (it's functional), loops happen through recursive function calls. The function call instrumentation above handles this. However, if there are any explicit loop constructs in MIR (like the actor's receive-loop), insert a reduction check at the loop back-edge.

The `snow_reduction_check()` call is lightweight (decrement counter, branch on zero), so inserting it at every call site has minimal overhead. LLVM's optimizer can inline it.

**Main function wrapping:**

Update the main function codegen to:
1. Call `snow_rt_init_actor(0)` at the start (0 = auto-detect thread count)
2. The main function body runs as the "init" actor (per research: snow_main runs as the init actor)
3. This means the existing `snow_rt_init()` call should be replaced (or augmented) with `snow_rt_init_actor()` which also initializes the GC

Write tests:
- Compile a simple program with spawn and verify LLVM IR contains call to @snow_actor_spawn
- Compile a program with send and verify call to @snow_actor_send
- Verify reduction_check calls appear in LLVM IR at function call sites
- Verify MirType::Pid maps to i64 in LLVM
  </action>
  <verify>
`cargo test -p snow-codegen` passes all tests.
`cargo test --workspace` passes.
Verify via LLVM IR dump that actor programs produce correct extern function calls.
  </verify>
  <done>LLVM codegen generates correct calls to snow_actor_spawn/send/receive/self/link. Reduction checks inserted at every function call site. Pid maps to i64 at LLVM level. Main function initializes actor runtime. All tests pass.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-codegen` passes all tests
- `cargo test --workspace` passes (no regressions)
- LLVM IR dump of an actor program shows correct runtime function calls
- Reduction check calls appear at function call sites in generated IR
- Pid is i64 in LLVM IR
</verification>

<success_criteria>
1. Actor blocks lower to MIR functions with ActorReceive
2. spawn/send/receive/self/link generate correct LLVM IR calls to runtime
3. snow_reduction_check() inserted at every function call site for preemptive scheduling
4. Main function wraps with snow_rt_init_actor() call
5. Pid type maps to i64 at LLVM level
6. Existing sequential programs still compile correctly (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-05-SUMMARY.md`
</output>
