---
phase: 06-actor-runtime
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/snow-rt/src/actor/process.rs
  - crates/snow-rt/src/actor/mailbox.rs
  - crates/snow-rt/src/actor/heap.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/actor/scheduler.rs
  - crates/snow-rt/src/gc.rs
autonomous: true

must_haves:
  truths:
    - "Each actor has its own heap for memory allocation (no global arena contention)"
    - "Messages are deep-copied between actor heaps on send"
    - "An actor's mailbox delivers messages in strict FIFO order"
    - "An actor calling receive with no matching messages blocks until a message arrives"
    - "A blocked actor does not consume CPU (yields to scheduler, re-enqueued on message arrival)"
  artifacts:
    - path: "crates/snow-rt/src/actor/heap.rs"
      provides: "Per-actor bump allocator heap"
      contains: "pub struct ActorHeap"
    - path: "crates/snow-rt/src/actor/mailbox.rs"
      provides: "FIFO mailbox with typed messages"
      contains: "pub struct Mailbox"
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "snow_actor_send and snow_actor_receive extern C functions"
      contains: "snow_actor_send"
  key_links:
    - from: "crates/snow-rt/src/actor/mod.rs"
      to: "crates/snow-rt/src/actor/mailbox.rs"
      via: "snow_actor_send pushes to target's mailbox, snow_actor_receive pops from own mailbox"
      pattern: "mailbox.*push\\|pop\\|send\\|receive"
    - from: "crates/snow-rt/src/actor/mod.rs"
      to: "crates/snow-rt/src/actor/scheduler.rs"
      via: "receive wakes blocked actor by re-enqueuing into scheduler"
      pattern: "wake\\|enqueue\\|ready"
    - from: "crates/snow-rt/src/actor/heap.rs"
      to: "crates/snow-rt/src/gc.rs"
      via: "Per-actor heap replaces global arena for actor-allocated memory"
      pattern: "ActorHeap.*alloc"
---

<objective>
Implement per-actor heaps and FIFO message passing. Each actor gets its own bump allocator heap. Messages are deep-copied between heaps on send. The mailbox is a lock-protected VecDeque with strict FIFO ordering. Receive blocks (yields to scheduler when no message available, woken when message arrives).

Purpose: Actor isolation requires per-actor heaps (a crashed actor's memory can be reclaimed without affecting others). Message passing must deep-copy data between heaps to maintain isolation. The receive-with-blocking mechanism is what makes actors reactive rather than busy-polling.

Output: ActorHeap (per-actor bump allocator), Mailbox (FIFO queue), snow_actor_send/snow_actor_receive extern "C" functions, scheduler integration for blocking/waking.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@.planning/phases/06-actor-runtime/06-01-SUMMARY.md
@crates/snow-rt/src/gc.rs
@crates/snow-rt/src/actor/process.rs
@crates/snow-rt/src/actor/scheduler.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Per-actor heap and message deep-copy</name>
  <files>
    crates/snow-rt/src/actor/heap.rs
    crates/snow-rt/src/actor/process.rs
    crates/snow-rt/src/gc.rs
  </files>
  <action>
Create `crates/snow-rt/src/actor/heap.rs`:

1. **ActorHeap** struct: A per-actor bump allocator. Same algorithm as the existing global Arena in gc.rs, but owned by a single actor.
   - `pages: Vec<Vec<u8>>` -- owned page list
   - `offset: usize` -- current bump pointer
   - `total_allocated: usize` -- tracking for GC trigger (future)
   - `fn new() -> Self` -- creates with initial 64KB page
   - `fn alloc(&mut self, size: usize, align: usize) -> *mut u8` -- bump allocate (same logic as Arena::alloc)
   - `fn reset(&mut self)` -- drops all pages, starts fresh (for GC or actor cleanup)
   - `fn total_bytes(&self) -> usize` -- returns total allocated

2. **MessageBuffer**: A serialized message representation for cross-heap copying.
   - `pub struct MessageBuffer { pub data: Vec<u8>, pub type_tag: u64 }`
   - `fn deep_copy_to_heap(&self, heap: &mut ActorHeap) -> *mut u8` -- allocates space in target heap, copies data bytes, returns pointer to the copy.
   - The type_tag identifies the runtime type for pattern matching dispatch. For Phase 6, use a simple tag scheme: tag = hash of the type name. The Pid<M> type checker (Plan 04) will generate these tags at compile time.

3. Update the **Message** struct in process.rs to use MessageBuffer instead of the placeholder:
   - `pub struct Message { pub buffer: MessageBuffer }`

4. Update `crates/snow-rt/src/gc.rs`:
   - Add `#[no_mangle] pub extern "C" fn snow_gc_alloc_actor(size: u64, align: u64) -> *mut u8` -- allocates from the current actor's heap (reads thread-local CURRENT_PROCESS to find the actor's heap). Falls back to global arena if no actor context (for non-actor code).
   - Keep the existing `snow_gc_alloc` working for backward compatibility (Phase 5 programs without actors still use global arena).

Write tests:
- ActorHeap allocates and returns valid pointers
- ActorHeap respects alignment
- MessageBuffer deep_copy_to_heap copies data correctly
- ActorHeap::reset reclaims all memory
  </action>
  <verify>
`cargo test -p snow-rt` passes all tests including new heap and message tests.
`cargo build -p snow-rt` compiles successfully.
  </verify>
  <done>Per-actor heap exists as ActorHeap with bump allocation. MessageBuffer supports deep-copy between heaps. snow_gc_alloc_actor allocates from current actor's heap. Global arena still works for non-actor code.</done>
</task>

<task type="auto">
  <name>Task 2: FIFO mailbox and send/receive with scheduler blocking</name>
  <files>
    crates/snow-rt/src/actor/mailbox.rs
    crates/snow-rt/src/actor/mod.rs
    crates/snow-rt/src/actor/scheduler.rs
    crates/snow-rt/src/actor/process.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
Create `crates/snow-rt/src/actor/mailbox.rs`:

1. **Mailbox** struct:
   - `queue: VecDeque<Message>` -- strict FIFO (per user decision: messages processed in arrival order)
   - `lock: parking_lot::Mutex<()>` or use a `Mutex<VecDeque<Message>>` directly for thread-safe access
   - `fn push(&self, msg: Message)` -- append to back of queue
   - `fn pop(&self) -> Option<Message>` -- remove from front of queue
   - `fn is_empty(&self) -> bool`
   - `fn len(&self) -> usize`

2. Update **Process** in process.rs:
   - Replace the placeholder mailbox field with `pub mailbox: Arc<Mailbox>` (Arc because both the sending actor's thread and the owning actor's thread need access)
   - Add `pub heap: ActorHeap` field

3. Implement `snow_actor_send` in `actor/mod.rs`:
   ```
   #[no_mangle]
   pub extern "C" fn snow_actor_send(target_pid: u64, msg_ptr: *const u8, msg_size: u64)
   ```
   - Look up target Process by PID in the scheduler's process table
   - Create a MessageBuffer from the raw bytes (deep-copy: allocate new Vec<u8>, copy msg_size bytes from msg_ptr)
   - Push Message into target's mailbox
   - If target process state is Waiting (blocked on receive): change state to Ready, re-enqueue into scheduler (this is the wake mechanism)
   - Fire-and-forget: returns nothing (per discretion decision: send is fire-and-forget only)

4. Implement `snow_actor_receive` in `actor/mod.rs`:
   ```
   #[no_mangle]
   pub extern "C" fn snow_actor_receive(timeout_ms: i64) -> *const u8
   ```
   - Check current actor's mailbox (via thread-local CURRENT_PID -> process table lookup)
   - If mailbox has a message: pop it, deep-copy into actor's own heap, return pointer to the message data
   - If mailbox is empty:
     - If timeout_ms == 0: return null immediately (non-blocking check)
     - If timeout_ms > 0: set timer, change state to Waiting, yield to scheduler. When woken (either by message arrival or timeout), check again.
     - If timeout_ms < 0 (infinite): change state to Waiting, yield to scheduler. Woken only by message arrival.
   - The yield-on-empty is critical: a blocked actor must NOT spin. It yields via the thread-local Yielder (same mechanism as reduction_check), and the scheduler knows not to re-enqueue it until a message arrives (or timeout fires).

5. Update **Scheduler** in scheduler.rs:
   - Add `wake_process(pid: ProcessId)` method: looks up process, if state is Waiting, changes to Ready, pushes onto global queue.
   - The worker_loop should handle the case where a resumed coroutine yields due to receive-wait (process state = Waiting) differently from reduction-yield (state = Ready): do NOT re-enqueue Waiting processes.

6. Unmatched message handling (per discretion decision): crash the actor with ExitReason::Error("no matching receive clause"). This means if `snow_actor_receive` returns a message but the compiled match arms don't match, the actor panics. The codegen (Plan 05) will handle this by adding a default arm that calls snow_panic.

7. Update `crates/snow-rt/src/lib.rs`: re-export snow_actor_send, snow_actor_receive.

Write tests:
- Send a message to an actor, actor receives it (basic send/receive)
- Messages arrive in FIFO order (send 3 messages, receive them in order)
- Actor blocks on receive when mailbox is empty, wakes when message arrives
- Receive with timeout: returns null after timeout if no message
- Multiple actors sending to same target (concurrent send safety)
  </action>
  <verify>
`cargo test -p snow-rt` passes all tests.
Specifically verify:
- `test_send_receive_basic` -- message sent and received correctly
- `test_fifo_ordering` -- messages arrive in send order
- `test_receive_blocks_on_empty` -- actor yields and wakes on message
- `test_receive_timeout` -- null returned after timeout
- `test_concurrent_send` -- multiple senders to one receiver
All existing tests (GC, string, scheduler) still pass.
  </verify>
  <done>Mailbox delivers messages in strict FIFO order. snow_actor_send deep-copies messages and wakes blocked receivers. snow_actor_receive blocks (yields) on empty mailbox, wakes on message arrival or timeout. Per-actor heap integrated into Process. All verified by tests.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-rt` passes all old + new tests
- `cargo test --workspace` passes (no regressions)
- Send/receive between actors works correctly in multi-threaded scheduler
- Blocked actors do not consume CPU (they yield, not spin)
- FIFO ordering is maintained under concurrent sends
</verification>

<success_criteria>
1. Each actor has its own ActorHeap for memory allocation
2. Messages are deep-copied between actor heaps on send (no shared mutable state)
3. Mailbox is strict FIFO (per user locked decision)
4. Receive blocks when empty (yields to scheduler), wakes when message arrives
5. Receive supports timeout via timeout_ms parameter
6. snow_actor_send and snow_actor_receive exported as extern "C" functions
7. All tests pass including concurrent multi-actor send/receive scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-03-SUMMARY.md`
</output>
