---
phase: 06-actor-runtime
plan: 07
type: execute
wave: 5
depends_on: ["06-05", "06-06"]
files_modified:
  - crates/snowc/tests/e2e_actors.rs
  - tests/e2e/actors_basic.snow
  - tests/e2e/actors_messaging.snow
  - tests/e2e/actors_preemption.snow
  - tests/e2e/actors_linking.snow
  - tests/e2e/actors_typed_pid.snow
  - tests/e2e/actors_100k.snow
  - tests/e2e/actors_terminate.snow
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-rt/src/actor/scheduler.rs
autonomous: false

must_haves:
  truths:
    - "A Snow program can spawn 100,000 actors that hold state and respond to messages without crashing"
    - "Sending a wrongly-typed message to a typed Pid is rejected at compile time"
    - "An actor running an infinite computation does not prevent others from making progress"
    - "A receive block with pattern matching correctly dispatches messages to matching arms"
    - "When a linked actor crashes, the linked partner receives an exit signal"
    - "An actor with a terminate clause runs its cleanup logic before exiting"
  artifacts:
    - path: "crates/snowc/tests/e2e_actors.rs"
      provides: "End-to-end actor integration tests including terminate callback"
      contains: "actors_basic\\|actors_100k\\|actors_typed_pid\\|actors_terminate"
    - path: "tests/e2e/actors_100k.snow"
      provides: "100K actor benchmark program"
      contains: "spawn"
    - path: "tests/e2e/actors_typed_pid.snow"
      provides: "Typed Pid compile-time checking test"
      contains: "Pid"
    - path: "tests/e2e/actors_terminate.snow"
      provides: "Terminate callback E2E test"
      contains: "terminate"
  key_links:
    - from: "crates/snowc/tests/e2e_actors.rs"
      to: "crates/snowc/src/main.rs"
      via: "E2E tests invoke snowc build and run compiled binaries"
      pattern: "snowc.*build"
    - from: "tests/e2e/actors_100k.snow"
      to: "crates/snow-rt/src/actor/scheduler.rs"
      via: "100K benchmark exercises scheduler work-stealing and memory management"
      pattern: "spawn"
    - from: "tests/e2e/actors_terminate.snow"
      to: "crates/snow-rt/src/actor/scheduler.rs"
      via: "Terminate test exercises terminate callback invocation before exit"
      pattern: "terminate"
---

<objective>
End-to-end integration testing and bug fixing for the complete actor runtime. Write Snow programs that exercise all actor features (including terminate callbacks), compile them with snowc build, run the binaries, and verify correct output. Fix any integration issues discovered. Verify all Phase 6 success criteria.

Purpose: The previous plans built components in isolation (runtime, compiler frontend, type checker, codegen, linking). This plan integrates everything and verifies the full pipeline works end-to-end. It is the final gate before Phase 6 is complete.

Output: E2E test suite for actors (including terminate callback test), 100K actor benchmark, any integration bug fixes, verification of all success criteria.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@.planning/phases/06-actor-runtime/06-01-SUMMARY.md
@.planning/phases/06-actor-runtime/06-02-SUMMARY.md
@.planning/phases/06-actor-runtime/06-03-SUMMARY.md
@.planning/phases/06-actor-runtime/06-04-SUMMARY.md
@.planning/phases/06-actor-runtime/06-05-SUMMARY.md
@.planning/phases/06-actor-runtime/06-06-SUMMARY.md
@crates/snowc/tests/e2e.rs
@tests/e2e/comprehensive.snow
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write E2E actor test programs and integration test harness</name>
  <files>
    crates/snowc/tests/e2e_actors.rs
    tests/e2e/actors_basic.snow
    tests/e2e/actors_messaging.snow
    tests/e2e/actors_preemption.snow
    tests/e2e/actors_linking.snow
    tests/e2e/actors_typed_pid.snow
    tests/e2e/actors_100k.snow
    tests/e2e/actors_terminate.snow
  </files>
  <action>
Create `crates/snowc/tests/e2e_actors.rs` -- an E2E test harness following the existing pattern in `e2e.rs`. Each test:
1. Writes a .snow source file to a temp directory
2. Invokes `snowc build` to compile it
3. Runs the resulting binary
4. Asserts on stdout/stderr/exit code

**Test programs to create:**

1. `tests/e2e/actors_basic.snow` -- SC1: Basic actor spawning and messaging:
```snow
# Spawn a counter actor, send it increment messages, get the result
actor Counter(state :: Int) do
  receive do
    {:increment, amount} -> Counter(state + amount)
    {:get, sender} ->
      send(sender, state)
      Counter(state)
  end
end

def main() do
  let counter = spawn(Counter, 0)
  send(counter, {:increment, 10})
  send(counter, {:increment, 20})
  send(counter, {:increment, 12})
  send(counter, {:get, self()})
  receive do
    result -> println(int_to_string(result))
  end
end
```
Expected output: `42`

2. `tests/e2e/actors_messaging.snow` -- SC4: Receive with pattern matching:
```snow
# Test multiple message types and pattern dispatch
actor Greeter(name :: String) do
  receive do
    {:hello, sender} ->
      send(sender, "Hello, " ++ name ++ "!")
      Greeter(name)
    {:rename, new_name} ->
      Greeter(new_name)
  end
end

def main() do
  let g = spawn(Greeter, "World")
  send(g, {:hello, self()})
  receive do
    msg -> println(msg)
  end
  send(g, {:rename, "Snow"})
  send(g, {:hello, self()})
  receive do
    msg -> println(msg)
  end
end
```
Expected output:
```
Hello, World!
Hello, Snow!
```

3. `tests/e2e/actors_preemption.snow` -- SC3: Preemptive scheduling:
```snow
# An actor running an infinite computation does not prevent others from progress
actor Spinner() do
  # Tight loop -- should be preempted by reduction counting
  Spinner()
end

actor Reporter(count :: Int) do
  receive do
    :ping ->
      println("Reporter received ping " ++ int_to_string(count))
      Reporter(count + 1)
  end
end

def main() do
  let spinner = spawn(Spinner, ())
  let reporter = spawn(Reporter, 0)
  send(reporter, :ping)
  send(reporter, :ping)
  send(reporter, :ping)
  # Give time for messages to be processed
  # Reporter should respond despite Spinner running
  receive do
    _ -> ()
  after 1000 ->
    println("done")
  end
end
```
Expected: Reporter prints its ping messages despite Spinner running. The program completes without hanging.

4. `tests/e2e/actors_linking.snow` -- SC5: Process linking:
```snow
actor Crasher() do
  receive do
    :crash -> 1 / 0  # Deliberate crash
  end
end

actor Monitor() do
  receive do
    {:exit, pid, reason} ->
      println("Actor crashed: " ++ int_to_string(pid))
      Monitor()
  end
end

def main() do
  let m = spawn(Monitor, ())
  let c = spawn(Crasher, ())
  link(c)  # Link crasher to main
  send(c, :crash)
  receive do
    {:exit, pid, reason} ->
      println("Received exit signal")
  end
end
```
Expected: Prints "Received exit signal" (main receives exit from linked crasher).

5. `tests/e2e/actors_typed_pid.snow` -- SC2: Typed Pid compile-time checking:
Create two test programs:
- One that should COMPILE successfully (correct types)
- One that should FAIL compilation with type error E0014 (wrong message type sent to typed Pid)

The passing program:
```snow
actor IntReceiver(state :: Int) do
  receive do
    n :: Int -> IntReceiver(state + n)
  end
end

def main() do
  let pid :: Pid<Int> = spawn(IntReceiver, 0)
  send(pid, 42)  # OK: Int matches Pid<Int>
  println("typed send succeeded")
end
```

The failing program (separate test):
```snow
actor IntReceiver(state :: Int) do
  receive do
    n :: Int -> IntReceiver(state + n)
  end
end

def main() do
  let pid :: Pid<Int> = spawn(IntReceiver, 0)
  send(pid, "hello")  # ERROR: String sent to Pid<Int>
end
```
Assert: compilation fails with error containing "E0014" or "message type mismatch".

6. `tests/e2e/actors_100k.snow` -- SC1: 100K actor benchmark:
```snow
actor Worker(id :: Int) do
  receive do
    {:done, collector} ->
      send(collector, id)
  end
end

actor Collector(remaining :: Int) do
  receive do
    _ ->
      if remaining == 1 do
        println("All actors responded")
      else
        Collector(remaining - 1)
      end
  end
end

def main() do
  let n = 100000
  let collector = spawn(Collector, n)
  # Spawn 100K actors
  let i = 0
  # (use a recursive spawner since Snow doesn't have for loops)
  def spawn_workers(i :: Int, n :: Int, collector :: Pid) do
    if i < n do
      let w = spawn(Worker, i)
      send(w, {:done, collector})
      spawn_workers(i + 1, n, collector)
    end
  end
  spawn_workers(0, n, collector)
  # Wait for collector to finish
  receive do
    _ -> ()
  after 30000 ->
    println("Timeout")
  end
end
```
This test verifies 100K actors can be spawned and complete without crashing or exhausting memory. Expected output: "All actors responded" (within 30 seconds).

7. `tests/e2e/actors_terminate.snow` -- SC6: Terminate callback (per user locked decision):
```snow
# Test that terminate callbacks run before actor exit
actor Logger() do
  receive do
    msg -> println(msg)
    Logger()
  end
end

actor Worker(logger :: Pid) do
  receive do
    :quit -> ()  # Normal exit -- triggers terminate callback
  end

  terminate do
    # Cleanup logic that runs before full termination
    send(logger, "Worker cleanup executed")
  end
end

def main() do
  let logger = spawn(Logger, ())
  let w = spawn(Worker, logger)
  send(w, :quit)
  # Wait for logger to print the cleanup message
  receive do
    _ -> ()
  after 2000 ->
    println("done")
  end
end
```
Expected output: "Worker cleanup executed" (proving the terminate callback ran before the actor fully exited). The terminate block has access to the actor's state (logger pid) and can send final messages.

**E2E test harness (e2e_actors.rs):**

For each test, follow the pattern:
```rust
#[test]
fn test_actors_basic() {
    // compile .snow file with snowc build
    // run the binary
    // assert stdout contains expected output
}

#[test]
fn test_actors_typed_pid_error() {
    // compile the failing .snow file
    // assert compilation fails with E0014 error
}

#[test]
fn test_actors_terminate() {
    // compile actors_terminate.snow
    // run the binary
    // assert stdout contains "Worker cleanup executed"
}
```

Set a generous timeout (30s) for the 100K benchmark test. Set 5s timeout for other tests.
  </action>
  <verify>
`cargo test -p snowc --test e2e_actors` passes all tests.
The 100K benchmark completes within 30 seconds.
The typed Pid error test correctly catches E0014 at compile time.
The terminate callback test prints "Worker cleanup executed".
All existing e2e tests still pass: `cargo test -p snowc --test e2e`.
  </verify>
  <done>7 E2E test programs created covering all 6 success criteria (including terminate callback). Test harness compiles and runs all tests. 100K actor benchmark completes successfully. Typed Pid prevents wrong-type sends at compile time. Terminate callback runs before actor exit.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete actor runtime with M:N scheduler, typed message passing, preemptive scheduling, process linking, named registry, and terminate callbacks -- integrated into the Snow compiler and tested end-to-end.</what-built>
  <how-to-verify>
1. Run `cargo test --workspace` and verify all tests pass (should be 500+ tests)
2. Run `cargo test -p snowc --test e2e_actors` specifically to see actor E2E results
3. Try compiling and running a custom Snow program with actors:
   ```
   echo 'actor Pinger() do
     receive do
       {:ping, sender} ->
         send(sender, :pong)
         Pinger()
     end
   end

   def main() do
     let p = spawn(Pinger, ())
     send(p, {:ping, self()})
     receive do
       :pong -> println("Got pong!")
     end
   end' > /tmp/test_actor.snow
   cd /tmp && mkdir -p test_actor && cp test_actor.snow test_actor/main.snow
   snowc build test_actor/
   ./test_actor
   ```
   Expected: prints "Got pong!"
4. Verify that the 100K benchmark does not OOM or hang
5. Verify typing works: try sending wrong type to typed Pid and confirm compile error
6. Verify terminate callback: check that actors_terminate E2E test output contains "Worker cleanup executed"
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Phase 6 Success Criteria verification:

1. SC1 (100K actors): actors_100k.snow spawns 100K actors that hold state and respond to messages
2. SC2 (Typed Pid): actors_typed_pid.snow fails compilation when sending wrong type to Pid<Int>
3. SC3 (Preemption): actors_preemption.snow -- infinite-loop actor doesn't block others
4. SC4 (Receive pattern matching): actors_messaging.snow -- messages dispatched to correct arms
5. SC5 (Process linking): actors_linking.snow -- linked actor crash triggers exit signal
6. SC6 (Terminate callback): actors_terminate.snow -- terminate clause runs cleanup before exit

All 6 criteria verified by automated E2E tests + human verification.
</verification>

<success_criteria>
1. All E2E actor tests pass (actors_basic, actors_messaging, actors_preemption, actors_linking, actors_typed_pid, actors_100k, actors_terminate)
2. 100K actor benchmark completes within 30 seconds without OOM
3. Typed Pid rejects wrong-type sends at compile time
4. Preemptive scheduling prevents starvation
5. Process linking delivers exit signals on crash
6. Terminate callback runs cleanup logic before actor exit (per user locked decision)
7. All existing Phase 1-5 tests still pass (zero regressions)
8. Human verifies complete actor system works
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-07-SUMMARY.md`
</output>
