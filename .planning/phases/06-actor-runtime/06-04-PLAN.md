---
phase: 06-actor-runtime
plan: 04
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - crates/snow-typeck/src/ty.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/unify.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "Pid<M> is a valid type in the type system where M is the message type"
    - "Sending a message of wrong type to a typed Pid<M> is rejected at compile time"
    - "Untyped Pid (no type parameter) is allowed as an escape hatch"
    - "spawn() returns Pid<M> where M is inferred from the actor's receive type"
    - "self() returns Pid<M> typed to the current actor's message type"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Type inference for spawn, send, receive, self, link, actor blocks"
      contains: "infer_spawn\\|infer_actor\\|Pid"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Pid type constructor registration"
      contains: "Pid"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "Actor-specific type errors (wrong message type, etc.)"
      contains: "SendTypeMismatch\\|ActorType"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/unify.rs"
      via: "Unification of Pid<M> message types during send type checking"
      pattern: "unify.*Pid\\|message.*type"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "Pid type constructor resolved from builtins"
      pattern: "Pid.*TyCon\\|builtin"
---

<objective>
Add Pid<M> typed actor identity to the type checker. spawn() returns Pid<M>, send(pid, msg) validates message type M at compile time, receive blocks infer the actor's message type, self() returns the current actor's Pid<M>. Untyped Pid is permitted as an escape hatch with runtime type checking.

Purpose: Typed message passing is Snow's key differentiator from Erlang/Elixir. Sending a wrongly-typed message to an actor is caught at compile time, not at runtime. This plan implements the type checking rules that make this possible, using Pid<M> as a single-type-parameter generic (per discretion decision).

Output: Pid<M> type in the type system, inference rules for all actor expressions, compile-time send type validation, error messages for type mismatches.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-CONTEXT.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@.planning/phases/06-actor-runtime/06-02-SUMMARY.md
@crates/snow-typeck/src/ty.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/unify.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Pid type and add inference rules for actor expressions</name>
  <files>
    crates/snow-typeck/src/ty.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/unify.rs
  </files>
  <action>
**Type representation (ty.rs):**

No changes to the Ty enum itself -- Pid<M> is represented as `Ty::App(Box::new(Ty::Con(TyCon::new("Pid"))), vec![M])` using the existing generic application mechanism. Untyped Pid is `Ty::Con(TyCon::new("Pid"))` (no type arguments).

Add helper constructors in ty.rs:
```rust
impl Ty {
    pub fn pid(msg_type: Ty) -> Ty {
        Ty::App(Box::new(Ty::Con(TyCon::new("Pid"))), vec![msg_type])
    }
    pub fn untyped_pid() -> Ty {
        Ty::Con(TyCon::new("Pid"))
    }
}
```

**Builtins (builtins.rs):**

Register `Pid` as a known type constructor with arity 1 (like Option or Result). Add it alongside the existing builtin types:
- `"Pid"` with arity 0 (untyped) and arity 1 (typed `Pid<M>`)

The type checker should accept both `Pid` (untyped, arity 0) and `Pid<SomeType>` (typed, arity 1). This mirrors how Option works as both a type constructor and can be referenced without args.

**Unification (unify.rs):**

The existing unification should handle Pid<M> correctly since it's just a Ty::App. However, add a special case: unifying `Pid` (untyped, Ty::Con) with `Pid<M>` (typed, Ty::App) should succeed -- the untyped Pid accepts any message type. This is the escape hatch (per user locked decision).

Specifically: when unifying Ty::Con("Pid") with Ty::App(Ty::Con("Pid"), [M]), succeed without constraining M. And vice versa. This allows:
```snow
let typed_pid :: Pid<Int> = spawn(counter, 0)
let untyped :: Pid = typed_pid  # OK: typed -> untyped
```
But NOT the reverse without annotation (untyped -> typed requires explicit cast or annotation).

**Inference (infer.rs):**

Add inference for each actor AST node. Use the AST wrapper types from Plan 02.

1. **ActorDef**: An actor block defines a recursive function that:
   - Takes state parameter(s)
   - Has an implicit message type M derived from its receive block
   - Returns the same actor type (recursive self-call for state update)
   - Register the actor as a function in the environment: `actor_name :: (StateType) -> Never` (actors loop forever via recursive call)
   - The message type M is inferred from the patterns in the receive block

2. **SpawnExpr**: `spawn(actor_fn, initial_state)`:
   - Infer the type of actor_fn: should be a function type
   - The return type is `Pid<M>` where M is the actor's message type
   - Infer initial_state arguments and unify with actor function's parameter types

3. **SendExpr**: `send(pid, message)`:
   - Infer the type of pid: must be `Pid<M>` or untyped `Pid`
   - If typed `Pid<M>`: infer message type and unify with M. If mismatch, report SendTypeMismatch error.
   - If untyped `Pid`: accept any message type (runtime check per user decision)
   - Return type is Unit (fire-and-forget per discretion decision)

4. **ReceiveExpr**: The receive block is a pattern match on incoming messages:
   - Each arm has a pattern and body
   - Infer the message type from the union of all arm patterns
   - All arms must return the same type
   - If after clause present: infer timeout expression (must be Int), infer timeout body (must return same type as arms)
   - The overall receive expression type is the shared return type of all arms

5. **SelfExpr**: `self()`:
   - Returns `Pid<M>` where M is the current actor's message type
   - The current actor's message type must be available in the inference context (set when entering an actor block)
   - If called outside an actor block, report an error: "self() can only be called inside an actor block"

6. **LinkExpr**: `link(pid)`:
   - Infer pid type: must be Pid (typed or untyped)
   - Return type: Unit

Add a context field to the type inference state to track "currently inside actor block with message type M". This is needed for self() to know its return type.

Write type checking tests:
- spawn returns Pid<M> with correct M
- send to typed Pid with wrong type produces error
- send to untyped Pid with any type succeeds
- receive arms infer message type
- self() returns correct Pid type inside actor
- self() outside actor produces error
- Typed pid assignable to untyped pid
  </action>
  <verify>
`cargo test -p snow-typeck` passes all new + existing tests.
`cargo test --workspace` passes (no regressions).
  </verify>
  <done>Pid<M> registered as builtin type. spawn returns Pid<M>, send validates message type at compile time, receive infers message type from patterns, self() returns own Pid<M>. Untyped Pid is accepted as escape hatch. All verified by type checking tests.</done>
</task>

<task type="auto">
  <name>Task 2: Actor type errors and diagnostic messages</name>
  <files>
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/diagnostics.rs
  </files>
  <action>
**Error types (error.rs):**

Add new TypeError variants for actor-specific errors:

1. `SendTypeMismatch { expected: Ty, found: Ty, span: TextRange }` -- sending wrong message type to typed Pid
2. `SelfOutsideActor { span: TextRange }` -- self() called outside actor block
3. `SpawnNonFunction { found: Ty, span: TextRange }` -- spawn called with non-function argument
4. `ReceiveOutsideActor { span: TextRange }` -- receive used outside actor block (if we want to enforce this)

Assign error codes:
- E0014: SendTypeMismatch
- E0015: SelfOutsideActor
- E0016: SpawnNonFunction
- E0017: ReceiveOutsideActor (if applicable)

**Diagnostics (diagnostics.rs):**

Add ariadne-based rendering for each new error:

1. SendTypeMismatch:
   ```
   error[E0014]: message type mismatch
     --> file.snow:12:5
      |
   12 |     send(counter, "hello")
      |                   ^^^^^^^ expected Int, found String
      |
      = help: this Pid accepts messages of type Int
   ```

2. SelfOutsideActor:
   ```
   error[E0015]: self() used outside actor block
     --> file.snow:5:10
      |
    5 |     let me = self()
      |              ^^^^^^ self() is only available inside an actor block
   ```

3. SpawnNonFunction:
   ```
   error[E0016]: cannot spawn non-function
     --> file.snow:3:12
      |
    3 |     spawn(42, 0)
      |           ^^ expected a function, found Int
   ```

Follow the existing diagnostic pattern: use ariadne 0.6 with colorless config for deterministic snapshot output. Use the same render_diagnostic function pattern as existing errors.

Write snapshot tests for each error diagnostic output.
  </action>
  <verify>
`cargo test -p snow-typeck` passes all tests including new error diagnostic snapshots.
`cargo test --workspace` passes.
  </verify>
  <done>Actor-specific type errors defined with codes E0014-E0017. Ariadne diagnostic rendering produces clear error messages with source spans and help text. All verified by snapshot tests.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-typeck` passes all tests
- `cargo test --workspace` passes (no regressions)
- Type errors for actor constructs produce helpful diagnostic messages
- Pid<M> type checking prevents wrong-type sends at compile time
</verification>

<success_criteria>
1. Pid<M> is a valid type; Pid (untyped) is also valid
2. spawn() returns Pid<M> where M is inferred from actor's receive patterns
3. send(typed_pid, wrong_type) produces compile-time E0014 error
4. send(untyped_pid, any_type) succeeds (escape hatch)
5. self() returns Pid<M> inside actor, E0015 error outside
6. Error messages include source spans, expected/found types, and help text
7. All existing type checker tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-04-SUMMARY.md`
</output>
