---
phase: 06-actor-runtime
plan: 06
type: execute
wave: 4
depends_on: ["06-05"]
files_modified:
  - crates/snow-rt/src/actor/link.rs
  - crates/snow-rt/src/actor/registry.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/actor/process.rs
  - crates/snow-rt/src/actor/scheduler.rs
  - crates/snow-rt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "When a linked actor crashes, the linked partner receives an exit signal message"
    - "An actor can register itself with a name and be looked up by that name"
    - "link(pid) creates a bidirectional link between two actors"
    - "Normal exit does not propagate as a crash to linked processes (per discretion: silent cleanup)"
    - "Actor crash propagates exit reason to all linked processes"
    - "Terminate callback is invoked before exit propagation when set on a process"
  artifacts:
    - path: "crates/snow-rt/src/actor/link.rs"
      provides: "Link management and exit signal propagation"
      contains: "pub fn propagate_exit"
    - path: "crates/snow-rt/src/actor/registry.rs"
      provides: "Named process registration and lookup"
      contains: "pub fn register"
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "snow_actor_link, snow_actor_register, snow_actor_whereis, snow_actor_set_terminate extern C functions"
      contains: "snow_actor_set_terminate"
  key_links:
    - from: "crates/snow-rt/src/actor/link.rs"
      to: "crates/snow-rt/src/actor/scheduler.rs"
      via: "Exit propagation sends exit messages to linked processes and wakes them"
      pattern: "propagate.*exit\\|wake"
    - from: "crates/snow-rt/src/actor/registry.rs"
      to: "crates/snow-rt/src/actor/scheduler.rs"
      via: "Registry lookup returns PID from process table"
      pattern: "registry.*lookup\\|whereis"
    - from: "crates/snow-rt/src/actor/scheduler.rs"
      to: "crates/snow-rt/src/actor/process.rs"
      via: "Scheduler invokes terminate_callback on process before exit propagation"
      pattern: "terminate_callback"
---

<objective>
Implement process linking, named process registration, and terminate callback invocation. Linking creates bidirectional connections between actors: when one crashes, linked partners receive exit signals. Named registration allows actors to be looked up by name instead of PID. Terminate callbacks run before exit propagation per user locked decision.

Purpose: Process linking is a prerequisite for Phase 7 (supervision trees) and is required by the Phase 6 success criteria ("when a linked actor crashes, the linked partner receives an exit signal"). Named registration enables the `register(pid, :name)` pattern needed for global actor lookup (per user locked decision). Terminate callbacks fulfill the user locked decision that actors can define cleanup logic that runs before full termination.

Output: Bidirectional linking with exit signal propagation, named process registry with register/whereis, terminate callback invocation before exit, extern "C" functions for all operations.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@.planning/phases/06-actor-runtime/06-01-SUMMARY.md
@.planning/phases/06-actor-runtime/06-03-SUMMARY.md
@.planning/phases/06-actor-runtime/06-05-SUMMARY.md
@crates/snow-rt/src/actor/process.rs
@crates/snow-rt/src/actor/scheduler.rs
@crates/snow-rt/src/actor/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bidirectional process linking, terminate callback invocation, and exit signal propagation</name>
  <files>
    crates/snow-rt/src/actor/link.rs
    crates/snow-rt/src/actor/process.rs
    crates/snow-rt/src/actor/scheduler.rs
    crates/snow-rt/src/actor/mod.rs
  </files>
  <action>
Create `crates/snow-rt/src/actor/link.rs`:

1. **link(pid_a, pid_b)**: Create a bidirectional link between two processes:
   - Add pid_b to pid_a's links set
   - Add pid_a to pid_b's links set
   - Both operations must be atomic (lock both processes, or use the process table lock)

2. **unlink(pid_a, pid_b)**: Remove bidirectional link:
   - Remove pid_b from pid_a's links set
   - Remove pid_a from pid_b's links set

3. **propagate_exit(exiting_pid, reason: ExitReason)**: When an actor exits:
   - For each PID in the exiting actor's links set:
     - Send an exit signal message to the linked process: `{:exit, exiting_pid, reason}`
     - The exit signal is delivered as a special Message to the mailbox with a reserved type_tag (e.g., type_tag = u64::MAX for exit signals)
     - Wake the linked process if it's in Waiting state (so it can process the exit signal)
   - For Normal exit (per discretion decision: silent cleanup): send `{:exit, pid, :normal}` which linked processes ignore by default. Concretely: still deliver the message, but the default behavior is to NOT crash the linked process.
   - For Error/Killed exit: send `{:exit, pid, reason}` which by default causes the linked process to crash with the same reason (cascading failure)

4. Update **Process** in process.rs:
   - Change `links: Vec<ProcessId>` to `links: HashSet<ProcessId>` (for O(1) add/remove/contains)
   - Add `trap_exit: bool` field (default false). When true, exit signals are delivered as regular messages instead of causing crashes. This is needed for Phase 7 supervisors but the flag should exist now.

5. Update **Scheduler** in scheduler.rs:
   - When a process exits (in the worker_loop, after coroutine completes or panics):
     - **FIRST: Invoke terminate callback (per user locked decision).** Check if the process has a `terminate_callback` set (Option is Some). If so, call the terminate callback function pointer with the actor's current state pointer and a serialized exit reason. This runs the actor's cleanup logic (resource cleanup, final messages) BEFORE exit propagation. Wrap the callback invocation in `std::panic::catch_unwind` so a panicking terminate callback does not prevent exit propagation.
     - THEN: Call `propagate_exit(pid, exit_reason)` to notify linked processes
     - Remove process from process table
     - Clean up coroutine stack memory

6. Update `actor/mod.rs` with extern "C" functions:
   ```
   #[no_mangle]
   pub extern "C" fn snow_actor_link(other_pid: u64)
   ```
   - Gets current PID from thread-local
   - Calls link(current_pid, other_pid)

   ```
   #[no_mangle]
   pub extern "C" fn snow_actor_set_terminate(pid: u64, callback_fn_ptr: *const u8)
   ```
   - Looks up process by PID in the scheduler's process table
   - Sets process.terminate_callback = Some(unsafe { std::mem::transmute(callback_fn_ptr) })
   - This is called by compiled code immediately after spawn when an actor has a terminate clause

Handle actor panics: Wrap the actor coroutine entry in a `std::panic::catch_unwind`. If the actor panics:
- Set process state to Exited(Error(panic_message))
- Invoke terminate callback if set (with error reason) -- wrapped in its own catch_unwind
- Call propagate_exit with the error reason
- The actor's stack and heap are cleaned up

Write tests:
- Link two actors, crash one, verify the other receives exit signal
- Link two actors, normal exit of one, verify the other receives :normal exit (and doesn't crash)
- Unlink two actors, crash one, verify the other does NOT receive exit signal
- Chain linking: A links B, B links C, C crashes -> B receives signal, B crashes -> A receives signal
- trap_exit: actor with trap_exit=true receives exit as regular message
- **Terminate callback: spawn an actor with terminate_callback set, exit the actor, verify the callback was invoked (use a shared AtomicBool to prove callback ran)**
- **Terminate callback on crash: spawn actor with terminate_callback, crash it, verify callback runs before exit propagation**
- **Terminate callback panic safety: set a terminate_callback that panics, verify exit propagation still happens**
  </action>
  <verify>
`cargo test -p snow-rt` passes all tests.
Specifically:
- `test_link_crash_propagation` -- linked actor receives exit signal on crash
- `test_normal_exit_silent` -- normal exit delivers :normal, doesn't crash linked
- `test_unlink` -- unlinked actors don't receive signals
- `test_cascading_exit` -- exit cascades through link chains
- `test_trap_exit` -- trap_exit converts signals to messages
- `test_terminate_callback_on_exit` -- terminate callback runs on normal exit
- `test_terminate_callback_on_crash` -- terminate callback runs before exit propagation on crash
- `test_terminate_callback_panic_safety` -- panicking callback doesn't prevent exit propagation
  </verify>
  <done>Bidirectional linking works. Terminate callback is invoked before exit propagation (per user locked decision). Exit signals propagate to linked processes on crash. Normal exit is silent (delivers :normal signal, no crash). trap_exit flag exists for future supervisor use. Terminate callback panic-safe. All verified by tests.</done>
</task>

<task type="auto">
  <name>Task 2: Named process registry</name>
  <files>
    crates/snow-rt/src/actor/registry.rs
    crates/snow-rt/src/actor/mod.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
Create `crates/snow-rt/src/actor/registry.rs`:

1. **ProcessRegistry** struct:
   - `names: parking_lot::RwLock<FxHashMap<String, ProcessId>>` -- name to PID mapping
   - RwLock chosen per research: reads are lock-free, writes are rare (per pitfall #6)

2. **register(name: &str, pid: ProcessId) -> Result<(), RegistryError>**:
   - Write-lock the map
   - If name already taken: return Err(RegistryError::AlreadyRegistered)
   - Insert name -> pid mapping
   - Also store the name in the Process struct for cleanup on exit

3. **whereis(name: &str) -> Option<ProcessId>**:
   - Read-lock the map
   - Look up name, return PID if found

4. **unregister(name: &str)**:
   - Write-lock the map
   - Remove the name entry

5. **cleanup_process(pid: ProcessId)**:
   - Remove any name registrations for this PID
   - Called when a process exits

6. Store the global registry as a `static OnceLock<ProcessRegistry>` or inside the Scheduler.

Update `actor/mod.rs` with extern "C" functions:
```
#[no_mangle]
pub extern "C" fn snow_actor_register(name_ptr: *const u8, name_len: u64)
```
- Gets current PID from thread-local
- Converts name_ptr/name_len to &str
- Calls registry.register(name, current_pid)
- On error (name taken): panic or return error code

```
#[no_mangle]
pub extern "C" fn snow_actor_whereis(name_ptr: *const u8, name_len: u64) -> u64
```
- Converts name to &str
- Calls registry.whereis(name)
- Returns PID as u64, or 0 (invalid PID) if not found

Update process exit cleanup (in scheduler or link.rs) to call `registry.cleanup_process(pid)` when a process exits.

Update `crates/snow-rt/src/lib.rs`: re-export snow_actor_link, snow_actor_set_terminate, snow_actor_register, snow_actor_whereis.

Write tests:
- Register a name, whereis returns correct PID
- Register duplicate name fails
- whereis for unregistered name returns 0
- Process exits -> name automatically unregistered
- Concurrent register/whereis is safe (no data races)
  </action>
  <verify>
`cargo test -p snow-rt` passes all tests.
`cargo test --workspace` passes (no regressions).
  </verify>
  <done>Named process registry works: register/whereis/unregister with RwLock for read-heavy access. Auto-cleanup on process exit. snow_actor_register, snow_actor_whereis, and snow_actor_set_terminate exported as extern "C" functions. All verified by tests.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-rt` passes all old + new tests
- `cargo test --workspace` passes (no regressions)
- Linking, exit propagation, terminate callback invocation, and registry work correctly under concurrent actor scheduling
- Terminate callback runs before exit propagation on both normal exit and crash
- Process cleanup on exit handles terminate callback, links, and registry entries (in that order)
</verification>

<success_criteria>
1. link(pid) creates bidirectional link between calling actor and target
2. Crashed actor propagates exit signal to all linked partners
3. Normal exit sends :normal signal (linked partners don't crash)
4. trap_exit flag prevents crash propagation (converts to message)
5. Terminate callback invoked before exit propagation when set (per user locked decision)
6. Terminate callback is panic-safe (panicking callback doesn't prevent exit propagation)
7. snow_actor_set_terminate registers terminate callback on a process
8. register(name) and whereis(name) work for named process lookup
9. Process exit cleans up: terminate callback -> links -> registry entries
10. All operations are thread-safe under M:N scheduler
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-06-SUMMARY.md`
</output>
