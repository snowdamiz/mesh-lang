---
phase: 06-actor-runtime
plan: 06
type: execute
wave: 4
depends_on: ["06-05"]
files_modified:
  - crates/snow-rt/src/actor/link.rs
  - crates/snow-rt/src/actor/registry.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/actor/process.rs
  - crates/snow-rt/src/actor/scheduler.rs
  - crates/snow-rt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "When a linked actor crashes, the linked partner receives an exit signal message"
    - "An actor can register itself with a name and be looked up by that name"
    - "link(pid) creates a bidirectional link between two actors"
    - "Normal exit does not propagate as a crash to linked processes (per discretion: silent cleanup)"
    - "Actor crash propagates exit reason to all linked processes"
  artifacts:
    - path: "crates/snow-rt/src/actor/link.rs"
      provides: "Link management and exit signal propagation"
      contains: "pub fn propagate_exit"
    - path: "crates/snow-rt/src/actor/registry.rs"
      provides: "Named process registration and lookup"
      contains: "pub fn register"
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "snow_actor_link, snow_actor_register, snow_actor_whereis extern C functions"
      contains: "snow_actor_link"
  key_links:
    - from: "crates/snow-rt/src/actor/link.rs"
      to: "crates/snow-rt/src/actor/scheduler.rs"
      via: "Exit propagation sends exit messages to linked processes and wakes them"
      pattern: "propagate.*exit\\|wake"
    - from: "crates/snow-rt/src/actor/registry.rs"
      to: "crates/snow-rt/src/actor/scheduler.rs"
      via: "Registry lookup returns PID from process table"
      pattern: "registry.*lookup\\|whereis"
---

<objective>
Implement process linking and named process registration. Linking creates bidirectional connections between actors: when one crashes, linked partners receive exit signals. Named registration allows actors to be looked up by name instead of PID.

Purpose: Process linking is a prerequisite for Phase 7 (supervision trees) and is required by the Phase 6 success criteria ("when a linked actor crashes, the linked partner receives an exit signal"). Named registration enables the `register(pid, :name)` pattern needed for global actor lookup (per user locked decision).

Output: Bidirectional linking with exit signal propagation, named process registry with register/whereis, extern "C" functions for all operations.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@.planning/phases/06-actor-runtime/06-01-SUMMARY.md
@.planning/phases/06-actor-runtime/06-03-SUMMARY.md
@.planning/phases/06-actor-runtime/06-05-SUMMARY.md
@crates/snow-rt/src/actor/process.rs
@crates/snow-rt/src/actor/scheduler.rs
@crates/snow-rt/src/actor/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bidirectional process linking and exit signal propagation</name>
  <files>
    crates/snow-rt/src/actor/link.rs
    crates/snow-rt/src/actor/process.rs
    crates/snow-rt/src/actor/scheduler.rs
    crates/snow-rt/src/actor/mod.rs
  </files>
  <action>
Create `crates/snow-rt/src/actor/link.rs`:

1. **link(pid_a, pid_b)**: Create a bidirectional link between two processes:
   - Add pid_b to pid_a's links set
   - Add pid_a to pid_b's links set
   - Both operations must be atomic (lock both processes, or use the process table lock)

2. **unlink(pid_a, pid_b)**: Remove bidirectional link:
   - Remove pid_b from pid_a's links set
   - Remove pid_a from pid_b's links set

3. **propagate_exit(exiting_pid, reason: ExitReason)**: When an actor exits:
   - For each PID in the exiting actor's links set:
     - Send an exit signal message to the linked process: `{:exit, exiting_pid, reason}`
     - The exit signal is delivered as a special Message to the mailbox with a reserved type_tag (e.g., type_tag = u64::MAX for exit signals)
     - Wake the linked process if it's in Waiting state (so it can process the exit signal)
   - For Normal exit (per discretion decision: silent cleanup): send `{:exit, pid, :normal}` which linked processes ignore by default. Concretely: still deliver the message, but the default behavior is to NOT crash the linked process.
   - For Error/Killed exit: send `{:exit, pid, reason}` which by default causes the linked process to crash with the same reason (cascading failure)

4. Update **Process** in process.rs:
   - Change `links: Vec<ProcessId>` to `links: HashSet<ProcessId>` (for O(1) add/remove/contains)
   - Add `trap_exit: bool` field (default false). When true, exit signals are delivered as regular messages instead of causing crashes. This is needed for Phase 7 supervisors but the flag should exist now.

5. Update **Scheduler** in scheduler.rs:
   - When a process exits (in the worker_loop, after coroutine completes or panics):
     - Call `propagate_exit(pid, exit_reason)` to notify linked processes
     - Remove process from process table
     - Clean up coroutine stack memory

6. Update `actor/mod.rs` with extern "C" function:
   ```
   #[no_mangle]
   pub extern "C" fn snow_actor_link(other_pid: u64)
   ```
   - Gets current PID from thread-local
   - Calls link(current_pid, other_pid)

Handle actor panics: Wrap the actor coroutine entry in a `std::panic::catch_unwind`. If the actor panics:
- Set process state to Exited(Error(panic_message))
- Call propagate_exit with the error reason
- The actor's stack and heap are cleaned up

Write tests:
- Link two actors, crash one, verify the other receives exit signal
- Link two actors, normal exit of one, verify the other receives :normal exit (and doesn't crash)
- Unlink two actors, crash one, verify the other does NOT receive exit signal
- Chain linking: A links B, B links C, C crashes -> B receives signal, B crashes -> A receives signal
- trap_exit: actor with trap_exit=true receives exit as regular message
  </action>
  <verify>
`cargo test -p snow-rt` passes all tests.
Specifically:
- `test_link_crash_propagation` -- linked actor receives exit signal on crash
- `test_normal_exit_silent` -- normal exit delivers :normal, doesn't crash linked
- `test_unlink` -- unlinked actors don't receive signals
- `test_cascading_exit` -- exit cascades through link chains
- `test_trap_exit` -- trap_exit converts signals to messages
  </verify>
  <done>Bidirectional linking works. Exit signals propagate to linked processes on crash. Normal exit is silent (delivers :normal signal, no crash). trap_exit flag exists for future supervisor use. All verified by tests.</done>
</task>

<task type="auto">
  <name>Task 2: Named process registry</name>
  <files>
    crates/snow-rt/src/actor/registry.rs
    crates/snow-rt/src/actor/mod.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
Create `crates/snow-rt/src/actor/registry.rs`:

1. **ProcessRegistry** struct:
   - `names: parking_lot::RwLock<FxHashMap<String, ProcessId>>` -- name to PID mapping
   - RwLock chosen per research: reads are lock-free, writes are rare (per pitfall #6)

2. **register(name: &str, pid: ProcessId) -> Result<(), RegistryError>**:
   - Write-lock the map
   - If name already taken: return Err(RegistryError::AlreadyRegistered)
   - Insert name -> pid mapping
   - Also store the name in the Process struct for cleanup on exit

3. **whereis(name: &str) -> Option<ProcessId>**:
   - Read-lock the map
   - Look up name, return PID if found

4. **unregister(name: &str)**:
   - Write-lock the map
   - Remove the name entry

5. **cleanup_process(pid: ProcessId)**:
   - Remove any name registrations for this PID
   - Called when a process exits

6. Store the global registry as a `static OnceLock<ProcessRegistry>` or inside the Scheduler.

Update `actor/mod.rs` with extern "C" functions:
```
#[no_mangle]
pub extern "C" fn snow_actor_register(name_ptr: *const u8, name_len: u64)
```
- Gets current PID from thread-local
- Converts name_ptr/name_len to &str
- Calls registry.register(name, current_pid)
- On error (name taken): panic or return error code

```
#[no_mangle]
pub extern "C" fn snow_actor_whereis(name_ptr: *const u8, name_len: u64) -> u64
```
- Converts name to &str
- Calls registry.whereis(name)
- Returns PID as u64, or 0 (invalid PID) if not found

Update process exit cleanup (in scheduler or link.rs) to call `registry.cleanup_process(pid)` when a process exits.

Update `crates/snow-rt/src/lib.rs`: re-export snow_actor_link, snow_actor_register, snow_actor_whereis.

Write tests:
- Register a name, whereis returns correct PID
- Register duplicate name fails
- whereis for unregistered name returns 0
- Process exits -> name automatically unregistered
- Concurrent register/whereis is safe (no data races)
  </action>
  <verify>
`cargo test -p snow-rt` passes all tests.
`cargo test --workspace` passes (no regressions).
  </verify>
  <done>Named process registry works: register/whereis/unregister with RwLock for read-heavy access. Auto-cleanup on process exit. snow_actor_register and snow_actor_whereis exported as extern "C" functions. All verified by tests.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-rt` passes all old + new tests
- `cargo test --workspace` passes (no regressions)
- Linking, exit propagation, and registry work correctly under concurrent actor scheduling
- Process cleanup on exit handles both links and registry entries
</verification>

<success_criteria>
1. link(pid) creates bidirectional link between calling actor and target
2. Crashed actor propagates exit signal to all linked partners
3. Normal exit sends :normal signal (linked partners don't crash)
4. trap_exit flag prevents crash propagation (converts to message)
5. register(name) and whereis(name) work for named process lookup
6. Process exit cleans up both links and registry entries
7. All operations are thread-safe under M:N scheduler
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-06-SUMMARY.md`
</output>
