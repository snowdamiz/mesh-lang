---
phase: 06-actor-runtime
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-common/src/token.rs
  - crates/snow-lexer/src/lib.rs
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/parser/declarations.rs
  - crates/snow-parser/src/ast.rs
  - crates/snow-codegen/src/mir/mod.rs
autonomous: true

must_haves:
  truths:
    - "The `actor` keyword is recognized by the lexer"
    - "Actor block declarations parse to ACTOR_DEF AST nodes"
    - "spawn, send, receive, self() expressions parse to dedicated AST nodes"
    - "MIR has ActorSpawn, ActorSend, ActorReceive, ActorSelf, ActorLink expression variants and Pid type"
  artifacts:
    - path: "crates/snow-common/src/token.rs"
      provides: "Actor keyword token"
      contains: "Actor"
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "ACTOR_KW, ACTOR_DEF, SPAWN_EXPR, SEND_EXPR, RECEIVE_EXPR, SELF_EXPR syntax kinds"
      contains: "ACTOR_DEF"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "Parsing for spawn/send/receive/self expressions"
      contains: "SPAWN_EXPR"
    - path: "crates/snow-parser/src/parser/declarations.rs"
      provides: "Parsing for actor block declarations"
      contains: "ACTOR_DEF"
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "MIR actor expression variants and Pid type"
      contains: "ActorSpawn"
  key_links:
    - from: "crates/snow-lexer/src/lib.rs"
      to: "crates/snow-common/src/token.rs"
      via: "Lexer produces Actor token from 'actor' keyword"
      pattern: "Actor"
    - from: "crates/snow-parser/src/parser/declarations.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "Parser matches ACTOR_KW and emits ACTOR_DEF node"
      pattern: "ACTOR_KW.*ACTOR_DEF"
---

<objective>
Extend the compiler frontend (lexer, parser, MIR) with actor-related language constructs: the `actor` keyword, actor block declarations, spawn/send/receive/self expressions, and MIR representation for all actor operations.

Purpose: The compiler must understand actor syntax before code generation can emit actor runtime calls. This plan adds all the frontend plumbing -- from tokenization through AST to MIR -- without touching type checking or LLVM codegen (those come in Plans 04 and 05).

Output: The lexer tokenizes `actor`, the parser produces AST nodes for actor blocks and actor expressions, and the MIR has expression variants for all actor primitives.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-CONTEXT.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@crates/snow-common/src/token.rs
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/expressions.rs
@crates/snow-parser/src/parser/declarations.rs
@crates/snow-codegen/src/mir/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add actor keyword to lexer and parser syntax kinds</name>
  <files>
    crates/snow-common/src/token.rs
    crates/snow-lexer/src/lib.rs
    crates/snow-parser/src/syntax_kind.rs
  </files>
  <action>
In `crates/snow-common/src/token.rs`:
- Add `Actor` variant to `TokenKind` enum in the Keywords section (alphabetically, so it goes first or near the top).
- Add `"actor" => Some(TokenKind::Actor)` to the `keyword()` function.
- Add `("actor", TokenKind::Actor)` to the keyword test list.
- Update the keyword count comment from 40 to 41.

In `crates/snow-parser/src/syntax_kind.rs`:
- Add `ACTOR_KW` to the keyword section of `SyntaxKind` enum.
- Add new node kinds for actor constructs:
  - `ACTOR_DEF` -- actor block declaration (top-level or nested)
  - `SPAWN_EXPR` -- spawn expression
  - `SEND_EXPR` -- send expression
  - `RECEIVE_EXPR` -- receive block expression
  - `RECEIVE_ARM` -- individual arm within receive block
  - `SELF_EXPR` -- self() expression
  - `LINK_EXPR` -- link expression
  - `AFTER_CLAUSE` -- timeout clause in receive
- Add mapping `TokenKind::Actor => SyntaxKind::ACTOR_KW` in the `from_token` function.
- Ensure existing mappings for SPAWN_KW, SEND_KW, RECEIVE_KW, LINK_KW, SELF_KW, AFTER_KW are present and correct.

The lexer itself (lib.rs) should NOT need changes -- it already dispatches keywords through the common `keyword()` function. But verify that the `lex_normal` function does not have any special-case handling that would miss `actor`.

Write snapshot tests for the lexer tokenizing: `actor MyCounter do end`, `spawn(func, args)`, `send(pid, msg)`, `receive do end`, `self()`.
  </action>
  <verify>
`cargo test -p snow-common` passes (keyword count test updated).
`cargo test -p snow-lexer` passes (new snapshot tests for actor tokens).
`cargo test -p snow-parser` compiles (new SyntaxKind variants, no parse logic yet).
  </verify>
  <done>TokenKind::Actor added to lexer. SyntaxKind has ACTOR_KW, ACTOR_DEF, SPAWN_EXPR, SEND_EXPR, RECEIVE_EXPR, RECEIVE_ARM, SELF_EXPR, LINK_EXPR, AFTER_CLAUSE. Lexer correctly tokenizes `actor` as a keyword.</done>
</task>

<task type="auto">
  <name>Task 2: Parse actor blocks, spawn/send/receive/self expressions, and extend MIR</name>
  <files>
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-parser/src/parser/declarations.rs
    crates/snow-parser/src/ast.rs
    crates/snow-codegen/src/mir/mod.rs
  </files>
  <action>
**Parser -- declarations.rs:**

Add `parse_actor_def()` to handle actor block syntax. The actor block is a first-class language construct (per user decision). Syntax:

```snow
actor CounterActor do
  receive do
    {:increment, amount} -> CounterActor(state + amount)
    {:get, sender} ->
      send(sender, state)
      CounterActor(state)
  end
end
```

The parser should:
- Match `ACTOR_KW` followed by `IDENT` (actor name) followed by `DO_KW`
- Inside the block, parse function parameters (the recursive state argument): actor blocks are implicitly functions that take state as their argument
- Parse body statements (which should include receive blocks, send calls, spawn calls)
- Match closing `END_KW`
- Emit `ACTOR_DEF` node containing: name, parameters (state), body

Hook `parse_actor_def` into the top-level declaration dispatch (likely in `parse_item` or equivalent) when the parser sees `ACTOR_KW`.

**Parser -- expressions.rs:**

Add expression parsing for actor primitives:

1. `parse_spawn_expr()`: `spawn(actor_fn, args...)` or `spawn(actor_fn, args..., priority: :high)`
   - Match `SPAWN_KW` + `L_PAREN`
   - Parse argument list (function reference + initial state args)
   - Match `R_PAREN`
   - Emit `SPAWN_EXPR` node

2. `parse_send_expr()`: `send(pid, message)`
   - Match `SEND_KW` + `L_PAREN`
   - Parse two arguments: target pid expression and message expression
   - Match `R_PAREN`
   - Emit `SEND_EXPR` node

3. `parse_receive_expr()`: A receive block with pattern matching arms and optional `after` timeout.
   ```snow
   receive do
     {:msg, value} -> handle(value)
     :quit -> exit()
   after 5000 ->
     handle_timeout()
   end
   ```
   - Match `RECEIVE_KW` + `DO_KW`
   - Parse match arms (reuse existing match arm parsing: pattern `->` body), each as `RECEIVE_ARM`
   - Optionally parse `AFTER_KW` + timeout expression + `->` + timeout body as `AFTER_CLAUSE`
   - Match `END_KW`
   - Emit `RECEIVE_EXPR` node

4. `parse_self_expr()`: `self()`
   - Match `SELF_KW` + `L_PAREN` + `R_PAREN`
   - Emit `SELF_EXPR` node

5. `parse_link_expr()`: `link(pid)`
   - Match `LINK_KW` + `L_PAREN`
   - Parse one argument (pid expression)
   - Match `R_PAREN`
   - Emit `LINK_EXPR` node

Hook these into the expression parsing dispatch. In the main expression parsing function, when we see SPAWN_KW, SEND_KW, RECEIVE_KW, SELF_KW, or LINK_KW at expression position, dispatch to the appropriate parse function.

Note: `self` is already handled as a parameter name (from 03-01). It needs to be handled as an expression when followed by `()` -- `self()` returns own PID. Adjust the existing self handling in expressions to support `SELF_KW L_PAREN R_PAREN` as a `SELF_EXPR`.

**AST wrappers (ast.rs):**

Add typed AST wrapper structs for:
- `ActorDef` -- wraps ACTOR_DEF node, accessors for name, params, body
- `SpawnExpr` -- wraps SPAWN_EXPR, accessors for function and args
- `SendExpr` -- wraps SEND_EXPR, accessors for target and message
- `ReceiveExpr` -- wraps RECEIVE_EXPR, accessors for arms and after clause
- `ReceiveArm` -- wraps RECEIVE_ARM, accessors for pattern and body
- `SelfExpr` -- wraps SELF_EXPR
- `LinkExpr` -- wraps LINK_EXPR, accessors for target pid

Follow the existing `ast_node!` macro pattern used for other AST types. Add these variants to the `Item` and `Expr` enums as appropriate (ActorDef to Item, others to Expr).

**MIR (mir/mod.rs):**

Add new MirExpr variants:
```rust
/// Spawn a new actor process.
ActorSpawn {
    /// The function to run as the actor body.
    func: Box<MirExpr>,
    /// Arguments to pass (initial state).
    args: Vec<MirExpr>,
    /// Priority level (0=normal, 1=high, 2=low).
    priority: u8,
    /// Result type (Pid).
    ty: MirType,
},
/// Send a message to an actor.
ActorSend {
    /// Target actor PID.
    target: Box<MirExpr>,
    /// Message to send.
    message: Box<MirExpr>,
    /// Result type (Unit -- fire-and-forget per discretion decision).
    ty: MirType,
},
/// Receive a message (blocking). Contains compiled match arms.
ActorReceive {
    /// Match arms for incoming messages.
    arms: Vec<MirMatchArm>,
    /// Timeout in milliseconds (None = infinite wait).
    timeout_ms: Option<Box<MirExpr>>,
    /// Timeout body (executed if timeout fires).
    timeout_body: Option<Box<MirExpr>>,
    /// Result type.
    ty: MirType,
},
/// Get own PID.
ActorSelf {
    ty: MirType,
},
/// Link to another actor.
ActorLink {
    target: Box<MirExpr>,
    ty: MirType,
},
```

Add new MirType variant:
```rust
/// Actor PID, optionally typed with message type.
/// Pid(None) = untyped Pid, Pid(Some(T)) = Pid<T>.
Pid(Option<Box<MirType>>),
```

Update `MirExpr::ty()` to handle the new variants.
Update `MirType::Display` to handle `Pid`.

Write parser snapshot tests:
- Parse `actor Counter do ... end` and verify ACTOR_DEF structure
- Parse `spawn(counter, 0)` and verify SPAWN_EXPR
- Parse `send(pid, :hello)` and verify SEND_EXPR
- Parse `receive do :msg -> handle() end` and verify RECEIVE_EXPR with RECEIVE_ARM
- Parse `receive do :msg -> handle() after 5000 -> timeout() end` and verify AFTER_CLAUSE
- Parse `self()` and verify SELF_EXPR
- Parse `link(other_pid)` and verify LINK_EXPR
  </action>
  <verify>
`cargo test -p snow-parser` passes with new snapshot tests for actor syntax.
`cargo build -p snow-codegen` compiles with new MIR variants.
`cargo test --workspace` passes -- no regressions.
  </verify>
  <done>Actor keyword lexes. Actor blocks, spawn/send/receive/self/link expressions parse to correct AST nodes. Typed AST wrappers exist for all actor constructs. MIR has ActorSpawn, ActorSend, ActorReceive, ActorSelf, ActorLink variants and MirType::Pid. All verified by snapshot tests.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-common` -- keyword test passes with 41 keywords
- `cargo test -p snow-lexer` -- actor token snapshot tests pass
- `cargo test -p snow-parser` -- actor syntax snapshot tests pass
- `cargo build -p snow-codegen` -- MIR compiles with new variants
- `cargo test --workspace` -- no regressions across all crates
</verification>

<success_criteria>
1. `actor` is a recognized keyword producing TokenKind::Actor
2. Actor block declarations parse to ACTOR_DEF nodes with name, params, body
3. spawn(), send(), receive, self(), link() expressions parse to dedicated AST nodes
4. Receive blocks support pattern matching arms and optional after clause
5. MIR has ActorSpawn/ActorSend/ActorReceive/ActorSelf/ActorLink/Pid
6. All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-02-SUMMARY.md`
</output>
