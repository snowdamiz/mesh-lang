---
phase: 06-actor-runtime
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-common/src/token.rs
  - crates/snow-lexer/src/lib.rs
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/parser/declarations.rs
  - crates/snow-parser/src/ast.rs
  - crates/snow-codegen/src/mir/mod.rs
autonomous: true

must_haves:
  truths:
    - "The `actor` keyword is recognized by the lexer"
    - "Actor block declarations parse to ACTOR_DEF AST nodes"
    - "spawn, send, receive, self() expressions parse to dedicated AST nodes"
    - "MIR has ActorSpawn, ActorSend, ActorReceive, ActorSelf, ActorLink expression variants and Pid type"
    - "An optional `terminate do ... end` clause inside actor blocks parses to a TERMINATE_CLAUSE AST node"
  artifacts:
    - path: "crates/snow-common/src/token.rs"
      provides: "Actor and Terminate keyword tokens"
      contains: "Actor"
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "ACTOR_KW, ACTOR_DEF, SPAWN_EXPR, SEND_EXPR, RECEIVE_EXPR, SELF_EXPR, TERMINATE_KW, TERMINATE_CLAUSE syntax kinds"
      contains: "TERMINATE_CLAUSE"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "Parsing for spawn/send/receive/self expressions"
      contains: "SPAWN_EXPR"
    - path: "crates/snow-parser/src/parser/declarations.rs"
      provides: "Parsing for actor block declarations including terminate clause"
      contains: "TERMINATE_CLAUSE"
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "MIR actor expression variants, Pid type, and terminate callback representation"
      contains: "ActorSpawn"
  key_links:
    - from: "crates/snow-lexer/src/lib.rs"
      to: "crates/snow-common/src/token.rs"
      via: "Lexer produces Actor and Terminate tokens from keywords"
      pattern: "Actor|Terminate"
    - from: "crates/snow-parser/src/parser/declarations.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "Parser matches ACTOR_KW and emits ACTOR_DEF node; matches TERMINATE_KW and emits TERMINATE_CLAUSE"
      pattern: "ACTOR_KW.*ACTOR_DEF|TERMINATE_KW.*TERMINATE_CLAUSE"
---

<objective>
Extend the compiler frontend (lexer, parser, MIR) with actor-related language constructs: the `actor` keyword, actor block declarations (including optional terminate callback clause), spawn/send/receive/self expressions, and MIR representation for all actor operations.

Purpose: The compiler must understand actor syntax before code generation can emit actor runtime calls. This plan adds all the frontend plumbing -- from tokenization through AST to MIR -- without touching type checking or LLVM codegen (those come in Plans 04 and 05). The terminate clause is a locked user decision: actors can define cleanup logic that runs before full termination.

Output: The lexer tokenizes `actor` and `terminate`, the parser produces AST nodes for actor blocks (with optional terminate clause) and actor expressions, and the MIR has expression variants for all actor primitives including terminate callback.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-actor-runtime/06-CONTEXT.md
@.planning/phases/06-actor-runtime/06-RESEARCH.md
@crates/snow-common/src/token.rs
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/expressions.rs
@crates/snow-parser/src/parser/declarations.rs
@crates/snow-codegen/src/mir/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add actor and terminate keywords to lexer and parser syntax kinds</name>
  <files>
    crates/snow-common/src/token.rs
    crates/snow-lexer/src/lib.rs
    crates/snow-parser/src/syntax_kind.rs
  </files>
  <action>
In `crates/snow-common/src/token.rs`:
- Add `Actor` variant to `TokenKind` enum in the Keywords section (alphabetically, so it goes first or near the top).
- Add `Terminate` variant to `TokenKind` enum in the Keywords section.
- Add `"actor" => Some(TokenKind::Actor)` to the `keyword()` function.
- Add `"terminate" => Some(TokenKind::Terminate)` to the `keyword()` function.
- Add both to the keyword test list.
- Update the keyword count comment from 40 to 42.

In `crates/snow-parser/src/syntax_kind.rs`:
- Add `ACTOR_KW` to the keyword section of `SyntaxKind` enum.
- Add `TERMINATE_KW` to the keyword section of `SyntaxKind` enum.
- Add new node kinds for actor constructs:
  - `ACTOR_DEF` -- actor block declaration (top-level or nested)
  - `SPAWN_EXPR` -- spawn expression
  - `SEND_EXPR` -- send expression
  - `RECEIVE_EXPR` -- receive block expression
  - `RECEIVE_ARM` -- individual arm within receive block
  - `SELF_EXPR` -- self() expression
  - `LINK_EXPR` -- link expression
  - `AFTER_CLAUSE` -- timeout clause in receive
  - `TERMINATE_CLAUSE` -- terminate callback clause in actor block (per user locked decision: actors can define cleanup logic that runs before full termination)
- Add mapping `TokenKind::Actor => SyntaxKind::ACTOR_KW` in the `from_token` function.
- Add mapping `TokenKind::Terminate => SyntaxKind::TERMINATE_KW` in the `from_token` function.
- Ensure existing mappings for SPAWN_KW, SEND_KW, RECEIVE_KW, LINK_KW, SELF_KW, AFTER_KW are present and correct.

The lexer itself (lib.rs) should NOT need changes -- it already dispatches keywords through the common `keyword()` function. But verify that the `lex_normal` function does not have any special-case handling that would miss `actor` or `terminate`.

Write snapshot tests for the lexer tokenizing: `actor MyCounter do end`, `spawn(func, args)`, `send(pid, msg)`, `receive do end`, `self()`, `terminate do end`.
  </action>
  <verify>
`cargo test -p snow-common` passes (keyword count test updated).
`cargo test -p snow-lexer` passes (new snapshot tests for actor and terminate tokens).
`cargo test -p snow-parser` compiles (new SyntaxKind variants, no parse logic yet).
  </verify>
  <done>TokenKind::Actor and TokenKind::Terminate added to lexer. SyntaxKind has ACTOR_KW, TERMINATE_KW, ACTOR_DEF, SPAWN_EXPR, SEND_EXPR, RECEIVE_EXPR, RECEIVE_ARM, SELF_EXPR, LINK_EXPR, AFTER_CLAUSE, TERMINATE_CLAUSE. Lexer correctly tokenizes `actor` and `terminate` as keywords.</done>
</task>

<task type="auto">
  <name>Task 2: Parse actor blocks (with terminate clause), spawn/send/receive/self expressions, and extend MIR</name>
  <files>
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-parser/src/parser/declarations.rs
    crates/snow-parser/src/ast.rs
    crates/snow-codegen/src/mir/mod.rs
  </files>
  <action>
**Parser -- declarations.rs:**

Add `parse_actor_def()` to handle actor block syntax. The actor block is a first-class language construct (per user decision). Syntax:

```snow
actor CounterActor do
  receive do
    {:increment, amount} -> CounterActor(state + amount)
    {:get, sender} ->
      send(sender, state)
      CounterActor(state)
  end

  terminate do
    # Optional cleanup logic (per user locked decision)
    # Runs before full termination with access to current state
    send(logger, {:actor_stopped, self()})
  end
end
```

The parser should:
- Match `ACTOR_KW` followed by `IDENT` (actor name) followed by `DO_KW`
- Inside the block, parse function parameters (the recursive state argument): actor blocks are implicitly functions that take state as their argument
- Parse body statements (which should include receive blocks, send calls, spawn calls)
- Optionally parse a `terminate do ... end` clause: match `TERMINATE_KW` followed by `DO_KW`, parse body statements, match `END_KW`. Emit as `TERMINATE_CLAUSE` child node of `ACTOR_DEF`. The terminate clause defines cleanup logic that runs before the actor fully terminates (resource cleanup, final messages). Only one terminate clause per actor block. If multiple are found, report a parser error.
- Match closing `END_KW`
- Emit `ACTOR_DEF` node containing: name, parameters (state), body, optional terminate clause

Hook `parse_actor_def` into the top-level declaration dispatch (likely in `parse_item` or equivalent) when the parser sees `ACTOR_KW`.

**Parser -- expressions.rs:**

Add expression parsing for actor primitives:

1. `parse_spawn_expr()`: `spawn(actor_fn, args...)` or `spawn(actor_fn, args..., priority: :high)`
   - Match `SPAWN_KW` + `L_PAREN`
   - Parse argument list (function reference + initial state args)
   - Match `R_PAREN`
   - Emit `SPAWN_EXPR` node

2. `parse_send_expr()`: `send(pid, message)`
   - Match `SEND_KW` + `L_PAREN`
   - Parse two arguments: target pid expression and message expression
   - Match `R_PAREN`
   - Emit `SEND_EXPR` node

3. `parse_receive_expr()`: A receive block with pattern matching arms and optional `after` timeout.
   ```snow
   receive do
     {:msg, value} -> handle(value)
     :quit -> exit()
   after 5000 ->
     handle_timeout()
   end
   ```
   - Match `RECEIVE_KW` + `DO_KW`
   - Parse match arms (reuse existing match arm parsing: pattern `->` body), each as `RECEIVE_ARM`
   - Optionally parse `AFTER_KW` + timeout expression + `->` + timeout body as `AFTER_CLAUSE`
   - Match `END_KW`
   - Emit `RECEIVE_EXPR` node

4. `parse_self_expr()`: `self()`
   - Match `SELF_KW` + `L_PAREN` + `R_PAREN`
   - Emit `SELF_EXPR` node

5. `parse_link_expr()`: `link(pid)`
   - Match `LINK_KW` + `L_PAREN`
   - Parse one argument (pid expression)
   - Match `R_PAREN`
   - Emit `LINK_EXPR` node

Hook these into the expression parsing dispatch. In the main expression parsing function, when we see SPAWN_KW, SEND_KW, RECEIVE_KW, SELF_KW, or LINK_KW at expression position, dispatch to the appropriate parse function.

Note: `self` is already handled as a parameter name (from 03-01). It needs to be handled as an expression when followed by `()` -- `self()` returns own PID. Adjust the existing self handling in expressions to support `SELF_KW L_PAREN R_PAREN` as a `SELF_EXPR`.

**AST wrappers (ast.rs):**

Add typed AST wrapper structs for:
- `ActorDef` -- wraps ACTOR_DEF node, accessors for name, params, body, and `terminate_clause() -> Option<TerminateClause>` (accessor for optional terminate callback)
- `TerminateClause` -- wraps TERMINATE_CLAUSE node, accessor for body statements
- `SpawnExpr` -- wraps SPAWN_EXPR, accessors for function and args
- `SendExpr` -- wraps SEND_EXPR, accessors for target and message
- `ReceiveExpr` -- wraps RECEIVE_EXPR, accessors for arms and after clause
- `ReceiveArm` -- wraps RECEIVE_ARM, accessors for pattern and body
- `SelfExpr` -- wraps SELF_EXPR
- `LinkExpr` -- wraps LINK_EXPR, accessors for target pid

Follow the existing `ast_node!` macro pattern used for other AST types. Add these variants to the `Item` and `Expr` enums as appropriate (ActorDef to Item, others to Expr).

**MIR (mir/mod.rs):**

Add new MirExpr variants:
```rust
/// Spawn a new actor process.
ActorSpawn {
    /// The function to run as the actor body.
    func: Box<MirExpr>,
    /// Arguments to pass (initial state).
    args: Vec<MirExpr>,
    /// Priority level (0=normal, 1=high, 2=low).
    priority: u8,
    /// Optional terminate callback function (per user locked decision).
    /// When present, this is a function that takes (state, reason) and runs cleanup.
    terminate_callback: Option<Box<MirExpr>>,
    /// Result type (Pid).
    ty: MirType,
},
/// Send a message to an actor.
ActorSend {
    /// Target actor PID.
    target: Box<MirExpr>,
    /// Message to send.
    message: Box<MirExpr>,
    /// Result type (Unit -- fire-and-forget per discretion decision).
    ty: MirType,
},
/// Receive a message (blocking). Contains compiled match arms.
ActorReceive {
    /// Match arms for incoming messages.
    arms: Vec<MirMatchArm>,
    /// Timeout in milliseconds (None = infinite wait).
    timeout_ms: Option<Box<MirExpr>>,
    /// Timeout body (executed if timeout fires).
    timeout_body: Option<Box<MirExpr>>,
    /// Result type.
    ty: MirType,
},
/// Get own PID.
ActorSelf {
    ty: MirType,
},
/// Link to another actor.
ActorLink {
    target: Box<MirExpr>,
    ty: MirType,
},
```

Add new MirType variant:
```rust
/// Actor PID, optionally typed with message type.
/// Pid(None) = untyped Pid, Pid(Some(T)) = Pid<T>.
Pid(Option<Box<MirType>>),
```

Update `MirExpr::ty()` to handle the new variants.
Update `MirType::Display` to handle `Pid`.

Write parser snapshot tests:
- Parse `actor Counter do ... end` and verify ACTOR_DEF structure
- Parse `actor Counter do ... terminate do ... end end` and verify ACTOR_DEF with TERMINATE_CLAUSE child node
- Parse `spawn(counter, 0)` and verify SPAWN_EXPR
- Parse `send(pid, :hello)` and verify SEND_EXPR
- Parse `receive do :msg -> handle() end` and verify RECEIVE_EXPR with RECEIVE_ARM
- Parse `receive do :msg -> handle() after 5000 -> timeout() end` and verify AFTER_CLAUSE
- Parse `self()` and verify SELF_EXPR
- Parse `link(other_pid)` and verify LINK_EXPR
  </action>
  <verify>
`cargo test -p snow-parser` passes with new snapshot tests for actor syntax including terminate clause.
`cargo build -p snow-codegen` compiles with new MIR variants.
`cargo test --workspace` passes -- no regressions.
  </verify>
  <done>Actor keyword lexes. Actor blocks (with optional terminate clause), spawn/send/receive/self/link expressions parse to correct AST nodes. TerminateClause AST wrapper exists with body accessor. Typed AST wrappers exist for all actor constructs. MIR has ActorSpawn (with optional terminate_callback), ActorSend, ActorReceive, ActorSelf, ActorLink variants and MirType::Pid. All verified by snapshot tests.</done>
</task>

</tasks>

<verification>
- `cargo test -p snow-common` -- keyword test passes with 42 keywords (actor + terminate)
- `cargo test -p snow-lexer` -- actor and terminate token snapshot tests pass
- `cargo test -p snow-parser` -- actor syntax snapshot tests pass, including terminate clause
- `cargo build -p snow-codegen` -- MIR compiles with new variants including terminate_callback on ActorSpawn
- `cargo test --workspace` -- no regressions across all crates
</verification>

<success_criteria>
1. `actor` and `terminate` are recognized keywords producing TokenKind::Actor and TokenKind::Terminate
2. Actor block declarations parse to ACTOR_DEF nodes with name, params, body, and optional TERMINATE_CLAUSE
3. spawn(), send(), receive, self(), link() expressions parse to dedicated AST nodes
4. Receive blocks support pattern matching arms and optional after clause
5. Terminate clause parses inside actor blocks as optional cleanup logic (per user locked decision)
6. MIR has ActorSpawn (with terminate_callback)/ActorSend/ActorReceive/ActorSelf/ActorLink/Pid
7. All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/06-actor-runtime/06-02-SUMMARY.md`
</output>
