---
phase: 16-fun-type-parsing
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - tests/e2e/fun_type.snow
autonomous: true

must_haves:
  truths:
    - "Fun(Int, String) -> Bool is resolved to Ty::Fun([Int, String], Bool) during type checking"
    - "Function type annotations work in function parameters, return types, struct fields, and type aliases"
    - "Passing a closure where Fun(Int) -> String is expected unifies correctly without extra annotation"
    - "Nested function types Fun(Fun(Int) -> String) -> Bool resolve correctly"
    - "Zero-arity Fun() -> Int resolves correctly"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "ARROW token collection + Fun() handling in parse_type_tokens"
      contains: "SyntaxKind::ARROW"
    - path: "tests/e2e/fun_type.snow"
      provides: "End-to-end test exercising Fun() type annotations"
      contains: "Fun("
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "SyntaxKind::ARROW added to collect_annotation_tokens"
      pattern: "SyntaxKind::ARROW"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "Ty::Fun"
      via: "parse_type_tokens returns Ty::Fun for Fun() syntax"
      pattern: 'Ty::Fun\(param_tys'
    - from: "tests/e2e/fun_type.snow"
      to: "crates/snow-typeck/src/infer.rs"
      via: "e2e test exercises full parse+typecheck pipeline"
      pattern: "Fun\\("
---

<objective>
Wire the type checker to resolve Fun() type annotations into Ty::Fun and add end-to-end tests covering all three requirements (TYPE-01, TYPE-02, TYPE-03).

Purpose: Plan 01 made the parser emit FUN_TYPE nodes and ARROW tokens. This plan makes the type checker understand those tokens and produce correct Ty::Fun types, completing the full Fun() type annotation feature.
Output: Working Fun() type annotations that parse, type-check, and unify with inferred function types. Verified by e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-fun-type-parsing/16-RESEARCH.md
@.planning/phases/16-fun-type-parsing/16-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ARROW token collection and Fun() handling to type checker</name>
  <files>crates/snow-typeck/src/infer.rs</files>
  <action>
Three changes in infer.rs:

**Change 1: Add ARROW to collect_annotation_tokens() (line ~4924)**

In the main `collect_annotation_tokens` function, add `SyntaxKind::ARROW` to the token match:
```rust
SyntaxKind::IDENT | SyntaxKind::LT | SyntaxKind::GT
| SyntaxKind::COMMA | SyntaxKind::QUESTION | SyntaxKind::BANG
| SyntaxKind::L_PAREN | SyntaxKind::R_PAREN
| SyntaxKind::ARROW  // NEW: needed for Fun(params) -> RetType
```

**Change 2: Add ARROW to inline token collection in type alias resolution (line ~1505)**

There is a SECOND token collection site for type aliases. Find the match block around line 1505 that collects tokens for type alias RHS parsing. Add `SyntaxKind::ARROW` there too:
```rust
SyntaxKind::IDENT | SyntaxKind::LT | SyntaxKind::GT
| SyntaxKind::COMMA | SyntaxKind::QUESTION | SyntaxKind::BANG
| SyntaxKind::L_PAREN | SyntaxKind::R_PAREN
| SyntaxKind::ARROW  // NEW: needed for Fun(params) -> RetType
```

CRITICAL: Both sites MUST be updated. If only one is updated, Fun() types will work in function signatures and struct fields but NOT in type aliases (or vice versa). The research doc specifically warns about this (Pitfall 6).

**Change 3: Add Fun() handling in parse_type_tokens() (line ~4966)**

After the IDENT name is extracted (`let name = tokens[*pos].1.clone(); *pos += 1;`) and BEFORE the generic args check (`if *pos < tokens.len() && tokens[*pos].0 == SyntaxKind::LT`), insert a new branch:

```rust
// Function type: Fun(ParamTypes) -> ReturnType
if name == "Fun" && *pos < tokens.len() && tokens[*pos].0 == SyntaxKind::L_PAREN {
    *pos += 1; // skip (
    let mut param_tys = Vec::new();
    while *pos < tokens.len() && tokens[*pos].0 != SyntaxKind::R_PAREN {
        param_tys.push(parse_type_tokens(tokens, pos));
        if *pos < tokens.len() && tokens[*pos].0 == SyntaxKind::COMMA {
            *pos += 1;
        }
    }
    if *pos < tokens.len() && tokens[*pos].0 == SyntaxKind::R_PAREN {
        *pos += 1; // skip )
    }
    // Expect ->
    if *pos < tokens.len() && tokens[*pos].0 == SyntaxKind::ARROW {
        *pos += 1; // skip ->
    }
    let ret_ty = parse_type_tokens(tokens, pos);
    return Ty::Fun(param_tys, Box::new(ret_ty));
}
```

This produces `Ty::Fun(param_tys, Box::new(ret_ty))` -- the same internal representation the type checker already uses for inferred function types. This means unification (TYPE-03) works automatically via the existing `InferCtx::unify()` which already handles `Ty::Fun`.

Do NOT wrap the return in `apply_type_sugar` -- function types don't support `?` or `!` postfix (it would be ambiguous). The `return` exits before the sugar application.
  </action>
  <verify>Run `cargo build` -- the full compiler must build without errors.</verify>
  <done>Type checker collects ARROW tokens from both annotation collection sites. parse_type_tokens recognizes Fun(params) -> RetType and returns Ty::Fun. Compiler builds.</done>
</task>

<task type="auto">
  <name>Task 2: Add end-to-end tests for Fun() type annotations</name>
  <files>tests/e2e/fun_type.snow</files>
  <action>
Create a new e2e test file `tests/e2e/fun_type.snow` that exercises all three requirements. Follow existing e2e test patterns (print expected output, the test runner compiles and checks output).

The test must cover:

**TYPE-01: Basic function type parsing**
```snow
# Basic single-param function type
fn apply(f :: Fun(Int) -> String, x :: Int) -> String do
  f(x)
end

# Zero-arity function type
fn run_thunk(thunk :: Fun() -> Int) -> Int do
  thunk()
end

# Multi-param function type
fn apply2(f :: Fun(Int, Int) -> Int, a :: Int, b :: Int) -> Int do
  f(a, b)
end
```

**TYPE-02: Function types in various positions**
```snow
# Type alias
type IntToString = Fun(Int) -> String

# Struct field (if supported by existing struct field type annotations)
# Use in function parameter (already covered above)
```

**TYPE-03: Unification with inferred function types**
```snow
# Pass a closure where Fun(Int) -> String is expected
let result = apply(fn x -> to_string(x) end, 42)
println(result)

# Pass a closure for zero-arity
let val = run_thunk(fn -> 99 end)
println(to_string(val))

# Pass closure for multi-param
let sum = apply2(fn a, b -> a + b end, 10, 20)
println(to_string(sum))
```

The test should print expected values to verify the full pipeline works (parse -> typecheck -> codegen -> runtime). Expected output:
```
42
99
30
```

Keep the test simple and focused. Do NOT test nested function types in the e2e test if it adds complexity -- the parser handles them via recursion and the type checker handles them via recursive parse_type_tokens. The basic cases are sufficient to prove all three requirements.
  </action>
  <verify>
Run: `cargo run -- tests/e2e/fun_type.snow && ./output`
Expected output:
```
42
99
30
```
Also run: `cargo test` to verify no regressions across the full test suite.
  </verify>
  <done>
- TYPE-01: Fun(Int) -> String parses as a function type (not type constructor) -- verified by e2e test compiling and running
- TYPE-02: Function type annotations work in function parameters and type aliases -- verified by test using both
- TYPE-03: Closures unify with explicit Fun() type annotations -- verified by test passing closures where Fun() types are expected
- All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `cargo build` -- compiler builds with type checker changes
2. `cargo run -- tests/e2e/fun_type.snow && ./output` -- e2e test produces expected output (42, 99, 30)
3. `cargo test` -- full test suite passes, no regressions
4. The three requirements are met:
   - TYPE-01: Fun() parsed as function type (not type constructor)
   - TYPE-02: Function type annotations work in function parameters and type aliases
   - TYPE-03: Function type annotations unify with inferred function types
</verification>

<success_criteria>
- Fun(Int, String) -> Bool resolves to Ty::Fun([Int, String], Bool) in the type checker
- Closures passed where Fun() types are expected compile and run correctly
- Zero-arity Fun() -> Int works
- Type aliases using Fun() work
- All existing tests pass (no regressions)
- e2e test produces correct output
</success_criteria>

<output>
After completion, create `.planning/phases/16-fun-type-parsing/16-02-SUMMARY.md`
</output>
