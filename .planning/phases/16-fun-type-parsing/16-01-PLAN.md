---
phase: 16-fun-type-parsing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/items.rs
autonomous: true

must_haves:
  truths:
    - "Parser recognizes Fun(Int, String) -> Bool as a function type annotation, not a type constructor"
    - "Parser handles zero-arity Fun() -> Int"
    - "Parser handles nested function types like Fun(Fun(Int) -> String) -> Bool"
    - "Fun without parentheses falls through to normal IDENT type parsing"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "FUN_TYPE composite node kind"
      contains: "FUN_TYPE"
    - path: "crates/snow-parser/src/parser/items.rs"
      provides: "Fun() type parsing in parse_type()"
      contains: "FUN_TYPE"
  key_links:
    - from: "crates/snow-parser/src/parser/items.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "SyntaxKind::FUN_TYPE used in p.close()"
      pattern: "SyntaxKind::FUN_TYPE"
---

<objective>
Add FUN_TYPE CST node kind and parser support so that `Fun(Int, String) -> Bool` is parsed as a function type annotation rather than being misparsed as a type constructor.

Purpose: This is the parser foundation for TYPE-01/TYPE-02/TYPE-03. Without the parser emitting proper FUN_TYPE nodes with ARROW tokens, the type checker cannot resolve function type annotations.
Output: Parser correctly emits FUN_TYPE CST nodes for `Fun(ParamTypes) -> ReturnType` syntax in all type positions.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-fun-type-parsing/16-RESEARCH.md
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/items.rs
@crates/snow-parser/src/parser/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FUN_TYPE to SyntaxKind and update tests</name>
  <files>crates/snow-parser/src/syntax_kind.rs</files>
  <action>
Add a new composite node kind `FUN_TYPE` to the `SyntaxKind` enum. Place it in the composite node kinds section, near OPTION_TYPE and RESULT_TYPE (since they are all type-annotation-related nodes). Add a doc comment: `/// Function type annotation: Fun(Int, String) -> Bool`.

Also update the `syntax_kind_has_enough_variants` test:
1. Add `SyntaxKind::FUN_TYPE` to the `node_kinds` array (after RESULT_TYPE is a natural spot).
2. Update the assert count from `>= 72` to `>= 73` (one new variant added).

Do NOT make `Fun` a keyword -- it stays as IDENT. The parser uses text comparison in type position only.
  </action>
  <verify>Run `cargo test -p snow-parser --lib` -- the syntax_kind tests must pass with the new variant and updated count.</verify>
  <done>FUN_TYPE variant exists in SyntaxKind enum. The `syntax_kind_has_enough_variants` test passes with the updated count.</done>
</task>

<task type="auto">
  <name>Task 2: Add Fun() function type parsing to parse_type()</name>
  <files>crates/snow-parser/src/parser/items.rs</files>
  <action>
In `parse_type()`, insert a new branch BEFORE the existing `if !p.at(SyntaxKind::IDENT)` check (i.e., after the tuple type L_PAREN handling but before the generic IDENT fallthrough). The branch detects `IDENT("Fun")` followed by `L_PAREN` and parses the full function type syntax:

```rust
// Function type: Fun(ParamTypes) -> ReturnType
if p.at(SyntaxKind::IDENT) && p.current_text() == "Fun" && p.nth(1) == SyntaxKind::L_PAREN {
    let m = p.open();
    p.advance(); // Fun
    p.advance(); // (
    // Parse comma-separated parameter types (may be empty for Fun() -> T)
    if !p.at(SyntaxKind::R_PAREN) {
        parse_type(p);
        while p.eat(SyntaxKind::COMMA) {
            if p.at(SyntaxKind::R_PAREN) {
                break;
            }
            parse_type(p);
        }
    }
    p.expect(SyntaxKind::R_PAREN);
    p.expect(SyntaxKind::ARROW);
    if !p.has_error() {
        parse_type(p); // return type
    }
    p.close(m, SyntaxKind::FUN_TYPE);
    return;
}
```

Key details:
- `p.current_text() == "Fun"` -- uses the existing `current_text()` method on Parser (confirmed at mod.rs:158). This is the same pattern used elsewhere in the codebase (e.g., checking IDENT text for "strategy", "from", etc.).
- `p.nth(1)` -- lookahead to ensure Fun is followed by `(`. If `Fun` appears without `(`, it falls through to normal IDENT type handling (producing `Ty::Con("Fun")`).
- `p.expect(SyntaxKind::ARROW)` -- REQUIRES `->` after the closing paren. If missing, emits a parse error.
- The recursive `parse_type(p)` calls for parameters and return type handle nested function types automatically (e.g., `Fun(Fun(Int) -> String) -> Bool`).
- The `return` after `p.close()` prevents fallthrough to the IDENT/generic handling below.
  </action>
  <verify>Run `cargo test -p snow-parser` -- all existing parser tests must still pass. Then run `cargo build` to verify the full compiler builds without errors. No runtime test yet (type checker integration is Plan 02).</verify>
  <done>Parser correctly emits FUN_TYPE CST nodes when encountering `Fun(...)  -> RetType` in type positions. Existing parser tests still pass. Fun without `(` still parses as a normal IDENT type.</done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-parser` -- all parser tests pass (including updated syntax_kind variant count)
2. `cargo build` -- full compiler builds without errors
3. Manual check: the FUN_TYPE branch is inserted before the `if !p.at(SyntaxKind::IDENT)` check, ensuring Fun is caught before the generic IDENT fallthrough
</verification>

<success_criteria>
- FUN_TYPE variant exists in SyntaxKind
- parse_type() handles Fun(params) -> RetType syntax
- Fun without ( falls through to normal IDENT type parsing
- All existing tests pass
- Compiler builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/16-fun-type-parsing/16-01-SUMMARY.md`
</output>
