---
phase: 103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-rt/src/db/json.rs
  - crates/mesh-rt/src/db/mod.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-repl/src/jit.rs
  - mesher/ingestion/routes.mpl
  - mesher/ingestion/ws_handler.mpl
  - mesher/ingestion/pipeline.mpl
  - mesher/api/alerts.mpl
  - mesher/api/team.mpl
autonomous: true

must_haves:
  truths:
    - "Json.get(body, \"key\") extracts a string field from a JSON string without a database roundtrip"
    - "Json.get_nested(body, \"filters\", \"level\") extracts nested JSON fields"
    - "All 5 non-storage JSONB Pool.query calls are replaced with Json.get/Json.get_nested"
    - "Mesher compiles with zero new errors after the conversion"
  artifacts:
    - path: "crates/mesh-rt/src/db/json.rs"
      provides: "JSON field extraction runtime functions"
      contains: "mesh_json_get"
    - path: "mesher/ingestion/routes.mpl"
      provides: "Json.get replaces Pool.query JSONB parsing"
    - path: "mesher/api/team.mpl"
      provides: "Json.get replaces Pool.query JSONB parsing"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-rt/src/db/json.rs"
      via: "known_functions + map_builtin_name"
      pattern: "mesh_json_get"
---

<objective>
Add Mesh-native JSON field extraction intrinsics (Json.get, Json.get_nested) and replace all 5 non-storage JSONB Pool.query parsing calls.

Purpose: The 5 non-storage Pool.query calls in mesher/ingestion and mesher/api files use PostgreSQL purely as a JSON parser ($1::jsonb->>'key'). This is wasteful (DB roundtrip for string parsing). A Mesh-native runtime intrinsic backed by serde_json eliminates these calls entirely.

Output: json.rs runtime module, compiler pipeline registration, 5 MPL files rewritten.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-RESEARCH.md
@.planning/phases/97-schema-metadata-sql-generation/97-02-SUMMARY.md

Key patterns to follow:
- Pure Rust helper + extern C wrapper (matches orm.rs, migration.rs patterns)
- Known functions registration in lower.rs with MirType signatures
- LLVM intrinsic declaration in intrinsics.rs
- Module registration in infer.rs (STDLIB_MODULE_NAMES + type env)
- JIT symbol mapping in jit.rs
- serde_json is already a dependency of mesh-rt (used in db/pool.rs for row parsing)

Current JSONB parsing calls to replace:
1. mesher/ingestion/routes.mpl:400 -- Pool.query(pool, "SELECT COALESCE($1::jsonb->>'user_id', '') AS user_id", [body])
2. mesher/ingestion/ws_handler.mpl:108 -- Pool.query(pool, "SELECT COALESCE($1::jsonb->'filters'->>'level', '') AS level, COALESCE($1::jsonb->'filters'->>'environment', '') AS env", [message])
3. mesher/ingestion/pipeline.mpl:150 -- Pool.query(pool, "SELECT COALESCE($1::jsonb->>$2, '') AS val", [condition_json, field])
4. mesher/api/alerts.mpl:82 -- Pool.query(pool, "SELECT COALESCE($1::jsonb->>'enabled', 'true') AS enabled", [body])
5. mesher/api/team.mpl:44 -- Pool.query(pool, "SELECT COALESCE($1::jsonb->>$2, '') AS val", [body, field])
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Json runtime module with serde_json extraction</name>
  <files>
    crates/mesh-rt/src/db/json.rs
    crates/mesh-rt/src/db/mod.rs
    crates/mesh-rt/src/lib.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-typeck/src/infer.rs
    crates/mesh-repl/src/jit.rs
  </files>
  <action>
  Create `crates/mesh-rt/src/db/json.rs` with two extern C functions:

  1. `mesh_json_get(json_ptr: *mut u8, key_ptr: *mut u8) -> *mut u8`
     - Read json_ptr as MeshString, key_ptr as MeshString
     - Parse JSON string with serde_json::from_str::<serde_json::Value>()
     - Extract field by key using value.get(key)
     - If field exists and is a string: return the string value as MeshString
     - If field exists and is a number/bool/null: convert to string, return as MeshString
     - If field is missing or JSON is invalid: return empty string "" as MeshString
     - This matches the COALESCE($1::jsonb->>$2, '') pattern used in all 5 call sites

  2. `mesh_json_get_nested(json_ptr: *mut u8, path1_ptr: *mut u8, path2_ptr: *mut u8) -> *mut u8`
     - Same as above but traverses two levels: value.get(path1).and_then(|v| v.get(path2))
     - This handles the ws_handler.mpl case: $1::jsonb->'filters'->>'level'
     - Returns empty string on missing/invalid

  Register in the compiler pipeline following the exact pattern used by Orm module (97-02-SUMMARY.md):

  **crates/mesh-rt/src/db/mod.rs:** Add `pub mod json;`
  **crates/mesh-rt/src/lib.rs:** Re-export `pub use db::json::*;`

  **crates/mesh-codegen/src/codegen/intrinsics.rs:** Declare LLVM function types:
  - `mesh_json_get(ptr, ptr) -> ptr`
  - `mesh_json_get_nested(ptr, ptr, ptr) -> ptr`

  **crates/mesh-codegen/src/mir/lower.rs:**
  - Add to known_functions: `mesh_json_get` with type `FnPtr(vec![Ptr, Ptr], Box::new(Ptr))` (takes String, String -> String)
  - Add to known_functions: `mesh_json_get_nested` with type `FnPtr(vec![Ptr, Ptr, Ptr], Box::new(Ptr))` (takes String, String, String -> String)
  - Add "Json" to STDLIB_MODULES array
  - Add map_builtin_name entries: "Json.get" -> "mesh_json_get", "Json.get_nested" -> "mesh_json_get_nested"

  **crates/mesh-typeck/src/infer.rs:**
  - Add "Json" to STDLIB_MODULE_NAMES
  - Register Json module methods in register_stdlib_modules:
    - Json.get: (String, String) -> String
    - Json.get_nested: (String, String, String) -> String

  **crates/mesh-repl/src/jit.rs:** Add JIT symbol mappings:
  - "mesh_json_get" -> mesh_json_get as *const u8
  - "mesh_json_get_nested" -> mesh_json_get_nested as *const u8

  Test: `cargo build -p mesh-rt` and `cargo build -p mesh-codegen` compile without errors.
  </action>
  <verify>cargo build -p mesh-rt && cargo build -p mesh-codegen && cargo build -p mesh-typeck && cargo build -p mesh-repl</verify>
  <done>Json.get and Json.get_nested are callable from Mesh code, backed by serde_json, no DB roundtrip needed</done>
</task>

<task type="auto">
  <name>Task 2: Replace all 5 non-storage JSONB Pool.query calls with Json.get/Json.get_nested</name>
  <files>
    mesher/ingestion/routes.mpl
    mesher/ingestion/ws_handler.mpl
    mesher/ingestion/pipeline.mpl
    mesher/api/alerts.mpl
    mesher/api/team.mpl
  </files>
  <action>
  Replace each JSONB-parsing Pool.query call with Json.get or Json.get_nested. The replacements:

  1. **mesher/api/team.mpl** -- extract_json_field function (line ~43-48):
     Replace the entire function body. Instead of Pool.query + JSONB extraction:
     ```
     fn extract_json_field(pool :: PoolHandle, body :: String, field :: String) -> String!String do
       Ok(Json.get(body, field))
     end
     ```
     Note: pool parameter kept in signature for backward compatibility (callers pass it). The function no longer uses it. Alternatively, if the function is only called locally, remove pool param and update callers. Check callers first.

  2. **mesher/ingestion/pipeline.mpl** -- extract_condition_field function (line ~149-155):
     Same pattern as team.mpl:
     ```
     fn extract_condition_field(pool :: PoolHandle, condition_json :: String, field :: String) -> String!String do
       Ok(Json.get(condition_json, field))
     end
     ```

  3. **mesher/ingestion/routes.mpl** -- handle_assign_issue (line ~400):
     Replace `Pool.query(pool, "SELECT COALESCE($1::jsonb->>'user_id', '') AS user_id", [body])` with:
     ```
     let user_id = Json.get(body, "user_id")
     ```
     Then restructure the code flow to use user_id directly instead of going through rows_result/case/Ok(rows) pattern. The original code does:
     ```
     let rows_result = Pool.query(...)
     case rows_result do
       Err(e) -> HTTP.response(400, "{\"error\":\"invalid json\"}")
       Ok(rows) -> assign_from_rows(pool, issue_id, rows)
     end
     ```
     Json.get never fails (returns "" on invalid JSON), so simplify to:
     ```
     let user_id = Json.get(body, "user_id")
     ```
     Then call the assignment logic directly with user_id. Read assign_from_rows to understand what it does with the rows, and inline/adapt appropriately. If assign_from_rows extracts user_id from the first row, pass user_id directly.

  4. **mesher/ingestion/ws_handler.mpl** -- handle_subscribe_update (line ~108):
     This extracts TWO nested fields. Replace:
     ```
     let query_result = Pool.query(pool, "SELECT COALESCE($1::jsonb->'filters'->>'level', '') AS level, COALESCE($1::jsonb->'filters'->>'environment', '') AS env", [message])
     ```
     With:
     ```
     let level = Json.get_nested(message, "filters", "level")
     let env = Json.get_nested(message, "filters", "environment")
     ```
     Then restructure the code flow similarly -- instead of case query_result do Ok(rows) -> apply_filter_update(conn, rows), construct the needed data and call apply_filter_update appropriately. Read apply_filter_update to understand its interface. If it reads Map.get(row, "level") and Map.get(row, "env"), either:
     - Create a Map with those keys and wrap in a list, OR
     - Refactor to pass level/env directly (preferred if simple)

  5. **mesher/api/alerts.mpl** -- handle_toggle_rule (line ~82):
     Replace:
     ```
     let rows_result = Pool.query(pool, "SELECT COALESCE($1::jsonb->>'enabled', 'true') AS enabled", [body])
     ```
     With:
     ```
     let enabled_raw = Json.get(body, "enabled")
     let enabled = if String.length(enabled_raw) > 0 do enabled_raw else "true" end
     ```
     Note: the COALESCE default was 'true', so if Json.get returns "" (key missing), default to "true".
     Then restructure the code flow to use enabled directly instead of going through rows_result/case pattern.

  For each file, read the full function context around the Pool.query call to understand the data flow (especially what happens with the query results), then make the minimal change. Keep function signatures unchanged to avoid breaking callers.

  Build mesher after all 5 replacements: `cd mesher && ../target/debug/meshc build .`
  </action>
  <verify>cd /Users/sn0w/Documents/dev/snow/mesher && ../target/debug/meshc build . 2>&1 | head -20</verify>
  <done>All 5 non-storage JSONB Pool.query calls replaced with Json.get/Json.get_nested; mesher compiles; no Pool.query calls remain in ingestion/routes.mpl, ingestion/ws_handler.mpl, ingestion/pipeline.mpl, api/alerts.mpl, api/team.mpl</done>
</task>

</tasks>

<verification>
1. `cargo build -p mesh-rt` compiles with json module
2. `cargo test -p mesh-rt` -- existing tests pass
3. `grep -rn "Pool.query\|Pool.execute" mesher/ingestion/ mesher/api/alerts.mpl mesher/api/team.mpl` returns 0 results
4. Mesher compiles: `cd mesher && ../target/debug/meshc build .`
</verification>

<success_criteria>
- Json.get and Json.get_nested work as Mesh stdlib functions
- All 5 JSONB-parsing Pool.query calls eliminated from non-storage MPL files
- No new compilation errors introduced
- Zero database roundtrips for JSON field extraction
</success_criteria>

<output>
After completion, create `.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-01-SUMMARY.md`
</output>
