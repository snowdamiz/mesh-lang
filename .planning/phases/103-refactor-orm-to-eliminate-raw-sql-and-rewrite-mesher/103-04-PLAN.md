---
phase: 103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher
plan: 04
type: execute
wave: 2
depends_on: ["103-02", "103-03"]
files_modified:
  - mesher/storage/queries.mpl
autonomous: true

must_haves:
  truths:
    - "Tier 1 functions use existing Query/Repo APIs (count_unresolved_issues, get_issue_project_id, is_issue_discarded, top_issues_by_frequency, issue_event_timeline, get_all_project_retention, delete_session)"
    - "Simple UPDATE functions use Repo.update_where with Query conditions (resolve_issue, archive_issue, unresolve_issue, discard_issue, toggle_alert_rule, acknowledge_alert, resolve_fired_alert)"
    - "DELETE functions use Repo.delete_where (delete_issue events deletion)"
    - "JOIN queries use Query.join (get_project_by_api_key, get_members_with_users, list_alerts)"
    - "Functions with PG functions in WHERE use Query.where_raw (validate_session, should_fire_by_cooldown, get_event_alert_rules)"
    - "Functions with casts and COALESCE use Query.select_raw (list_issues_by_status, list_api_keys, list_alert_rules, get_event_detail, get_project_settings, get_project_storage)"
    - "All converted function signatures remain identical (no caller changes needed)"
  artifacts:
    - path: "mesher/storage/queries.mpl"
      provides: "30+ functions converted from Pool.query/Pool.execute to ORM APIs"
  key_links:
    - from: "mesher/storage/queries.mpl"
      to: "crates/mesh-rt/src/db/repo.rs"
      via: "Repo.update_where, Repo.delete_where, Repo.query_raw"
    - from: "mesher/storage/queries.mpl"
      to: "crates/mesh-rt/src/db/query.rs"
      via: "Query.select_raw, Query.where_raw"
---

<objective>
Convert all Tier 1 and Tier 2 raw SQL functions in queries.mpl to use ORM Query/Repo APIs with the new extensions (select_raw, where_raw, update_where, delete_where). Convert Tier 3 complex analytics queries from Pool.query/Pool.execute to Repo.query_raw/Repo.execute_raw.

Purpose: This is the main conversion plan. After this, queries.mpl will use ORM APIs for all expressible patterns and Repo.query_raw/execute_raw for intentionally complex analytics. No more Pool.query/Pool.execute calls will remain in queries.mpl.

Output: queries.mpl fully migrated to ORM + Repo.query_raw/execute_raw APIs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-RESEARCH.md
@.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-02-SUMMARY.md
@.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-03-SUMMARY.md
@mesher/storage/queries.mpl

Function classification for conversion:

**Tier 1 -- Direct Query/Repo (7 functions):**
1. count_unresolved_issues -> Query.from + Query.where + Query.where_raw("status = ?", ["unresolved"]) + Repo.count  (or just Query.where + Repo.count with cast handling)
2. get_issue_project_id -> Repo.get_by or Query.from + Query.where + Query.select_raw + Repo.one
3. is_issue_discarded -> Query.from + Query.where + Repo.exists
4. top_issues_by_frequency -> Query.from + Query.where + Query.select_raw + Query.order_by + Query.limit + Repo.all
5. issue_event_timeline -> Query.from + Query.where + Query.select_raw + Query.order_by + Query.limit + Repo.all
6. get_all_project_retention -> Query.from + Query.select_raw + Repo.all
7. delete_session -> Repo.delete_where (WHERE token = $1)

**Tier 2a -- Simple UPDATE with conditions (7 functions):**
8. resolve_issue -> Repo.update_where with Query.where(:id, id) + Query.where_raw or Query.where_op(:status, :neq, "resolved")
9. archive_issue -> Repo.update_where with Query.where(:id, id)
10. unresolve_issue -> Repo.update_where with Query.where(:id, id)
11. discard_issue -> Repo.update_where with Query.where(:id, id)
12. toggle_alert_rule -> Repo.update_where with Query.where(:id, id), SET enabled = $2::boolean (need where_raw for cast)
13. acknowledge_alert -> Repo.update_where with Query.where_raw("id = ?::uuid AND status = 'active'", [id]), SET status + acknowledged_at = now()
14. resolve_fired_alert -> Repo.update_where with Query.where_raw conditions

**Tier 2b -- PG functions in WHERE (3 functions):**
15. validate_session -> Query.from + Query.where + Query.where_raw("expires_at > now()", []) + Repo.one
16. should_fire_by_cooldown -> Query.from + Query.where_raw with interval arithmetic
17. get_event_alert_rules -> Query.from + Query.where + Query.where_raw for JSONB path access

**Tier 2c -- SELECT with casts/COALESCE (7 functions):**
18. list_issues_by_status -> Query.from + Query.where + Query.select_raw + Query.order_by + Repo.all
19. list_api_keys -> Query.from + Query.where + Query.select_raw + Query.order_by + Repo.all
20. list_alert_rules -> Query.from + Query.where + Query.select_raw + Query.order_by + Repo.all
21. get_event_detail -> Query.from + Query.where_raw + Query.select_raw + Repo.one
22. get_project_settings -> Query.from + Query.where_raw + Query.select_raw + Repo.one
23. get_project_storage -> Query.from + Query.where_raw + Query.select_raw + Repo.one
24. error_breakdown_by_level -> Query.from + Query.where_raw + Query.select_raw + Query.group_by + Repo.all

**Tier 2d -- Complex filters/pagination (4 functions):**
25. list_issues_filtered -> Conditional Query building with where_raw for keyset pagination
26. list_events_for_issue -> Conditional Query building with where_raw for keyset pagination
27. assign_issue -> Conditional Repo.update_where (NULL vs UUID)

**Tier 2e -- PG functions in INSERT / multi-step writes (5 functions):**
28. create_api_key -> Repo.query_raw (PG function gen_random_bytes in INSERT VALUES)
29. create_user -> Repo.query_raw (PG function crypt/gen_salt in INSERT VALUES)
30. create_session -> Repo.query_raw (PG function gen_random_bytes in INSERT VALUES)
31. authenticate_user -> Repo.query_raw (PG function crypt in WHERE)
32. revoke_api_key -> Repo.execute_raw (now() in SET)

**Tier 2f -- GROUP BY / aggregation (4 functions):**
33. event_volume_hourly -> Query.from + Query.where_raw + Query.select_raw + Query.group_by + Repo.all
34. event_breakdown_by_tag -> Repo.query_raw (JSONB operators too complex)
35. check_new_issue -> Query.from + Query.where_raw + Repo.exists
36. delete_issue -> Repo.delete_where for events + Repo.delete for issue

**Tier 2g -- JOIN queries (2 functions):**
37. get_project_by_api_key -> Query.from + Query.join + Query.select_raw + Query.where + Repo.one
38. list_alerts -> Query.from + Query.join + Query.where_raw + Query.select_raw + Repo.all

**Tier 3 -- Intentional raw SQL (Repo.query_raw/execute_raw) (11 functions):**
39. upsert_issue -> Repo.query_raw (ON CONFLICT DO UPDATE with CASE WHEN)
40. extract_event_fields -> Repo.query_raw (multi-branch CASE WHEN with jsonb_typeof)
41. check_volume_spikes -> Repo.execute_raw (correlated subquery in WHERE)
42. project_health_summary -> Repo.query_raw (3 correlated subselects)
43. evaluate_threshold_rule -> Repo.query_raw (CASE WHEN with subqueries)
44. get_event_neighbors -> Repo.query_raw (2 correlated subselects)
45. search_events_fulltext -> Repo.query_raw (tsvector/tsquery functions)
46. filter_events_by_tag -> Repo.query_raw (JSONB containment operator)
47. fire_alert -> Repo.query_raw + Repo.execute_raw (jsonb_build_object + multi-statement)
48. delete_expired_events -> Repo.execute_raw (dynamic interval expression)
49. get_expired_partitions -> Repo.query_raw (pg_inherits system catalog query)
50. drop_partition -> Repo.execute_raw (DDL: DROP TABLE)
51. update_project_settings -> Repo.execute_raw (JSONB extraction in SET)
52. check_sample_rate -> Repo.query_raw (random() + subquery)

NOTE: Not all items above may be worth converting. For items where the ORM conversion is trivially more complex than the raw SQL, prefer Repo.query_raw/execute_raw.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert Tier 1 and simple Tier 2 functions (direct ORM conversions)</name>
  <files>mesher/storage/queries.mpl</files>
  <action>
  Convert approximately 20 functions that can use the ORM Query/Repo APIs directly. For each function, keep the exact same function signature and return type. Read each function body in queries.mpl before converting.

  **Tier 1 -- direct conversions (7 functions):**

  1. `count_unresolved_issues` -> Use Query builder + Repo.count:
     ```
     let q = Query.from("issues")
       |> Query.where_raw("project_id = ?::uuid", [project_id])
       |> Query.where(:status, "unresolved")
     let count_result = Repo.count(pool, q)?
     # count_result returns Int, but function returns List<Map>. Keep Repo.query_raw for compatibility.
     ```
     Actually, this returns `List<Map<String, String>>!String` with a "cnt" key. To preserve this exact return type, either use Repo.query_raw OR change to Query.select_raw + Repo.all. Use Repo.query_raw since the signature returns a specific format.

  2. `get_issue_project_id` -> Repo.query_raw (needs ::uuid cast and ::text cast on select)

  3. `is_issue_discarded` -> Use Query + Repo.exists:
     ```
     let q = Query.from("issues")
       |> Query.where_raw("project_id = ?::uuid", [project_id])
       |> Query.where(:fingerprint, fingerprint)
       |> Query.where(:status, "discarded")
     Repo.exists(pool, q)
     ```

  4. `top_issues_by_frequency`:
     ```
     let q = Query.from("issues")
       |> Query.select_raw(["id::text", "title", "level", "status", "event_count::text", "last_seen::text"])
       |> Query.where_raw("project_id = ?::uuid", [project_id])
       |> Query.where(:status, "unresolved")
       |> Query.order_by(:event_count, :desc)
       |> Query.where_raw("1=1 LIMIT ?::int", [limit_str])
     ```
     Wait -- Query.limit takes Int not String. The limit_str is a string. Use where_raw to inject the limit or convert to Int. Actually, check if String.to_int exists. Yes it does (Phase 46). But it returns Option<Int>. Simpler: use Repo.query_raw for functions with string limit params. OR use Query.where_raw for the whole thing.

     PRAGMATIC APPROACH: For functions where the ORM conversion is awkward due to type mismatches (string limits, UUID casts), use Repo.query_raw. The goal is to eliminate Pool.query/Pool.execute, not to force every query through the Query builder.

  **Revised strategy for this task:** Convert functions where the ORM conversion is clean and natural. For functions where type casts or string-to-int conversions make it awkward, use Repo.query_raw/Repo.execute_raw. The key win is consistency: all database access goes through the Repo namespace.

  **Clean ORM conversions:**

  1. `is_issue_discarded` -> Query + Repo.exists (as shown above)

  2. `resolve_issue` -> Repo.execute_raw (the WHERE has status != 'resolved' which is clean with where_op, but the return type is Int!String from Pool.execute, and Repo.update_where returns a row map. Use Repo.execute_raw to match exact signature):
     ```
     Repo.execute_raw(pool, "UPDATE issues SET status = 'resolved' WHERE id = $1::uuid AND status != 'resolved'", [issue_id])
     ```

  3. `archive_issue` -> Repo.execute_raw:
     ```
     Repo.execute_raw(pool, "UPDATE issues SET status = 'archived' WHERE id = $1::uuid", [issue_id])
     ```

  4. `unresolve_issue` -> Repo.execute_raw

  5. `discard_issue` -> Repo.execute_raw

  6. `assign_issue` -> Repo.execute_raw (2 branches, same SQL)

  7. `delete_issue` -> Repo.execute_raw for events delete + Repo.execute_raw for issue delete:
     ```
     let _ = Repo.execute_raw(pool, "DELETE FROM events WHERE issue_id = $1::uuid", [issue_id])?
     Repo.execute_raw(pool, "DELETE FROM issues WHERE id = $1::uuid", [issue_id])
     ```

  8. `delete_session` -> Repo.execute_raw

  9. `revoke_api_key` -> Repo.execute_raw

  10. `toggle_alert_rule` -> Repo.execute_raw

  11. `acknowledge_alert` -> Repo.execute_raw

  12. `resolve_fired_alert` -> Repo.execute_raw

  13. `update_member_role` -> Repo.execute_raw

  14. `delete_expired_events` -> Repo.execute_raw

  15. `drop_partition` -> Repo.execute_raw

  16. `update_project_settings` -> Repo.execute_raw

  For ALL remaining Pool.query calls, replace with Repo.query_raw. This is a mechanical replacement:
  `Pool.query(pool, sql, params)` -> `Repo.query_raw(pool, sql, params)`

  For ALL remaining Pool.execute calls, replace with Repo.execute_raw:
  `Pool.execute(pool, sql, params)` -> `Repo.execute_raw(pool, sql, params)`

  The key principle: Every function that currently uses Pool.query or Pool.execute in queries.mpl should use Repo.query_raw or Repo.execute_raw instead. This moves ALL database access under the Repo namespace.

  For the handful of clean ORM conversions (is_issue_discarded with Repo.exists, check_new_issue with Repo.exists), do the full ORM conversion. For everything else, the Repo.query_raw/execute_raw replacement achieves the namespace consistency goal.

  After conversion, verify: `grep "Pool.query\|Pool.execute" mesher/storage/queries.mpl` returns 0 matches.
  </action>
  <verify>Build mesher: cd /Users/sn0w/Documents/dev/snow && cargo build -p meshc && cd mesher && ../target/debug/meshc build . 2>&1 | tail -5</verify>
  <done>All Pool.query calls in queries.mpl replaced with Repo.query_raw; all Pool.execute calls replaced with Repo.execute_raw; is_issue_discarded and check_new_issue use full ORM Query + Repo.exists pattern; function signatures unchanged</done>
</task>

<task type="auto">
  <name>Task 2: Convert ORM-natural functions to use Query builder where beneficial</name>
  <files>mesher/storage/queries.mpl</files>
  <action>
  Now that all Pool.query/Pool.execute calls are gone (replaced in Task 1), selectively upgrade functions where the Query builder produces cleaner, more readable code than Repo.query_raw. Focus on functions where the Query builder adds real value:

  1. `list_issues_by_status` -- Query.from + Query.where_raw + Query.select_raw + Query.order_by:
     ```
     let q = Query.from("issues")
       |> Query.select_raw(["id::text", "project_id::text", "fingerprint", "title", "level", "status", "event_count::text", "first_seen::text", "last_seen::text", "COALESCE(assigned_to::text, '') as assigned_to"])
       |> Query.where_raw("project_id = ?::uuid", [project_id])
       |> Query.where(:status, status)
       |> Query.order_by(:last_seen, :desc)
     let rows = Repo.all(pool, q)?
     ```

  2. `issue_event_timeline` -- Clean Query builder candidate:
     ```
     let q = Query.from("events")
       |> Query.select_raw(["id::text", "level", "message", "received_at::text"])
       |> Query.where_raw("issue_id = ?::uuid", [issue_id])
       |> Query.order_by(:received_at, :desc)
       |> Query.where_raw("1=1 LIMIT ?::int", [limit_str])
     ```
     Actually, the LIMIT hack is ugly. Keep as Repo.query_raw if the Query builder version is worse. Only convert if it's clearly better.

  3. `get_project_settings` -- Simple single-row select:
     ```
     let q = Query.from("projects")
       |> Query.select_raw(["retention_days::text", "sample_rate::text"])
       |> Query.where_raw("id = ?::uuid", [project_id])
     Repo.all(pool, q)
     ```

  4. `error_breakdown_by_level` -- GROUP BY candidate:
     ```
     let q = Query.from("events")
       |> Query.select_raw(["level", "count(*)::text AS count"])
       |> Query.where_raw("project_id = ?::uuid AND received_at > now() - interval '24 hours'", [project_id])
       |> Query.group_by(:level)
       |> Query.order_by(:count, :desc)
     Repo.all(pool, q)
     ```

  Be pragmatic: if the Repo.query_raw version from Task 1 is already clean and readable, leave it. Only convert where the Query builder genuinely improves readability or composability. The goal is NOT to force everything through Query builder -- it's to provide the right tool for each job.

  A good heuristic: if the SQL has simple WHERE + ORDER BY + GROUP BY, the Query builder is better. If the SQL has complex subqueries, CASE WHEN, or multi-table operations, Repo.query_raw is better.

  After selective conversions, build mesher to verify compilation.
  </action>
  <verify>cd /Users/sn0w/Documents/dev/snow/mesher && ../target/debug/meshc build . 2>&1 | tail -5</verify>
  <done>Selected functions upgraded to Query builder where it improves readability; remaining complex queries use Repo.query_raw/execute_raw; zero Pool.query/Pool.execute calls in queries.mpl</done>
</task>

</tasks>

<verification>
1. `grep -c "Pool.query\|Pool.execute" mesher/storage/queries.mpl` returns 0
2. `grep -c "Repo.query_raw\|Repo.execute_raw\|Repo.all\|Repo.one\|Repo.get\|Repo.get_by\|Repo.insert\|Repo.delete\|Repo.exists\|Repo.count" mesher/storage/queries.mpl` shows all functions use Repo namespace
3. Mesher compiles: `cd mesher && ../target/debug/meshc build .`
4. All function signatures unchanged (no caller breakage)
</verification>

<success_criteria>
- Zero Pool.query/Pool.execute calls remain in queries.mpl
- All database access uses Repo.* namespace (mix of Repo.all/one/get/insert/delete + Repo.query_raw/execute_raw)
- Clean Query builder used where it adds value (simple WHERE + ORDER BY + GROUP BY patterns)
- Repo.query_raw/execute_raw used for complex analytics/PG-function-heavy queries
- Function signatures completely preserved
- Mesher compiles without new errors
</success_criteria>

<output>
After completion, create `.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-04-SUMMARY.md`
</output>
