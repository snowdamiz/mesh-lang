---
phase: 103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-rt/src/db/query.rs
  - crates/mesh-rt/src/db/repo.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-repl/src/jit.rs
autonomous: true

must_haves:
  truths:
    - "Query.select_raw(q, [\"count(*)::text AS count\", \"level\"]) produces SELECT with raw SQL expressions unquoted"
    - "Query.where_raw(q, \"expires_at > now()\", []) adds a raw WHERE clause without quoting"
    - "Query.where_raw with parameters works: Query.where_raw(q, \"status IN ($1, $2)\", [\"a\", \"b\"]) correctly numbers params"
    - "Existing Query.where and Query.select continue to work unchanged (no regressions)"
  artifacts:
    - path: "crates/mesh-rt/src/db/query.rs"
      provides: "select_raw and where_raw query builder functions"
      contains: "mesh_query_select_raw"
    - path: "crates/mesh-rt/src/db/repo.rs"
      provides: "Updated SQL builder that handles RAW: prefixed entries"
      contains: "RAW:"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-rt/src/db/query.rs"
      via: "known_functions + map_builtin_name"
      pattern: "mesh_query_select_raw"
    - from: "crates/mesh-rt/src/db/repo.rs"
      to: "crates/mesh-rt/src/db/query.rs"
      via: "slot access for SQL generation"
      pattern: "SLOT_SELECT"
---

<objective>
Add Query.select_raw and Query.where_raw to the Query builder, enabling raw SQL expressions in SELECT and WHERE clauses.

Purpose: Many remaining raw SQL calls in queries.mpl use PG functions (now(), count(*), date_trunc, crypt), type casts (::uuid, ::text), and operators (@>, ?) that cannot be expressed through the existing quoted-identifier Query.select and parameterized Query.where. These two extensions allow mixing safe parameterized queries with raw SQL fragments, covering Tier 2a-2h patterns identified in research.

Output: Two new Query builder functions with full compiler pipeline integration.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-RESEARCH.md
@crates/mesh-rt/src/db/query.rs
@crates/mesh-rt/src/db/repo.rs

Key design decisions from research:
- Q1 answer: Reuse SLOT_SELECT with "RAW:" prefix convention (no new slot, no ABI change)
- Q2 answer: Manual casts via where_raw fragments (no auto-casting from schema metadata)
- where_raw clause entries use "RAW:..." prefix that the SQL builder passes through without quoting
- select_raw entries use "RAW:..." prefix that bypasses quote_ident in SQL generation
- Parameter numbering must be handled carefully: where_raw params are appended to existing where_params list, and $N numbering continues sequentially from prior parameters in the SQL builder

Existing Query layout: 13 slots, 104 bytes. No change needed.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement select_raw and where_raw in query.rs runtime</name>
  <files>
    crates/mesh-rt/src/db/query.rs
  </files>
  <action>
  Add two new extern C functions to query.rs, following the exact same clone-and-modify pattern used by existing Query builder functions (e.g., mesh_query_select, mesh_query_where):

  1. `#[no_mangle] pub unsafe extern "C" fn mesh_query_select_raw(q: *mut u8, expressions: *mut u8) -> *mut u8`
     - Clone the query (allocate new 104-byte query via mesh_gc_alloc_actor, copy all slots)
     - Read `expressions` as a List<String> (same type as Query.select's fields parameter)
     - For each expression string in the list, prefix it with "RAW:" and append to the SLOT_SELECT list
     - Example: input ["count(*)::text AS count", "level"] -> stored as ["RAW:count(*)::text AS count", "RAW:level"]
     - Return the new query pointer

  2. `#[no_mangle] pub unsafe extern "C" fn mesh_query_where_raw(q: *mut u8, clause: *mut u8, params: *mut u8) -> *mut u8`
     - Clone the query (allocate new 104-byte query, copy all slots)
     - Read `clause` as a MeshString (the raw SQL WHERE clause, e.g., "expires_at > now()")
     - Read `params` as a List<String> (parameter values to bind, can be empty)
     - Prefix the clause with "RAW:" and append to SLOT_WHERE_CLAUSES list
     - Append all params to SLOT_WHERE_PARAMS list
     - The clause may contain $N placeholders. IMPORTANT: the clause should use relative placeholders that the SQL builder will renumber. Convention: use $1, $2, etc. in the raw clause, and the SQL builder will offset them to the correct absolute position based on how many params preceded them.
     - Actually, simpler approach: the raw clause should contain NO $N placeholders for its own params. Instead, the SQL builder in repo.rs will detect "RAW:" entries and append the clause verbatim, then number any param slots automatically. For params that need positional binding, the caller provides the values and the SQL builder appends `$N` references at the correct offsets.
     - SIMPLEST approach: The raw clause can reference `?` as parameter placeholder (or can simply use static SQL like "expires_at > now()"). The SQL builder in repo.rs, when it encounters a RAW: where clause, will replace each `?` with the next $N. The values in where_params correspond positionally.
     - Actually, the cleanest approach matching the existing pattern: The RAW: where clause is emitted verbatim. If it references parameters, those params are already in the where_params list. The SQL builder in repo.rs already numbers $1, $2, ... for where_params entries. We need to handle this: for normal where clauses, each clause consumes exactly one param (except IS NULL/IS NOT NULL). For RAW: clauses, the number of params consumed equals the number of params passed to where_raw. So store the param count with the clause: "RAW:2:status IN ($?, $?)" where 2 is the param count, and $? are replaced with the next available $N values.
     - FINAL DESIGN (simplest that works): RAW where clauses are stored as "RAW:{clause}" in where_clauses. The params are appended to where_params. The clause should contain `?` placeholders that get replaced with $N by the SQL builder. If the clause has no params (like "expires_at > now()"), params list is empty and no replacement occurs.
     - Return the new query pointer

  Both functions follow the identical allocation pattern as mesh_query_where:
  ```rust
  let new_q = mesh_gc_alloc_actor(QUERY_SIZE as u64, 8) as *mut u8;
  std::ptr::copy_nonoverlapping(q, new_q, QUERY_SIZE);
  // ... modify slots on new_q ...
  new_q
  ```
  </action>
  <verify>cargo build -p mesh-rt</verify>
  <done>mesh_query_select_raw and mesh_query_where_raw compile in mesh-rt and follow the clone-and-modify Query pattern</done>
</task>

<task type="auto">
  <name>Task 2: Update repo.rs SQL builder to handle RAW: prefixed entries + register compiler pipeline</name>
  <files>
    crates/mesh-rt/src/db/repo.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-typeck/src/infer.rs
    crates/mesh-repl/src/jit.rs
  </files>
  <action>
  **Part A: Update SQL builder in repo.rs**

  The `build_select_sql_from_parts` function (or equivalent SQL generation code in repo.rs) builds the SELECT and WHERE clauses from the Query slots. Update it to handle RAW: prefixed entries:

  1. **SELECT clause handling:**
     When iterating over select_fields (SLOT_SELECT), check if each entry starts with "RAW:":
     - If yes: strip the "RAW:" prefix and emit the expression verbatim (no quote_ident wrapping)
     - If no: apply quote_ident as before
     - If the select list contains a mix of RAW: and normal entries, emit them all comma-separated
     - Example: select_fields = ["RAW:count(*)::text AS count", "level"] -> `count(*)::text AS count, "level"`

  2. **WHERE clause handling:**
     When iterating over where_clauses (SLOT_WHERE_CLAUSES), check if each entry starts with "RAW:":
     - If yes: strip the "RAW:" prefix. The clause text may contain `?` placeholders.
       - Count the number of `?` in the clause
       - Replace each `?` with the next sequential `$N` (continuing from the current param_idx)
       - Advance param_idx by the number of `?` found
       - Append the clause to the WHERE part with AND
     - If no: handle as before (existing logic for "column op" format with IS NULL/IS NOT NULL detection)

     Important: param_idx must be tracked correctly across both normal and RAW: where clauses. Normal clauses that are NOT IS NULL/IS NOT NULL consume 1 param each. RAW: clauses consume N params where N is the count of `?` in the clause.

  **Part B: Register in compiler pipeline**

  Follow the exact pattern used for mesh_query_select and mesh_query_where:

  **crates/mesh-codegen/src/codegen/intrinsics.rs:**
  - `mesh_query_select_raw(ptr, ptr) -> ptr` (query, expressions_list -> new query)
  - `mesh_query_where_raw(ptr, ptr, ptr) -> ptr` (query, clause, params_list -> new query)

  **crates/mesh-codegen/src/mir/lower.rs:**
  - known_functions: `mesh_query_select_raw` -> FnPtr(vec![Ptr, Ptr], Box::new(Ptr))
  - known_functions: `mesh_query_where_raw` -> FnPtr(vec![Ptr, Ptr, Ptr], Box::new(Ptr))
  - map_builtin_name: "Query.select_raw" -> "mesh_query_select_raw"
  - map_builtin_name: "Query.where_raw" -> "mesh_query_where_raw"

  **crates/mesh-typeck/src/infer.rs:**
  Register in Query module type signatures:
  - Query.select_raw: (Ptr, List<String>) -> Ptr  [same shape as Query.select]
  - Query.where_raw: (Ptr, String, List<String>) -> Ptr  [query, clause, params -> query]

  **crates/mesh-repl/src/jit.rs:**
  - "mesh_query_select_raw" -> mesh_query_select_raw as *const u8
  - "mesh_query_where_raw" -> mesh_query_where_raw as *const u8

  Test full build: `cargo build -p mesh-rt && cargo build -p mesh-codegen && cargo build -p mesh-typeck`
  </action>
  <verify>cargo build -p mesh-rt && cargo build -p mesh-codegen && cargo build -p mesh-typeck && cargo build -p mesh-repl</verify>
  <done>Query.select_raw and Query.where_raw are fully integrated into the compiler pipeline; SQL builder correctly handles RAW: prefixed select and where entries with proper $N parameter numbering</done>
</task>

</tasks>

<verification>
1. `cargo build` -- full workspace compiles
2. `cargo test -p mesh-rt` -- existing tests pass, no regressions
3. Manual verification: the SQL builder correctly generates:
   - SELECT with RAW: entries emitted verbatim alongside quoted normal entries
   - WHERE with RAW: entries emitted verbatim, `?` replaced with correct $N, params sequenced correctly
</verification>

<success_criteria>
- Query.select_raw accepts a List<String> of raw SQL expressions and stores them with RAW: prefix
- Query.where_raw accepts a raw SQL clause string and params list, stores with RAW: prefix
- SQL builder in repo.rs correctly processes RAW: entries without quoting/escaping
- Parameter numbering ($1, $2, ...) is correct across mixed normal and RAW: clauses
- Existing Query.where and Query.select behavior unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-02-SUMMARY.md`
</output>
