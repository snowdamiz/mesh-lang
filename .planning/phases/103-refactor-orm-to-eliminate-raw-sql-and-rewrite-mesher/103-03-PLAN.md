---
phase: 103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-rt/src/db/repo.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-repl/src/jit.rs
autonomous: true

must_haves:
  truths:
    - "Repo.update_where(pool, table, fields, query) updates rows matching a Query's WHERE conditions"
    - "Repo.delete_where(pool, table, query) deletes rows matching a Query's WHERE conditions"
    - "Repo.query_raw(pool, sql, params) executes raw SQL and returns List<Map<String,String>>!String"
    - "Repo.execute_raw(pool, sql, params) executes raw SQL and returns Int!String"
    - "Existing Repo.insert, Repo.update, Repo.delete continue to work unchanged"
  artifacts:
    - path: "crates/mesh-rt/src/db/repo.rs"
      provides: "update_where, delete_where, query_raw, execute_raw runtime functions"
      contains: "mesh_repo_update_where"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Known function and builtin name mappings for new Repo functions"
      contains: "mesh_repo_delete_where"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-rt/src/db/repo.rs"
      via: "known_functions + map_builtin_name"
      pattern: "mesh_repo_update_where"
---

<objective>
Add Repo.update_where, Repo.delete_where, Repo.query_raw, and Repo.execute_raw to the Repo module.

Purpose: Many queries.mpl functions use UPDATE/DELETE with WHERE conditions beyond simple primary key (e.g., UPDATE issues SET status='resolved' WHERE id=$1 AND status!='resolved'). The current Repo.update only accepts an id. Repo.update_where accepts a Query with WHERE conditions. Repo.query_raw and Repo.execute_raw provide an explicit escape hatch for Tier 3 complex queries that are intentionally raw SQL, replacing the implicit Pool.query/Pool.execute pattern with a Repo-namespaced equivalent.

Output: Four new Repo functions with full compiler pipeline integration.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-RESEARCH.md
@crates/mesh-rt/src/db/repo.rs

Key patterns:
- Repo functions take pool as i64 (PoolHandle), return *mut u8 (MeshResult<Ptr>)
- Write operations use RETURNING * (returns Map<String,String>)
- ORM SQL builders in orm.rs: build_update_sql, build_delete_sql (pure Rust helpers)
- Pool.query -> mesh_pool_query(pool, sql, params) for row-returning queries
- Pool.execute uses same underlying function but returns affected count
- Query slots provide WHERE clause data via SLOT_WHERE_CLAUSES and SLOT_WHERE_PARAMS

Target use patterns:
- Repo.update_where(pool, "issues", %{"status" => "resolved"}, query) where query has .where(:id, id).where_op(:status, :neq, "resolved")
- Repo.delete_where(pool, "events", query) where query has .where(:issue_id, id)
- Repo.query_raw(pool, "SELECT ... complex SQL ...", ["param1", "param2"]) -> List<Map>!String
- Repo.execute_raw(pool, "UPDATE ... complex SQL ...", ["param1"]) -> Int!String
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement update_where, delete_where, query_raw, execute_raw in repo.rs</name>
  <files>
    crates/mesh-rt/src/db/repo.rs
    crates/mesh-rt/src/lib.rs
  </files>
  <action>
  Add four new extern C functions to repo.rs:

  1. `#[no_mangle] pub unsafe extern "C" fn mesh_repo_update_where(pool: i64, table: *mut u8, fields: *mut u8, query: *mut u8) -> *mut u8`
     - Read table as MeshString
     - Read fields as Map<String,String> (the SET columns, same extraction pattern as mesh_repo_insert)
     - Read query's SLOT_WHERE_CLAUSES and SLOT_WHERE_PARAMS for WHERE conditions
     - Build SQL: `UPDATE "table" SET "col1" = $1, "col2" = $2 WHERE <conditions> RETURNING *`
     - Parameter numbering: SET columns get $1..$N, WHERE clause params continue from $N+1
     - Handle RAW: prefixed where clauses (if Plan 02 is already done) -- pass through verbatim with `?` -> $N replacement
     - Handle normal where clauses with the existing "column op" format
     - Execute via mesh_pool_query (RETURNING * returns a row)
     - Return first row as ok_result(row_map), or err_result if no rows affected
     - IMPORTANT: If query has no WHERE clauses, return err_result("update_where: no WHERE conditions") to prevent accidental table-wide updates

  2. `#[no_mangle] pub unsafe extern "C" fn mesh_repo_delete_where(pool: i64, table: *mut u8, query: *mut u8) -> *mut u8`
     - Read table as MeshString
     - Read query's SLOT_WHERE_CLAUSES and SLOT_WHERE_PARAMS
     - Build SQL: `DELETE FROM "table" WHERE <conditions>`
     - Execute via mesh_pool_query with the SQL (Pool.execute returns affected count)
     - Return ok_result(count) as Int result
     - IMPORTANT: If query has no WHERE clauses, return err_result("delete_where: no WHERE conditions") to prevent accidental table-wide deletes

  3. `#[no_mangle] pub unsafe extern "C" fn mesh_repo_query_raw(pool: i64, sql: *mut u8, params: *mut u8) -> *mut u8`
     - Read sql as MeshString
     - Read params as List<String>
     - Execute the SQL string as-is via mesh_pool_query(pool, sql_ptr, params_list)
     - This is essentially an alias for Pool.query but namespaced under Repo for explicit "intentional raw SQL" semantics
     - Return the result directly (List<Map<String,String>>!String)

  4. `#[no_mangle] pub unsafe extern "C" fn mesh_repo_execute_raw(pool: i64, sql: *mut u8, params: *mut u8) -> *mut u8`
     - Read sql as MeshString
     - Read params as List<String>
     - Execute via the pool execute path (returns Int!String affected count)
     - Build the params list and call the underlying pool execute function
     - This is essentially Pool.execute namespaced under Repo

  For update_where and delete_where, extract the WHERE clause building logic into a shared helper function (e.g., `build_where_clause_from_query`) that reads SLOT_WHERE_CLAUSES and SLOT_WHERE_PARAMS and produces a WHERE SQL string with correct $N numbering starting from a given offset. This helper is also useful for the existing build_select_sql_from_parts, which does the same thing.

  Re-export in lib.rs if needed (follow the existing pattern for mesh_repo_insert etc.).
  </action>
  <verify>cargo build -p mesh-rt</verify>
  <done>Four new Repo functions compile in mesh-rt: update_where, delete_where, query_raw, execute_raw</done>
</task>

<task type="auto">
  <name>Task 2: Register all four new Repo functions in compiler pipeline</name>
  <files>
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-typeck/src/infer.rs
    crates/mesh-repl/src/jit.rs
  </files>
  <action>
  Register all four functions following the exact pattern of existing Repo functions (mesh_repo_insert, mesh_repo_delete, etc.):

  **crates/mesh-codegen/src/codegen/intrinsics.rs:**
  Declare LLVM function types:
  - `mesh_repo_update_where(i64, ptr, ptr, ptr) -> ptr` (pool, table, fields_map, query -> result)
  - `mesh_repo_delete_where(i64, ptr, ptr) -> ptr` (pool, table, query -> result)
  - `mesh_repo_query_raw(i64, ptr, ptr) -> ptr` (pool, sql, params -> result)
  - `mesh_repo_execute_raw(i64, ptr, ptr) -> ptr` (pool, sql, params -> result)

  **crates/mesh-codegen/src/mir/lower.rs:**
  known_functions entries:
  - `mesh_repo_update_where` -> FnPtr(vec![Int, Ptr, Ptr, Ptr], Box::new(Ptr))
  - `mesh_repo_delete_where` -> FnPtr(vec![Int, Ptr, Ptr], Box::new(Ptr))
  - `mesh_repo_query_raw` -> FnPtr(vec![Int, Ptr, Ptr], Box::new(Ptr))
  - `mesh_repo_execute_raw` -> FnPtr(vec![Int, Ptr, Ptr], Box::new(Ptr))

  map_builtin_name entries:
  - "Repo.update_where" -> "mesh_repo_update_where"
  - "Repo.delete_where" -> "mesh_repo_delete_where"
  - "Repo.query_raw" -> "mesh_repo_query_raw"
  - "Repo.execute_raw" -> "mesh_repo_execute_raw"

  **crates/mesh-typeck/src/infer.rs:**
  Register in Repo module type signatures:
  - Repo.update_where: (PoolHandle/Int, String, Map<String,String>, Ptr) -> Ptr [Result]
    Note: The table is String, fields is Map (resolves to Ptr at MIR level), query is Ptr
    Actually check existing Repo.insert signature pattern. It uses (Int, Ptr, Ptr) -> Ptr.
    Follow the same: Repo.update_where: (Int, Ptr, Ptr, Ptr) -> Ptr
  - Repo.delete_where: (Int, Ptr, Ptr) -> Ptr [pool, table, query -> Result]
  - Repo.query_raw: (Int, Ptr, Ptr) -> Ptr [pool, sql, params -> Result]
  - Repo.execute_raw: (Int, Ptr, Ptr) -> Ptr [pool, sql, params -> Result]

  Wait -- check how Repo.insert is typed in infer.rs. The PoolHandle is typed as Int in typeck. The table is String. The fields is Map<String,String>. But at MIR level everything except Int becomes Ptr. So:
  - Look at how Repo.insert is registered in infer.rs and follow that exact pattern for the return type (it returns a Result type, which is Ptr at MIR)

  **crates/mesh-repl/src/jit.rs:**
  - "mesh_repo_update_where" -> mesh_repo_update_where as *const u8
  - "mesh_repo_delete_where" -> mesh_repo_delete_where as *const u8
  - "mesh_repo_query_raw" -> mesh_repo_query_raw as *const u8
  - "mesh_repo_execute_raw" -> mesh_repo_execute_raw as *const u8

  Test: `cargo build -p mesh-codegen && cargo build -p mesh-typeck && cargo build -p mesh-repl`
  </action>
  <verify>cargo build -p mesh-rt && cargo build -p mesh-codegen && cargo build -p mesh-typeck && cargo build -p mesh-repl</verify>
  <done>All four new Repo functions registered across LLVM intrinsics, MIR lower, typeck, and JIT; full workspace builds cleanly</done>
</task>

</tasks>

<verification>
1. `cargo build` -- full workspace compiles
2. `cargo test -p mesh-rt` -- existing tests pass
3. New functions are callable from Mesh code: Repo.update_where, Repo.delete_where, Repo.query_raw, Repo.execute_raw
</verification>

<success_criteria>
- Repo.update_where builds UPDATE SET + WHERE from Map fields + Query conditions, returns updated row
- Repo.delete_where builds DELETE WHERE from Query conditions, returns affected count
- Repo.query_raw and Repo.execute_raw delegate to pool with explicit "intentional raw SQL" semantics
- No regression in existing Repo functions
- All four functions properly registered in compiler pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/103-refactor-orm-to-eliminate-raw-sql-and-rewrite-mesher/103-03-SUMMARY.md`
</output>
