---
phase: 90-real-time-streaming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-typeck/src/infer.rs
  - mesher/services/stream_manager.mpl
autonomous: true

must_haves:
  truths:
    - "Mesh code calling Ws.join, Ws.leave, Ws.broadcast, Ws.broadcast_except compiles without typechecker errors"
    - "StreamManager service can track per-connection subscription state including project_id and filter criteria"
    - "StreamManager supports registering, querying, and removing connection state"
  artifacts:
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Ws.join, Ws.leave, Ws.broadcast, Ws.broadcast_except type signatures in ws_mod"
      contains: "ws_mod.insert(\"join\""
    - path: "mesher/services/stream_manager.mpl"
      provides: "StreamManager service with per-connection filter state and buffer management"
      contains: "service StreamManager"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "ws_mod entries match lowerer ws_join/ws_leave/ws_broadcast/ws_broadcast_except mappings"
      pattern: "ws_mod\\.insert.*join"
    - from: "mesher/services/stream_manager.mpl"
      to: "mesher/ingestion/ws_handler.mpl"
      via: "StreamManager.register_client and StreamManager.remove_client called from WS callbacks"
      pattern: "StreamManager"
---

<objective>
Add WebSocket room function type signatures to the Mesh typechecker and create the StreamManager service for per-connection subscription state management.

Purpose: The four room functions (Ws.join, Ws.leave, Ws.broadcast, Ws.broadcast_except) are fully implemented in the runtime (rooms.rs) and codegen (intrinsics.rs, lower.rs) but missing from the typechecker (infer.rs). Without these entries, any Mesh code calling them fails to compile. The StreamManager service provides the stateful per-connection tracking needed for filtered event delivery and backpressure.

Output: Typechecker entries enabling Ws room functions in Mesh code; StreamManager service module.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/90-real-time-streaming/90-RESEARCH.md

# Key source files
@crates/mesh-typeck/src/infer.rs (lines 864-881 -- ws_mod with only send/serve entries)
@crates/mesh-codegen/src/mir/lower.rs (lines 733-741 -- known_functions for room intrinsics; lines 9867-9870 -- ws_join/ws_leave/ws_broadcast/ws_broadcast_except name mappings)
@mesher/services/writer.mpl (reference pattern for service + ticker actor)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Ws room function type signatures to typechecker</name>
  <files>crates/mesh-typeck/src/infer.rs</files>
  <action>
Add four entries to the `ws_mod` HashMap in `stdlib_modules()` in `infer.rs`, after the existing `Ws.send` and `Ws.serve` entries (around line 880, before `modules.insert("Ws", ws_mod)`).

The type signatures must match the runtime function signatures in rooms.rs and the codegen mappings in lower.rs:

```rust
// Ws.join: fn(Int, String) -> Int  (conn_handle, room_name -> 0 success)
ws_mod.insert("join".to_string(), Scheme::mono(Ty::fun(
    vec![Ty::int(), Ty::string()],
    Ty::int(),
)));
// Ws.leave: fn(Int, String) -> Int  (conn_handle, room_name -> 0 success)
ws_mod.insert("leave".to_string(), Scheme::mono(Ty::fun(
    vec![Ty::int(), Ty::string()],
    Ty::int(),
)));
// Ws.broadcast: fn(String, String) -> Int  (room_name, message -> failure_count)
ws_mod.insert("broadcast".to_string(), Scheme::mono(Ty::fun(
    vec![Ty::string(), Ty::string()],
    Ty::int(),
)));
// Ws.broadcast_except: fn(String, String, Int) -> Int  (room, msg, except_conn -> failure_count)
ws_mod.insert("broadcast_except".to_string(), Scheme::mono(Ty::fun(
    vec![Ty::string(), Ty::string(), Ty::int()],
    Ty::int(),
)));
```

Cross-reference: lower.rs maps `ws_join` -> `mesh_ws_join`, `ws_leave` -> `mesh_ws_leave`, `ws_broadcast` -> `mesh_ws_broadcast`, `ws_broadcast_except` -> `mesh_ws_broadcast_except` (lines 9867-9870). The known_functions entries (lines 734-741) already have the correct LLVM types. The intrinsics.rs declarations also exist. Only the typechecker entries are missing.

Note: `conn` is typed as `Int` at the Mesh level (pointer cast to i64), consistent with `Ws.send: fn(Int, String) -> Int`.
  </action>
  <verify>Run `cargo build -p mesh-typeck` to verify the typechecker compiles. Then create a minimal test .mpl file that calls `Ws.join(0, "test")`, `Ws.leave(0, "test")`, `Ws.broadcast("room", "msg")`, and `Ws.broadcast_except("room", "msg", 0)` and verify it passes type checking (compiles without "unknown function" errors).</verify>
  <done>All four Ws room functions have entries in ws_mod in infer.rs. Mesh code calling Ws.join, Ws.leave, Ws.broadcast, Ws.broadcast_except compiles without type errors. cargo build -p mesh-typeck succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Create StreamManager service for per-connection state</name>
  <files>mesher/services/stream_manager.mpl</files>
  <action>
Create `mesher/services/stream_manager.mpl` with a service that tracks per-connection subscription state (project_id, filters, message buffer) for WebSocket streaming clients.

Follow the established service pattern from `mesher/services/writer.mpl` -- helper functions outside the service block, minimal service handler bodies.

**Struct definitions:**

```mesh
struct ConnectionState do
  project_id :: String
  level_filter :: String      # "" means no filter (accept all)
  env_filter :: String        # "" means no filter (accept all)
  buffer :: List<String>      # pending messages for slow client
  buffer_len :: Int
  max_buffer :: Int           # drop oldest when exceeded (default 100)
end

struct StreamState do
  connections :: Map<Int, ConnectionState>  # conn_handle -> state
end
```

Use simple String fields for filters (level_filter, env_filter) instead of `Map<String, String>` to avoid Map.collect integer key assumption (known limitation). Empty string "" means "no filter" (accept all).

**Service definition:**

```mesh
service StreamManager do
  fn init() -> StreamState do
    StreamState { connections: Map.new() }
  end

  # Register a streaming client connection with project and filter preferences
  cast RegisterClient(conn :: Int, project_id :: String, level_filter :: String, env_filter :: String) do |state|
    register_client(state, conn, project_id, level_filter, env_filter)
  end

  # Remove a connection (called on disconnect)
  cast RemoveClient(conn :: Int) do |state|
    remove_client(state, conn)
  end

  # Check if a connection is a streaming client (vs ingestion client)
  call IsStreamClient(conn :: Int) :: Bool do |state|
    (state, is_stream_client(state, conn))
  end

  # Get the project_id for a streaming client
  call GetProjectId(conn :: Int) :: String do |state|
    (state, get_project_id(state, conn))
  end

  # Check if an event matches a connection's filters
  call MatchesFilter(conn :: Int, level :: String, environment :: String) :: Bool do |state|
    (state, matches_filter(state, conn, level, environment))
  end
end
```

**Helper functions** (outside service block):

- `register_client(state, conn, project_id, level_filter, env_filter)` -- creates ConnectionState, puts into connections map
- `remove_client(state, conn)` -- removes from connections map via Map.remove
- `is_stream_client(state, conn)` -- checks Map.has_key(state.connections, conn)
- `get_project_id(state, conn)` -- returns cs.project_id or "" if not found
- `matches_filter(state, conn, level, environment)` -- checks if event's level/environment match the connection's filters. Empty filter string means "accept all". Both filters must match (AND logic).

Use Map.has_key for existence checks. Use Map.get for retrieval. Return sensible defaults ("", false) when connection not found.

Note: Backpressure buffering (STREAM-05) is handled here conceptually but the actual buffer drain mechanism will be wired in Plan 02 via a ticker actor pattern (same as flush_ticker in writer.mpl).
  </action>
  <verify>Verify the file compiles as part of the Mesher build: `cd mesher && ../target/debug/meshc build .` (or equivalent build command). Verify service struct fields and function signatures are syntactically correct Mesh code. Check that imports are minimal (no external dependencies needed for this service).</verify>
  <done>StreamManager service exists at mesher/services/stream_manager.mpl with RegisterClient, RemoveClient, IsStreamClient, GetProjectId, and MatchesFilter handlers. ConnectionState struct tracks project_id, level/env filters, and buffer. All helper functions are outside the service block per established pattern.</done>
</task>

</tasks>

<verification>
1. `cargo build -p mesh-typeck` succeeds with the new ws_mod entries
2. A test Mesh file using Ws.join/Ws.leave/Ws.broadcast/Ws.broadcast_except compiles without type errors
3. StreamManager service module exists and follows established service patterns
4. No existing tests are broken by the typechecker additions
</verification>

<success_criteria>
- Ws.join, Ws.leave, Ws.broadcast, Ws.broadcast_except are callable from Mesh code (typechecker entries present)
- StreamManager service can register/query/remove per-connection streaming state
- cargo build succeeds for the typechecker crate
</success_criteria>

<output>
After completion, create `.planning/phases/90-real-time-streaming/90-01-SUMMARY.md`
</output>
