---
phase: 88-ingestion-pipeline
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - mesher/ingestion/pipeline.mpl
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Crashed pipeline services (RateLimiter, EventProcessor, StorageWriter) are automatically restarted"
    - "System continues processing events after a service crash and restart"
    - "Restart behavior is observable via log output"
  artifacts:
    - path: "mesher/ingestion/pipeline.mpl"
      provides: "Process.monitor-based restart watcher that detects service crashes and restarts them"
      contains: "Process.monitor"
  key_links:
    - from: "mesher/ingestion/pipeline.mpl (restart watcher)"
      to: "crates/mesh-rt/src/actor/mod.rs (mesh_process_monitor)"
      via: "Process.monitor runtime function monitors service PIDs"
      pattern: "Process\\.monitor"
    - from: "mesher/ingestion/pipeline.mpl (restart watcher)"
      to: "mesher/ingestion/pipeline.mpl (start_pipeline)"
      via: "Restart watcher re-starts crashed services and updates PipelineRegistry"
      pattern: "restart"
---

<objective>
Implement Process.monitor-based restart logic for pipeline services so crashed actors are automatically restarted, closing Gap 2 from VERIFICATION.md.

Purpose: Closes Gap 2 (Truth 7 partial) -- supervision restart logic not implemented. RESIL-01 and RESIL-03 requirements blocked. The supervisor block syntax has known LLVM codegen issues with service.start() in child spec closures, so this plan uses the Process.monitor approach instead: monitor service PIDs, receive DOWN messages on crash, and restart the failed service.

Output: Self-healing pipeline that automatically restarts crashed services via Process.monitor + receive loop.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/88-ingestion-pipeline/88-03-SUMMARY.md

# Key source files
@mesher/ingestion/pipeline.mpl
@crates/mesh-rt/src/actor/mod.rs
@crates/mesh-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Process.monitor-based restart watcher to pipeline.mpl</name>
  <files>mesher/ingestion/pipeline.mpl</files>
  <action>
The current `start_pipeline` function starts services manually without restart logic. The supervisor block syntax cannot be used (LLVM struct type issues with service.start() in child spec closures -- see 88-03 decisions).

Instead, implement restart behavior using `Process.monitor` and a watcher actor that:
1. Monitors each service PID after startup
2. Receives DOWN messages when a monitored service crashes
3. Restarts the crashed service and re-monitors the new PID
4. Updates PipelineRegistry with the new PID

**Implementation approach:**

Add a `pipeline_watcher` actor function that uses the actor receive loop pattern. The watcher:
- Takes (pool, rate_limiter_pid, processor_pid, writer_pid, registry_pid) as initial context
- Monitors all three service PIDs via Process.monitor
- Loops on receive waiting for DOWN messages
- When a DOWN is received, identifies which service crashed (by comparing PIDs), restarts it, monitors the new PID, and continues the loop

The DOWN message format from the runtime (mesh_process_monitor in actor/mod.rs line 1120) delivers a tuple message when a monitored process exits. The runtime sends a message with tag=DOWN containing (monitor_ref, pid, reason).

In Mesh, the receive pattern for DOWN messages needs to match the runtime's delivery format. Check how Process.monitor DOWN messages are received in Mesh -- the runtime calls `mesh_actor_send` to the monitoring process with a DOWN-tagged message.

Looking at the runtime code (actor/mod.rs), when a monitored process exits, `deliver_down_message` sends a message. The message format is a 3-tuple: (monitor_ref: Int, pid: Int, reason: String). In Mesh, this arrives as a regular message that can be received with `receive`.

**Simplified approach using a recursive watcher actor:**

Since Mesh actors use the `receive` primitive and Mesh has no mutable variables, use a recursive function pattern:

```mesh
# Watcher actor: monitors services and restarts on crash.
# Runs as a spawned actor in a receive loop.
fn pipeline_watcher(pool :: PoolHandle, registry_pid :: Pid) do
  # Get current service PIDs from registry
  let rl_pid = PipelineRegistry.get_rate_limiter(registry_pid)
  let proc_pid = PipelineRegistry.get_processor(registry_pid)
  let wr_pid = PipelineRegistry.get_writer(registry_pid)

  # Monitor all services
  let _ = Process.monitor(rl_pid)
  let _ = Process.monitor(proc_pid)
  let _ = Process.monitor(wr_pid)

  # Enter restart loop
  watch_loop(pool, registry_pid)
end

fn watch_loop(pool :: PoolHandle, registry_pid :: Pid) do
  # Receive any message (DOWN messages arrive here)
  let msg = receive()
  println("[Mesher] Service DOWN detected, restarting...")

  # Restart all services (simpler than identifying which one crashed)
  # This is the "one_for_all" restart strategy
  let new_rl = RateLimiter.start(60, 1000)
  let new_proc = EventProcessor.start(pool)
  let new_wr = StorageWriter.start(pool, "default")

  # Re-monitor new PIDs
  let _ = Process.monitor(new_rl)
  let _ = Process.monitor(new_proc)
  let _ = Process.monitor(new_wr)

  # Update registry with new PIDs
  # Note: PipelineRegistry itself needs to be notified of new PIDs.
  # Since PipelineRegistry is a service, we can add a cast to update PIDs.
  # For simplicity in this gap closure, restart the registry too.
  let new_registry = PipelineRegistry.start(pool, new_rl, new_proc, new_wr)
  let _ = Process.register("mesher_registry", new_registry)

  println("[Mesher] Services restarted")

  # Continue watching
  watch_loop(pool, new_registry)
end
```

**IMPORTANT considerations:**
- Check whether `receive()` (no-arg) is supported in Mesh typeck. Look at the Process module types in infer.rs. If not, the runtime's `mesh_actor_receive` is exposed as `receive`. Check how it's typed.
- If `receive()` doesn't exist as a bare function in typeck, use a different approach: the watcher can use `Process.monitor` and then periodically check if PIDs are alive using a timer + process alive check. However, `receive` IS the standard Erlang/OTP pattern.
- The Mesh runtime delivers DOWN messages to the monitoring actor's mailbox. The `receive` keyword should work if it's defined in the language.

Check the parser and typeck for `receive` support. If `receive` is a keyword (RECEIVE_KW), check how it's used. If it takes a timeout or pattern, adapt accordingly.

**Fallback if receive() is not available as a function:**
Use a timer-based polling approach:
```mesh
fn watch_loop(pool, registry_pid, rl_pid, proc_pid, wr_pid) do
  Timer.sleep(1000)  # Check every second
  # Try to call each service; if it fails, it crashed
  # Restart and recurse
  watch_loop(pool, registry_pid, rl_pid, proc_pid, wr_pid)
end
```

This is less elegant but works without receive().

**Modify start_pipeline to spawn the watcher:**
At the end of `start_pipeline`, after registering PipelineRegistry, add:
```mesh
  # Spawn restart watcher
  spawn pipeline_watcher(pool, registry_pid)
  println("[Mesher] Pipeline watcher started (auto-restart enabled)")
```

The watcher runs as a separate actor monitoring all service PIDs.
  </action>
  <verify>
1. `cargo run -p meshc -- mesher/ingestion/pipeline.mpl` compiles without errors (check the module in isolation or as part of main)
2. pipeline.mpl contains `Process.monitor` calls
3. pipeline.mpl contains a `pipeline_watcher` or equivalent restart actor
4. `start_pipeline` spawns the watcher actor
5. The watcher uses recursive loop pattern (no mutable state)
  </verify>
  <done>
pipeline.mpl contains a Process.monitor-based restart watcher that monitors service PIDs, detects crashes via DOWN messages or periodic checks, restarts failed services, and continues monitoring. start_pipeline spawns this watcher. RESIL-01 (supervision trees) and RESIL-03 (self-healing restart) requirements are satisfied via the Process.monitor approach.
  </done>
</task>

</tasks>

<verification>
1. meshc compiles pipeline.mpl (within the mesher project) without errors
2. pipeline.mpl has Process.monitor calls for service PIDs
3. A watcher/supervisor actor is spawned that restarts crashed services
4. The restart loop is recursive (Mesh pattern -- no mutable variables)
5. Log output indicates restart monitoring is active
</verification>

<success_criteria>
- Gap 2 (Supervision Restart Logic Not Implemented) is closed
- RESIL-01 requirement (supervision trees for pipeline) is satisfied via Process.monitor watcher
- RESIL-03 requirement (self-healing via restart) is satisfied -- crashed services are restarted
- No regression in existing pipeline functionality
</success_criteria>

<output>
After completion, create `.planning/phases/88-ingestion-pipeline/88-05-SUMMARY.md`
</output>
