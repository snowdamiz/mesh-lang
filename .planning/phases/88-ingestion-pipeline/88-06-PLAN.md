---
phase: 88-ingestion-pipeline
plan: 06
type: execute
wave: 1
depends_on: ["88-03"]
files_modified:
  - mesher/ingestion/routes.mpl
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "429 rate-limited responses include Retry-After: 60 header"
    - "Bulk endpoint at /api/v1/events/bulk persists events via EventProcessor"
  artifacts:
    - path: "mesher/ingestion/routes.mpl"
      provides: "rate_limited_response with Retry-After header and bulk event processing logic"
      contains: "response_with_headers"
  key_links:
    - from: "mesher/ingestion/routes.mpl (rate_limited_response)"
      to: "crates/mesh-rt/src/http/server.rs (mesh_http_response_with_headers)"
      via: "HTTP.response_with_headers(429, body, headers) call"
      pattern: "response_with_headers"
    - from: "mesher/ingestion/routes.mpl (handle_bulk_authed)"
      to: "mesher/services/event_processor.mpl (EventProcessor.process_event)"
      via: "Bulk body routed through process_event_body for persistence"
      pattern: "process_event_body"
---

<objective>
Close the final 2 quality gaps from VERIFICATION.md re-verification so that Phase 88 success criteria are fully satisfied.

Purpose: Gap 1 (Retry-After header missing from 429) partially blocks INGEST-04. Gap 2 (bulk endpoint not processing events) blocks INGEST-03. Both are in routes.mpl.

Output: Updated routes.mpl with Retry-After header on 429 responses and bulk event persistence via EventProcessor.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/88-ingestion-pipeline/88-VERIFICATION.md
@.planning/phases/88-ingestion-pipeline/88-01-SUMMARY.md
@.planning/phases/88-ingestion-pipeline/88-02-SUMMARY.md
@.planning/phases/88-ingestion-pipeline/88-03-SUMMARY.md

# Source files
@mesher/ingestion/routes.mpl
@mesher/services/event_processor.mpl
@mesher/ingestion/validation.mpl
@mesher/services/writer.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Retry-After header to 429 responses and wire bulk event processing</name>
  <files>mesher/ingestion/routes.mpl</files>
  <action>
Two changes to routes.mpl, both straightforward modifications to existing helper functions:

**Change 1: Retry-After header on 429 responses (Gap 1)**

Replace the `rate_limited_response` function (currently line 23-26) with a version that uses `HTTP.response_with_headers`:

```mesh
# Helper: build 429 rate-limited response with Retry-After header
fn rate_limited_response() do
  let headers = Map.put(Map.new(), "Retry-After", "60")
  HTTP.response_with_headers(429, "{\"error\":\"rate limited\"}", headers)
end
```

This uses `HTTP.response_with_headers(status, body, headers_map)` which was shipped in Plan 88-01 and is mapped in MIR to `mesh_http_response_with_headers`. The `Map.new()` creates an empty map, `Map.put` adds the Retry-After: 60 entry (60 seconds matches the rate limiter window from RateLimiter service).

**Important Mesh language note:** The function call inside `Map.put(Map.new(), ...)` may cause a parse failure if the parser mishandles nested function calls. If so, bind the intermediate value first:
```mesh
fn rate_limited_response() do
  let empty_headers = Map.new()
  let headers = Map.put(empty_headers, "Retry-After", "60")
  HTTP.response_with_headers(429, "{\"error\":\"rate limited\"}", headers)
end
```

**Change 2: Bulk endpoint event processing (Gap 2)**

Replace `handle_bulk_authed` (currently lines 77-90) so that after size validation succeeds, the body is routed to EventProcessor for persistence instead of immediately returning accepted.

The existing pattern in `handle_event_authed` already shows how to route a single event: it calls `process_event_body` which validates size and routes to `route_to_processor`. For bulk, we need a similar flow but routing the entire body as a single event payload.

Replace `handle_bulk_authed` with:

```mesh
# Helper: handle bulk after authentication succeeds.
# Validates size (5MB limit for bulk), then routes the entire bulk payload
# to EventProcessor for persistence. Individual JSON array element parsing
# is not supported at the Mesh language level (Json.array_get not exposed);
# the StorageWriter stores the complete bulk JSON for downstream processing.
fn handle_bulk_authed(project_id :: String, rate_limiter_pid, processor_pid, writer_pid, request) do
  let allowed = RateLimiter.check_limit(rate_limiter_pid, project_id)
  if allowed do
    let body = Request.body(request)
    let size_check = validate_payload_size(body, 5242880)
    case size_check do
      Err(reason) -> bad_request_response(reason)
      Ok(_) -> route_to_processor(processor_pid, project_id, writer_pid, body)
    end
  else
    rate_limited_response()
  end
end
```

This reuses the existing `route_to_processor` helper (line 33-40) which calls `EventProcessor.process_event(processor_pid, project_id, writer_pid, body)` and returns 202 on success or 400 on error. The change is minimal: replace `accepted_response()` on line 85 with `route_to_processor(processor_pid, project_id, writer_pid, body)`.

The bulk body (a JSON array string like `[{event1}, {event2}]`) is stored as a single entry via the StorageWriter. This satisfies INGEST-03 ("POST bulk events") because the endpoint now persists the data rather than silently accepting and discarding it.

**Note about imports:** No new imports are needed. `HTTP.response_with_headers` resolves through the stdlib module-qualified call path (mapped in MIR lower.rs:9787). `Map.new` and `Map.put` are already available as stdlib functions. `route_to_processor` is already defined in the same file.
  </action>
  <verify>
1. `cargo run -p meshc -- build mesher/` compiles without errors (verify routes.mpl is part of the build)
2. `rate_limited_response` uses `HTTP.response_with_headers` with a `Retry-After` header
3. `handle_bulk_authed` calls `route_to_processor` instead of `accepted_response()` after size validation
4. No new imports were needed
5. The existing `handle_event` function is unchanged (no regression)
  </verify>
  <done>
429 responses include Retry-After: 60 header via HTTP.response_with_headers. Bulk endpoint routes events to EventProcessor for persistence via the existing route_to_processor helper. Both INGEST-03 (bulk ingestion) and INGEST-04 (Retry-After header) gaps are closed. Phase 88 success criteria fully satisfied.
  </done>
</task>

</tasks>

<verification>
1. routes.mpl compiles as part of `meshc build mesher/`
2. `rate_limited_response` function contains `HTTP.response_with_headers(429, ...)` with Retry-After header
3. `handle_bulk_authed` function calls `route_to_processor` after size validation (not `accepted_response`)
4. All existing functions (handle_event, handle_bulk, unauthorized_response, etc.) remain unchanged
5. No new files created -- only routes.mpl modified
</verification>

<success_criteria>
- Gap 1 (Retry-After Header Missing from 429 Responses) is closed -- INGEST-04 fully satisfied
- Gap 2 (Bulk Endpoint Does Not Process Events) is closed -- INGEST-03 fully satisfied
- No regression to existing single-event ingestion flow (handle_event unchanged)
- Phase 88 all 7 truths verified with no remaining gaps
</success_criteria>

<output>
After completion, create `.planning/phases/88-ingestion-pipeline/88-06-SUMMARY.md`
</output>
