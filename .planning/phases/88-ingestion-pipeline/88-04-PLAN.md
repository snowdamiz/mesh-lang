---
phase: 88-ingestion-pipeline
plan: 04
type: execute
wave: 1
depends_on: ["88-03"]
files_modified:
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - mesher/main.mpl
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Ws.serve(ws_on_connect, ws_on_message, ws_on_close, 8081) compiles without type inference errors"
    - "WebSocket server starts on port 8081 when mesher binary launches"
    - "Client can connect to ws://localhost:8081 and send/receive messages"
  artifacts:
    - path: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      provides: "Single, correct mesh_ws_serve intrinsic declaration (7 args: 3 fn/env pairs + port)"
      contains: "mesh_ws_serve"
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "codegen_call handles bare function names passed to intrinsics expecting fn_ptr/env_ptr pairs"
      contains: "codegen_call"
    - path: "mesher/main.mpl"
      provides: "Ws.serve call with WebSocket callbacks on port 8081"
      contains: "Ws.serve"
  key_links:
    - from: "mesher/main.mpl"
      to: "crates/mesh-rt/src/ws/server.rs"
      via: "Ws.serve -> mesh_ws_serve runtime function"
      pattern: "Ws\\.serve"
    - from: "crates/mesh-codegen/src/codegen/expr.rs"
      to: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      via: "codegen_call splits fn args into fn_ptr/env_ptr pairs matching intrinsic signature"
      pattern: "fn_ptr.*env_ptr"
---

<objective>
Fix the Ws.serve codegen so bare function references are correctly split into fn_ptr/env_ptr pairs when calling runtime intrinsics, then wire the WebSocket server in main.mpl.

Purpose: Closes Gap 1 from VERIFICATION.md -- WebSocket server not started (Truth 5 failed, INGEST-05 blocked). The callbacks exist in ws_handler.mpl but Ws.serve was deferred due to a type inference cascade error that is actually a codegen argument-count mismatch.

Output: Working Ws.serve call in main.mpl, correct intrinsic declarations, codegen that handles bare functions passed to intrinsics expecting closure pairs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/88-ingestion-pipeline/88-03-SUMMARY.md

# Key source files for understanding the problem
@crates/mesh-codegen/src/codegen/intrinsics.rs
@crates/mesh-codegen/src/codegen/expr.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-rt/src/ws/server.rs
@crates/mesh-typeck/src/infer.rs
@mesher/main.mpl
@mesher/ingestion/ws_handler.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix mesh_ws_serve intrinsic declaration and bare-function codegen for fn_ptr/env_ptr splitting</name>
  <files>
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-codegen/src/codegen/expr.rs
  </files>
  <action>
There are two bugs preventing Ws.serve from compiling:

**Bug A: Duplicate intrinsic declarations in intrinsics.rs**

There are TWO `mesh_ws_serve` declarations in `declare_intrinsics`:
1. Line ~430-431 (Phase 60, CORRECT): 7 args -- `(on_connect_fn: ptr, on_connect_env: ptr, on_message_fn: ptr, on_message_env: ptr, on_close_fn: ptr, on_close_env: ptr, port: i64)`
2. Line ~813-816 (Phase 88 addition, WRONG): 4 args -- `(on_connect: ptr, on_message: ptr, on_close: ptr, port: i64)`

Similarly, `mesh_ws_send` has a duplicate:
1. Line ~434 (Phase 60, CORRECT): `(conn: ptr, msg: ptr) -> i64`
2. Line ~808-811 (Phase 88 addition, WRONG): `(conn: i64, msg: ptr) -> i64`

Fix: Remove the Phase 88 duplicate declarations at lines ~808-816. The Phase 60 declarations at lines ~430-440 are correct and match the runtime signatures in `mesh-rt/src/ws/server.rs`. The duplicates were erroneously added during 88-03 planning.

**Bug B: codegen_call does not split bare function references into fn_ptr/env_ptr pairs**

In `codegen_call` (expr.rs line ~607-646), the closure splitting logic checks `matches!(arg.ty(), MirType::Closure(_, _))`. When Ws.serve is called with bare function names like `ws_on_connect`, these resolve to `MirType::FnPtr(...)` in the MIR (not `MirType::Closure`), so the fn_ptr/env_ptr split is skipped. This produces 4 arguments (3 fn_ptrs + port) instead of the 7 that `mesh_ws_serve` expects (3 fn_ptr/env_ptr pairs + port).

Fix: In the `codegen_call` argument loop (expr.rs, the `for arg in args` loop around line 611), extend the closure-splitting condition to also handle `MirType::FnPtr(...)` arguments when the callee is a runtime intrinsic (not a user function). For `MirType::FnPtr` args:
1. The compiled value IS the fn_ptr (a pointer to the function)
2. The env_ptr should be `null` (bare functions have no closure environment)

Add a second branch after the existing `MirType::Closure` branch:
```rust
} else if matches!(arg.ty(), MirType::FnPtr(_, _)) && !is_user_fn {
    // Bare function reference passed to runtime intrinsic.
    // Runtime expects (fn_ptr, env_ptr) pairs; env_ptr is null for non-closures.
    let ptr_ty = self.context.ptr_type(inkwell::AddressSpace::default());
    arg_vals.push(val.into());
    arg_vals.push(ptr_ty.const_null().into());
    _has_closure_args = true;
} else {
```

This ensures bare functions passed to runtime intrinsics like mesh_ws_serve, mesh_list_sort, mesh_iter_map etc. get properly paired with null env pointers.

Important: The `is_user_fn` check prevents this from applying to calls between user-defined Mesh functions, which pass function values as-is (single pointer or closure struct).
  </action>
  <verify>
1. `cargo build -p mesh-codegen` compiles without errors
2. `cargo test -p mesh-codegen` -- all existing tests pass (including intrinsic declaration tests)
3. Grep intrinsics.rs to confirm only ONE `mesh_ws_serve` declaration exists
4. Grep intrinsics.rs to confirm only ONE `mesh_ws_send` declaration exists
  </verify>
  <done>
mesh_ws_serve has a single correct 7-arg intrinsic declaration. codegen_call correctly splits bare FnPtr arguments into (fn_ptr, null_env) pairs for runtime intrinsics. All existing codegen tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Ws.serve call in main.mpl to start WebSocket server</name>
  <files>mesher/main.mpl</files>
  <action>
Add the Ws.serve call to main.mpl's `start_services` function, AFTER the HTTP server setup.

The current code ends with:
```
  println("[Mesher] HTTP server starting on :8080")
  HTTP.serve(r, 8080)
end
```

HTTP.serve blocks the calling thread (it's the main event loop). The WebSocket server also blocks. To run both, the WS server needs to start BEFORE HTTP.serve (which blocks). Alternatively, spawn the WS server in a separate actor.

The simplest approach: Start WS server in a spawned actor, then block on HTTP.serve in the main flow.

Replace the end of `start_services` with:
```mesh
  # Start WebSocket server in background actor (Ws.serve blocks)
  spawn ws_server(8081)

  println("[Mesher] HTTP server starting on :8080")
  HTTP.serve(r, 8080)
end

fn ws_server(port :: Int) do
  println("[Mesher] WebSocket server starting on :" <> String.from(port))
  Ws.serve(ws_on_connect, ws_on_message, ws_on_close, port)
end
```

This spawns a separate actor to run `Ws.serve(ws_on_connect, ws_on_message, ws_on_close, 8081)` which blocks that actor's thread on the TCP listener loop, while the main flow continues to `HTTP.serve(r, 8080)`.

Note: The ws_on_connect, ws_on_message, ws_on_close functions are already imported at the top of main.mpl from `Ingestion.WsHandler`.

After the change, verify meshc builds the file without type inference errors:
```
cargo run -p meshc -- mesher/main.mpl --check
```
Or if meshc doesn't have --check, just run the compiler and check exit code.
  </action>
  <verify>
1. `cargo run -p meshc -- mesher/main.mpl` compiles without errors (or builds the mesher binary)
2. The generated LLVM IR contains a call to `mesh_ws_serve` with 7 arguments
3. The ws_on_connect, ws_on_message, ws_on_close imports are no longer "unused" (they're now passed to Ws.serve)
  </verify>
  <done>
main.mpl contains Ws.serve(ws_on_connect, ws_on_message, ws_on_close, 8081) call in a spawned actor. meshc compiles main.mpl without type inference or codegen errors. WebSocket server will start on port 8081 alongside the HTTP server on port 8080.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p mesh-codegen` succeeds
2. `cargo test -p mesh-codegen` all tests pass
3. `cargo build -p mesh-rt` succeeds (runtime unchanged but confirm)
4. meshc compiles mesher/main.mpl without errors
5. Only one `mesh_ws_serve` intrinsic declaration exists in intrinsics.rs
6. main.mpl contains Ws.serve call with the three callback functions
</verification>

<success_criteria>
- Gap 1 (WebSocket Server Not Started) is closed
- INGEST-05 requirement (WebSocket event streaming) is unblocked
- Ws.serve compiles and generates correct LLVM IR with 7 arguments
- No regression in existing codegen tests
</success_criteria>

<output>
After completion, create `.planning/phases/88-ingestion-pipeline/88-04-SUMMARY.md`
</output>
