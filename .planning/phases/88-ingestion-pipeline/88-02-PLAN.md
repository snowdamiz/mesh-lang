---
phase: 88-ingestion-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["88-01"]
files_modified:
  - mesher/services/rate_limiter.mpl
  - mesher/services/event_processor.mpl
  - mesher/ingestion/auth.mpl
  - mesher/ingestion/validation.mpl
autonomous: true

must_haves:
  truths:
    - "RateLimiter service tracks per-project event counts in a time window and returns allowed/denied with retry-after seconds"
    - "EventProcessor service validates events and routes valid ones to StorageWriter"
    - "Auth functions extract API key from request headers and look up the project via database"
    - "Validation functions check required fields, valid severity levels, timestamp format, and payload size"
  artifacts:
    - path: "mesher/services/rate_limiter.mpl"
      provides: "RateLimiter service with CheckLimit call, ResetWindow cast, and rate_window_ticker actor"
      contains: "service RateLimiter"
    - path: "mesher/services/event_processor.mpl"
      provides: "EventProcessor service with ProcessEvent call handler that validates and routes to StorageWriter"
      contains: "service EventProcessor"
    - path: "mesher/ingestion/auth.mpl"
      provides: "extract_api_key and authenticate_request functions"
      contains: "pub fn extract_api_key"
    - path: "mesher/ingestion/validation.mpl"
      provides: "validate_event, validate_bulk_count, validate_payload_size functions"
      contains: "pub fn validate_event"
  key_links:
    - from: "mesher/ingestion/auth.mpl"
      to: "mesher/storage/queries.mpl"
      via: "import get_project_by_api_key"
      pattern: "from Storage.Queries import get_project_by_api_key"
    - from: "mesher/services/event_processor.mpl"
      to: "mesher/services/writer.mpl"
      via: "StorageWriter.store cast for validated events"
      pattern: "StorageWriter.store"
    - from: "mesher/ingestion/validation.mpl"
      to: "mesher/types/event.mpl"
      via: "EventPayload struct for field validation"
      pattern: "from Types.Event import EventPayload"
---

<objective>
Build the core ingestion services in Mesh: RateLimiter service actor, EventProcessor service actor, authentication helpers, and event validation functions.

Purpose: These are the building blocks that the HTTP routes and WebSocket handler (Plan 03) will compose. Separating them into modules keeps each file focused and testable. The RateLimiter enforces per-project rate limits (INGEST-04). The EventProcessor validates and routes events (INGEST-02). Auth helpers handle DSN key extraction (INGEST-01).

Output: 4 new Mesh files in mesher/services/ and mesher/ingestion/.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/88-ingestion-pipeline/88-RESEARCH.md
@.planning/phases/87.2-refactor-phase-87-code-to-use-cross-module-services/87.2-02-SUMMARY.md
@mesher/main.mpl
@mesher/services/writer.mpl
@mesher/storage/queries.mpl
@mesher/types/event.mpl
@mesher/types/project.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RateLimiter service and auth/validation modules</name>
  <files>mesher/services/rate_limiter.mpl, mesher/ingestion/auth.mpl, mesher/ingestion/validation.mpl</files>
  <action>
**Create `mesher/ingestion/` directory** (new module namespace: Ingestion.Auth, Ingestion.Validation).

**File: mesher/ingestion/auth.mpl**

Authentication helper functions for API key extraction and project lookup.

```mesh
from Storage.Queries import get_project_by_api_key
from Types.Project import Project

# Extract API key from request headers.
# Checks X-Sentry-Auth header first, falls back to Authorization header.
# Returns Option<String> with the raw key value.
pub fn extract_api_key(request) -> Option<String> do
  let auth = Request.header(request, "x-sentry-auth")
  case auth do
    Some(key) -> Some(key)
    None ->
      let bearer = Request.header(request, "authorization")
      case bearer do
        Some(token) -> Some(token)
        None -> None
      end
  end
end

# Authenticate a request by looking up the API key against the database.
# Returns the Project if the key is valid and non-revoked.
pub fn authenticate_request(pool :: PoolHandle, request) -> Project!String do
  let key_opt = extract_api_key(request)
  case key_opt do
    Some(key) -> get_project_by_api_key(pool, key)
    None -> Err("missing API key")
  end
end
```

IMPORTANT: Middleware in Mesh receives `(request, next)` but cannot pass context. Per the research, the handler will re-query the project. The auth module provides reusable functions that both middleware and handlers can call. The middleware approach with double-query is acceptable per research recommendation.

**File: mesher/ingestion/validation.mpl**

Event payload validation functions.

```mesh
from Types.Event import EventPayload

# Validate a single event payload. Checks required fields and valid severity level.
# Returns Ok("valid") or Err with a descriptive error message.
pub fn validate_event(payload :: EventPayload) -> String!String do
  if String.length(payload.message) == 0 do
    Err("missing required field: message")
  else
    let valid_levels = ["fatal", "error", "warning", "info", "debug"]
    if List.contains(valid_levels, payload.level) do
      Ok("valid")
    else
      Err("invalid level: must be fatal, error, warning, info, or debug")
    end
  end
end

# Validate payload size. Returns Err if body exceeds max bytes (1MB default).
pub fn validate_payload_size(body :: String, max_bytes :: Int) -> String!String do
  if String.length(body) > max_bytes do
    Err("payload too large")
  else
    Ok("ok")
  end
end

# Validate bulk event count. Returns Err if count exceeds max (100 default).
pub fn validate_bulk_count(count :: Int, max_events :: Int) -> String!String do
  if count > max_events do
    Err("too many events in bulk request (max " <> String.from(max_events) <> ")")
  else
    Ok("ok")
  end
end
```

**File: mesher/services/rate_limiter.mpl**

Single global RateLimiter service actor with per-project counters in a Map.

```mesh
# RateLimiter service -- single actor managing per-project rate counters.
# Uses a fixed-window approach: counts events per project within a time window.
# Window reset handled by rate_window_ticker actor (Timer.sleep + cast pattern).

struct RateLimitEntry do
  count :: Int
  window_start :: Int
end

struct RateLimitState do
  limits :: Map<String, Int>    # project_id -> event count in current window
  window_seconds :: Int         # window duration in seconds (e.g., 60)
  max_events :: Int             # max events per project per window (e.g., 1000)
end

fn check_limit_impl(state :: RateLimitState, project_id :: String) -> (RateLimitState, Bool) do
  let count = Map.get_or(state.limits, project_id, 0)
  if count >= state.max_events do
    (state, false)
  else
    let new_limits = Map.put(state.limits, project_id, count + 1)
    let new_state = RateLimitState { limits: new_limits, window_seconds: state.window_seconds, max_events: state.max_events }
    (new_state, true)
  end
end

fn reset_window_impl(state :: RateLimitState) -> RateLimitState do
  RateLimitState { limits: Map.new(), window_seconds: state.window_seconds, max_events: state.max_events }
end

service RateLimiter do
  fn init(window_seconds :: Int, max_events :: Int) -> RateLimitState do
    RateLimitState {
      limits: Map.new(),
      window_seconds: window_seconds,
      max_events: max_events
    }
  end

  # Synchronous check: returns true if allowed, false if rate limited.
  call CheckLimit(project_id :: String) :: Bool do |state|
    check_limit_impl(state, project_id)
  end

  # Async reset: clears all counters for a new window.
  cast ResetWindow() do |state|
    reset_window_impl(state)
  end
end

# Ticker actor for periodic window reset.
# Same pattern as flush_ticker in StorageWriter.
actor rate_window_ticker(limiter_pid, interval :: Int) do
  Timer.sleep(interval)
  RateLimiter.reset_window(limiter_pid)
  rate_window_ticker(limiter_pid, interval)
end
```

Note: `Map.get_or` may not exist in stdlib. If not, use `Map.get` which returns Option, then case match on Some/None. Check existing Mesh stdlib. If `Map.get_or` is unavailable, implement as:
```mesh
fn map_get_or(m, key, default_val) do
  let result = Map.get(m, key)
  case result do
    Some(v) -> v
    None -> default_val
  end
end
```
And use that helper instead.

IMPORTANT per decision [87-01]: Recursive helper functions for iteration. Per decision [87.2-02]: explicit case in retry functions, ? only in flush_loop. This plan has no retry logic so these constraints don't apply directly, but follow the service module convention from [87.2-01].
  </action>
  <verify>
    `meshc build mesher/` compiles successfully with the new modules imported.
    Note: Do NOT import these new modules in main.mpl yet -- that happens in Plan 03. Instead verify compilation by temporarily adding imports or by checking that each file parses individually. If the compiler requires all modules to be imported to build, add minimal temporary imports in main.mpl.
  </verify>
  <done>
    - mesher/services/rate_limiter.mpl exists with RateLimiter service (init, CheckLimit call, ResetWindow cast) and rate_window_ticker actor
    - mesher/ingestion/auth.mpl exists with extract_api_key and authenticate_request functions
    - mesher/ingestion/validation.mpl exists with validate_event, validate_payload_size, validate_bulk_count functions
    - All files compile as part of `meshc build mesher/`
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EventProcessor service</name>
  <files>mesher/services/event_processor.mpl</files>
  <action>
**File: mesher/services/event_processor.mpl**

EventProcessor service that validates an event and routes it to the correct StorageWriter.

```mesh
from Ingestion.Validation import validate_event
from Services.Writer import StorageWriter
from Types.Event import EventPayload

# EventProcessor state holds pool handle for writer lookup/creation.
# In Phase 88, we use a simple approach: the caller provides the writer PID
# alongside the event. The EventProcessor validates and forwards.

struct ProcessorState do
  pool :: PoolHandle
  processed_count :: Int
end

fn process_event_impl(state :: ProcessorState, project_id :: String, writer_pid, event_json :: String) -> (ProcessorState, String!String) do
  # Parse the JSON into an EventPayload for validation
  let parse_result = Json.parse(event_json)
  case parse_result do
    Ok(json) ->
      let payload_result = EventPayload.from_json(json)
      case payload_result do
        Ok(payload) ->
          let valid = validate_event(payload)
          case valid do
            Ok(_) ->
              # Valid event -- route to StorageWriter
              StorageWriter.store(writer_pid, event_json)
              let new_state = ProcessorState { pool: state.pool, processed_count: state.processed_count + 1 }
              (new_state, Ok(project_id))
            Err(reason) ->
              (state, Err(reason))
          end
        Err(reason) ->
          (state, Err("invalid event payload: " <> reason))
      end
    Err(reason) ->
      (state, Err("invalid JSON: " <> reason))
  end
end

service EventProcessor do
  fn init(pool :: PoolHandle) -> ProcessorState do
    ProcessorState { pool: pool, processed_count: 0 }
  end

  # Synchronous event processing: validates and routes to writer.
  # Returns Ok(project_id) on success, Err(reason) on validation failure.
  call ProcessEvent(project_id :: String, writer_pid, event_json :: String) :: String!String do |state|
    process_event_impl(state, project_id, writer_pid, event_json)
  end
end
```

IMPORTANT design notes:
- The EventProcessor uses a `call` (synchronous) handler so the HTTP handler can get the validation result back and return an appropriate error response to the client.
- The writer_pid is passed in by the caller (the HTTP route handler gets it from a registry or starts one). This avoids the EventProcessor needing to manage writer lifecycle.
- Per [87.2-01], service modules only depend on Storage.Queries and Types.*, never on each other. However, EventProcessor depends on StorageWriter via cast (not call), and on Ingestion.Validation. This is acceptable because it's a one-way dependency (process -> write), not circular.
- Use explicit case matching (not ? operator) per decision [87-02] for the nested result handling where error branches need different messages.
  </action>
  <verify>
    `meshc build mesher/` compiles successfully with EventProcessor module. The service has an init handler and a ProcessEvent call handler.
  </verify>
  <done>
    - mesher/services/event_processor.mpl exists with EventProcessor service (init, ProcessEvent call)
    - ProcessEvent validates JSON, validates event fields, and routes to StorageWriter
    - Compiles as part of `meshc build mesher/`
  </done>
</task>

</tasks>

<verification>
1. `meshc build mesher/` compiles cleanly
2. All 4 new files exist: services/rate_limiter.mpl, services/event_processor.mpl, ingestion/auth.mpl, ingestion/validation.mpl
3. RateLimiter has CheckLimit call and ResetWindow cast
4. EventProcessor has ProcessEvent call
5. Auth has extract_api_key and authenticate_request
6. Validation has validate_event, validate_payload_size, validate_bulk_count
</verification>

<success_criteria>
- 4 new Mesh module files created and compiling
- RateLimiter service with per-project rate counting and window reset
- EventProcessor service with JSON parsing, validation, and StorageWriter routing
- Auth functions for API key extraction from request headers
- Validation functions for event payload checking
- No circular dependencies between modules
</success_criteria>

<output>
After completion, create `.planning/phases/88-ingestion-pipeline/88-02-SUMMARY.md`
</output>
