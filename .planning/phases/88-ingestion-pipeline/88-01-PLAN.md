---
phase: 88-ingestion-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-rt/src/http/server.rs
  - crates/mesh-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "HTTP.response_with_headers(status, body, headers_map) constructs a response with custom headers"
    - "write_response emits custom headers from the response struct"
    - "Status codes 202 and 429 produce correct status text (Accepted, Too Many Requests)"
    - "Existing HTTP.response(status, body) continues to work with no headers (backward compatible)"
  artifacts:
    - path: "crates/mesh-rt/src/http/server.rs"
      provides: "MeshHttpResponse with headers field, mesh_http_response_with_headers constructor, write_response emitting custom headers, 202/429 status text"
      contains: "mesh_http_response_with_headers"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "MIR mapping for http_response_with_headers -> mesh_http_response_with_headers"
      contains: "http_response_with_headers"
  key_links:
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-rt/src/http/server.rs"
      via: "known_functions mapping"
      pattern: "mesh_http_response_with_headers"
    - from: "crates/mesh-rt/src/http/server.rs (process_request)"
      to: "crates/mesh-rt/src/http/server.rs (write_response)"
      via: "headers extracted from MeshHttpResponse and passed to write_response"
      pattern: "write_response.*headers"
---

<objective>
Extend the Mesh runtime HTTP server to support response headers, 202/429 status codes, and a new HTTP.response_with_headers() API.

Purpose: The ingestion pipeline requires Retry-After headers on 429 responses (INGEST-04) and 202 Accepted status (INGEST-06). The current MeshHttpResponse has only {status, body} with no headers field. This runtime extension is the prerequisite for all Mesh-level ingestion code.

Output: Updated server.rs with headers support, updated lower.rs with MIR mapping.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/88-ingestion-pipeline/88-RESEARCH.md
@crates/mesh-rt/src/http/server.rs
@crates/mesh-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add response headers to MeshHttpResponse and write_response</name>
  <files>crates/mesh-rt/src/http/server.rs</files>
  <action>
1. Add a `headers` field to `MeshHttpResponse` (type: `*mut u8`, nullable pointer to a MeshMap). Place it after `body`. The struct is `repr(C)` so field order matters.

2. Update `mesh_http_response_new` to set `headers` to `std::ptr::null_mut()` (backward compatible -- no headers by default).

3. Add a new extern "C" function `mesh_http_response_with_headers(status: i64, body: *const MeshString, headers: *mut u8) -> *mut u8` that allocates a MeshHttpResponse with all three fields set. The `headers` parameter is a MeshMap pointer (same type used for request headers).

4. Add status text entries for 202 and 429 in `write_response`:
   - 202 => "Accepted"
   - 429 => "Too Many Requests"

5. Update `write_response` signature to accept optional extra headers: `fn write_response(stream: &mut HttpStream, status: u16, body: &[u8], extra_headers: Option<Vec<(String, String)>>) -> Result<(), String>`. When `extra_headers` is Some, emit each header as `{name}: {value}\r\n` between the standard headers (Content-Type, Content-Length, Connection) and the blank line.

6. Update `process_request` (around line 767-776) to extract headers from the MeshHttpResponse struct. If `resp.headers` is non-null, iterate the MeshMap to build a `Vec<(String, String)>`. Return type changes from `(u16, Vec<u8>)` to `(u16, Vec<u8>, Option<Vec<(String, String)>>)`.

7. Update `connection_handler_entry` (line 386-387) to pass the headers from `process_request` to `write_response`:
   ```rust
   let (status, body, headers) = process_request(router_ptr, parsed);
   let _ = write_response(&mut stream, status, &body, headers);
   ```

8. To iterate the MeshMap for extracting headers, use the existing `mesh_map_entries` or `mesh_map_to_list` function from the map module. If those don't exist, iterate the MeshMap's internal structure. The map stores string keys/values as u64-casted pointers. For each entry, cast the key/value back to `*const MeshString` and extract the string slices.

9. Update the test `test_response_creation` to also test the new constructor and verify headers field is null for the old constructor.

10. Also add the 404 path (line 763 `return (404, ...)`) to match the new return type: `return (404, b"Not Found".to_vec(), None);`
  </action>
  <verify>
    `cargo build -p mesh-rt` compiles successfully. `cargo test -p mesh-rt -- http::server::tests` passes.
  </verify>
  <done>MeshHttpResponse has a headers field. mesh_http_response_with_headers constructor exists. write_response emits custom headers. Status 202 and 429 have correct text. Backward compatible: mesh_http_response_new still works with null headers.</done>
</task>

<task type="auto">
  <name>Task 2: Add MIR mapping for HTTP.response_with_headers</name>
  <files>crates/mesh-codegen/src/mir/lower.rs</files>
  <action>
1. In the `known_functions` block (around line 707), add:
   ```rust
   self.known_functions.insert("mesh_http_response_with_headers".to_string(), MirType::FnPtr(vec![MirType::Int, MirType::String, MirType::Ptr], Box::new(MirType::Ptr)));
   ```
   The signature is: (status: Int, body: String, headers: Ptr) -> Ptr. The headers parameter is a MeshMap (Ptr).

2. In the known function name mapping (around line 9785), add:
   ```rust
   "http_response_with_headers" => "mesh_http_response_with_headers".to_string(),
   ```
   This maps `HTTP.response_with_headers(status, body, headers)` in Mesh code to the runtime function.

3. Verify the mapping is consistent with existing patterns (e.g., `http_response` -> `mesh_http_response_new`).
  </action>
  <verify>
    `cargo build -p mesh-codegen` compiles successfully. Grep for "response_with_headers" in lower.rs confirms both the known_functions entry and the name mapping exist.
  </verify>
  <done>Mesh code can call HTTP.response_with_headers(202, body, headers_map) and it compiles to the correct runtime function call. Full `cargo build` succeeds.</done>
</task>

</tasks>

<verification>
1. `cargo build` (full workspace) succeeds
2. `cargo test -p mesh-rt -- http::server` passes
3. Grep confirms: `mesh_http_response_with_headers` in server.rs, `http_response_with_headers` in lower.rs
4. Status 202 and 429 text entries in write_response match arm
</verification>

<success_criteria>
- MeshHttpResponse struct has 3 fields: status, body, headers
- mesh_http_response_new sets headers to null (backward compatible)
- mesh_http_response_with_headers sets all 3 fields
- write_response emits extra headers when present
- 202 => "Accepted", 429 => "Too Many Requests" in status text
- HTTP.response_with_headers MIR mapping exists in lower.rs
- Full workspace cargo build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/88-ingestion-pipeline/88-01-SUMMARY.md`
</output>
