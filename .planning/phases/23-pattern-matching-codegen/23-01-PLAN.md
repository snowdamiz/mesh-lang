---
phase: 23-pattern-matching-codegen
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-codegen/src/pattern/compile.rs
  - crates/snow-codegen/src/codegen/expr.rs
autonomous: true

must_haves:
  truths:
    - "Pattern matching on sum types dispatches to the correct arm regardless of arm ordering vs type definition order"
    - "Non-nullary variant fields are extracted with correct LLVM types (not Unit placeholders)"
    - "Nested constructor patterns like Some(Some(x)) extract the inner value correctly"
  artifacts:
    - path: "crates/snow-codegen/src/pattern/compile.rs"
      provides: "Fixed pattern compiler with correct tag assignment and field type resolution"
      contains: "sum_type_defs"
  key_links:
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/pattern/compile.rs"
      via: "compile_match call passes sum_type_defs"
      pattern: "compile_match.*sum_type_defs"
    - from: "crates/snow-codegen/src/pattern/compile.rs"
      to: "MirSumTypeDef"
      via: "tag lookup from sum type definition"
      pattern: "def\\.variants.*\\.tag"
---

<objective>
Fix the two root-cause bugs in the pattern compiler that prevent sum type pattern matching from extracting field values at the LLVM codegen level.

Purpose: These two bugs (constructor tag mismatch and Unit type placeholders for variant fields) are the sole reason `case opt do Some(x) -> x end` does not bind `x` to the inner value at runtime. Fixing them unblocks all non-nullary variant pattern matching across the entire language.

Output: A working pattern compiler that assigns constructor tags from the sum type definition (not pattern appearance order) and resolves variant field types from the sum type definition (not Unit placeholders).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-pattern-matching-codegen/23-RESEARCH.md
@crates/snow-codegen/src/pattern/compile.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-codegen/src/pattern/mod.rs
@crates/snow-codegen/src/mir/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix constructor tag assignment and field type resolution in pattern compiler</name>
  <files>crates/snow-codegen/src/pattern/compile.rs, crates/snow-codegen/src/codegen/expr.rs</files>
  <action>
    This task fixes two tightly-coupled bugs in the pattern compiler. Both require the same architectural change: passing `sum_type_defs: &FxHashMap<String, MirSumTypeDef>` into the pattern compilation pipeline.

    **Step 1: Update `compile_match` signature to accept sum_type_defs.**

    In `crates/snow-codegen/src/pattern/compile.rs`:
    - Add `use crate::mir::MirSumTypeDef;` and `use rustc_hash::FxHashMap;` to imports.
    - Change `compile_match` signature to add `sum_type_defs: &FxHashMap<String, MirSumTypeDef>` as the last parameter (before the return type).
    - Thread `sum_type_defs` through `compile_matrix`, `compile_constructor_switch`, `compile_literal_tests`, `default_matrix` calls (all internal functions that recurse need access).
    - The simplest approach: add `sum_type_defs` as a field on `PatMatrix` so it propagates automatically through all matrix operations without changing every function signature. Add it as `sum_type_defs: &'a FxHashMap<String, MirSumTypeDef>` -- but since PatMatrix is not lifetime-parameterized and is cloned, the simpler approach is to pass it as a separate parameter to `compile_matrix` and thread it through `compile_constructor_switch`, `compile_literal_tests`, `specialize_for_constructor`, and `collect_head_constructors`.

    **Step 2: Fix tag assignment in `collect_head_constructors` (line 347-351).**

    Replace the appearance-order tag assignment:
    ```rust
    let tag = result
        .iter()
        .filter(|c| matches!(c, HeadCtor::Constructor { .. }))
        .count() as u8;
    ```

    With a lookup from the sum type definition:
    ```rust
    let tag = sum_type_defs.get(type_name.as_str())
        .or_else(|| type_name.split('_').next().and_then(|base| sum_type_defs.get(base)))
        .and_then(|def| def.variants.iter().find(|v| v.name == *variant))
        .map(|v| v.tag)
        .unwrap_or_else(|| {
            // Fallback: count existing constructors (old behavior) if type not found
            result.iter().filter(|c| matches!(c, HeadCtor::Constructor { .. })).count() as u8
        });
    ```

    This looks up the actual tag from `MirSumTypeDef.variants[i].tag` for the matching variant name. Falls back to old behavior if the type is not in the map (defensive, should not happen in practice).

    **Step 3: Fix field type resolution in `specialize_for_constructor` (line 519-521).**

    Replace the Unit placeholder:
    ```rust
    new_types.push(MirType::Unit);
    ```

    With actual field type lookup:
    ```rust
    // Look up actual field types from sum type definition
    let parent_ty = &matrix.column_types[col];
    let field_types: Vec<MirType> = if let MirType::SumType(type_name) = parent_ty {
        sum_type_defs.get(type_name.as_str())
            .or_else(|| type_name.split('_').next().and_then(|base| sum_type_defs.get(base)))
            .and_then(|def| def.variants.iter().find(|v| v.name == target_variant))
            .map(|v| v.fields.clone())
            .unwrap_or_else(|| vec![MirType::Unit; arity])
    } else {
        vec![MirType::Unit; arity]
    };
    ```

    Then in the loop, use `field_types.get(i).cloned().unwrap_or(MirType::Unit)` instead of `MirType::Unit`.

    Move the field_types computation BEFORE the `for i in 0..arity` loop, and modify the loop body to use it. The `parent_ty` reference is already available from `matrix.column_types[col]`.

    **Step 4: Update the call site in `codegen_match`.**

    In `crates/snow-codegen/src/codegen/expr.rs`, line 965:
    ```rust
    let tree = compile_match(scrutinee_ty, arms, "<unknown>", 0);
    ```
    Change to:
    ```rust
    let tree = compile_match(scrutinee_ty, arms, "<unknown>", 0, &self.sum_type_defs);
    ```

    **Step 5: Update the `compile_patterns` walker.**

    In `compile.rs`, `compile_patterns` calls `compile_match` via `compile_expr_patterns`. Since this walker operates on a `MirModule`, extract `sum_type_defs` from the module's sum_type_defs field (check `MirModule` struct for the field name -- it has `sum_type_defs: Vec<MirSumTypeDef>`). Build a `FxHashMap<String, MirSumTypeDef>` from the Vec and pass it through. If `compile_expr_patterns` does not actually call `compile_match` directly (inspection shows line 909 does call `compile_match`), then pass the map through the recursive walker. However, looking at the code, `compile_expr_patterns` at line 909 calls `compile_match` but discards the result (the `_tree` variable). This walker is not actually used in the main codegen path -- `codegen_match` calls `compile_match` directly. So either thread it through `compile_patterns`/`compile_expr_patterns` too, or pass an empty map as a fallback since this code path is not exercised. For correctness, build the map from `module.sum_type_defs` and pass it through.

    **Step 6: Update existing tests.**

    The existing unit tests in `compile.rs` call `compile_match` without `sum_type_defs`. Update all test calls to pass `&FxHashMap::default()` (empty map -- tests use ad-hoc type names like "Shape", "Color", "Option" that are not in a real sum_type_defs map). The tests verify decision tree structure, not tag correctness from definitions, so empty map is fine for existing tests. The tag fallback (old behavior) will activate for empty maps, preserving existing test expectations.

    Add a NEW test that verifies correct tag assignment from sum_type_defs:
    - Create a `FxHashMap` with a `MirSumTypeDef` for Option (Some=tag 0, None=tag 1).
    - Create arms `[None -> 0, Some(x) -> x]` (reversed from definition order).
    - Verify the Switch cases have `None.tag == 1` and `Some.tag == 0` (from definition, NOT from appearance order 0 and 1).

    Add another test for field type resolution:
    - Create a `FxHashMap` with Option def where Some has field type `MirType::Int`.
    - Create arm `Some(x) -> x` and verify the binding for `x` has type `MirType::Int` (not `MirType::Unit`).
  </action>
  <verify>
    Run `cargo test -p snow-codegen` -- all existing pattern compiler tests pass, plus the two new tests pass.
    Run `cargo build` -- project compiles without errors.
  </verify>
  <done>
    - `compile_match` accepts `sum_type_defs` parameter and uses it for tag lookup and field type resolution.
    - Constructor tags in the decision tree match the sum type definition, not the pattern appearance order.
    - Variant field bindings get correct types from the sum type definition, not MirType::Unit.
    - All existing tests pass (updated to pass empty map).
    - Two new tests validate tag correctness and field type correctness.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p snow-codegen` passes with all existing tests plus new tag/field-type tests.
- `cargo build` succeeds (no compile errors from signature changes).
- Inspect decision tree output for `[None -> 0, Some(x) -> x]` -- None has tag 1, Some has tag 0 (from definition order, not appearance order).
</verification>

<success_criteria>
1. The `compile_match` function accepts and uses sum type definitions for tag assignment and field type resolution.
2. All 14+ existing pattern compiler unit tests pass.
3. New test confirms tags come from type definition (not pattern order).
4. New test confirms field types come from type definition (not Unit placeholder).
5. `cargo build` compiles the full project.
</success_criteria>

<output>
After completion, create `.planning/phases/23-pattern-matching-codegen/23-01-SUMMARY.md`
</output>
