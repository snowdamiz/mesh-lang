---
phase: 23-pattern-matching-codegen
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "Ordering (Less | Equal | Greater) is a registered built-in sum type usable in Snow programs"
    - "compare(a, b) returns an Ordering value for types that implement Ord"
    - "Pattern matching on Ordering works: case compare(a, b) do Less -> ... | Equal -> ... | Greater -> ... end"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Ordering registered as built-in sum type"
      contains: "Ordering"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "compare() method added to Ord trait"
      contains: "compare"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Ord__compare__Type MIR function generation"
      contains: "Ord__compare__"
  key_links:
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "crates/snow-typeck/src/infer.rs"
      via: "Ord trait references Ordering return type"
      pattern: "Ordering"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "MirExpr::ConstructVariant"
      via: "compare functions construct Ordering variants"
      pattern: "ConstructVariant.*Ordering"
---

<objective>
Register the Ordering sum type as a built-in, add compare() to the Ord trait, generate compare MIR functions, and add a compare() built-in function. Then validate the entire phase with end-to-end integration tests.

Purpose: This completes PATM-02 (Ordering as a user-visible type) and validates PATM-01 (field extraction works) with real Snow programs. After this plan, all four Phase 23 success criteria are met.

Output: Ordering type registered, compare() works for Int/Float/String, end-to-end tests prove pattern matching extracts variant fields and Ordering works.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-pattern-matching-codegen/23-RESEARCH.md
@.planning/phases/23-pattern-matching-codegen/23-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Ordering sum type and add compare() to Ord trait</name>
  <files>crates/snow-typeck/src/infer.rs, crates/snow-typeck/src/builtins.rs</files>
  <action>
    **Part A: Register Ordering as a built-in sum type.**

    In `crates/snow-typeck/src/infer.rs`, inside `register_builtin_sum_types()`, after the Result registration block (after line 721), add:

    ```rust
    // -- Ordering (Less | Equal | Greater) -- no generic params
    //
    // type Ordering do
    //   Less
    //   Equal
    //   Greater
    // end

    let ordering_variants = vec![
        VariantInfo {
            name: "Less".to_string(),
            fields: vec![],
        },
        VariantInfo {
            name: "Equal".to_string(),
            fields: vec![],
        },
        VariantInfo {
            name: "Greater".to_string(),
            fields: vec![],
        },
    ];

    type_registry.register_sum_type(SumTypeDefInfo {
        name: "Ordering".to_string(),
        generic_params: vec![],
        variants: ordering_variants.clone(),
    });

    register_variant_constructors(ctx, env, "Ordering", &[], &ordering_variants);
    ```

    This registers `Less`, `Equal`, `Greater` as constructors in the type environment, making them available in expressions and patterns.

    **Part B: Add compare() method to the Ord trait.**

    In `crates/snow-typeck/src/builtins.rs`, update the Ord trait registration (around line 650-658). Change the `methods` vec from containing just `lt` to containing both `lt` and `compare`:

    ```rust
    registry.register_trait(TraitDef {
        name: "Ord".to_string(),
        methods: vec![
            TraitMethodSig {
                name: "lt".to_string(),
                has_self: true,
                param_count: 1,
                return_type: Some(Ty::bool()),
                has_default_body: false,
            },
            TraitMethodSig {
                name: "compare".to_string(),
                has_self: true,
                param_count: 1,
                return_type: Some(Ty::Con(TyCon::new("Ordering"))),
                has_default_body: true,  // default impl uses lt/eq
            },
        ],
    });
    ```

    Update the Ord impl registrations for Int, Float, String (around line 662-681) to also include `compare`:

    ```rust
    for (ty, ty_name) in &[
        (Ty::int(), "Int"),
        (Ty::float(), "Float"),
        (Ty::string(), "String"),
    ] {
        let mut methods = FxHashMap::default();
        methods.insert(
            "lt".to_string(),
            ImplMethodSig {
                has_self: true,
                param_count: 1,
                return_type: Some(Ty::bool()),
            },
        );
        methods.insert(
            "compare".to_string(),
            ImplMethodSig {
                has_self: true,
                param_count: 1,
                return_type: Some(Ty::Con(TyCon::new("Ordering"))),
            },
        );
        let _ = registry.register_impl(ImplDef {
            trait_name: "Ord".to_string(),
            impl_type: ty.clone(),
            impl_type_name: ty_name.to_string(),
            methods,
        });
    }
    ```

    **Part C: Register `compare` as a built-in function in the type environment.**

    In `crates/snow-typeck/src/builtins.rs`, in `register_builtins()`, add a polymorphic `compare` function (follow the `to_string` pattern). After the `default` registration or near the `to_string`-like registrations:

    ```rust
    // compare(a, b) -> Ordering -- polymorphic, dispatches via Ord trait
    {
        let t_var = TyVar(99002);  // unique TyVar number not used elsewhere
        let t = Ty::Var(t_var);
        env.insert(
            "compare".into(),
            Scheme {
                vars: vec![t_var],
                ty: Ty::fun(vec![t.clone(), t], Ty::Con(TyCon::new("Ordering"))),
            },
        );
    }
    ```

    Check existing TyVar numbers in the file to pick a unique one (99000 is used for `default`). Use 99002 or another unused number.
  </action>
  <verify>
    Run `cargo test -p snow-typeck` -- all existing tests pass plus Ordering constructors are now resolvable.
    Run `cargo build` -- project compiles without errors.
  </verify>
  <done>
    - Ordering is registered as a built-in sum type with variants Less (tag 0), Equal (tag 1), Greater (tag 2).
    - Less, Equal, Greater are available as identifiers in the type environment.
    - Ord trait has both `lt` and `compare` methods.
    - Ord impls for Int, Float, String include `compare` method signature.
    - `compare` is a polymorphic built-in function `(T, T) -> Ordering`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate Ord__compare__Type MIR functions and add end-to-end tests</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
    **Part A: Add Ordering sum type def to MIR lowerer.**

    In `crates/snow-codegen/src/mir/lower.rs`, find where built-in sum types are registered for codegen (search for where Option/Result MirSumTypeDef are created and pushed to `self.module.sum_type_defs`). Add an Ordering MirSumTypeDef:

    ```rust
    self.module.sum_type_defs.push(MirSumTypeDef {
        name: "Ordering".to_string(),
        variants: vec![
            MirVariantDef { name: "Less".to_string(), fields: vec![], tag: 0 },
            MirVariantDef { name: "Equal".to_string(), fields: vec![], tag: 1 },
            MirVariantDef { name: "Greater".to_string(), fields: vec![], tag: 2 },
        ],
    });
    ```

    **Part B: Generate `Ord__compare__Type` MIR functions.**

    Find where `generate_ord_struct` and `generate_ord_sum` are called to generate `Ord__lt__Type` functions. After each `generate_ord_struct`/`generate_ord_sum` call, also generate the corresponding `compare` function.

    Add new methods `generate_compare_struct` and `generate_compare_sum` (or a unified `generate_compare` function). The logic for compare:

    For a primitive type like Int:
    ```
    fn Ord__compare__Int(self: Int, other: Int) -> Ordering =
      if Ord__lt__Int(self, other) then Less
      else if Eq__eq__Int(self, other) then Equal
      else Greater
    ```

    In MIR terms, this is:
    ```rust
    fn generate_compare_for_type(&mut self, type_name: &str, mir_type: &MirType) {
        let mangled = format!("Ord__compare__{}", type_name);
        let ordering_ty = MirType::SumType("Ordering".to_string());
        let self_var = MirExpr::Var("self".to_string(), mir_type.clone());
        let other_var = MirExpr::Var("other".to_string(), mir_type.clone());

        let lt_call = MirExpr::Call {
            func: Box::new(MirExpr::Var(
                format!("Ord__lt__{}", type_name),
                MirType::Fun(vec![mir_type.clone(), mir_type.clone()], Box::new(MirType::Bool)),
            )),
            args: vec![self_var.clone(), other_var.clone()],
            ty: MirType::Bool,
        };

        let eq_call = MirExpr::Call {
            func: Box::new(MirExpr::Var(
                format!("Eq__eq__{}", type_name),
                MirType::Fun(vec![mir_type.clone(), mir_type.clone()], Box::new(MirType::Bool)),
            )),
            args: vec![self_var.clone(), other_var.clone()],
            ty: MirType::Bool,
        };

        let body = MirExpr::If {
            cond: Box::new(lt_call),
            then_body: Box::new(MirExpr::ConstructVariant {
                type_name: "Ordering".to_string(),
                variant: "Less".to_string(),
                fields: vec![],
                ty: ordering_ty.clone(),
            }),
            else_body: Box::new(MirExpr::If {
                cond: Box::new(eq_call),
                then_body: Box::new(MirExpr::ConstructVariant {
                    type_name: "Ordering".to_string(),
                    variant: "Equal".to_string(),
                    fields: vec![],
                    ty: ordering_ty.clone(),
                }),
                else_body: Box::new(MirExpr::ConstructVariant {
                    type_name: "Ordering".to_string(),
                    variant: "Greater".to_string(),
                    fields: vec![],
                    ty: ordering_ty.clone(),
                }),
                ty: ordering_ty.clone(),
            }),
            ty: ordering_ty.clone(),
        };

        // Push function (follow same pattern as Ord__lt__ generation)
        self.module.functions.push(MirFunction {
            name: mangled,
            params: vec![
                ("self".to_string(), mir_type.clone()),
                ("other".to_string(), mir_type.clone()),
            ],
            return_type: ordering_ty,
            body,
            is_closure: false,
        });
    }
    ```

    Call this method for each type that has both Ord and Eq implementations: Int, Float, String. Also generate for user-defined structs and sum types that derive Ord (find where `generate_ord_struct`/`generate_ord_sum` is called and add corresponding `generate_compare_for_type` calls).

    **Part C: Handle `compare` function dispatch in MIR lowering.**

    Find where `to_string` calls are lowered to `Display__to_string__Type` (search for `"to_string"` in lower.rs). Add similar dispatch for `compare`:

    When the lowerer encounters a call to `compare(a, b)`, it should resolve the concrete type of `a` and rewrite the call to `Ord__compare__Type(a, b)`. This follows the same pattern as `to_string(x)` -> `Display__to_string__Type(x)`.

    Search for the function call lowering logic that handles `to_string` and add a parallel case for `compare`. The key pattern:
    - If function name is `"compare"` and there are 2 arguments
    - Resolve the concrete type name from the first argument's type
    - Rewrite to `Ord__compare__TypeName`

    **Part D: Add end-to-end compiler integration tests.**

    Add tests to the snow-codegen test suite (or snowc integration tests -- check existing test patterns). Create test Snow programs that exercise all four success criteria:

    1. `case opt do Some(x) -> x | None -> 0 end` -- binds x to inner value (PATM-01)
    2. `case compare(3, 5) do Less -> 1 | Equal -> 2 | Greater -> 3 end` -- Ordering works (PATM-02)
    3. Ordering as a variable: `let ord = compare(1, 2)` followed by pattern match on `ord`
    4. Nested patterns: `case opt do Some(Some(x)) -> x | Some(None) -> 0 | None -> 0 end` (nested Some(Some(x)))

    Look at existing integration test patterns in the project (check `tests/` directory or `snowc` integration tests) and follow the same pattern. If tests compile and run Snow programs to verify output, do that. If tests use the MIR/codegen pipeline directly, do that.
  </action>
  <verify>
    Run `cargo test` (full test suite) -- all tests pass including new integration tests.
    Run `cargo build` -- project compiles.
    If integration tests compile and run Snow programs: verify output matches expected values.
  </verify>
  <done>
    - Ordering sum type is registered in the MIR lowerer with correct tag assignments (Less=0, Equal=1, Greater=2).
    - `Ord__compare__Int`, `Ord__compare__Float`, `Ord__compare__String` MIR functions are generated.
    - `compare(a, b)` calls dispatch to the correct monomorphized function.
    - Integration test: `case opt do Some(x) -> x end` extracts the inner value.
    - Integration test: `case compare(a, b) do Less -> ... | Equal -> ... | Greater -> ... end` works.
    - Integration test: nested `Some(Some(x))` extracts the doubly-wrapped value.
    - All 1,187+ existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
Run the full test suite:
```
cargo test
```

All tests pass. Then verify specific success criteria with Snow programs if possible:
1. Sum type pattern matching extracts field values (PATM-01).
2. Ordering type is usable in Snow code (PATM-02).
3. Nested constructor patterns work.
4. compare() dispatches correctly for Int, Float, String.
</verification>

<success_criteria>
1. `case opt do Some(x) -> x end` binds `x` to the inner value at runtime.
2. `case compare(a, b) do Less -> ... | Equal -> ... | Greater -> ... end` compiles and runs correctly.
3. Ordering is importable/usable as a first-class sum type (return values, variable bindings, pattern matches).
4. Nested constructor patterns work (e.g., `Some(Some(x))` extracts the doubly-wrapped value).
5. All existing 1,187+ tests continue to pass.
</success_criteria>

<output>
After completion, create `.planning/phases/23-pattern-matching-codegen/23-02-SUMMARY.md`
</output>
