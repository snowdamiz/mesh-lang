---
phase: 05-llvm-codegen-native-binaries
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/snow-rt/Cargo.toml
  - crates/snow-rt/src/lib.rs
  - crates/snow-rt/src/gc.rs
  - crates/snow-rt/src/string.rs
  - crates/snow-rt/src/panic.rs
  - crates/snow-codegen/Cargo.toml
  - crates/snow-codegen/src/lib.rs
  - crates/snow-typeck/src/lib.rs
  - crates/snow-typeck/src/infer.rs
  - .cargo/config.toml
autonomous: true

must_haves:
  truths:
    - "snow-rt crate compiles as a static library with extern C functions"
    - "snow-codegen crate compiles and depends on snow-typeck and inkwell"
    - "TypeckResult exposes struct definitions, sum type definitions, and trait registry to downstream crates"
    - "LLVM_SYS_211_PREFIX is configured so inkwell builds successfully"
  artifacts:
    - path: "crates/snow-rt/src/lib.rs"
      provides: "Runtime library entry point with GC init"
      exports: ["snow_rt_init", "snow_gc_alloc", "snow_println", "snow_print"]
    - path: "crates/snow-rt/src/gc.rs"
      provides: "Simple arena/bump allocator for GC-managed memory"
      contains: "snow_gc_alloc"
    - path: "crates/snow-rt/src/string.rs"
      provides: "GC-managed string operations"
      contains: "snow_string_new"
    - path: "crates/snow-rt/src/panic.rs"
      provides: "Runtime panic handler"
      contains: "snow_panic"
    - path: "crates/snow-codegen/src/lib.rs"
      provides: "Codegen crate entry point"
    - path: "crates/snow-typeck/src/lib.rs"
      provides: "TypeckResult with public type definitions"
      contains: "StructDefInfo"
  key_links:
    - from: "crates/snow-codegen/Cargo.toml"
      to: "crates/snow-typeck"
      via: "path dependency"
      pattern: "snow-typeck.*path"
    - from: "crates/snow-codegen/Cargo.toml"
      to: "inkwell"
      via: "workspace dependency"
      pattern: "inkwell"
---

<objective>
Create the snow-rt runtime library and snow-codegen crate scaffolding, expose TypeckResult internals for codegen consumption, and configure the LLVM build environment.

Purpose: This is the foundation for all codegen work. The runtime stub provides the extern "C" functions that compiled Snow programs call (string ops, GC allocation, panic, println). The codegen crate is where MIR lowering and LLVM IR generation will live. TypeckResult must expose struct/sum type definitions so codegen can determine memory layouts.

Output: Two new crates (snow-rt, snow-codegen) added to workspace, TypeckResult enriched with public type registry, LLVM build environment configured.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llvm-codegen-native-binaries/05-RESEARCH.md
@crates/snow-typeck/src/lib.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/ty.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snow-rt runtime crate with extern C functions</name>
  <files>
    Cargo.toml
    crates/snow-rt/Cargo.toml
    crates/snow-rt/src/lib.rs
    crates/snow-rt/src/gc.rs
    crates/snow-rt/src/string.rs
    crates/snow-rt/src/panic.rs
  </files>
  <action>
Create the `snow-rt` crate as a Rust library that compiles to a static library (`crate-type = ["staticlib", "lib"]`). This is the runtime linked into every Snow binary.

1. Add `snow-rt` to workspace members in root `Cargo.toml`.

2. Create `crates/snow-rt/Cargo.toml`:
   - `crate-type = ["staticlib", "lib"]` -- staticlib for linking into Snow binaries, lib for Rust tests
   - No external dependencies needed (pure Rust using std)

3. Create `crates/snow-rt/src/gc.rs`:
   - Implement a simple arena/bump allocator. For Phase 5, the GC does NOT collect -- it allocates from a growing arena. True mark-sweep collection is deferred to Phase 6.
   - Global mutable state: a `Vec<Vec<u8>>` of allocated pages (each page e.g. 64KB), current page pointer and offset.
   - `#[no_mangle] pub extern "C" fn snow_gc_alloc(size: u64, align: u64) -> *mut u8` -- bump-allocate from current page, allocate new page if needed. Returns aligned pointer.
   - `#[no_mangle] pub extern "C" fn snow_rt_init()` -- initialize the arena (called once at program start from main).
   - Use `std::sync::Mutex` or `std::cell::RefCell` (single-threaded for Phase 5) to protect the global arena state. Prefer a simple `static mut` with unsafe for performance, wrapped in an init function.
   - Prepare the GC API surface for Phase 6 (per-actor GC) by keeping allocation behind the `snow_gc_alloc` function -- the implementation can change without changing the ABI.

4. Create `crates/snow-rt/src/string.rs`:
   - `SnowString` repr(C) struct: `{ len: u64 }` with data bytes immediately following.
   - `#[no_mangle] pub extern "C" fn snow_string_new(data: *const u8, len: u64) -> *mut SnowString` -- allocate via `snow_gc_alloc`, copy data.
   - `#[no_mangle] pub extern "C" fn snow_string_concat(a: *const SnowString, b: *const SnowString) -> *mut SnowString` -- allocate new string, copy both.
   - `#[no_mangle] pub extern "C" fn snow_int_to_string(val: i64) -> *mut SnowString` -- format integer as string.
   - `#[no_mangle] pub extern "C" fn snow_float_to_string(val: f64) -> *mut SnowString` -- format float as string.
   - `#[no_mangle] pub extern "C" fn snow_bool_to_string(val: i8) -> *mut SnowString` -- "true" or "false".
   - `#[no_mangle] pub extern "C" fn snow_print(s: *const SnowString)` -- print string to stdout (no newline).
   - `#[no_mangle] pub extern "C" fn snow_println(s: *const SnowString)` -- print string to stdout with newline.

5. Create `crates/snow-rt/src/panic.rs`:
   - `#[no_mangle] pub extern "C" fn snow_panic(msg: *const u8, msg_len: u64, file: *const u8, file_len: u64, line: u32) -> !` -- prints "Snow panic at {file}:{line}: {msg}" to stderr and calls `std::process::abort()`.

6. Create `crates/snow-rt/src/lib.rs`:
   - `pub mod gc;` `pub mod string;` `pub mod panic;`
   - Re-export key functions for Rust-side testing.
  </action>
  <verify>
Run `cargo build -p snow-rt` and verify it compiles. Run `cargo test -p snow-rt` for any basic unit tests. Verify that the staticlib is produced: check `target/debug/libsnow_rt.a` exists after build.
  </verify>
  <done>snow-rt compiles as both a Rust lib and a static library. All extern "C" functions (snow_gc_alloc, snow_string_new, snow_string_concat, snow_int_to_string, snow_float_to_string, snow_bool_to_string, snow_print, snow_println, snow_panic, snow_rt_init) are defined and exported.</done>
</task>

<task type="auto">
  <name>Task 2: Create snow-codegen crate scaffolding and expose TypeckResult internals</name>
  <files>
    Cargo.toml
    crates/snow-codegen/Cargo.toml
    crates/snow-codegen/src/lib.rs
    crates/snow-typeck/src/lib.rs
    crates/snow-typeck/src/infer.rs
    .cargo/config.toml
  </files>
  <action>
1. Configure LLVM build environment:
   - Create `.cargo/config.toml` with:
     ```toml
     [env]
     LLVM_SYS_211_PREFIX = "/opt/homebrew/opt/llvm"
     ```
   - This ensures inkwell/llvm-sys can find LLVM 21 during compilation without manual env setup.

2. Add workspace dependencies to root `Cargo.toml`:
   ```toml
   inkwell = { version = "0.8.0", features = ["llvm21-1"] }
   clap = { version = "4.5", features = ["derive"] }
   ```

3. Add `snow-codegen` to workspace members in root `Cargo.toml`.

4. Create `crates/snow-codegen/Cargo.toml`:
   ```toml
   [package]
   name = "snow-codegen"
   version = "0.1.0"
   edition = "2021"

   [dependencies]
   inkwell = { workspace = true }
   snow-common = { path = "../snow-common" }
   snow-parser = { path = "../snow-parser" }
   snow-typeck = { path = "../snow-typeck" }
   rustc-hash = { workspace = true }

   [dev-dependencies]
   insta = { workspace = true }
   ```

5. Create `crates/snow-codegen/src/lib.rs`:
   - Declare module stubs: `pub mod mir;` `pub mod codegen;`
   - Create empty `crates/snow-codegen/src/mir/mod.rs` and `crates/snow-codegen/src/codegen/mod.rs` placeholder files.
   - Add a placeholder public compile function: `pub fn compile(_parse: &snow_parser::Parse, _typeck: &snow_typeck::TypeckResult) -> Result<(), String> { todo!() }`

6. Expose TypeckResult internals in snow-typeck:
   - In `crates/snow-typeck/src/infer.rs`: Change `StructDefInfo`, `SumTypeDefInfo`, `VariantInfo`, `VariantFieldInfo`, `TypeAliasInfo`, and `TypeRegistry` from `pub(crate)` / private to `pub`.
   - In `crates/snow-typeck/src/infer.rs`: Add a method to the `infer()` function to return the TypeRegistry alongside the TypeckResult. Modify the `infer()` function signature or add the type registry as a field on TypeckResult.
   - In `crates/snow-typeck/src/lib.rs`: Add `pub type_registry: TypeRegistry` field to `TypeckResult` (where `TypeRegistry` is re-exported from `infer` module). Also re-export the struct/sum type info types from `lib.rs` for convenient access.
   - Update the `check()` function to pass through the registry.
   - Make sure existing tests still pass after visibility changes.

The key types to expose publicly:
- `StructDefInfo { name, generic_params, fields: Vec<(String, Ty)> }`
- `SumTypeDefInfo { name, generic_params, variants: Vec<VariantInfo> }`
- `VariantInfo { name, fields: Vec<VariantFieldInfo> }`
- `VariantFieldInfo::Positional(Ty) | Named(String, Ty)`
- `TypeRegistry { struct_defs, sum_type_defs, type_aliases }`
  </action>
  <verify>
Run `cargo build -p snow-codegen` and verify it compiles (including inkwell linking with LLVM). Run `cargo test` on the full workspace to verify no regressions from TypeckResult changes.
  </verify>
  <done>snow-codegen crate exists and compiles with inkwell dependency. TypeckResult now contains a public type_registry field with StructDefInfo, SumTypeDefInfo, and related types accessible to downstream crates. All existing tests pass. LLVM build environment is configured in .cargo/config.toml.</done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` succeeds and `target/debug/libsnow_rt.a` exists
2. `cargo build -p snow-codegen` succeeds (inkwell links against LLVM 21)
3. `cargo test` passes all existing tests (no regressions from TypeckResult changes)
4. `TypeckResult.type_registry` is accessible from outside snow-typeck crate
</verification>

<success_criteria>
- Two new crates (snow-rt, snow-codegen) in workspace, both compiling
- Runtime exports all extern "C" functions needed by compiled Snow programs
- TypeckResult exposes struct/sum type definitions for codegen consumption
- LLVM environment configured and inkwell builds successfully
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-llvm-codegen-native-binaries/05-01-SUMMARY.md`
</output>
