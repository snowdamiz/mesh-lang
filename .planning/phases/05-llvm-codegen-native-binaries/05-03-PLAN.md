---
phase: 05-llvm-codegen-native-binaries
plan: 03
type: tdd
wave: 3
depends_on: ["05-02"]
files_modified:
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/pattern/mod.rs
  - crates/snow-codegen/src/pattern/compile.rs
autonomous: true

must_haves:
  truths:
    - "MIR match expressions compile to decision trees with Switch/Test/Guard/Leaf/Fail nodes"
    - "Or-patterns produce duplicated arms (one Leaf per alternative)"
    - "Guarded arms generate Guard nodes that fall through to Fail on runtime guard failure"
    - "All pattern types (wildcard, var, literal, constructor, tuple, or) compile correctly"
    - "Decision trees never test the same sub-value twice"
  artifacts:
    - path: "crates/snow-codegen/src/pattern/mod.rs"
      provides: "DecisionTree type definitions"
      contains: "DecisionTree"
    - path: "crates/snow-codegen/src/pattern/compile.rs"
      provides: "Pattern matrix -> decision tree compiler"
      contains: "fn compile_match"
  key_links:
    - from: "crates/snow-codegen/src/pattern/compile.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "reads MirPattern, produces DecisionTree"
      pattern: "MirPattern"
---

<objective>
Compile MIR pattern match expressions into decision trees using Maranget's algorithm, producing efficient Switch/Test/Guard/Leaf/Fail nodes that map directly to LLVM switch instructions and conditional branches.

Purpose: Pattern matching is a core Snow feature. The decision tree representation eliminates redundant tests and provides a direct mapping to LLVM's switch and branch instructions. This follows the same algorithm family as the Phase 4 exhaustiveness checker but targets code generation rather than analysis.

Output: A pattern match compiler that transforms `MirExpr::Match` nodes into `DecisionTree` structures ready for LLVM codegen.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llvm-codegen-native-binaries/05-RESEARCH.md
@.planning/phases/05-llvm-codegen-native-binaries/05-02-SUMMARY.md
@crates/snow-codegen/src/mir/mod.rs
</context>

<feature>
  <name>Pattern Match Compilation to Decision Trees</name>
  <files>
    crates/snow-codegen/src/pattern/mod.rs
    crates/snow-codegen/src/pattern/compile.rs
  </files>
  <behavior>
Pattern match compilation takes a scrutinee expression and a list of match arms (MirMatchArm with MirPattern + optional guard + body) and produces a DecisionTree.

**Decision tree node types:**
- `Leaf { arm_index, bindings: Vec<(String, MirType, AccessPath)> }` -- execute arm body with variable bindings
- `Switch { scrutinee_path: AccessPath, cases: Vec<(ConstructorTag, DecisionTree)>, default: Option<Box<DecisionTree>> }` -- switch on sum type tag
- `Test { scrutinee_path: AccessPath, value: MirLiteral, success: Box<DecisionTree>, failure: Box<DecisionTree> }` -- test literal equality
- `Guard { guard_expr: MirExpr, success: Box<DecisionTree>, failure: Box<DecisionTree> }` -- evaluate guard, branch
- `Fail { message: String, file: String, line: u32 }` -- runtime panic for non-exhaustive match with guards

**AccessPath** describes how to reach a sub-value:
- `Root` -- the scrutinee itself
- `TupleField(Box<AccessPath>, usize)` -- field N of a tuple
- `VariantField(Box<AccessPath>, String, usize)` -- field N of a variant
- `StructField(Box<AccessPath>, String)` -- named field of a struct

**Test cases (input -> expected output):**

1. Single wildcard arm:
   `match x { _ -> 1 }` -> `Leaf { arm_index: 0, bindings: [] }`

2. Variable binding:
   `match x { y -> y }` -> `Leaf { arm_index: 0, bindings: [(y, Int, Root)] }`

3. Integer literal tests:
   `match x { 1 -> "one", 2 -> "two", _ -> "other" }` ->
   `Test(Root, 1, Leaf(0), Test(Root, 2, Leaf(1), Leaf(2)))`

4. Constructor switch:
   `match shape { Circle(r) -> r, Rectangle(w, h) -> w * h }` ->
   `Switch(Root, [(0, Leaf(0, [(r, Float, VariantField(Root, "Circle", 0))])), (1, Leaf(1, [...]))])`

5. Nested patterns:
   `match pair { (Some(x), _) -> x, (None, y) -> y }` ->
   `Switch(TupleField(Root, 0), [(Some_tag, Leaf(0, [...])), (None_tag, Leaf(1, [...]))])`

6. Or-patterns (duplicate arms per locked decision):
   `match x { 1 | 2 -> "small", _ -> "big" }` ->
   `Test(Root, 1, Leaf(0), Test(Root, 2, Leaf(0_dup), Leaf(1)))`

7. Guard:
   `match x { n when n > 0 -> "positive", _ -> "non-positive" }` ->
   `Guard(guard_expr, Leaf(0, [(n, Int, Root)]), Leaf(1))`

8. Guard with Fail fallback (guarded arms not covering all cases):
   If all non-default arms have guards and might fail, the default arm leads to Leaf, but if there is no default, a `Fail` node is produced.
  </behavior>
  <implementation>
Implement Maranget-style pattern compilation:

1. **Pattern matrix**: Represent the match as a matrix where rows are arms and columns are pattern positions. Initially one column (the scrutinee).

2. **Column selection**: Choose the column with the most constructor diversity (heuristic for good decision trees).

3. **Specialization**: For each constructor in the selected column:
   - Filter rows matching that constructor
   - Expand sub-patterns (e.g., `Circle(r)` adds `r` as a new column)
   - Recurse on the specialized matrix

4. **Default matrix**: Rows with wildcard/variable in the selected column form the default case.

5. **Leaf generation**: When matrix has one row with all wildcards/variables, produce a Leaf with bindings.

6. **Guard handling**: When a Leaf arm has a guard, wrap in a Guard node. The failure branch continues to the next alternative (from the default matrix or Fail).

7. **Or-pattern expansion**: Before compilation, expand or-patterns by duplicating the arm for each alternative. `(1 | 2) -> body` becomes two rows: `1 -> body`, `2 -> body`. This follows the locked decision.

8. **Fail node**: When no arm matches (possible only with guards), produce `Fail { message: "non-exhaustive match", file, line }`.

Add `pub mod pattern;` to `crates/snow-codegen/src/lib.rs`.

The AccessPath type should also go in `pattern/mod.rs` or be defined alongside DecisionTree.

Add a `compile_patterns(module: &mut MirModule)` function that walks all MirExpr::Match nodes in the module and replaces them with `MirExpr::CompiledMatch { scrutinee, decision_tree, arms_bodies: Vec<MirExpr>, ty }` (add this variant to MirExpr in mod.rs).
  </implementation>
</feature>

<verification>
1. `cargo test -p snow-codegen` passes all pattern compilation tests
2. Tests cover: wildcard, variable binding, integer literals, boolean literals, constructor patterns, nested patterns, or-patterns (duplicated), guards, guard failure
3. Decision trees never have redundant tests on the same access path
</verification>

<success_criteria>
- DecisionTree type with Switch/Test/Guard/Leaf/Fail nodes defined
- Pattern compiler handles all MirPattern variants
- Or-patterns duplicate arm bodies per locked decision
- Guards produce Guard nodes with Fail fallback
- Unit tests verify correct tree structure for each pattern type
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-llvm-codegen-native-binaries/05-03-SUMMARY.md`
</output>
