---
phase: 05-llvm-codegen-native-binaries
plan: 05
type: execute
wave: 5
depends_on: ["05-04"]
files_modified:
  - crates/snowc/Cargo.toml
  - crates/snowc/src/main.rs
  - crates/snow-codegen/src/lib.rs
  - crates/snow-codegen/src/link.rs
  - tests/e2e/hello.snow
  - tests/e2e/functions.snow
  - tests/e2e/pattern_match.snow
  - tests/e2e/closures.snow
  - tests/e2e/pipe.snow
  - tests/e2e/string_interp.snow
  - tests/e2e/adts.snow
  - tests/e2e/comprehensive.snow
autonomous: false

must_haves:
  truths:
    - "`snowc build <dir>` produces a native executable in the project directory"
    - "The executable runs and prints correct output to stdout"
    - "Hello World program compiles and runs: prints 'Hello, World!'"
    - "Program using functions, pattern matching, ADTs, closures, pipe, string interpolation compiles and runs with correct output"
    - "The binary is self-contained with no external runtime dependencies (snow-rt statically linked)"
    - "`snowc build --emit-llvm` dumps .ll file alongside binary"
    - "Both -O0 and -O2 optimization levels work"
    - "Compilation of 100-line program completes in under 5 seconds at -O0"
  artifacts:
    - path: "crates/snowc/src/main.rs"
      provides: "CLI with snowc build subcommand"
      contains: "snowc build"
    - path: "crates/snow-codegen/src/link.rs"
      provides: "Object file linking via system cc"
      contains: "fn link"
    - path: "tests/e2e/hello.snow"
      provides: "Hello World test program"
      contains: "Hello, World!"
    - path: "tests/e2e/comprehensive.snow"
      provides: "Multi-feature test program"
      min_lines: 50
  key_links:
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-codegen/src/lib.rs"
      via: "calls compile pipeline"
      pattern: "snow_codegen"
    - from: "crates/snow-codegen/src/link.rs"
      to: "system cc"
      via: "invokes cc to link object file + snow-rt static lib"
      pattern: "Command::new.*cc"
---

<objective>
Implement the `snowc build` CLI command, object file linking with snow-rt, and comprehensive end-to-end integration tests that verify all phase success criteria.

Purpose: This is the final integration plan that connects everything: the CLI parses arguments, invokes the full compilation pipeline (lex -> parse -> typecheck -> MIR lower -> LLVM codegen -> object file -> link), and produces a runnable native binary. End-to-end tests prove all success criteria are met.

Output: Working `snowc build <dir>` command, linked native binaries, and integration tests covering hello world, functions, pattern matching, ADTs, closures, pipe operator, string interpolation, and a comprehensive multi-feature program.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llvm-codegen-native-binaries/05-RESEARCH.md
@.planning/phases/05-llvm-codegen-native-binaries/05-04-SUMMARY.md
@crates/snowc/src/main.rs
@crates/snowc/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement snowc build CLI, linker integration, and compilation pipeline</name>
  <files>
    crates/snowc/Cargo.toml
    crates/snowc/src/main.rs
    crates/snow-codegen/src/link.rs
    crates/snow-codegen/src/lib.rs
  </files>
  <action>
1. **Update snowc Cargo.toml** to add all dependencies:
   ```toml
   [dependencies]
   clap = { workspace = true }
   snow-common = { path = "../snow-common" }
   snow-lexer = { path = "../snow-lexer" }
   snow-parser = { path = "../snow-parser" }
   snow-typeck = { path = "../snow-typeck" }
   snow-codegen = { path = "../snow-codegen" }
   ariadne = { workspace = true }
   ```

2. **Implement CLI in main.rs** using clap derive:
   ```
   snowc build <dir> [--opt-level=0|2] [--emit-llvm] [--output=<path>]
   ```
   - `<dir>`: project directory containing `main.snow`
   - `--opt-level`: 0 (default for debug) or 2 (release). Maps to LLVM OptimizationLevel::None / OptimizationLevel::Default.
   - `--emit-llvm`: dump `.ll` file alongside binary
   - `--output`: output binary path (default: `<dir>/build/<project_name>`)

   Pipeline in `build` subcommand handler:
   1. Find `main.snow` in `<dir>`. If not found, error: "No main.snow found in {dir}".
   2. Read source file.
   3. Parse with `snow_parser::parse(&source)`. If errors, render with ariadne and exit 1.
   4. Type-check with `snow_typeck::check(&parse)`. If errors, render diagnostics and exit 1.
   5. Compile with `snow_codegen::compile_to_binary(&parse, &typeck, &output_path, opt_level, emit_llvm)`. If errors, render and exit 1.
   6. Print "Compiled: {output_path}" on success.

3. **Implement linker in `crates/snow-codegen/src/link.rs`**:

   `pub fn link(object_path: &Path, output_path: &Path, rt_lib_path: &Path) -> Result<(), String>`:
   - Invoke system `cc` as the linker driver (handles macOS vs Linux automatically per research):
     ```
     cc <object_path> -L<rt_lib_dir> -lsnow_rt -o <output_path>
     ```
   - On macOS: cc invokes clang. On Linux: cc invokes gcc or clang.
   - If `cc` fails, capture stderr and return as error.
   - Clean up the `.o` file after successful linking.

   **Finding the snow-rt static library:**
   - The snow-rt crate compiles to `target/{profile}/libsnow_rt.a` when built as staticlib.
   - Use a build-time approach: `snow-codegen` or `snowc` embeds the path to the compiled snow-rt library.
   - Pragmatic approach for Phase 5: `snowc build` first runs `cargo build -p snow-rt --release` (or uses the already-built library from the workspace target dir). Locate it at `{workspace_root}/target/{profile}/libsnow_rt.a`.
   - Alternative simpler approach: compile snow-rt functions inline as LLVM IR (add runtime function bodies directly to the LLVM module instead of linking). However, the static library approach is more maintainable and matches Phase 6 needs. Use the static library approach.

4. **Update snow-codegen/src/lib.rs** with the full pipeline function:

   `pub fn compile_to_binary(parse: &Parse, typeck: &TypeckResult, output_path: &Path, opt_level: OptimizationLevel, emit_llvm: bool) -> Result<(), Vec<String>>`:
   1. Lower to MIR
   2. Compile patterns
   3. Create LLVM CodeGen, compile to LLVM IR
   4. If emit_llvm, write .ll file
   5. Run optimization passes
   6. Emit object file to temp path
   7. Link object file with snow-rt to produce final binary
   8. Return Ok or errors

Add `pub mod link;` to lib.rs.
  </action>
  <verify>
1. `cargo build -p snowc` compiles
2. Create a minimal `test_project/main.snow` with `fn main() do println("Hello, World!") end`
3. Run `cargo run -p snowc -- build test_project/` and verify it produces a binary
4. Run the binary and verify it prints "Hello, World!"
5. Test `--emit-llvm` flag produces .ll file
  </verify>
  <done>`snowc build <dir>` compiles Snow source to a native binary. The linker integrates snow-rt static library. --emit-llvm flag works. --opt-level 0 and 2 both work. Error messages use ariadne rendering.</done>
</task>

<task type="auto">
  <name>Task 2: End-to-end integration tests for all success criteria</name>
  <files>
    tests/e2e/hello.snow
    tests/e2e/functions.snow
    tests/e2e/pattern_match.snow
    tests/e2e/closures.snow
    tests/e2e/pipe.snow
    tests/e2e/string_interp.snow
    tests/e2e/adts.snow
    tests/e2e/comprehensive.snow
  </files>
  <action>
Create end-to-end integration tests that compile Snow programs and verify their output. These tests directly validate the phase success criteria.

Create a test harness (either as a Rust integration test in `crates/snowc/tests/e2e.rs` or as a shell script). The Rust integration test approach is preferred:

Each test:
1. Writes a `.snow` file to a temp directory
2. Invokes `snowc build` on it (via `Command::new(cargo_bin("snowc"))`)
3. Runs the produced binary
4. Asserts stdout matches expected output
5. Cleans up

**Test programs:**

1. **hello.snow** (Success Criterion 1):
   ```snow
   fn main() do
     println("Hello, World!")
   end
   ```
   Expected: "Hello, World!\n"

2. **functions.snow**:
   ```snow
   fn add(a :: Int, b :: Int) :: Int do
     a + b
   end

   fn double(x :: Int) :: Int do
     x * 2
   end

   fn main() do
     let result = add(3, 4)
     println(int_to_string(result))
     println(int_to_string(double(5)))
   end
   ```
   Expected: "7\n10\n"

3. **pattern_match.snow**:
   ```snow
   fn describe(n :: Int) :: String do
     match n do
       0 -> "zero"
       1 -> "one"
       _ -> "other"
     end
   end

   fn main() do
     println(describe(0))
     println(describe(1))
     println(describe(42))
   end
   ```
   Expected: "zero\none\nother\n"

4. **adts.snow**:
   ```snow
   type Shape do
     Circle(Float)
     Rectangle(Float, Float)
     Point
   end

   fn area(s :: Shape) :: Float do
     match s do
       Circle(r) -> 3.14159 * r * r
       Rectangle(w, h) -> w * h
       Point -> 0.0
     end
   end

   fn main() do
     let c = Circle(5.0)
     let r = Rectangle(3.0, 4.0)
     println(float_to_string(area(c)))
     println(float_to_string(area(r)))
     println(float_to_string(area(Point)))
   end
   ```
   Expected: area values for circle (78.53975), rectangle (12.0), point (0.0)

5. **closures.snow**:
   ```snow
   fn make_adder(x :: Int) :: (Int) -> Int do
     fn(y :: Int) -> x + y end
   end

   fn main() do
     let add5 = make_adder(5)
     println(int_to_string(add5(3)))
     println(int_to_string(add5(10)))
   end
   ```
   Expected: "8\n15\n"

6. **pipe.snow**:
   ```snow
   fn double(x :: Int) :: Int do x * 2 end
   fn add_one(x :: Int) :: Int do x + 1 end

   fn main() do
     let result = 5 |> double |> add_one
     println(int_to_string(result))
   end
   ```
   Expected: "11\n"

7. **string_interp.snow**:
   ```snow
   fn main() do
     let name = "World"
     let age = 42
     println("Hello, ${name}!")
     println("The answer is ${age}")
   end
   ```
   Expected: "Hello, World!\nThe answer is 42\n"

8. **comprehensive.snow** (Success Criterion 2 -- uses ALL features, 100+ lines):
   A program that combines functions, pattern matching, ADTs, closures, pipe operator, and string interpolation. This is the ultimate integration test. Include at least:
   - Multiple function definitions
   - A sum type with multiple variants
   - Pattern matching with guards
   - A closure capturing a variable
   - Pipe operator chaining
   - String interpolation with computed values
   - Nested function calls
   Expected output should be deterministic and verified.

**Performance test** (Success Criterion 5):
Add a test that measures compilation time of the comprehensive.snow (or a dedicated 100-line program) at -O0 and asserts < 5 seconds.

**Self-contained binary test** (Success Criterion 3):
After compilation, verify the binary has no dynamic dependency on snow-rt:
- On macOS: `otool -L <binary>` should not reference snow_rt
- On Linux: `ldd <binary>` should not reference snow_rt
(Static linking means it is embedded in the binary.)

Note: The cross-platform test (Success Criterion 4 - macOS + Linux) is verified by running the full test suite on both platforms. The test infrastructure should be platform-agnostic. Add a note in test comments that CI should run on both platforms.
  </action>
  <verify>
1. `cargo test -p snowc` passes all e2e tests
2. hello.snow binary prints "Hello, World!"
3. comprehensive.snow binary produces correct output for all feature combinations
4. --emit-llvm produces readable .ll file
5. Compilation time for 100-line program < 5 seconds at -O0
6. Binary has no dynamic snow-rt dependency (statically linked)
  </verify>
  <done>All 8 e2e test programs compile and run with correct output. Hello World works. Multi-feature comprehensive program works. Binary is self-contained. Compilation performance is under 5 seconds. All phase success criteria verified.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Snow compilation pipeline: snowc build produces native binaries from Snow source code. All sequential language features (functions, pattern matching, ADTs, closures, pipe operator, string interpolation) compile and run correctly.</what-built>
  <how-to-verify>
1. Run `cargo test` to verify all tests pass (existing + new e2e tests)
2. Create a test project:
   ```
   mkdir /tmp/snow-test && cat > /tmp/snow-test/main.snow << 'EOF'
   fn main() do
     let greeting = "Hello"
     let name = "Snow"
     println("${greeting}, ${name}!")

     let result = 5 |> double |> add_one
     println("Result: ${int_to_string(result)}")
   end

   fn double(x :: Int) :: Int do x * 2 end
   fn add_one(x :: Int) :: Int do x + 1 end
   EOF
   ```
3. Compile: `cargo run -p snowc -- build /tmp/snow-test/`
4. Run: `/tmp/snow-test/build/snow-test` (or wherever the binary is placed)
5. Expected output:
   ```
   Hello, Snow!
   Result: 11
   ```
6. Verify `--emit-llvm` works: `cargo run -p snowc -- build /tmp/snow-test/ --emit-llvm`
   Check that a `.ll` file was produced alongside the binary.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `snowc build <dir>` produces a native executable from Snow source
2. Hello World compiles and runs: prints "Hello, World!"
3. Multi-feature program compiles and runs with all features working
4. Binary is self-contained (no external runtime dependency)
5. --emit-llvm flag produces .ll file
6. Both -O0 and -O2 optimization levels work
7. 100-line program compiles in under 5 seconds at -O0
8. All existing tests (lexer, parser, typeck) still pass
</verification>

<success_criteria>
- `snowc build hello_project/` produces a binary that prints "Hello, World!" (SC1)
- Functions, pattern matching, ADTs, closures, pipe, string interp all work in a single program (SC2)
- Binary has no external runtime dependency -- snow-rt is statically linked (SC3)
- Tests pass on macOS (Linux verified when CI is set up) (SC4)
- 100-line program compiles in < 5 seconds at -O0 (SC5)
</success_criteria>

<output>
After completion, create `.planning/phases/05-llvm-codegen-native-binaries/05-05-SUMMARY.md`
</output>
