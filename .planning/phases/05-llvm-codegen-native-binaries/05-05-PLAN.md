---
phase: 05-llvm-codegen-native-binaries
plan: 05
type: execute
wave: 5
depends_on: ["05-04"]
files_modified:
  - crates/snowc/Cargo.toml
  - crates/snowc/src/main.rs
  - crates/snow-codegen/src/lib.rs
  - crates/snow-codegen/src/link.rs
  - tests/e2e/hello.snow
  - tests/e2e/functions.snow
  - tests/e2e/pattern_match.snow
  - tests/e2e/closures.snow
  - tests/e2e/pipe.snow
  - tests/e2e/string_interp.snow
  - tests/e2e/adts.snow
  - tests/e2e/comprehensive.snow
autonomous: false

must_haves:
  truths:
    - "`snowc build <dir>` produces a native executable in the project directory"
    - "The executable runs and prints correct output to stdout"
    - "Hello World program compiles and runs: prints 'Hello, World!'"
    - "Program using functions, pattern matching, ADTs, closures, pipe, string interpolation compiles and runs with correct output"
    - "The binary is self-contained with no external runtime dependencies (snow-rt statically linked)"
    - "`snowc build --emit-llvm` dumps .ll file alongside binary"
    - "Both -O0 and -O2 optimization levels work"
    - "Compilation of 100-line program completes in under 5 seconds at -O0"
    - "`snowc build --target <triple>` accepts a target triple for cross-platform object file generation"
    - "LLVM native target initialization succeeds on the host platform"
  artifacts:
    - path: "crates/snowc/src/main.rs"
      provides: "CLI with snowc build subcommand, --target flag"
      contains: "snowc build"
    - path: "crates/snow-codegen/src/link.rs"
      provides: "Object file linking via system cc"
      contains: "fn link"
    - path: "tests/e2e/hello.snow"
      provides: "Hello World test program"
      contains: "Hello, World!"
    - path: "tests/e2e/comprehensive.snow"
      provides: "Multi-feature test program"
      min_lines: 50
  key_links:
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-codegen/src/lib.rs"
      via: "calls compile pipeline with target_triple parameter"
      pattern: "snow_codegen"
    - from: "crates/snow-codegen/src/link.rs"
      to: "system cc"
      via: "invokes cc to link object file + snow-rt static lib"
      pattern: "Command::new.*cc"
---

<objective>
Implement the `snowc build` CLI command with `--target` flag, object file linking with snow-rt, and comprehensive end-to-end integration tests that verify all phase success criteria.

Purpose: This is the final integration plan that connects everything: the CLI parses arguments, invokes the full compilation pipeline (lex -> parse -> typecheck -> MIR lower -> LLVM codegen -> object file -> link), and produces a runnable native binary. The `--target` flag enables cross-platform object file generation. End-to-end tests prove all success criteria are met.

Output: Working `snowc build <dir>` command with `--target` support, linked native binaries, and integration tests covering hello world, functions, pattern matching, ADTs, closures, pipe operator, string interpolation, and a comprehensive multi-feature program.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llvm-codegen-native-binaries/05-RESEARCH.md
@.planning/phases/05-llvm-codegen-native-binaries/05-04-SUMMARY.md
@crates/snowc/src/main.rs
@crates/snowc/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement snowc build CLI with --target flag, linker integration, and compilation pipeline</name>
  <files>
    crates/snowc/Cargo.toml
    crates/snowc/src/main.rs
    crates/snow-codegen/src/link.rs
    crates/snow-codegen/src/lib.rs
  </files>
  <action>
1. **Update snowc Cargo.toml** to add all dependencies:
   ```toml
   [dependencies]
   clap = { workspace = true }
   snow-common = { path = "../snow-common" }
   snow-lexer = { path = "../snow-lexer" }
   snow-parser = { path = "../snow-parser" }
   snow-typeck = { path = "../snow-typeck" }
   snow-codegen = { path = "../snow-codegen" }
   ariadne = { workspace = true }
   ```

2. **Implement CLI in main.rs** using clap derive:
   ```
   snowc build <dir> [--opt-level=0|2] [--emit-llvm] [--output=<path>] [--target=<triple>]
   ```
   - `<dir>`: project directory containing `main.snow`
   - `--opt-level`: 0 (default for debug) or 2 (release). Maps to LLVM OptimizationLevel::None / OptimizationLevel::Default.
   - `--emit-llvm`: dump `.ll` file alongside binary
   - `--output`: output binary path (default: `<dir>/build/<project_name>`)
   - `--target`: target triple for cross-platform compilation (default: host platform). Examples: `x86_64-unknown-linux-gnu`, `aarch64-apple-darwin`. When specified, the compiler generates an object file for that target but still attempts to link with the host linker. If the target does not match the host, warn the user that cross-linking requires an appropriate cross-compilation toolchain. For host-only compilation (no --target), this parameter is omitted and CodeGen uses the host default.

   Pipeline in `build` subcommand handler:
   1. Find `main.snow` in `<dir>`. If not found, error: "No main.snow found in {dir}".
   2. Read source file.
   3. Parse with `snow_parser::parse(&source)`. If errors, render with ariadne and exit 1.
   4. Type-check with `snow_typeck::check(&parse)`. If errors, render diagnostics and exit 1.
   5. Compile with `snow_codegen::compile_to_binary(&parse, &typeck, &output_path, opt_level, emit_llvm, target_triple)`. The `target_triple` is `Option<&str>` -- `None` for host, `Some(triple)` when --target is provided. If errors, render and exit 1.
   6. Print "Compiled: {output_path}" on success.

3. **Implement linker in `crates/snow-codegen/src/link.rs`**:

   `pub fn link(object_path: &Path, output_path: &Path, rt_lib_path: &Path) -> Result<(), String>`:
   - Invoke system `cc` as the linker driver (handles macOS vs Linux automatically per research):
     ```
     cc <object_path> -L<rt_lib_dir> -lsnow_rt -o <output_path>
     ```
   - On macOS: cc invokes clang. On Linux: cc invokes gcc or clang.
   - If `cc` fails, capture stderr and return as error.
   - Clean up the `.o` file after successful linking.

   **Finding the snow-rt static library:**
   - The snow-rt crate compiles to `target/{profile}/libsnow_rt.a` when built as staticlib.
   - Use a build-time approach: `snow-codegen` or `snowc` embeds the path to the compiled snow-rt library.
   - Pragmatic approach for Phase 5: `snowc build` first runs `cargo build -p snow-rt --release` (or uses the already-built library from the workspace target dir). Locate it at `{workspace_root}/target/{profile}/libsnow_rt.a`.
   - Alternative simpler approach: compile snow-rt functions inline as LLVM IR (add runtime function bodies directly to the LLVM module instead of linking). However, the static library approach is more maintainable and matches Phase 6 needs. Use the static library approach.

4. **Update snow-codegen/src/lib.rs** with the full pipeline function:

   `pub fn compile_to_binary(parse: &Parse, typeck: &TypeckResult, output_path: &Path, opt_level: OptimizationLevel, emit_llvm: bool, target_triple: Option<&str>) -> Result<(), Vec<String>>`:
   1. Lower to MIR
   2. Compile patterns
   3. Create LLVM CodeGen with `target_triple`, compile to LLVM IR
   4. If emit_llvm, write .ll file
   5. Run optimization passes
   6. Emit object file to temp path
   7. Link object file with snow-rt to produce final binary
   8. Return Ok or errors

Add `pub mod link;` to lib.rs.
  </action>
  <verify>
1. `cargo build -p snowc` compiles
2. Create a minimal `test_project/main.snow` with `fn main() do println("Hello, World!") end`
3. Run `cargo run -p snowc -- build test_project/` and verify it produces a binary
4. Run the binary and verify it prints "Hello, World!"
5. Test `--emit-llvm` flag produces .ll file
6. Test `--target` flag: `cargo run -p snowc -- build test_project/ --target x86_64-unknown-linux-gnu` should either succeed (producing a .o for that target) or give a clear error about cross-linking requirements -- it must NOT fail silently or crash during LLVM target initialization
7. `cargo test -p snow-codegen -- test_native_target_init` confirms that `Target::initialize_native()` succeeds and the target machine is created with the correct triple for the host platform (this test was added in Plan 05-04 Task 1; verify it passes here as part of the full pipeline)
  </verify>
  <done>`snowc build <dir>` compiles Snow source to a native binary. `--target <triple>` flag passes a configurable target triple through to CodeGen for cross-platform object file generation. The linker integrates snow-rt static library. --emit-llvm flag works. --opt-level 0 and 2 both work. Error messages use ariadne rendering. LLVM native target initialization is verified to succeed.</done>
</task>

<task type="auto">
  <name>Task 2: End-to-end integration tests for all success criteria</name>
  <files>
    tests/e2e/hello.snow
    tests/e2e/functions.snow
    tests/e2e/pattern_match.snow
    tests/e2e/closures.snow
    tests/e2e/pipe.snow
    tests/e2e/string_interp.snow
    tests/e2e/adts.snow
    tests/e2e/comprehensive.snow
  </files>
  <action>
Create end-to-end integration tests that compile Snow programs and verify their output. These tests directly validate the phase success criteria.

Create a test harness (either as a Rust integration test in `crates/snowc/tests/e2e.rs` or as a shell script). The Rust integration test approach is preferred:

Each test:
1. Writes a `.snow` file to a temp directory
2. Invokes `snowc build` on it (via `Command::new(cargo_bin("snowc"))`)
3. Runs the produced binary
4. Asserts stdout matches expected output
5. Cleans up

**Test programs:**

1. **hello.snow** (Success Criterion 1):
   ```snow
   fn main() do
     println("Hello, World!")
   end
   ```
   Expected: "Hello, World!\n"

2. **functions.snow**:
   ```snow
   fn add(a :: Int, b :: Int) :: Int do
     a + b
   end

   fn double(x :: Int) :: Int do
     x * 2
   end

   fn main() do
     let result = add(3, 4)
     println(int_to_string(result))
     println(int_to_string(double(5)))
   end
   ```
   Expected: "7\n10\n"

3. **pattern_match.snow**:
   ```snow
   fn describe(n :: Int) :: String do
     match n do
       0 -> "zero"
       1 -> "one"
       _ -> "other"
     end
   end

   fn main() do
     println(describe(0))
     println(describe(1))
     println(describe(42))
   end
   ```
   Expected: "zero\none\nother\n"

4. **adts.snow**:
   ```snow
   type Shape do
     Circle(Float)
     Rectangle(Float, Float)
     Point
   end

   fn area(s :: Shape) :: Float do
     match s do
       Circle(r) -> 3.14159 * r * r
       Rectangle(w, h) -> w * h
       Point -> 0.0
     end
   end

   fn main() do
     let c = Circle(5.0)
     let r = Rectangle(3.0, 4.0)
     println(float_to_string(area(c)))
     println(float_to_string(area(r)))
     println(float_to_string(area(Point)))
   end
   ```
   Expected: area values for circle (78.53975), rectangle (12.0), point (0.0)

5. **closures.snow**:
   ```snow
   fn make_adder(x :: Int) :: (Int) -> Int do
     fn(y :: Int) -> x + y end
   end

   fn main() do
     let add5 = make_adder(5)
     println(int_to_string(add5(3)))
     println(int_to_string(add5(10)))
   end
   ```
   Expected: "8\n15\n"

6. **pipe.snow**:
   ```snow
   fn double(x :: Int) :: Int do x * 2 end
   fn add_one(x :: Int) :: Int do x + 1 end

   fn main() do
     let result = 5 |> double |> add_one
     println(int_to_string(result))
   end
   ```
   Expected: "11\n"

7. **string_interp.snow**:
   ```snow
   fn main() do
     let name = "World"
     let age = 42
     println("Hello, ${name}!")
     println("The answer is ${age}")
   end
   ```
   Expected: "Hello, World!\nThe answer is 42\n"

8. **comprehensive.snow** (Success Criterion 2 -- uses ALL features, 100+ lines):
   A program that combines functions, pattern matching, ADTs, closures, pipe operator, and string interpolation. This is the ultimate integration test. Include at least:
   - Multiple function definitions
   - A sum type with multiple variants
   - Pattern matching with guards
   - A closure capturing a variable
   - Pipe operator chaining
   - String interpolation with computed values
   - Nested function calls
   Expected output should be deterministic and verified.

**Performance test** (Success Criterion 5):
Add a test that measures compilation time of the comprehensive.snow (or a dedicated 100-line program) at -O0 and asserts < 5 seconds.

**Self-contained binary test** (Success Criterion 3):
After compilation, verify the binary has no dynamic dependency on snow-rt:
- On macOS: `otool -L <binary>` should not reference snow_rt
- On Linux: `ldd <binary>` should not reference snow_rt
(Static linking means it is embedded in the binary.)

**Cross-platform test** (Success Criterion 4):
Add a test that verifies host compilation works on the current platform:
- The e2e tests themselves verify host compilation produces working binaries.
- Add a comment that CI should run the full test suite on both macOS and Linux to verify cross-platform support.
- Add a test `test_target_flag_host` that runs `snowc build --target <host_triple>` (where host_triple is detected at test time) and verifies the produced binary works identically to the default (no --target) build. This confirms the target triple plumbing works end-to-end.
  </action>
  <verify>
1. `cargo test -p snowc` passes all e2e tests
2. hello.snow binary prints "Hello, World!"
3. comprehensive.snow binary produces correct output for all feature combinations
4. --emit-llvm produces readable .ll file
5. Compilation time for 100-line program < 5 seconds at -O0
6. Binary has no dynamic snow-rt dependency (statically linked)
7. `test_target_flag_host` confirms --target with host triple produces a working binary
  </verify>
  <done>All 8 e2e test programs compile and run with correct output. Hello World works. Multi-feature comprehensive program works. Binary is self-contained. Compilation performance is under 5 seconds. --target flag works for host triple. All phase success criteria verified.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Snow compilation pipeline: snowc build produces native binaries from Snow source code. All sequential language features (functions, pattern matching, ADTs, closures, pipe operator, string interpolation) compile and run correctly. Cross-platform target triple support is available via --target flag.</what-built>
  <how-to-verify>
1. Run `cargo test` to verify all tests pass (existing + new e2e tests)
2. Create a test project:
   ```
   mkdir /tmp/snow-test && cat > /tmp/snow-test/main.snow << 'EOF'
   fn main() do
     let greeting = "Hello"
     let name = "Snow"
     println("${greeting}, ${name}!")

     let result = 5 |> double |> add_one
     println("Result: ${int_to_string(result)}")
   end

   fn double(x :: Int) :: Int do x * 2 end
   fn add_one(x :: Int) :: Int do x + 1 end
   EOF
   ```
3. Compile: `cargo run -p snowc -- build /tmp/snow-test/`
4. Run: `/tmp/snow-test/build/snow-test` (or wherever the binary is placed)
5. Expected output:
   ```
   Hello, Snow!
   Result: 11
   ```
6. Verify `--emit-llvm` works: `cargo run -p snowc -- build /tmp/snow-test/ --emit-llvm`
   Check that a `.ll` file was produced alongside the binary.
7. Verify `--target` flag: `cargo run -p snowc -- build /tmp/snow-test/ --target $(rustc -vV | grep host | cut -d' ' -f2)` should produce identical binary as without the flag.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `snowc build <dir>` produces a native executable from Snow source
2. Hello World compiles and runs: prints "Hello, World!"
3. Multi-feature program compiles and runs with all features working
4. Binary is self-contained (no external runtime dependency)
5. --emit-llvm flag produces .ll file
6. Both -O0 and -O2 optimization levels work
7. 100-line program compiles in under 5 seconds at -O0
8. All existing tests (lexer, parser, typeck) still pass
9. --target flag accepts target triples and threads them through to CodeGen
10. LLVM native target initialization succeeds (verified by codegen tests)
</verification>

<success_criteria>
- `snowc build hello_project/` produces a binary that prints "Hello, World!" (SC1)
- Functions, pattern matching, ADTs, closures, pipe, string interp all work in a single program (SC2)
- Binary has no external runtime dependency -- snow-rt is statically linked (SC3)
- Tests pass on macOS; --target flag supports configurable triples for cross-platform (SC4)
- 100-line program compiles in < 5 seconds at -O0 (SC5)
</success_criteria>

<output>
After completion, create `.planning/phases/05-llvm-codegen-native-binaries/05-05-SUMMARY.md`
</output>
