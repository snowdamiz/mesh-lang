---
phase: 05-llvm-codegen-native-binaries
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/types.rs
  - crates/snow-codegen/src/mir/mono.rs
autonomous: true

must_haves:
  truths:
    - "Typed AST lowers to a MIR representation with resolved types and no type variables"
    - "Pipe operator is desugared to function calls in MIR"
    - "String interpolation is desugared to concat chains in MIR"
    - "Generic functions are monomorphized into concrete instantiations"
    - "Closures are converted to lifted functions with explicit capture lists"
  artifacts:
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "MIR type definitions (MirModule, MirFunction, MirExpr, MirType, MirPattern)"
      min_lines: 100
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "AST + TypeckResult -> MIR lowering"
      contains: "fn lower"
    - path: "crates/snow-codegen/src/mir/types.rs"
      provides: "Ty -> MirType resolution"
      contains: "fn resolve_type"
    - path: "crates/snow-codegen/src/mir/mono.rs"
      provides: "Monomorphization pass"
      contains: "fn monomorphize"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "snow_typeck::TypeckResult"
      via: "type_registry access for struct/sum type layout"
      pattern: "type_registry"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "constructs MirModule from AST"
      pattern: "MirModule"
---

<objective>
Define the Mid-level IR (MIR) type system and implement lowering from the typed AST (Rowan CST + TypeckResult) to MIR, including pipe operator desugaring, string interpolation compilation, closure conversion, and monomorphization.

Purpose: The MIR is the bridge between the syntax-heavy Rowan CST and LLVM IR. It explicitly represents resolved concrete types, desugared syntax, lifted closures with capture lists, and monomorphized generic functions. This makes the subsequent LLVM codegen a straightforward mechanical translation.

Output: MIR type definitions, AST-to-MIR lowering pass, monomorphization pass. After this plan, any Snow program can be lowered to a flat list of monomorphic MIR functions with no type variables, no syntactic sugar, and explicit closures.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llvm-codegen-native-binaries/05-RESEARCH.md
@.planning/phases/05-llvm-codegen-native-binaries/05-01-SUMMARY.md
@crates/snow-typeck/src/ty.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-parser/src/ast/expr.rs
@crates/snow-parser/src/ast/item.rs
@crates/snow-parser/src/ast/pat.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define MIR type system</name>
  <files>
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/mir/types.rs
  </files>
  <action>
Define the complete MIR type system in `crates/snow-codegen/src/mir/mod.rs`. The MIR is a desugared, explicitly-typed intermediate representation. All types are concrete (no type variables).

**MIR types to define:**

```rust
pub mod lower;
pub mod types;
pub mod mono;
```

`mod.rs` defines:

1. **MirModule** -- top-level compilation unit:
   - `functions: Vec<MirFunction>` -- all functions (including lifted closures)
   - `structs: Vec<MirStructDef>` -- struct type definitions
   - `sum_types: Vec<MirSumTypeDef>` -- sum type definitions
   - `entry_function: Option<String>` -- name of main() if present

2. **MirFunction**:
   - `name: String` -- mangled name (e.g. "identity_Int" for monomorphized)
   - `params: Vec<(String, MirType)>`
   - `return_type: MirType`
   - `body: MirExpr`
   - `is_closure_fn: bool` -- if true, first param is env_ptr
   - `captures: Vec<(String, MirType)>` -- captured variables (for closure functions only)

3. **MirType** enum:
   - `Int` (i64)
   - `Float` (f64)
   - `Bool` (i8, 0/1)
   - `String` (pointer to GC-managed SnowString)
   - `Unit` (void / empty tuple)
   - `Tuple(Vec<MirType>)`
   - `Struct(String)` (named struct reference)
   - `SumType(String)` (named sum type reference)
   - `FnPtr(Vec<MirType>, Box<MirType>)` (known function pointer)
   - `Closure(Vec<MirType>, Box<MirType>)` (closure = {fn_ptr, env_ptr})
   - `Ptr` (raw pointer, for env_ptr etc.)
   - `Never`

4. **MirExpr** enum (each variant carries its MirType):
   - `IntLit(i64, MirType)`
   - `FloatLit(f64, MirType)`
   - `BoolLit(bool, MirType)`
   - `StringLit(String, MirType)` -- literal string value
   - `Var(String, MirType)` -- variable reference
   - `BinOp { op: BinOp, lhs: Box<MirExpr>, rhs: Box<MirExpr>, ty: MirType }`
   - `UnaryOp { op: UnaryOp, operand: Box<MirExpr>, ty: MirType }`
   - `Call { func: Box<MirExpr>, args: Vec<MirExpr>, ty: MirType }` -- direct function call
   - `ClosureCall { closure: Box<MirExpr>, args: Vec<MirExpr>, ty: MirType }` -- call through closure
   - `If { cond: Box<MirExpr>, then_body: Box<MirExpr>, else_body: Box<MirExpr>, ty: MirType }`
   - `Let { name: String, ty: MirType, value: Box<MirExpr>, body: Box<MirExpr> }`
   - `Block(Vec<MirExpr>, MirType)` -- sequence of expressions, last is value
   - `Match { scrutinee: Box<MirExpr>, arms: Vec<MirMatchArm>, ty: MirType }` -- NOT yet compiled to decision tree (that's Plan 03)
   - `StructLit { name: String, fields: Vec<(String, MirExpr)>, ty: MirType }`
   - `FieldAccess { object: Box<MirExpr>, field: String, ty: MirType }`
   - `ConstructVariant { type_name: String, variant: String, fields: Vec<MirExpr>, ty: MirType }`
   - `MakeClosure { fn_name: String, captures: Vec<MirExpr>, ty: MirType }`
   - `Return(Box<MirExpr>)`
   - `Panic { message: String, file: String, line: u32 }`
   - `Unit` -- unit value (empty tuple)

5. **MirMatchArm**: `{ pattern: MirPattern, guard: Option<MirExpr>, body: MirExpr }`

6. **MirPattern** enum:
   - `Wildcard`
   - `Var(String, MirType)` -- binds a name
   - `Literal(MirLiteral)`
   - `Constructor { type_name: String, variant: String, fields: Vec<MirPattern>, bindings: Vec<(String, MirType)> }`
   - `Tuple(Vec<MirPattern>)`
   - `Or(Vec<MirPattern>)` -- or-pattern (body duplicated per alternative per locked decision)

7. **MirLiteral**: `Int(i64)`, `Float(f64)`, `Bool(bool)`, `String(String)`

8. **BinOp** / **UnaryOp** enums with standard arithmetic, comparison, boolean operators.

9. **MirStructDef**: `{ name: String, fields: Vec<(String, MirType)> }`

10. **MirSumTypeDef**: `{ name: String, variants: Vec<MirVariantDef> }`
    **MirVariantDef**: `{ name: String, fields: Vec<MirType>, tag: u8 }`

In `types.rs`, implement `fn resolve_type(ty: &snow_typeck::ty::Ty, ...) -> MirType` that converts the typechecker's `Ty` to `MirType`. Handle:
- `Ty::Con("Int")` -> `MirType::Int`
- `Ty::Con("Float")` -> `MirType::Float`
- `Ty::Con("Bool")` -> `MirType::Bool`
- `Ty::Con("String")` -> `MirType::String`
- `Ty::Fun(params, ret)` -> `MirType::FnPtr(...)` for known functions, `MirType::Closure(...)` for closures
- `Ty::App(Con("Option"), [T])` -> `MirType::SumType("Option_T")` (monomorphized name)
- `Ty::App(Con(name), [])` -> `MirType::Struct(name)` or `MirType::SumType(name)`
- `Ty::Tuple(elems)` -> `MirType::Tuple(...)`, empty tuple -> `MirType::Unit`
- `Ty::Never` -> `MirType::Never`
- `Ty::Var(_)` -> should not appear after type checking; panic with diagnostic
  </action>
  <verify>
`cargo build -p snow-codegen` compiles. Write a few unit tests in `crates/snow-codegen/src/mir/types.rs` (or a tests module) that verify `resolve_type` correctly maps `Ty::int()` -> `MirType::Int`, `Ty::fun(vec![Ty::int()], Ty::string())` -> `MirType::FnPtr(...)`, etc.
  </verify>
  <done>MIR type definitions are complete and compile. resolve_type converts all Ty variants to MirType. Unit tests pass for type resolution.</done>
</task>

<task type="auto">
  <name>Task 2: Implement AST-to-MIR lowering with desugaring, closure conversion, and monomorphization</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/mir/mono.rs
    crates/snow-codegen/src/lib.rs
  </files>
  <action>
Implement the main lowering pass in `lower.rs` and the monomorphization pass in `mono.rs`.

**lower.rs -- AST to MIR lowering:**

Create a `Lowerer` struct that holds:
- `parse: &Parse` (the CST)
- `typeck: &TypeckResult` (type map + type registry)
- `module: MirModule` (being built)
- `current_scope: Vec<HashMap<String, MirType>>` (local variable types)
- `closure_counter: u32` (for generating unique lifted function names)

The lowerer walks the typed AST top-down:

1. **Top-level items**: Walk `SourceFile.items()`. For each:
   - `FnDef` -> lower to `MirFunction`. Look up function type from `typeck.types` using the fn name's TextRange.
   - `StructDef` -> lower to `MirStructDef` using TypeRegistry.
   - `SumTypeDef` -> lower to `MirSumTypeDef` using TypeRegistry. Assign sequential tag values (0, 1, 2...) to variants.
   - `LetBinding` (top-level) -> lower as a global, or treat as init code in an implicit entry function.
   - `InterfaceDef` / `ImplDef` -> extract method implementations as MirFunctions.
   - `TypeAliasDef` -> skip (aliases resolved during type checking).

2. **Expressions** (`lower_expr`): For each AST Expr, look up its type from `typeck.types` using the expr's TextRange, resolve to MirType, then:
   - `Literal` (int/float/string/bool) -> `MirExpr::IntLit` / `FloatLit` / `StringLit` / `BoolLit`
   - `NameRef` -> `MirExpr::Var`
   - `BinaryExpr` -> `MirExpr::BinOp` (extract operator from syntax)
   - `UnaryExpr` -> `MirExpr::UnaryOp`
   - `CallExpr` -> `MirExpr::Call` or `MirExpr::ClosureCall` (distinguish based on callee type from typeck)
   - `IfExpr` -> `MirExpr::If` (with else branch; if no else, use `MirExpr::Unit`)
   - `CaseExpr` -> `MirExpr::Match` with `MirMatchArm` list (patterns lowered to MirPattern)
   - `TupleExpr` -> handle single-element as grouping parens (per decision 03-02), multi-element as tuple construction
   - `ClosureExpr` -> **Closure conversion**: lift the closure body to a new `MirFunction` with an env_ptr first parameter. Create `MirExpr::MakeClosure` referencing the lifted function name and the captured values. Determine captured variables by scanning the closure body for free variables not in its parameter list.
   - `StructLiteral` -> `MirExpr::StructLit`
   - `FieldAccess` -> `MirExpr::FieldAccess`
   - **PipeExpr** -> **Desugar**: `x |> f` becomes `Call(f, [x])`. `x |> f(a, b)` becomes `Call(f, [x, a, b])`. This is pure syntactic desugaring per research recommendation.
   - `ReturnExpr` -> `MirExpr::Return`
   - `Block` -> `MirExpr::Block`
   - String interpolation: when a StringLit contains interpolation segments (detected from the CST's INTERP_START/INTERP_END tokens), desugar into a chain of `snow_string_concat` calls. Each interpolated expression gets a `to_string` call (snow_int_to_string, snow_float_to_string, etc. based on type).

3. **Patterns** (`lower_pattern`): For each AST Pattern:
   - `WildcardPat` -> `MirPattern::Wildcard`
   - `IdentPat` -> `MirPattern::Var`
   - `LiteralPat` -> `MirPattern::Literal`
   - `ConstructorPat` -> `MirPattern::Constructor` (look up variant in TypeRegistry for tag)
   - `TuplePat` -> `MirPattern::Tuple`
   - `OrPat` -> `MirPattern::Or` (will be expanded to duplicate arms during pattern compilation in Plan 03)
   - `LayeredPat` (as-pattern) -> `MirPattern::Var` wrapping inner pattern

4. **Let bindings**: `Let { name, value, body }` where body is the rest of the block.

**mono.rs -- Monomorphization:**

Implement a `monomorphize(module: &mut MirModule)` function that:
1. Finds the entry point (main function) and starts from there.
2. For each function call, if the called function is generic (detected from the original TypeRegistry), create a specialized copy with concrete types substituted.
3. Name mangling: `fn_name + "_" + type1 + "_" + type2` (e.g., `identity_Int`, `map_List_Int_String`).
4. Collect all reachable monomorphized functions transitively.
5. Replace the module's function list with only the reachable monomorphized functions.
6. For Phase 5, this can be a simple approach: since the type checker has already resolved all concrete types at each call site, monomorphization mainly involves creating per-instantiation copies and substituting types.

**Update lib.rs:**
- Add a public `lower_to_mir(parse: &Parse, typeck: &TypeckResult) -> Result<MirModule, String>` function that creates a Lowerer, lowers the AST, runs monomorphization, and returns the MirModule.
- Add snapshot tests for lowering simple programs: `let x = 42`, `fn add(a, b) do a + b end`, `fn main() do println("hello") end`.
  </action>
  <verify>
`cargo test -p snow-codegen` passes. Snapshot tests verify that:
1. A simple integer literal lowers to `MirExpr::IntLit(42, MirType::Int)`
2. A function definition produces a `MirFunction` with correct params and body
3. Pipe expression `x |> f` lowers to `Call(f, [x])`
4. String interpolation "hello ${name}" lowers to concat chain
5. A closure `fn(x) -> x + y end` produces a lifted function + MakeClosure
  </verify>
  <done>AST-to-MIR lowering handles all Snow expression types, pipe desugaring, string interpolation compilation, closure conversion, and pattern lowering. Monomorphization produces concrete function instantiations. Snapshot tests verify correct lowering for representative programs.</done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-codegen` compiles
2. `cargo test -p snow-codegen` passes all MIR lowering tests
3. `cargo test` passes all existing tests (no regressions)
4. MIR output for a multi-feature program contains: monomorphized functions, desugared pipes, lowered string interpolation, lifted closure functions
</verification>

<success_criteria>
- MIR type system fully defined with all Snow type mappings
- AST-to-MIR lowering handles: literals, variables, binary/unary ops, calls, if/else, match, let bindings, closures, structs, sum types, pipe operator, string interpolation, return
- Pipe operator desugared to function calls
- String interpolation desugared to runtime concat calls
- Closures converted to lifted functions + MakeClosure nodes
- Monomorphization produces concrete function copies
- Tests verify correctness
</success_criteria>

<output>
After completion, create `.planning/phases/05-llvm-codegen-native-binaries/05-02-SUMMARY.md`
</output>
