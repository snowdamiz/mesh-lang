---
phase: 05-llvm-codegen-native-binaries
plan: 04
type: execute
wave: 4
depends_on: ["05-03"]
files_modified:
  - crates/snow-codegen/src/codegen/mod.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-codegen/src/codegen/pattern.rs
  - crates/snow-codegen/src/codegen/types.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "MIR functions translate to LLVM IR functions with correct signatures"
    - "Integer, float, and boolean arithmetic produces correct LLVM instructions"
    - "If/else expressions produce correct branching with alloca+mem2reg pattern"
    - "Decision trees produce correct switch/branch LLVM IR"
    - "Sum types use tagged union layout in LLVM IR"
    - "Closures produce {fn_ptr, env_ptr} pairs with GC-allocated environments"
    - "String literals produce calls to snow_string_new runtime function"
    - "println() calls produce calls to snow_println runtime function"
    - "LLVM module verification passes for generated IR"
    - "CodeGen supports configurable target triples for cross-platform compilation"
  artifacts:
    - path: "crates/snow-codegen/src/codegen/mod.rs"
      provides: "CodeGen struct with LLVM context, module, builder, configurable target"
      contains: "struct CodeGen"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "MIR expression to LLVM IR translation"
      contains: "fn codegen_expr"
    - path: "crates/snow-codegen/src/codegen/pattern.rs"
      provides: "Decision tree to LLVM branch/switch translation"
      contains: "fn codegen_decision_tree"
    - path: "crates/snow-codegen/src/codegen/types.rs"
      provides: "MirType to LLVM type mapping"
      contains: "fn llvm_type"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "Runtime function declarations in LLVM module"
      contains: "snow_string_new"
  key_links:
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "calls runtime functions for string ops, GC alloc, panic"
      pattern: "call_runtime"
    - from: "crates/snow-codegen/src/codegen/mod.rs"
      to: "inkwell"
      via: "LLVM context, module, builder"
      pattern: "inkwell::context::Context"
    - from: "crates/snow-codegen/src/codegen/pattern.rs"
      to: "crates/snow-codegen/src/pattern/mod.rs"
      via: "reads DecisionTree nodes"
      pattern: "DecisionTree"
---

<objective>
Implement LLVM IR code generation from MIR, translating all MIR expression types, decision tree pattern matches, type layouts, and runtime intrinsic calls into valid LLVM IR using Inkwell 0.8.0.

Purpose: This is the core codegen pass that transforms the desugared, monomorphized MIR into LLVM IR. After this plan, Snow programs can be compiled to LLVM IR (and to object files via LLVM's target machine). The generated IR should pass LLVM verification.

Output: Complete LLVM codegen for all MIR node types. An LLVM module containing all functions, type layouts, and runtime declarations. Object file emission capability. Configurable target triple support for cross-platform compilation.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llvm-codegen-native-binaries/05-RESEARCH.md
@.planning/phases/05-llvm-codegen-native-binaries/05-02-SUMMARY.md
@.planning/phases/05-llvm-codegen-native-binaries/05-03-SUMMARY.md
@crates/snow-codegen/src/mir/mod.rs
@crates/snow-codegen/src/pattern/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: LLVM type mapping, runtime intrinsic declarations, and CodeGen scaffolding with configurable target</name>
  <files>
    crates/snow-codegen/src/codegen/mod.rs
    crates/snow-codegen/src/codegen/types.rs
    crates/snow-codegen/src/codegen/intrinsics.rs
  </files>
  <action>
Implement the foundational LLVM codegen infrastructure.

**codegen/mod.rs -- CodeGen struct:**

Create `CodeGen<'ctx>` struct:
```rust
pub struct CodeGen<'ctx> {
    pub context: &'ctx Context,
    pub module: Module<'ctx>,
    pub builder: Builder<'ctx>,
    pub target_machine: TargetMachine,
    // Type caches
    struct_types: FxHashMap<String, StructType<'ctx>>,
    sum_type_layouts: FxHashMap<String, SumTypeLayout<'ctx>>,
    // Function lookup
    functions: FxHashMap<String, FunctionValue<'ctx>>,
    // Current function being compiled
    current_fn: Option<FunctionValue<'ctx>>,
    // Local variable allocas
    locals: FxHashMap<String, (PointerValue<'ctx>, BasicTypeEnum<'ctx>)>,
    // MIR module reference
    mir: MirModule,
}
```

Key methods:
- `new(context: &'ctx Context, mir: MirModule, opt_level: OptimizationLevel, target_triple: Option<&str>) -> Result<Self, String>` -- create module, builder, initialize target, create target machine. **Target triple handling:**
  1. If `target_triple` is `None`, use `TargetMachine::get_default_triple()` (host platform).
  2. If `target_triple` is `Some(triple)`, parse it as a `TargetTriple::create(triple)`.
  3. Call `Target::initialize_native(&InitializationConfig::default())` for host compilation, or `Target::initialize_all(&InitializationConfig::default())` when a non-host triple is specified.
  4. Look up the target with `Target::from_triple(&triple)`.
  5. Create `TargetMachine` with the resolved triple, CPU ("generic" for cross, host CPU for native), features, opt_level, reloc mode `RelocMode::PIC`, and code model `CodeModel::Default`.
  6. Set the module's target triple and data layout from the target machine.
  7. Return an error if target initialization or target machine creation fails (with a clear message like "Failed to initialize LLVM target for triple '{triple}': {reason}").
  Supported triples: host default, `x86_64-unknown-linux-gnu`, `aarch64-apple-darwin`, `x86_64-apple-darwin`, `aarch64-unknown-linux-gnu`. The compiler does not need to bundle cross-compilation sysroots -- it produces object files for the target, and the user provides an appropriate linker/sysroot. For Phase 5, host compilation is the primary use case; cross-compilation support is structural (the API accepts it, errors are clear if linker is missing).
- `compile(&mut self) -> Result<(), String>` -- orchestrate full compilation:
  1. Declare runtime intrinsics
  2. Create LLVM type layouts for all structs and sum types
  3. Declare all functions (forward declarations for mutual recursion)
  4. Codegen each function body
  5. Generate `main` wrapper that calls `snow_rt_init()` then the Snow `main()` function
  6. Verify module
- `emit_object(&self, path: &Path) -> Result<(), String>` -- write object file via target machine
- `emit_llvm_ir(&self, path: &Path) -> Result<(), String>` -- write .ll file (for --emit-llvm flag)
- `run_optimization_passes(&self) -> Result<(), String>` -- run LLVM's new pass manager. For -O0: "default<O0>". For -O2: "default<O2>" which includes mem2reg, instcombine, etc.

**codegen/types.rs -- MirType to LLVM type mapping:**

`fn llvm_type(&self, ty: &MirType) -> BasicTypeEnum<'ctx>`:
- `MirType::Int` -> `context.i64_type()`
- `MirType::Float` -> `context.f64_type()`
- `MirType::Bool` -> `context.bool_type()` (i1)
- `MirType::String` -> `context.ptr_type(AddressSpace::default())` (pointer to SnowString)
- `MirType::Unit` -> `context.struct_type(&[], false)` (empty struct, or use void for returns)
- `MirType::Tuple(elems)` -> `context.struct_type(&[llvm_type(e) for e in elems], false)`
- `MirType::Struct(name)` -> look up from `struct_types` cache
- `MirType::SumType(name)` -> look up from `sum_type_layouts` cache (the base tagged union type)
- `MirType::FnPtr(params, ret)` -> `context.ptr_type(AddressSpace::default())` (function pointer is just ptr in opaque pointer world)
- `MirType::Closure(params, ret)` -> closure struct type `{ ptr, ptr }` (fn_ptr, env_ptr)
- `MirType::Ptr` -> `context.ptr_type(AddressSpace::default())`
- `MirType::Never` -> use void or i8 (never-returning functions are marked noreturn)

`fn create_struct_type(&mut self, def: &MirStructDef) -> StructType<'ctx>`:
- Named struct: `context.opaque_struct_type(&def.name)`
- Set body: field types from MIR

`fn create_sum_type_layout(&mut self, def: &MirSumTypeDef) -> SumTypeLayout<'ctx>`:
- Calculate max payload size across all variants
- Base type: `{ i8, [max_payload x i8] }` named struct
- Per-variant struct overlay: `{ i8, field_types... }` for each variant
- Store both in `SumTypeLayout { base: StructType, variants: Vec<StructType>, tag_map: HashMap<String, u8> }`

**codegen/intrinsics.rs -- Runtime function declarations:**

Declare extern functions in the LLVM module matching snow-rt's extern "C" signatures:
- `snow_rt_init: () -> void`
- `snow_gc_alloc: (i64, i64) -> ptr`
- `snow_string_new: (ptr, i64) -> ptr`
- `snow_string_concat: (ptr, ptr) -> ptr`
- `snow_int_to_string: (i64) -> ptr`
- `snow_float_to_string: (f64) -> ptr`
- `snow_bool_to_string: (i8) -> ptr`
- `snow_print: (ptr) -> void`
- `snow_println: (ptr) -> void`
- `snow_panic: (ptr, i64, ptr, i64, i32) -> void` (mark as noreturn)

Store these as `FunctionValue` entries in the CodeGen's function map for easy lookup.
  </action>
  <verify>
1. `cargo build -p snow-codegen` compiles.
2. Write a test that creates a CodeGen with an empty MirModule using `target_triple: None` (host), declares intrinsics, and verifies the LLVM module passes verification.
3. Write a test `test_native_target_init` that confirms `CodeGen::new()` with `target_triple: None` succeeds and the resulting `target_machine` has a triple matching the host (e.g., contains "apple-darwin" on macOS or "linux" on Linux).
4. Write a test that `CodeGen::new()` with an invalid triple like `"invalid-unknown-unknown"` returns a descriptive error.
  </verify>
  <done>CodeGen struct with LLVM context/module/builder is operational. Target triple is configurable via CodeGen::new() parameter -- defaults to host platform, accepts custom triples for cross-platform support. MirType maps to LLVM types correctly. Struct and sum type layouts are created. Runtime intrinsics are declared. Empty module passes LLVM verification. Native target initialization is tested.</done>
</task>

<task type="auto">
  <name>Task 2: Expression codegen, decision tree codegen, and function compilation</name>
  <files>
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-codegen/src/codegen/pattern.rs
    crates/snow-codegen/src/codegen/mod.rs
    crates/snow-codegen/src/lib.rs
  </files>
  <action>
Implement LLVM IR generation for all MIR expression types and decision tree pattern matching.

**codegen/expr.rs -- Expression codegen:**

`fn codegen_expr(&mut self, expr: &MirExpr) -> BasicValueEnum<'ctx>`:

1. **IntLit(n)** -> `i64_type.const_int(n, true)`
2. **FloatLit(f)** -> `f64_type.const_float(f)`
3. **BoolLit(b)** -> `bool_type.const_int(b as u64, false)`
4. **StringLit(s)** -> call `snow_string_new` with a global constant string:
   - Create global constant byte array for string data
   - Call `snow_string_new(global_ptr, len)` to get GC-managed SnowString
5. **Var(name)** -> load from local alloca: `build_load(ty, ptr, name)`
6. **BinOp** -> dispatch on operator and type:
   - Int arithmetic: `build_int_add`, `build_int_sub`, `build_int_mul`, `build_int_signed_div`
   - Float arithmetic: `build_float_add`, `build_float_sub`, `build_float_mul`, `build_float_div`
   - Int comparisons: `build_int_compare` with IntPredicate
   - Float comparisons: `build_float_compare` with FloatPredicate
   - String concat: call `snow_string_concat`
   - Boolean and/or: `build_and`, `build_or`
7. **UnaryOp** -> negate int (`build_int_neg`), negate float (`build_float_neg`), not bool (`build_not`)
8. **Call { func, args }** -> for direct known function calls:
   - Look up function in `self.functions`
   - `build_call(fn_val, &args, "call")`
   - Extract return value
9. **ClosureCall { closure, args }** -> load fn_ptr and env_ptr from closure struct:
   - `build_struct_gep` to get fn_ptr slot, load it
   - `build_struct_gep` to get env_ptr slot, load it
   - Build indirect call: `build_indirect_call(fn_type, fn_ptr, &[env_ptr, ...args], "closurecall")`
10. **If { cond, then, else }** -> alloca+mem2reg pattern (from research):
    - Alloca result variable
    - `build_conditional_branch(cond, then_bb, else_bb)`
    - Codegen then-body into then_bb, store result, branch to merge
    - Codegen else-body into else_bb, store result, branch to merge
    - Position at merge_bb, load result
11. **Let { name, ty, value, body }** ->
    - Alloca for the variable
    - Codegen value, store into alloca
    - Push variable into locals map
    - Codegen body
    - Pop variable from locals
12. **Block(exprs)** -> codegen each expr in sequence, return last value. Handle empty block as Unit.
13. **CompiledMatch { scrutinee, decision_tree, arms_bodies }** -> delegate to pattern.rs (see below)
14. **StructLit** -> alloca struct type, store each field via GEP, load result
15. **FieldAccess** -> GEP into struct, load field
16. **ConstructVariant** -> alloca sum type, store tag byte, cast to variant overlay type, store fields via GEP, load result as base type
17. **MakeClosure** -> call `snow_gc_alloc` for env struct, store captures into env, create closure struct `{ fn_ptr, env_ptr }`
18. **Return(expr)** -> codegen expr, `build_return`
19. **Panic** -> call `snow_panic` with message string, then `build_unreachable()`
20. **Unit** -> return an empty struct constant

**codegen/pattern.rs -- Decision tree codegen:**

`fn codegen_decision_tree(&mut self, tree: &DecisionTree, scrutinee: BasicValueEnum<'ctx>, arm_bodies: &[MirExpr], result_alloca: PointerValue<'ctx>, merge_bb: BasicBlock<'ctx>)`:

1. **Leaf { arm_index, bindings }** ->
   - For each binding: navigate the scrutinee using AccessPath (GEP for tuple/struct fields, bitcast+GEP for variant fields), store into local alloca
   - Codegen `arm_bodies[arm_index]`
   - Store result into result_alloca
   - Branch to merge_bb

2. **Switch { scrutinee_path, cases, default }** ->
   - Navigate to scrutinee sub-value using AccessPath
   - Load tag byte: GEP[0] on the sum type pointer
   - Create basic blocks for each case + default
   - `build_switch(tag, default_bb, &[(tag_const, case_bb)])`
   - For each case: position at case_bb, recurse with specialized scrutinee
   - For default: recurse with same scrutinee

3. **Test { scrutinee_path, value, success, failure }** ->
   - Navigate to value, compare with literal:
     - Int: `build_int_compare(EQ)`
     - Float: `build_float_compare(OEQ)`
     - Bool: `build_int_compare(EQ)`
     - String: call a runtime `snow_string_eq` (add to intrinsics if needed) or compare length+bytes
   - `build_conditional_branch(cmp, success_bb, failure_bb)`
   - Recurse into both branches

4. **Guard { guard_expr, success, failure }** ->
   - Codegen guard_expr (produces bool)
   - `build_conditional_branch(guard_val, success_bb, failure_bb)`
   - Recurse

5. **Fail { message, file, line }** ->
   - Call `snow_panic` with the message and source location
   - `build_unreachable()`

**Function compilation (in mod.rs):**

`fn compile_function(&mut self, mir_fn: &MirFunction)`:
- Get or create the LLVM function (already forward-declared)
- Create "entry" basic block
- For each parameter: create alloca, store param value, add to locals
- For closure functions: first param is env_ptr, extract captured values from env struct into local allocas
- Codegen the function body
- If body returns a value, `build_return(value)`
- If body is Unit/void return type, `build_ret_void()`

**Main wrapper function:**
Generate a C-style `main(argc: i32, argv: **i8) -> i32` function that:
1. Calls `snow_rt_init()`
2. Calls the Snow `main()` function
3. Returns 0

**Update lib.rs:**
Wire everything together in a `compile_to_object(parse: &Parse, typeck: &TypeckResult, output: &Path, opt_level: OptimizationLevel, target_triple: Option<&str>) -> Result<(), String>` function that:
1. Calls `lower_to_mir(parse, typeck)`
2. Compiles patterns
3. Creates CodeGen with `target_triple` parameter, runs compile, emits object file
4. Return Ok or errors

Note: The `target_triple` parameter flows from the CLI `--target` flag through `compile_to_binary` -> `compile_to_object` -> `CodeGen::new()`.

Add LLVM IR snapshot tests: compile a simple "fn main() do println("hello") end" and verify the `.ll` output looks correct.
  </action>
  <verify>
1. `cargo test -p snow-codegen` passes all codegen tests
2. A "hello world" MIR module generates valid LLVM IR (module verification passes)
3. A function with if/else generates correct branching LLVM IR
4. A match on a sum type generates correct switch instruction
5. String literal generates snow_string_new call
6. Closure generates env allocation + fn_ptr/env_ptr struct
  </verify>
  <done>Complete LLVM codegen for all MIR expression types. Decision trees compile to LLVM switch/branch chains. Type layouts (structs, tagged unions, closures) are correct. Runtime intrinsics are called for string operations, GC allocation, and panic. Generated LLVM modules pass verification. Object file emission works via target machine. Target triple is threaded through from compile_to_object API.</done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-codegen` compiles
2. `cargo test -p snow-codegen` passes all codegen tests
3. `cargo test` passes all tests (no regressions)
4. LLVM IR for a hello-world program contains: main wrapper calling snow_rt_init + snow main, snow_string_new call, snow_println call
5. LLVM module verification passes for generated IR
6. Native target initialization test passes on host platform
7. CodeGen::new() accepts optional target_triple parameter for cross-platform support
</verification>

<success_criteria>
- All MIR expression types generate correct LLVM IR
- Decision trees produce efficient switch/branch code
- Tagged union layout works for sum types
- Closure creation and invocation produces correct code
- String operations call runtime functions
- Main wrapper initializes runtime and calls Snow main
- LLVM module verification passes
- Object file emission works
- CodeGen supports configurable target triples (host default, x86_64-linux, aarch64-darwin, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/05-llvm-codegen-native-binaries/05-04-SUMMARY.md`
</output>
