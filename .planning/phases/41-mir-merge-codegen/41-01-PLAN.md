---
phase: 41-mir-merge-codegen
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-codegen/src/lib.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snowc/src/main.rs
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Two modules each defining a private function named helper compile without name collision"
    - "Generic functions defined in one module and called with concrete types in another module monomorphize correctly"
    - "A multi-module project with imports, pub items, generics, and traits produces a working native binary"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Module-qualified private function and closure naming in Lowerer"
      contains: "module_name"
    - path: "crates/snow-codegen/src/lib.rs"
      provides: "Updated lower_to_mir_raw accepting module_name and pub_fns parameters"
      contains: "module_name"
    - path: "crates/snowc/src/main.rs"
      provides: "Build pipeline passing module name and pub function set to MIR lowering"
      contains: "module_name"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "E2E tests for XMOD-06 (cross-module generics) and XMOD-07 (name collision)"
      contains: "xmod07"
  key_links:
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-codegen/src/lib.rs"
      via: "lower_to_mir_raw call with module_name"
      pattern: "lower_to_mir_raw.*module_name"
    - from: "crates/snow-codegen/src/lib.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "lower_to_mir call propagating module_name"
      pattern: "lower_to_mir.*module_name"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "MirFunction name field"
      via: "Module prefix applied to private function names"
      pattern: "module_name.*__"
---

<objective>
Add module-qualified name mangling to private functions and closures in MIR lowering to prevent name collisions across modules (XMOD-07), and validate cross-module generic monomorphization (XMOD-06) with E2E tests.

Purpose: Without module-qualified names, two modules defining a private function with the same name (e.g., `helper`) will collide during MIR merge -- the second is silently dropped, causing the second module's calls to dispatch to the first module's version. This plan fixes the name collision by prefixing private (non-pub) function names and closure names with the module name using the existing double-underscore convention (`ModuleName__function_name`). It also validates that cross-module generic functions work correctly end-to-end.

Output: Module-qualified private name mangling in MIR lowering, updated build pipeline passing module metadata to the lowerer, and E2E tests proving XMOD-06, XMOD-07, and the comprehensive multi-module binary success criterion.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-mir-merge-codegen/41-RESEARCH.md
@.planning/phases/39-cross-module-type-checking/39-03-SUMMARY.md
@.planning/phases/40-visibility-enforcement/40-01-SUMMARY.md
@crates/snow-codegen/src/lib.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snowc/src/main.rs
@crates/snowc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Module-qualified private name mangling in MIR lowering</name>
  <files>
    crates/snow-codegen/src/lib.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snowc/src/main.rs
  </files>
  <action>
Thread the module name and pub function set through the MIR lowering pipeline so that private (non-pub) functions and closures get module-qualified names.

**1. Update `lower_to_mir_raw` signature in `crates/snow-codegen/src/lib.rs` (line ~58):**
Add two new parameters: `module_name: &str` and `pub_fns: &HashSet<String>` (use `std::collections::HashSet`). Pass them through to `lower_to_mir`.

Also update `lower_to_mir` (the internal function called by both `lower_to_mir_raw` and `lower_to_mir_module`) to accept and forward these parameters. For `lower_to_mir_module` (single-file path, line ~41), pass `module_name: ""` and `pub_fns: &HashSet::new()` so that single-file compilation is unaffected (empty module name means no prefix is added).

Similarly update `compile_to_object`, `compile_to_llvm_ir`, `compile_to_binary`, and `compile` to pass empty module name and empty pub_fns to `lower_to_mir_module`. These single-file entry points must remain backward-compatible.

**2. Update `Lowerer` struct in `crates/snow-codegen/src/mir/lower.rs` (line ~158):**
Add two fields:
- `module_name: String` -- the PascalCase module name (e.g., "Utils", "Math.Vector", "Main")
- `pub_functions: HashSet<String>` -- names of pub functions that should NOT be prefixed

Update `Lowerer::new()` to accept `module_name: &str` and `pub_fns: &HashSet<String>` and store them. Update the `lower_to_mir` public function to accept and forward these.

**3. Add a helper method `fn qualify_name(&self, name: &str) -> String` to `Lowerer`:**
This method applies the module prefix rule:
- If `self.module_name` is empty (single-file mode), return name unchanged
- If `name == "main"`, return name unchanged (handled separately as `snow_main`)
- If `name` is in `self.pub_functions`, return name unchanged (pub functions keep unqualified names for cross-module references)
- If `name` starts with a known builtin/runtime prefix (like `snow_`, `Ord__`, `Eq__`, `Display__`, `Debug__`, `Hash__`, `Default__`, `Add__`, `Sub__`, `Mul__`, `Div__`, `Rem__`, `Neg__`), return name unchanged
- Otherwise, return `format!("{}__{}",  self.module_name.replace('.', "_"), name)` -- note the dot-to-underscore conversion for nested modules like "Math.Vector" -> "Math_Vector__helper"

**4. Apply `qualify_name` in `lower_fn_def` (line ~740-746):**
After the `main` -> `snow_main` rename check, apply `qualify_name` to the final function name. The logic should be:
```
let fn_name = if name == "main" {
    self.entry_function = Some("snow_main".to_string());
    "snow_main".to_string()
} else {
    self.qualify_name(&name)
};
```

**5. Apply `qualify_name` in `lower_multi_clause_fn` (lines ~1067-1072 and ~1088-1093):**
Same pattern as `lower_fn_def` -- both single-param and multi-param branches need the same treatment.

**6. Apply module prefix to closure names (lines ~4448-4449 and ~4551-4552):**
Change closure naming from `format!("__closure_{}", self.closure_counter)` to:
```
let closure_fn_name = if self.module_name.is_empty() {
    format!("__closure_{}", self.closure_counter)
} else {
    format!("{}__closure_{}", self.module_name.replace('.', "_"), self.closure_counter)
};
```
Apply this in BOTH closure lowering locations (single-clause and multi-clause closures).

**7. Update `known_functions` registration:**
When functions are registered in `known_functions` (for distinguishing direct calls from closure calls), the qualified name must be used. Grep for all `self.known_functions.insert(` calls and ensure the inserted name matches the qualified name that was pushed to `self.functions`. The key location is near the end of `lower_fn_def` and `lower_multi_clause_fn` where functions are pushed -- the name in `known_functions` must match the name in the MirFunction.

Also, look for any call-site resolution logic that looks up function names in `known_functions` -- these lookups use the ORIGINAL (unqualified) name from the AST. So calls within the SAME module will use the unqualified name. You need to ensure that intra-module calls resolve correctly. The approach: in `lower_fn_def` and `lower_multi_clause_fn`, insert BOTH the original name and the qualified name into `known_functions` (the original name maps to the same MirType). This ensures backward compatibility for call-site resolution within the same module.

**8. Update the build pipeline in `crates/snowc/src/main.rs` (lines ~340-349):**
In the MIR lowering loop, extract the module name and build the pub_fns set for each module:
```rust
for (i, &id) in project.compilation_order.iter().enumerate() {
    let idx = id.0 as usize;
    let parse = &project.module_parses[idx];
    let typeck = all_typeck[idx].as_ref()
        .ok_or("Module was not type-checked")?;

    // Build set of pub function names for this module
    let module_name = &project.graph.get(id).name;
    let pub_fns: std::collections::HashSet<String> = all_exports[idx]
        .as_ref()
        .map(|e| e.functions.keys().cloned().collect())
        .unwrap_or_default();

    let mir = snow_codegen::lower_to_mir_raw(parse, typeck, module_name, &pub_fns)?;
    // ... rest unchanged
}
```

**IMPORTANT things to NOT do:**
- Do NOT prefix `snow_main` -- the entry function rename happens before qualification
- Do NOT prefix trait impl functions like `Eq__eq__Point` -- these are already mangled with trait-based names and must remain globally consistent. The `qualify_name` method handles this by checking for known trait prefixes.
- Do NOT prefix imported function CALLS -- only DEFINITIONS. Call sites reference functions by their original name within the same module (handled by known_functions dual registration) or by their unqualified pub name for cross-module calls (pub functions are not prefixed).
- Do NOT change `merge_mir_modules` -- once names are unique, the existing dedup works correctly.
  </action>
  <verify>
Run `cargo test --workspace` from the project root. All existing tests must pass with zero regressions. The key tests to watch:
- All existing multi-module E2E tests in `snowc/tests/e2e.rs` (cross-module function calls, selective imports, structs, sum types)
- All existing single-file E2E tests (backward compatibility)
- All unit tests across all crates

If any test fails, the module prefix is likely being applied too broadly (breaking cross-module pub function calls) or not broadly enough (missing closure prefixes).
  </verify>
  <done>
`cargo test --workspace` passes with zero regressions. The `lower_to_mir_raw` function accepts `module_name` and `pub_fns` parameters. The `Lowerer` struct has `module_name` and `pub_functions` fields. Private functions are prefixed with `ModuleName__` in MIR. Closures are prefixed with `ModuleName__closure_N`. Pub functions, main, builtins, and trait impls are NOT prefixed.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E tests for XMOD-06, XMOD-07, and comprehensive multi-module binary</name>
  <files>
    crates/snowc/tests/e2e.rs
  </files>
  <action>
Add E2E tests to `crates/snowc/tests/e2e.rs` using the existing `compile_multifile_and_run` helper. These tests validate the three success criteria for Phase 41.

**Test 1: XMOD-07 -- Private function name collision (two modules, same private function name)**
```
Test name: e2e_xmod07_private_function_name_collision
Files:
  utils.snow:
    pub fn get_utils_value() -> Int do
      helper()
    end
    fn helper() -> Int do
      42
    end
  math.snow:
    pub fn get_math_value() -> Int do
      helper()
    end
    fn helper() -> Int do
    99
    end
  main.snow:
    import Utils
    import Math
    fn main() do
      println(Utils.get_utils_value())
      println(Math.get_math_value())
    end
Expected output: "42\n99\n"
```
This test fails without module-qualified naming because both `helper` functions collide in MIR merge.

**Test 2: XMOD-07 -- Closure name collision (two modules with closures)**
```
Test name: e2e_xmod07_closure_name_collision
Files:
  utils.snow:
    pub fn apply_utils(x :: Int) -> Int do
      let f = |n| n + 10 end
      f(x)
    end
  math.snow:
    pub fn apply_math(x :: Int) -> Int do
      let f = |n| n * 2 end
      f(x)
    end
  main.snow:
    import Utils
    import Math
    fn main() do
      println(Utils.apply_utils(5))
      println(Math.apply_math(5))
    end
Expected output: "15\n10\n"
```
This test fails without closure name prefixing because both modules generate `__closure_1`.

**Test 3: XMOD-06 -- Cross-module generic function call**
```
Test name: e2e_xmod06_cross_module_generic_function
Files:
  utils.snow:
    pub fn identity(x :: Int) -> Int do
      x
    end
  main.snow:
    from Utils import identity
    fn main() do
      println(identity(42))
    end
Expected output: "42\n"
```
Note: Start with a concrete-typed version first. If this passes, add a truly generic version to test the Ty::Var -> MirType::Unit fallback path. If the generic version fails, document it as a known limitation and note in the summary. The concrete-typed version covers the common cross-module pattern.

**Test 4: XMOD-06 -- Cross-module generic function (truly generic)**
```
Test name: e2e_xmod06_cross_module_generic_identity
Files:
  utils.snow:
    pub fn identity<T>(x :: T) -> T = x
  main.snow:
    from Utils import identity
    fn main() do
      println(identity(42))
      println(identity("hello"))
    end
Expected output: "42\nhello\n"
```
If this test fails due to the Ty::Var -> MirType::Unit fallback for the generic function definition in utils.snow, the fix approach is: in the merged MIR, the call site has the correct concrete types. The monomorphization pass (reachability only) does not specialize. If LLVM rejects the type mismatch, a workaround is to have the calling module's lowerer also emit the function body with concrete types. However, first try the test -- it may work because LLVM uses opaque pointers and all Snow values are u64-sized.

**Test 5: Comprehensive multi-module binary (imports, pub, generics, traits, structs)**
```
Test name: e2e_xmod_comprehensive_multi_module_binary
Files:
  geometry.snow:
    pub struct Point do
      x :: Int
      y :: Int
    end
    pub fn make_point(x :: Int, y :: Int) -> Point do
      Point { x: x, y: y }
    end
    pub fn point_to_string(p :: Point) -> String do
      "(" ++ to_string(p.x) ++ ", " ++ to_string(p.y) ++ ")"
    end
  math.snow:
    from Geometry import Point, make_point, point_to_string
    pub fn add_points(a :: Point, b :: Point) -> Point do
      make_point(a.x + b.x, a.y + b.y)
    end
    fn helper() -> Int do
      0
    end
  main.snow:
    import Geometry
    import Math
    fn main() do
      let a = Geometry.make_point(1, 2)
      let b = Geometry.make_point(3, 4)
      let c = Math.add_points(a, b)
      println(Geometry.point_to_string(c))
    end
Expected output: "(4, 6)\n"
```
This test exercises: cross-module struct construction and field access, selective and qualified imports together, private function (`helper` in math.snow) not interfering, and a 3-module project producing a correct binary.

If any test fails and the issue is in the name mangling logic from Task 1 (e.g., pub function getting prefixed, or call site not matching definition), fix the issue in the Task 1 files before proceeding. This is expected Rule 3 behavior.
  </action>
  <verify>
Run `cargo test --workspace` -- all new tests and all existing tests pass. Specifically:
- `cargo test -p snowc --test e2e e2e_xmod07` runs both XMOD-07 tests
- `cargo test -p snowc --test e2e e2e_xmod06` runs both XMOD-06 tests
- `cargo test -p snowc --test e2e e2e_xmod_comprehensive` runs the comprehensive test

All five new tests produce expected output. Zero regressions on existing tests.
  </verify>
  <done>
At least 4 E2E tests pass covering: (1) private function name collision resolved (XMOD-07), (2) closure name collision resolved (XMOD-07), (3) cross-module function call with concrete types (XMOD-06 baseline), (4) comprehensive multi-module binary with structs/imports/pub. If the truly generic cross-module test (Test 4) fails due to the Ty::Var fallback, it is documented as a known limitation for a future phase rather than blocking this plan.
  </done>
</task>

</tasks>

<verification>
Phase 41 success criteria verification:

1. **XMOD-07 -- No private name collision:** `e2e_xmod07_private_function_name_collision` test passes, producing correct output from both modules' private `helper` functions.

2. **XMOD-06 -- Cross-module generics:** `e2e_xmod06_cross_module_generic_function` test passes, proving that a function defined in one module can be called from another with correct types.

3. **Working multi-module binary:** `e2e_xmod_comprehensive_multi_module_binary` test passes, proving a 3-module project with structs, imports, pub items, and private functions compiles to a working native binary.

Overall: `cargo test --workspace` passes with all new tests green and zero regressions.
</verification>

<success_criteria>
- `cargo test --workspace` passes with zero regressions
- At least 4 new E2E tests pass (XMOD-07 x2, XMOD-06 x1, comprehensive x1)
- Private functions in MIR have module-qualified names (e.g., `Utils__helper`)
- Closures in MIR have module-qualified names (e.g., `Utils__closure_1`)
- Pub functions, main, builtins, and trait impls retain their unqualified names
- A 3-module project with structs, imports, and private functions produces correct output
</success_criteria>

<output>
After completion, create `.planning/phases/41-mir-merge-codegen/41-01-SUMMARY.md`
</output>
