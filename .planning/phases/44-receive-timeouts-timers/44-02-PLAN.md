---
phase: 44-receive-timeouts-timers
plan: 02
type: execute
wave: 2
depends_on: ["44-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-rt/src/actor/mod.rs
  - crates/snow-rt/src/lib.rs
  - crates/snowc/tests/e2e_concurrency_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "Timer.sleep(ms) suspends the current actor for approximately ms milliseconds without blocking other actors"
    - "Timer.send_after(pid, ms, msg) delivers msg to the target actor after approximately ms milliseconds"
    - "Timer.sleep does not consume messages from the actor's mailbox"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Timer module type signatures for sleep and send_after"
      contains: "Timer"
    - path: "crates/snow-rt/src/actor/mod.rs"
      provides: "snow_timer_sleep and snow_timer_send_after runtime functions"
      contains: "snow_timer_sleep"
    - path: "crates/snowc/tests/e2e_concurrency_stdlib.rs"
      provides: "E2E tests for Timer.sleep and Timer.send_after"
      contains: "timer_sleep"
  key_links:
    - from: "Timer.sleep(ms) in Snow source"
      to: "snow_timer_sleep in snow-rt"
      via: "typeck -> MIR lower (timer_sleep -> snow_timer_sleep) -> intrinsics declaration -> codegen call"
      pattern: "snow_timer_sleep"
    - from: "Timer.send_after(pid, ms, msg) in Snow source"
      to: "snow_timer_send_after in snow-rt"
      via: "typeck -> MIR lower -> intrinsics declaration -> codegen call"
      pattern: "snow_timer_send_after"
---

<objective>
Add Timer.sleep(ms) and Timer.send_after(pid, ms, msg) stdlib primitives following the established four-layer module pattern (typeck, MIR lower, codegen intrinsics, runtime).

Purpose: Actors need timer primitives for delayed operations. Timer.sleep suspends an actor cooperatively (without blocking the scheduler), and Timer.send_after schedules a delayed message delivery.

Output: Working Timer module with sleep and send_after, e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-receive-timeouts-timers/44-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-rt/src/actor/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Timer module in typeck and MIR lowering layers</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
Follow the exact same four-layer stdlib module registration pattern used by Math/Job modules.

**Layer 1: Type checker (infer.rs)**

In `stdlib_modules()` function, after the Float module block (before the closing `modules`), add:

```rust
// ── Timer module (Phase 44 Plan 02) ───────────────────────────────
let mut timer_mod = HashMap::new();
// Timer.sleep: fn(Int) -> Unit
timer_mod.insert("sleep".to_string(), Scheme::mono(Ty::fun(vec![Ty::int()], Ty::unit())));
// Timer.send_after: fn(Pid, Int, T) -> Unit
// For now, use Int for msg type (most common); polymorphic send_after is future work
timer_mod.insert("send_after".to_string(), Scheme::mono(Ty::fun(vec![Ty::int(), Ty::int(), Ty::int()], Ty::unit())));
modules.insert("Timer".to_string(), timer_mod);
```

Note on send_after type: The simplest correct approach is `fn(Int, Int, Int) -> Unit` where args are (pid, ms, msg_as_int). This matches the existing actor send pattern where messages are serialized to bytes. The pid is `Int` (Pid is represented as i64), ms is `Int`, and the message is `Int` (matching the simple receive codegen which handles Int messages). Using a polymorphic T for the message type would require complex generic serialization -- defer to future work.

In `STDLIB_MODULE_NAMES` const array, add `"Timer"` to the list.

**Layer 2: MIR lowering (lower.rs)**

In `STDLIB_MODULES` const array (line ~7202), add `"Timer"` to the list.

In `map_builtin_name` function, add:
```rust
"timer_sleep" => "snow_timer_sleep".to_string(),
"timer_send_after" => "snow_timer_send_after".to_string(),
```

In the `known_functions` initialization section (where Job functions are registered, line ~597-605), add:
```rust
// ── Timer functions (Phase 44 Plan 02) ──────────────────────────────
// snow_timer_sleep(ms: i64) -> void (Unit)
self.known_functions.insert("snow_timer_sleep".to_string(), MirType::FnPtr(vec![MirType::Int], Box::new(MirType::Unit)));
// snow_timer_send_after(pid: i64, ms: i64, msg_ptr: ptr, msg_size: i64) -> void (Unit)
self.known_functions.insert("snow_timer_send_after".to_string(), MirType::FnPtr(vec![MirType::Int, MirType::Int, MirType::Ptr, MirType::Int], Box::new(MirType::Unit)));
```

Wait -- the send_after in typeck takes (Int, Int, Int) but the runtime needs (pid, ms, msg_ptr, msg_size). The MIR lowering will handle the Int message by serializing it to bytes, just like `snow_actor_send`. Actually, looking at how actor_send works: `snow_actor_send(target_pid, msg_ptr, msg_size)` -- the codegen serializes the message value to a stack alloca and passes its pointer and size. The same pattern applies here.

Revised approach for send_after: The runtime function should be `snow_timer_send_after(pid: i64, ms: i64, msg_ptr: *const u8, msg_size: u64)` -- same as snow_actor_send but with an added ms parameter. The codegen layer already knows how to serialize messages for snow_actor_send; we need the same serialization for send_after.

However, to keep this simple and avoid duplicating the message serialization logic in codegen, implement send_after at the runtime level as: `snow_timer_send_after(pid: i64, ms: i64, msg_ptr: *const u8, msg_size: u64)`. The codegen for Timer.send_after(pid, ms, msg) should serialize msg the same way as actor send, then call the runtime function.

Actually, the simplest correct approach: make the known_functions signature match the codegen call pattern. Since Timer.send_after takes (pid, ms, msg) where msg is Int, the codegen will pass all 3 as i64 values, and the runtime can reconstruct the message bytes from the i64 value (same as snow_actor_send does with the raw bytes).

Simplify: Use `snow_timer_send_after(pid: i64, ms: i64, msg_ptr: *const u8, msg_size: u64)` matching the send pattern.

```rust
self.known_functions.insert("snow_timer_send_after".to_string(), MirType::FnPtr(vec![MirType::Int, MirType::Int, MirType::Ptr, MirType::Int], Box::new(MirType::Unit)));
```
  </action>
  <verify>
`cargo check -p snow-typeck` and `cargo check -p snow-codegen` both pass.
  </verify>
  <done>Timer module registered in typeck with sleep/send_after type signatures, added to STDLIB_MODULE_NAMES and STDLIB_MODULES, name mappings and known_functions registered.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Timer runtime functions and codegen intrinsics</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-rt/src/actor/mod.rs
    crates/snow-rt/src/lib.rs
  </files>
  <action>
**Intrinsics declaration (intrinsics.rs):**

In `declare_intrinsics`, after the Job function declarations (line ~434), add:

```rust
// ── Timer functions (Phase 44 Plan 02) ──────────────────────────────

// snow_timer_sleep(ms: i64) -> void
let timer_sleep_ty = void_type.fn_type(&[i64_type.into()], false);
module.add_function("snow_timer_sleep", timer_sleep_ty, Some(inkwell::module::Linkage::External));

// snow_timer_send_after(pid: i64, ms: i64, msg_ptr: ptr, msg_size: i64) -> void
let timer_send_after_ty = void_type.fn_type(&[i64_type.into(), i64_type.into(), ptr_type.into(), i64_type.into()], false);
module.add_function("snow_timer_send_after", timer_send_after_ty, Some(inkwell::module::Linkage::External));
```

In the test at the bottom of intrinsics.rs, add assertions:
```rust
assert!(module.get_function("snow_timer_sleep").is_some());
assert!(module.get_function("snow_timer_send_after").is_some());
```

**Codegen for Timer.send_after (expr.rs):**

In the `codegen_call` function, add a match arm for "snow_timer_send_after" that serializes the message argument the same way `codegen_actor_send` does. Find where snow_actor_send is handled and add a parallel case:

When the callee name is "snow_timer_send_after" and there are 3 arguments (pid, ms, msg):
1. Codegen the pid argument -> pid_val (i64)
2. Codegen the ms argument -> ms_val (i64)
3. Codegen the msg argument -> msg_val
4. Allocate msg on stack (same pattern as codegen_actor_send): `build_alloca`, `build_store`, then get pointer and size
5. Call `snow_timer_send_after(pid_val, ms_val, msg_ptr, msg_size)`
6. Return Unit (empty struct const_zero)

Look at `codegen_actor_send` (around line 1670-1708) for the exact message serialization pattern. The Timer.send_after codegen should do the same thing but with two extra leading arguments (pid, ms) before the msg_ptr and msg_size.

Actually, since the MIR lowering already handles Timer.send_after as a regular function call via `codegen_call`, and the known_functions signature has (Int, Int, Ptr, Int), the message serialization needs to happen in the codegen_call path. The simplest approach is to handle this as a special case in codegen_call: detect "snow_timer_send_after" by name, serialize the 3rd argument to (ptr, size), and call with 4 LLVM args.

**Runtime implementation (snow-rt/src/actor/mod.rs):**

Add after the `snow_actor_receive` function (after line ~419):

```rust
/// Sleep the current actor for `ms` milliseconds without blocking other actors.
///
/// Uses a yield loop with deadline checking. The actor stays Ready (not Waiting)
/// so the scheduler continues to resume it. On each resume, checks if the
/// deadline has passed. Does NOT consume messages from the mailbox.
#[no_mangle]
pub extern "C" fn snow_timer_sleep(ms: i64) {
    if ms <= 0 {
        return;
    }

    let in_coroutine = stack::CURRENT_YIELDER.with(|c| c.get().is_some());

    if !in_coroutine {
        // Main thread: just use thread::sleep
        std::thread::sleep(std::time::Duration::from_millis(ms as u64));
        return;
    }

    // Coroutine path: yield loop with deadline
    let deadline = std::time::Instant::now() + std::time::Duration::from_millis(ms as u64);

    loop {
        // Yield to scheduler (state stays Ready/Running -- NOT Waiting)
        // This is critical: if we set state to Waiting, the scheduler would
        // skip this process and it would never be resumed (unless a message arrives).
        stack::yield_current();

        if std::time::Instant::now() >= deadline {
            return;
        }
    }
}

/// Schedule a message to be sent to `target_pid` after `ms` milliseconds.
///
/// Spawns a background OS thread that sleeps for `ms` then sends the message.
/// The message bytes are deep-copied at call time so the caller's stack frame
/// can be freed safely.
#[no_mangle]
pub extern "C" fn snow_timer_send_after(target_pid: u64, ms: u64, msg_ptr: *const u8, msg_size: u64) {
    // Deep-copy message bytes before spawning thread
    let data = if msg_ptr.is_null() || msg_size == 0 {
        Vec::new()
    } else {
        let slice = unsafe { std::slice::from_raw_parts(msg_ptr, msg_size as usize) };
        slice.to_vec()
    };

    let pid = target_pid;
    let delay = std::time::Duration::from_millis(ms);

    std::thread::spawn(move || {
        std::thread::sleep(delay);
        // Reuse snow_actor_send logic: construct message and deliver
        snow_actor_send(pid, data.as_ptr(), data.len() as u64);
    });
}
```

IMPORTANT for Timer.sleep: Do NOT set ProcessState::Waiting. The scheduler skips Waiting processes (scheduler.rs line 409). Timer.sleep must yield normally (state stays Ready), letting the scheduler resume it on next cycle to check the deadline.

**Re-export (snow-rt/src/lib.rs):**

Add to the `pub use actor::` block:
```rust
pub use actor::{snow_timer_sleep, snow_timer_send_after};
```

Or if the existing block is getting long, add a new line:
```rust
pub use actor::{snow_timer_sleep, snow_timer_send_after};
```
  </action>
  <verify>
`cargo check -p snow-rt` and `cargo check -p snow-codegen` both pass. `cargo test -p snow-rt` passes (unit tests still work).
  </verify>
  <done>Timer runtime functions implemented (sleep via yield loop, send_after via background thread), intrinsics declared, codegen handles Timer.send_after message serialization, functions re-exported.</done>
</task>

<task type="auto">
  <name>Task 3: Add e2e tests for Timer.sleep and Timer.send_after</name>
  <files>crates/snowc/tests/e2e_concurrency_stdlib.rs</files>
  <action>
Add e2e tests to `e2e_concurrency_stdlib.rs` using the existing `compile_and_run_with_timeout` helper.

**Test 1: `test_timer_sleep_basic`**
Verify Timer.sleep(ms) suspends the actor and resumes after the delay.

Snow source:
```
fn main() {
  Timer.sleep(100)
  IO.println("awake")
}
```

Expected output: `awake`
Use 5-second timeout. Assert stdout.trim() == "awake".
This proves sleep returns without hanging and doesn't crash.

**Test 2: `test_timer_sleep_does_not_block_other_actors`**
Spawn two actors: one sleeps for 200ms then prints "slow", the other prints "fast" immediately. Both should complete (fast first, then slow).

Snow source:
```
fn slow() {
  Timer.sleep(200)
  IO.println("slow")
}

fn fast() {
  IO.println("fast")
}

fn main() {
  spawn slow()
  spawn fast()
  Timer.sleep(500)
}
```

Expected output: `fast` on first line, `slow` on second line (order may vary due to scheduling, but both must appear).
Use 5-second timeout. Assert stdout contains both "fast" and "slow".

**Test 3: `test_timer_send_after_delivers_message`**
Use Timer.send_after to schedule a delayed message delivery.

Snow source:
```
fn worker() {
  let result = receive {
    msg -> msg
  } after 5000 -> -1
  IO.println(Int.to_string(result))
}

fn main() {
  let pid = spawn worker()
  Timer.send_after(pid, 100, 99)
  Timer.sleep(500)
}
```

Expected output: `99` (the delayed message, not the timeout value -1).
Use 5-second timeout. Assert stdout.trim() == "99".

**Test 4: `test_timer_send_after_arrives_after_delay`**
Verify the message doesn't arrive immediately -- it arrives after the specified delay. Use a short receive timeout that expires BEFORE the send_after delay.

Snow source:
```
fn worker() {
  let result = receive {
    msg -> msg
  } after 50 -> -1
  IO.println(Int.to_string(result))
}

fn main() {
  let pid = spawn worker()
  Timer.send_after(pid, 500, 99)
  Timer.sleep(1000)
}
```

Expected output: `-1` (the receive times out at 50ms because the message won't arrive until 500ms).
Use 5-second timeout. Assert stdout.trim() == "-1".
  </action>
  <verify>
`cargo test -p snowc test_timer -- --test-threads=1` passes. All 4 new tests pass. Run full suite: `cargo test -p snowc -- --test-threads=1` to verify zero regressions.
  </verify>
  <done>4 e2e tests pass: Timer.sleep works, Timer.sleep doesn't block other actors, Timer.send_after delivers message, Timer.send_after respects delay timing.</done>
</task>

</tasks>

<verification>
1. `cargo check` -- full workspace compiles
2. `cargo test -p snow-rt` -- runtime unit tests pass
3. `cargo test -p snowc test_timer -- --test-threads=1` -- all 4 Timer tests pass
4. `cargo test -p snowc -- --test-threads=1` -- full e2e suite, zero regressions
5. Timer.sleep doesn't block other actors (test 2 proves both actors complete)
6. Timer.send_after respects delay timing (test 4 proves message arrives after specified delay)
</verification>

<success_criteria>
- TIMER-01: Timer.sleep(ms) suspends the current actor for ms milliseconds without blocking other actors
- TIMER-02: Timer.send_after(pid, ms, msg) delivers msg to the target actor after ms milliseconds
- All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/44-receive-timeouts-timers/44-02-SUMMARY.md`
</output>
