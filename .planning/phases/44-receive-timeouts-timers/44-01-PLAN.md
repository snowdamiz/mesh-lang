---
phase: 44-receive-timeouts-timers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snowc/tests/e2e_concurrency_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "receive { msg -> body } after 50 -> timeout_body executes timeout_body when no message arrives within 50ms"
    - "receive with after clause returns the value from timeout body, not a null dereference segfault"
    - "Compiler rejects type mismatches between receive arm types and timeout body type"
  artifacts:
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "Null-check branching after snow_actor_receive and timeout body codegen"
      contains: "timeout_body"
    - path: "crates/snowc/tests/e2e_concurrency_stdlib.rs"
      provides: "E2E tests for receive-with-timeout"
      contains: "receive_after"
  key_links:
    - from: "codegen_actor_receive"
      to: "snow_actor_receive"
      via: "build_is_null null-check on returned ptr, branch to timeout_bb when null"
      pattern: "build_is_null.*msg_is_null"
---

<objective>
Complete the `receive ... after ms -> body` codegen gap so that timeout bodies actually execute when no message arrives within the specified duration.

Purpose: The parser, type checker, and MIR lowerer already handle the `after` clause fully -- only the LLVM IR codegen ignores it (line 130: `timeout_body: _`). This causes a segfault when a receive times out because the null pointer from `snow_actor_receive` is dereferenced without a null check.

Output: Working receive-with-timeout codegen, e2e tests proving timeout execution.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-codegen/src/mir/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement receive-with-timeout codegen (null-check + timeout body branching)</name>
  <files>crates/snow-codegen/src/codegen/expr.rs</files>
  <action>
Fix the `codegen_actor_receive` method in `expr.rs` to handle timeout bodies. Two changes needed:

**Change 1: Pass timeout_body through the match arm (line ~127-132).**

Replace:
```rust
MirExpr::ActorReceive {
    arms,
    timeout_ms,
    timeout_body: _,
    ty,
} => self.codegen_actor_receive(arms, timeout_ms.as_deref(), ty),
```
With:
```rust
MirExpr::ActorReceive {
    arms,
    timeout_ms,
    timeout_body,
    ty,
} => self.codegen_actor_receive(arms, timeout_ms.as_deref(), timeout_body.as_deref(), ty),
```

**Change 2: Update `codegen_actor_receive` signature and add null-check branching (line ~1710).**

Update the function signature to accept `timeout_body: Option<&MirExpr>`.

After `snow_actor_receive` returns `msg_ptr` (line ~1736), add null-check branching ONLY when `timeout_body` is `Some`. The branching pattern follows the if-expression pattern already in expr.rs (lines 1048-1106):

When timeout_body is Some:
1. Create `result_alloca` for the receive result type using `self.llvm_type(result_ty)`
2. Create basic blocks: `timeout_bb`, `msg_bb`, `recv_merge_bb`
3. `build_is_null(msg_ptr, "msg_is_null")` then `build_conditional_branch(is_null, timeout_bb, msg_bb)`
4. **timeout_bb:** `position_at_end(timeout_bb)`, codegen the timeout_body expression, store result into `result_alloca`, `build_unconditional_branch(recv_merge_bb)`
5. **msg_bb:** `position_at_end(msg_bb)`, move ALL existing message-processing code here (data_ptr GEP, msg_val load, arm pattern binding, arm body codegen), store result into `result_alloca`, `build_unconditional_branch(recv_merge_bb)`
6. **recv_merge_bb:** `position_at_end(recv_merge_bb)`, `build_load(result_ty, result_alloca, "recv_val")`, return as Ok

When timeout_body is None: keep existing behavior unchanged (no null check, no branching -- the runtime returns a valid pointer for infinite wait).

CRITICAL: The existing message-processing code (lines 1738-1813) must be moved INSIDE the msg_bb block. Do NOT duplicate it. The control flow is:

```
  [snow_actor_receive call]
      |
  [is_null check]  (only when timeout_body exists)
    /        \
timeout_bb  msg_bb
    |           |
  [codegen    [existing msg
   timeout     processing +
   body]       arm body]
    \        /
   recv_merge_bb
      |
  [load result_alloca]
```

For the no-arms case (empty receive used by Timer.sleep in plan 02): when arms is empty AND timeout_body is Some, the msg_bb should just store the raw msg_val to result_alloca (existing line 1816 behavior).

Reference the service loop pattern at line ~2373-2390 for the null-check idiom (`build_is_null` + `build_conditional_branch`).
Reference the if-expression pattern at line ~1048-1106 for the result_alloca + merge block idiom.
  </action>
  <verify>
`cargo check -p snow-codegen` passes with no errors. The function signature change and match arm update compile cleanly.
  </verify>
  <done>codegen_actor_receive accepts timeout_body parameter, performs null-check branching when timeout_body is Some, and falls through to existing behavior when None.</done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for receive-with-timeout</name>
  <files>crates/snowc/tests/e2e_concurrency_stdlib.rs</files>
  <action>
Add e2e tests to `e2e_concurrency_stdlib.rs` (this file already has `compile_and_run_with_timeout` helper for concurrency tests).

**Test 1: `test_receive_after_timeout_fires`**
Spawn an actor that does `receive { msg -> msg } after 50 -> -1` with nobody sending a message. The actor should return -1 (the timeout body) since no message arrives within 50ms. The spawning main function sends the result to stdout via IO.println.

Snow source:
```
fn worker() -> Int {
  receive {
    msg -> msg
  } after 50 -> -1
}

fn main() {
  let pid = spawn worker()
  // Don't send anything -- let it timeout
  // Wait for the actor to finish (use a small sleep via receive-after on main)
  let result = receive {
    x -> x
  } after 200 -> 0
  IO.println(Int.to_string(result))
}
```

Wait -- the above won't work because receive in main needs someone to send. Instead, use a simpler approach: the worker prints the timeout value directly.

Snow source:
```
fn worker() {
  let result = receive {
    msg -> msg
  } after 50 -> -1
  IO.println(Int.to_string(result))
}

fn main() {
  spawn worker()
  // Wait long enough for the worker to timeout and print
  receive { x -> x } after 500 -> 0
}
```

Expected output: `-1` (the timeout body value).
Use `compile_and_run_with_timeout(source, 5)` with a 5-second process timeout.
Assert stdout.trim() == "-1".

**Test 2: `test_receive_after_message_arrives_before_timeout`**
Spawn an actor that does `receive { msg -> msg } after 5000 -> -1` and immediately send it a message. The message should arrive well before the 5-second timeout, so the arm body runs (not the timeout body).

Snow source:
```
fn worker() {
  let result = receive {
    msg -> msg
  } after 5000 -> -1
  IO.println(Int.to_string(result))
}

fn main() {
  let pid = spawn worker()
  send pid 42
  receive { x -> x } after 500 -> 0
}
```

Expected output: `42` (the message, not the timeout value).
Assert stdout.trim() == "42".

**Test 3: `test_receive_after_timeout_returns_string`**
Test that the timeout body can return a String type (not just Int), verifying the type unification between arms and timeout body works end-to-end.

Snow source:
```
fn worker() {
  let result = receive {
    msg -> msg
  } after 50 -> "timeout"
  IO.println(result)
}

fn main() {
  spawn worker()
  receive { x -> x } after 500 -> "done"
}
```

Expected output: `timeout`.
Assert stdout.trim() == "timeout".
  </action>
  <verify>
`cargo test -p snowc test_receive_after -- --test-threads=1` passes. All 3 new tests pass. Run the full test suite: `cargo test -p snowc -- --test-threads=1` to verify zero regressions.
  </verify>
  <done>3 e2e tests pass: timeout fires when no message arrives, message arrival before timeout works correctly, timeout body can return String type.</done>
</task>

</tasks>

<verification>
1. `cargo check -p snow-codegen` -- codegen compiles
2. `cargo test -p snowc test_receive_after -- --test-threads=1` -- all 3 new tests pass
3. `cargo test -p snowc -- --test-threads=1` -- full test suite, zero regressions
4. Manual: receive-with-timeout no longer segfaults (proven by tests)
</verification>

<success_criteria>
- RECV-01: `receive { ... } after ms -> body` executes timeout body when no message arrives within ms (no segfault)
- RECV-02: Type checking of timeout body against arm types is already implemented in typeck; verified by test_receive_after_timeout_returns_string test (String type unification)
- All existing tests continue to pass (no regressions from the codegen change)
</success_criteria>

<output>
After completion, create `.planning/phases/44-receive-timeouts-timers/44-01-SUMMARY.md`
</output>
