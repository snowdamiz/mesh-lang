---
phase: 78-lazy-combinators-terminals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-rt/src/iter.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-rt/src/collections/list.rs
  - crates/mesh-rt/src/collections/map.rs
  - crates/mesh-rt/src/collections/set.rs
  - crates/mesh-rt/src/collections/range.rs
autonomous: true

must_haves:
  truths:
    - "All iterator handles (List, Map, Set, Range, adapters) have a u8 type tag as their first field for generic dispatch"
    - "mesh_iter_generic_next dispatches to the correct _next function based on type tag"
    - "All 6 combinator adapter structs (Map, Filter, Take, Skip, Enumerate, Zip) exist with _new and _next functions"
    - "All 6 terminal functions (count, sum, any, all, find, reduce) consume iterators via generic_next loop"
    - "Existing for-in iteration over lists/maps/sets/ranges still works (zero regressions)"
  artifacts:
    - path: "crates/mesh-rt/src/iter.rs"
      provides: "Adapter structs, generic dispatch, terminal operations"
    - path: "crates/mesh-rt/src/lib.rs"
      provides: "mod iter declaration"
  key_links:
    - from: "crates/mesh-rt/src/iter.rs"
      to: "crates/mesh-rt/src/collections/list.rs"
      via: "mesh_list_iter_next called from generic dispatch"
      pattern: "mesh_list_iter_next"
    - from: "crates/mesh-rt/src/iter.rs"
      to: "crates/mesh-rt/src/option.rs"
      via: "alloc_option for iterator results"
      pattern: "alloc_option"
---

<objective>
Implement the runtime infrastructure for lazy iterator adapters and terminal operations.

Purpose: Create the C-level adapter handle structs (MapAdapter, FilterAdapter, TakeAdapter, SkipAdapter, EnumerateAdapter, ZipAdapter), their _new/_next functions, a generic next dispatch function using type tags, all terminal operations (count, sum, any, all, find, reduce), and retrofit existing Phase 76 iterator handles with type tags for uniform dispatch.

Output: crates/mesh-rt/src/iter.rs with all adapter + terminal functions, updated collection iterators with type tags.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/78-lazy-combinators-terminals/78-RESEARCH.md
@.planning/phases/76-iterator-protocol/76-01-SUMMARY.md
@.planning/phases/76-iterator-protocol/76-02-SUMMARY.md
@crates/mesh-rt/src/option.rs
@crates/mesh-rt/src/collections/list.rs (lines 63-68: alloc_pair, lines 186-210: BareFn/ClosureFn pattern, lines 789-835: ListIterator + mesh_list_iter_new/next/from)
@crates/mesh-rt/src/collections/map.rs (MapIterator struct)
@crates/mesh-rt/src/collections/set.rs (SetIterator struct)
@crates/mesh-rt/src/collections/range.rs (RangeIterator struct)
@crates/mesh-rt/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type tags to existing iterator handles and create generic dispatch</name>
  <files>
    crates/mesh-rt/src/collections/list.rs
    crates/mesh-rt/src/collections/map.rs
    crates/mesh-rt/src/collections/set.rs
    crates/mesh-rt/src/collections/range.rs
    crates/mesh-rt/src/iter.rs
    crates/mesh-rt/src/lib.rs
  </files>
  <action>
**Step 1: Add type tag to existing Phase 76 iterator handles.**

Modify each existing iterator struct to add `tag: u8` as the FIRST field. Update each `_new` function to write the tag. The struct layout changes automatically via `#[repr(C)]` -- all `_next` functions that cast via `iter_ptr as *mut XyzIterator` automatically pick up the new layout.

Constants for type tags:
```rust
pub const ITER_TAG_LIST: u8 = 0;
pub const ITER_TAG_MAP: u8 = 1;
pub const ITER_TAG_SET: u8 = 2;
pub const ITER_TAG_RANGE: u8 = 3;
pub const ITER_TAG_MAP_ADAPTER: u8 = 10;
pub const ITER_TAG_FILTER_ADAPTER: u8 = 11;
pub const ITER_TAG_TAKE_ADAPTER: u8 = 12;
pub const ITER_TAG_SKIP_ADAPTER: u8 = 13;
pub const ITER_TAG_ENUMERATE_ADAPTER: u8 = 14;
pub const ITER_TAG_ZIP_ADAPTER: u8 = 15;
```

For ListIterator in list.rs:
```rust
#[repr(C)]
struct ListIterator {
    tag: u8,       // NEW: ITER_TAG_LIST
    list: *mut u8,
    index: i64,
    length: i64,
}
```
In `mesh_list_iter_new`, add: `(*iter).tag = 0;` (ITER_TAG_LIST).
Do the same for MapIterator (tag=1), SetIterator (tag=2), RangeIterator (tag=3).

**IMPORTANT:** The tag constants should be defined in `crates/mesh-rt/src/iter.rs` and imported by each collection module via `use crate::iter::ITER_TAG_LIST;` etc. Alternatively, define them as plain u8 literals in each `_new` function if circular dependency is a concern.

**Step 2: Update `mesh_iter_from` in list.rs** to continue delegating to `mesh_list_iter_new` (which now writes the tag). No functional change needed -- the tag is written by `mesh_list_iter_new`.

**Step 3: Create `crates/mesh-rt/src/iter.rs`** with:
- Type tag constants (exported as `pub const`)
- Import `alloc_option` from `crate::option`
- Import `alloc_pair` from `crate::collections::list`
- Import all `mesh_*_iter_next` functions via extern declarations or direct function calls
- `mesh_iter_generic_next(iter: *mut u8) -> *mut u8` function that reads the first byte as tag and dispatches:
  - Tag 0 -> `mesh_list_iter_next(iter)`
  - Tag 1 -> `mesh_map_iter_next(iter)`
  - Tag 2 -> `mesh_set_iter_next(iter)`
  - Tag 3 -> `mesh_range_iter_next(iter)`
  - Tags 10-15 -> adapter `_next` functions (will be added in Task 2)
  - Unknown -> `alloc_option(1, null)` (None)

**Step 4: Add `mod iter;` to `crates/mesh-rt/src/lib.rs`.**

**CRITICAL:** The `_next` functions for each collection iterator will need to be callable from iter.rs. Since they're in the same crate, use `crate::collections::list::mesh_list_iter_next` etc. But these are `extern "C"` functions, so they're callable by name. The simplest approach: declare them in iter.rs as `extern "C" { fn mesh_list_iter_next(iter: *mut u8) -> *mut u8; }` etc., OR import them via `use crate::collections::list::mesh_list_iter_next;`. Prefer the `use` import since they're in the same crate.
  </action>
  <verify>
`cargo build -p mesh-rt` compiles cleanly. Run `cargo test -p mesh-rt` to verify existing iterator tests pass (ListIterator with tag field doesn't break existing tests). Check that iter.rs compiles with generic_next dispatch stub.
  </verify>
  <done>
All 4 existing iterator handles have tag fields. mesh_iter_generic_next dispatches by tag. iter.rs exists and compiles. Existing runtime tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement all combinator adapters and terminal operations</name>
  <files>
    crates/mesh-rt/src/iter.rs
  </files>
  <action>
Add all 6 combinator adapter structs and all 6 terminal functions to `crates/mesh-rt/src/iter.rs`.

**Combinator Adapters** (each needs a `#[repr(C)]` struct, `#[no_mangle] pub extern "C"` _new and _next functions):

1. **MapAdapter** (tag=10):
   - Struct: `{ tag: u8, source: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8 }`
   - `mesh_iter_map(source: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> *mut u8` -- allocate via `mesh_gc_alloc_actor`, write tag=10, store source/fn_ptr/env_ptr
   - `mesh_iter_map_next(adapter: *mut u8) -> *mut u8` -- call `mesh_iter_generic_next(source)`, if None return None, if Some apply fn (BareFn or ClosureFn pattern based on env_ptr null check), return `alloc_option(0, result)`

2. **FilterAdapter** (tag=11):
   - Struct: `{ tag: u8, source: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8 }`
   - `mesh_iter_filter(source, fn_ptr, env_ptr) -> *mut u8`
   - `mesh_iter_filter_next(adapter) -> *mut u8` -- loop: call `mesh_iter_generic_next(source)`, if None return None, if Some test predicate (BareFn/ClosureFn returning i8/bool, nonzero = true), if passes return the option, if not continue loop

3. **TakeAdapter** (tag=12):
   - Struct: `{ tag: u8, source: *mut u8, remaining: i64 }`
   - `mesh_iter_take(source: *mut u8, n: i64) -> *mut u8`
   - `mesh_iter_take_next(adapter) -> *mut u8` -- if remaining <= 0 return None, decrement remaining, call `mesh_iter_generic_next(source)` and return result

4. **SkipAdapter** (tag=13):
   - Struct: `{ tag: u8, source: *mut u8, to_skip: i64, skipped: u8 }` (skipped flag: 0=not yet, 1=done)
   - `mesh_iter_skip(source: *mut u8, n: i64) -> *mut u8`
   - `mesh_iter_skip_next(adapter) -> *mut u8` -- if not skipped yet, loop calling `mesh_iter_generic_next` n times (discarding results), set skipped=1. Then call and return `mesh_iter_generic_next(source)`

5. **EnumerateAdapter** (tag=14):
   - Struct: `{ tag: u8, source: *mut u8, index: i64 }`
   - `mesh_iter_enumerate(source: *mut u8) -> *mut u8`
   - `mesh_iter_enumerate_next(adapter) -> *mut u8` -- call `mesh_iter_generic_next(source)`, if None return None, if Some create `alloc_pair(index, value)`, increment index, return `alloc_option(0, pair)`

6. **ZipAdapter** (tag=15):
   - Struct: `{ tag: u8, source_a: *mut u8, source_b: *mut u8 }`
   - `mesh_iter_zip(source_a: *mut u8, source_b: *mut u8) -> *mut u8`
   - `mesh_iter_zip_next(adapter) -> *mut u8` -- call `mesh_iter_generic_next` on both sources, if either is None return None, else `alloc_pair(a_value, b_value)` wrapped in Some

**Update `mesh_iter_generic_next`** to add dispatches for tags 10-15 to the new `_next` functions.

**Terminal Operations** (each is a `#[no_mangle] pub extern "C"` function):

1. `mesh_iter_count(iter: *mut u8) -> i64` -- loop calling `mesh_iter_generic_next` until None, count Somes
2. `mesh_iter_sum(iter: *mut u8) -> i64` -- loop, sum `option.value as i64` for each Some
3. `mesh_iter_any(iter: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> i8` -- loop, apply predicate to each elem, return 1 on first true, 0 if exhausted (short-circuit)
4. `mesh_iter_all(iter: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> i8` -- loop, apply predicate, return 0 on first false, 1 if all pass (short-circuit)
5. `mesh_iter_find(iter: *mut u8, fn_ptr: *mut u8, env_ptr: *mut u8) -> *mut u8` -- loop, apply predicate, return `alloc_option(0, elem)` on first match, `alloc_option(1, null)` if exhausted
6. `mesh_iter_reduce(iter: *mut u8, init: u64, fn_ptr: *mut u8, env_ptr: *mut u8) -> u64` -- loop with accumulator, call `fn(acc, elem)` for each Some, return final acc

**Closure calling pattern** (proven from list.rs):
```rust
type BareFn = unsafe extern "C" fn(u64) -> u64;
type ClosureFn = unsafe extern "C" fn(*mut u8, u64) -> u64;
// For two-arg (reduce):
type BareFn2 = unsafe extern "C" fn(u64, u64) -> u64;
type ClosureFn2 = unsafe extern "C" fn(*mut u8, u64, u64) -> u64;
```
Check `env_ptr.is_null()` to decide which to use.

**For predicate closures (filter, any, all, find):**
The predicate returns a boolean. In Mesh, Bool is i8 (0=false, nonzero=true). The BareFn/ClosureFn returns u64, but the boolean value is in the low byte. Cast result to `i8` or check `result != 0`.

**Import helpers:**
- `use crate::option::{MeshOption, alloc_option};`
- `use crate::collections::list::alloc_pair;`
- `use crate::gc::mesh_gc_alloc_actor;`
- `use crate::collections::list::mesh_list_iter_next;`
- `use crate::collections::map::mesh_map_iter_next;`
- `use crate::collections::set::mesh_set_iter_next;`
- `use crate::collections::range::mesh_range_iter_next;`

Note: `alloc_pair` is `pub(crate)` in list.rs. If not, make it `pub(crate)` or `pub`.
  </action>
  <verify>
`cargo build -p mesh-rt` compiles cleanly. `cargo test -p mesh-rt` passes. All 12 new `#[no_mangle] extern "C"` functions exist (6 adapter _new + 6 _next + 6 terminals = 18 total new functions).
  </verify>
  <done>
All 6 combinator adapters (MapAdapter, FilterAdapter, TakeAdapter, SkipAdapter, EnumerateAdapter, ZipAdapter) with _new/_next functions are implemented. All 6 terminal operations (count, sum, any, all, find, reduce) are implemented. Generic next dispatch handles tags 0-3 and 10-15. Runtime builds and tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p mesh-rt` -- runtime compiles with all new adapter + terminal code
2. `cargo test -p mesh-rt` -- existing iterator tests pass (type tag addition doesn't break)
3. `cargo build --workspace` -- full workspace builds (no cross-crate issues)
4. Verify iter.rs exports at least 18 new extern "C" functions
</verification>

<success_criteria>
- All 4 existing iterator handles (List, Map, Set, Range) have type tag first field
- mesh_iter_generic_next dispatches to correct _next by tag (10 dispatch arms)
- 6 combinator adapters are lazy (no intermediate list allocation in any _new or _next)
- 6 terminal operations loop via generic_next until None
- Runtime compiles and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/78-lazy-combinators-terminals/78-01-SUMMARY.md`
</output>
