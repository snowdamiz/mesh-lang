---
phase: 78-lazy-combinators-terminals
plan: 03
type: execute
wave: 3
depends_on: ["78-01", "78-02"]
files_modified:
  - tests/e2e/iter_map_filter.mpl
  - tests/e2e/iter_take_skip.mpl
  - tests/e2e/iter_enumerate_zip.mpl
  - tests/e2e/iter_terminals.mpl
  - tests/e2e/iter_pipeline.mpl
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Iter.from(list) |> Iter.map(fn) |> Iter.filter(fn) compiles and produces correct results with no intermediate list allocated"
    - "Iter.take and Iter.skip correctly limit and offset iteration"
    - "Iter.enumerate produces (index, element) tuples and Iter.zip combines two iterators into tuples"
    - "All 6 terminals (count, sum, any, all, find, reduce) produce correct scalar results"
    - "Multi-combinator pipeline with take short-circuits (does not process all elements)"
    - "Pipe operator |> works for chaining all combinators and terminals"
  artifacts:
    - path: "tests/e2e/iter_map_filter.mpl"
      provides: "E2E test for Iter.map and Iter.filter combinators"
    - path: "tests/e2e/iter_take_skip.mpl"
      provides: "E2E test for Iter.take and Iter.skip combinators"
    - path: "tests/e2e/iter_enumerate_zip.mpl"
      provides: "E2E test for Iter.enumerate and Iter.zip combinators"
    - path: "tests/e2e/iter_terminals.mpl"
      provides: "E2E test for count, sum, any, all, find, reduce terminals"
    - path: "tests/e2e/iter_pipeline.mpl"
      provides: "E2E test for multi-combinator pipeline with short-circuit"
    - path: "crates/meshc/tests/e2e.rs"
      provides: "Test harness entries for all 5 new E2E tests"
  key_links:
    - from: "tests/e2e/iter_pipeline.mpl"
      to: "crates/mesh-rt/src/iter.rs"
      via: "Multi-combinator chain exercises generic dispatch and short-circuit"
      pattern: "Iter.from.*Iter.filter.*Iter.take.*Iter.count"
---

<objective>
Add comprehensive E2E tests verifying all lazy combinators (map, filter, take, skip, enumerate, zip) and terminal operations (count, sum, any, all, find, reduce) work correctly through the full compiler pipeline.

Purpose: Validate that the runtime adapters (Plan 01) and compiler wiring (Plan 02) produce correct end-to-end behavior for user-written Mesh programs using lazy iterator pipelines.

Output: 5 E2E test files exercising all 11 requirements (COMB-01 through COMB-06, TERM-01 through TERM-05) with expected output verification.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/78-lazy-combinators-terminals/78-RESEARCH.md
@.planning/phases/78-lazy-combinators-terminals/78-01-SUMMARY.md
@.planning/phases/78-lazy-combinators-terminals/78-02-SUMMARY.md
@crates/meshc/tests/e2e.rs (existing test harness entries)
@tests/e2e/iterator_iterable.mpl (existing iterator E2E test for pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: E2E tests for combinators (map, filter, take, skip, enumerate, zip)</name>
  <files>
    tests/e2e/iter_map_filter.mpl
    tests/e2e/iter_take_skip.mpl
    tests/e2e/iter_enumerate_zip.mpl
    crates/meshc/tests/e2e.rs
  </files>
  <action>
**Create `tests/e2e/iter_map_filter.mpl`** (COMB-01, COMB-02, COMB-06):
```mesh
fn main() do
  let list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

  # Map: double each element
  let doubled = Iter.from(list) |> Iter.map(fn x -> x * 2 end) |> Iter.count()
  println(doubled.to_string())  # 10

  # Filter: keep even numbers
  let even_count = Iter.from(list) |> Iter.filter(fn x -> x % 2 == 0 end) |> Iter.count()
  println(even_count.to_string())  # 5

  # Map + Filter chain: double then keep > 10
  let big = Iter.from(list) |> Iter.map(fn x -> x * 2 end) |> Iter.filter(fn x -> x > 10 end) |> Iter.count()
  println(big.to_string())  # 5

  # Map then sum
  let sum = Iter.from(list) |> Iter.map(fn x -> x * 3 end) |> Iter.sum()
  println(sum.to_string())  # 165
end
```
Expected output: `10\n5\n5\n165`

**Create `tests/e2e/iter_take_skip.mpl`** (COMB-03):
```mesh
fn main() do
  let list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

  # Take first 3
  let first3 = Iter.from(list) |> Iter.take(3) |> Iter.sum()
  println(first3.to_string())  # 6

  # Skip first 7, then sum remaining
  let last3 = Iter.from(list) |> Iter.skip(7) |> Iter.sum()
  println(last3.to_string())  # 27

  # Take 0
  let zero = Iter.from(list) |> Iter.take(0) |> Iter.count()
  println(zero.to_string())  # 0

  # Skip all
  let skip_all = Iter.from(list) |> Iter.skip(100) |> Iter.count()
  println(skip_all.to_string())  # 0
end
```
Expected output: `6\n27\n0\n0`

**Create `tests/e2e/iter_enumerate_zip.mpl`** (COMB-04, COMB-05):
```mesh
fn main() do
  let list = [10, 20, 30]

  # Enumerate: count elements (verifies enumerate produces tuples)
  let n = Iter.from(list) |> Iter.enumerate() |> Iter.count()
  println(n.to_string())  # 3

  # Zip: combine two iterators, count pairs
  let a = [1, 2, 3]
  let b = [4, 5, 6]
  let pairs = Iter.from(a) |> Iter.zip(Iter.from(b)) |> Iter.count()
  println(pairs.to_string())  # 3

  # Zip with unequal lengths: shorter determines count
  let short = [1, 2]
  let long = [10, 20, 30, 40]
  let zipped = Iter.from(short) |> Iter.zip(Iter.from(long)) |> Iter.count()
  println(zipped.to_string())  # 2
end
```
Expected output: `3\n3\n2`

**Add test harness entries** in `crates/meshc/tests/e2e.rs`:
Follow the existing pattern (look for `e2e_iterator_iterable` or similar entries). Add:
```rust
e2e_test!(e2e_iter_map_filter, "iter_map_filter", "10\n5\n5\n165\n");
e2e_test!(e2e_iter_take_skip, "iter_take_skip", "6\n27\n0\n0\n");
e2e_test!(e2e_iter_enumerate_zip, "iter_enumerate_zip", "3\n3\n2\n");
```
  </action>
  <verify>
`cargo test -p meshc e2e_iter_map_filter -- --nocapture` passes with expected output. Same for `e2e_iter_take_skip` and `e2e_iter_enumerate_zip`. All existing E2E tests still pass.
  </verify>
  <done>
Map, filter, take, skip, enumerate, zip combinators all produce correct results in E2E tests. Pipe operator chains work. No intermediate list allocations (lazy design). 3 new E2E tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: E2E tests for terminals and multi-combinator pipeline with short-circuit</name>
  <files>
    tests/e2e/iter_terminals.mpl
    tests/e2e/iter_pipeline.mpl
    crates/meshc/tests/e2e.rs
  </files>
  <action>
**Create `tests/e2e/iter_terminals.mpl`** (TERM-01 through TERM-05):
```mesh
fn main() do
  let list = [1, 2, 3, 4, 5]

  # Count (TERM-01)
  let c = Iter.from(list) |> Iter.count()
  println(c.to_string())  # 5

  # Sum (TERM-02)
  let s = Iter.from(list) |> Iter.sum()
  println(s.to_string())  # 15

  # Any - true case (TERM-03)
  let has_even = Iter.from(list) |> Iter.any(fn x -> x % 2 == 0 end)
  println(has_even.to_string())  # true

  # Any - false case
  let has_big = Iter.from(list) |> Iter.any(fn x -> x > 100 end)
  println(has_big.to_string())  # false

  # All - true case (TERM-03)
  let all_pos = Iter.from(list) |> Iter.all(fn x -> x > 0 end)
  println(all_pos.to_string())  # true

  # All - false case
  let all_even = Iter.from(list) |> Iter.all(fn x -> x % 2 == 0 end)
  println(all_even.to_string())  # false

  # Reduce (TERM-05)
  let product = Iter.from(list) |> Iter.reduce(1, fn acc, x -> acc * x end)
  println(product.to_string())  # 120

  # Reduce sum
  let sum2 = Iter.from(list) |> Iter.reduce(0, fn acc, x -> acc + x end)
  println(sum2.to_string())  # 15
end
```
Expected output: `5\n15\ntrue\nfalse\ntrue\nfalse\n120\n15`

**NOTE on `find` (TERM-04):** The `find` function returns an Option (MeshOption pointer). Mesh may or may not have a built-in way to print Options. If `println` doesn't support Option printing, skip the `find` test in this file OR test it via a different approach (e.g., check if the find result is used in a match expression). If the existing E2E tests show a pattern for testing Option values, follow that. Otherwise, defer `find` testing to a later gap closure if printing Options isn't supported.

**ALTERNATIVE for find:** Test it by checking its count -- `find` returns an Option, but we can use it indirectly:
```mesh
  # Find (TERM-04) - test that find returns a result by using it
  let list2 = [10, 20, 30, 40]
  let found = Iter.from(list2) |> Iter.find(fn x -> x > 25 end)
  # found is an Option -- if Mesh can match on it, test that way
  # Otherwise just verify it doesn't crash
```
If Options can't be easily printed, test find by verifying the pipeline doesn't crash. The correctness is proven by the runtime unit test.

**Create `tests/e2e/iter_pipeline.mpl`** (COMB-06 laziness, Success Criterion 4 short-circuit):
```mesh
fn main() do
  # Multi-combinator pipeline: map -> filter -> take -> count
  let list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

  let result = Iter.from(list)
    |> Iter.map(fn x -> x * 2 end)
    |> Iter.filter(fn x -> x > 10 end)
    |> Iter.take(3)
    |> Iter.count()
  println(result.to_string())  # 3

  # Pipeline: filter -> map -> sum
  let result2 = Iter.from(list)
    |> Iter.filter(fn x -> x > 5 end)
    |> Iter.map(fn x -> x * 10 end)
    |> Iter.sum()
  println(result2.to_string())  # 400

  # Pipeline: skip -> take -> count (windowing)
  let window = Iter.from(list)
    |> Iter.skip(2)
    |> Iter.take(5)
    |> Iter.count()
  println(window.to_string())  # 5

  # Pipeline with closure capturing local variable
  let threshold = 3
  let above = Iter.from(list)
    |> Iter.filter(fn x -> x > threshold end)
    |> Iter.count()
  println(above.to_string())  # 7
end
```
Expected output: `3\n400\n5\n7`

**Add test harness entries** in `crates/meshc/tests/e2e.rs`:
```rust
e2e_test!(e2e_iter_terminals, "iter_terminals", "5\n15\ntrue\nfalse\ntrue\nfalse\n120\n15\n");
e2e_test!(e2e_iter_pipeline, "iter_pipeline", "3\n400\n5\n7\n");
```

**IMPORTANT:** If any test fails due to unexpected type checker or codegen behavior, debug and fix the issue. Common issues:
- Pipe operator desugars `x |> f(a)` to `f(x, a)` -- verify closure args come after the iterator
- Closure splitting: codegen auto-splits `{fn_ptr, env_ptr}` struct args for runtime intrinsics
- Bool return type: `any`/`all` return i8 (0 or 1), codegen must handle i8->Bool conversion for `println(bool.to_string())`
- Terminal return types: `count`/`sum` return i64, not Ptr -- type checker must propagate Int, not Ptr
  </action>
  <verify>
`cargo test -p meshc e2e_iter_terminals -- --nocapture` passes. `cargo test -p meshc e2e_iter_pipeline -- --nocapture` passes. Run `cargo test -p meshc` to verify ALL E2E tests pass (zero regressions). The total test count should increase by 5.
  </verify>
  <done>
All 6 terminal operations produce correct scalar results. Multi-combinator pipeline with map+filter+take+count works with short-circuit evaluation. Closure capturing works in iterator pipelines. All 5 new E2E tests pass alongside all existing tests.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p meshc` -- all E2E tests pass (existing + 5 new)
2. Each success criterion from ROADMAP.md verified:
   - SC1: `Iter.from(list) |> Iter.map(fn) |> Iter.filter(fn)` works (iter_map_filter test)
   - SC2: take/skip/enumerate/zip chain (iter_take_skip, iter_enumerate_zip tests)
   - SC3: count/sum/any/all/find/reduce produce correct results (iter_terminals test)
   - SC4: filter+take+count stops early (iter_pipeline test)
3. Zero regressions across all existing E2E tests
</verification>

<success_criteria>
- 5 new E2E test files compile and run successfully
- All 4 success criteria from the phase roadmap are verified
- Pipe operator works for chaining combinators and terminals
- Closures with captured variables work in iterator pipelines
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/78-lazy-combinators-terminals/78-03-SUMMARY.md`
</output>
