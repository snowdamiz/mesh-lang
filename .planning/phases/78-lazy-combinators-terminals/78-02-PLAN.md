---
phase: 78-lazy-combinators-terminals
plan: 02
type: execute
wave: 2
depends_on: ["78-01"]
files_modified:
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-typeck/src/builtins.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - crates/mesh-codegen/src/mir/types.rs
  - crates/mesh-rt/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Iter.map/filter/take/skip/enumerate/zip/count/sum/any/all/find/reduce are recognized by the type checker as valid Iter module functions"
    - "The MIR lowerer maps each Iter.method to the correct mesh_iter_* runtime function name"
    - "LLVM intrinsic declarations exist for all 18+ new runtime functions with correct signatures"
    - "Adapter iterator types resolve to MirType::Ptr in the type system"
    - "resolve_iterator_fn maps Iterator__next__XyzAdapterIterator to the correct mesh_iter_xyz_next function"
  artifacts:
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Iter module type signatures for all 12 methods"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "map_builtin_name entries for all 12 iter_ prefixed names"
    - path: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM extern declarations for all new runtime functions"
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "resolve_iterator_fn mappings for adapter types"
    - path: "crates/mesh-codegen/src/mir/types.rs"
      provides: "Adapter type names -> MirType::Ptr"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "Iter.map type-checks then lowers to iter_map then map_builtin_name resolves to mesh_iter_map"
      pattern: "iter_map.*mesh_iter_map"
    - from: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      to: "crates/mesh-rt/src/iter.rs"
      via: "LLVM extern declarations match runtime extern C function signatures"
      pattern: "mesh_iter_map"
    - from: "crates/mesh-codegen/src/codegen/expr.rs"
      to: "crates/mesh-rt/src/iter.rs"
      via: "resolve_iterator_fn maps adapter next calls to runtime functions"
      pattern: "mesh_iter_map_next"
---

<objective>
Wire all lazy combinator and terminal operations through the compiler pipeline: type checker signatures, MIR lowerer name mappings, LLVM intrinsic declarations, codegen iterator function resolution, and adapter type registration.

Purpose: Connect the runtime adapter infrastructure (Plan 01) to the compiler so that user-written `Iter.map(...)`, `Iter.filter(...)`, `Iter.count()` etc. compile to the correct runtime function calls.

Output: Complete compiler pipeline from source `Iter.method()` calls to runtime `mesh_iter_*` function invocations.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/78-lazy-combinators-terminals/78-RESEARCH.md
@.planning/phases/78-lazy-combinators-terminals/78-01-SUMMARY.md
@crates/mesh-typeck/src/infer.rs (lines 212-846: stdlib_modules, lines 848-860: STDLIB_MODULE_NAMES)
@crates/mesh-typeck/src/builtins.rs (lines 954-972: Iterator impl for ListIterator pattern)
@crates/mesh-codegen/src/mir/lower.rs (lines 9586-9592: STDLIB_MODULES, lines 9599-9865: map_builtin_name)
@crates/mesh-codegen/src/codegen/intrinsics.rs (lines 804-821: Phase 76 iterator intrinsics)
@crates/mesh-codegen/src/codegen/expr.rs (lines 3774-3791: resolve_iterator_fn)
@crates/mesh-codegen/src/mir/types.rs (line 85: ListIterator -> MirType::Ptr)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Type checker signatures and MIR lowerer mappings for all Iter methods</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-typeck/src/builtins.rs
  </files>
  <action>
**Step 1: Add Iter method signatures to `stdlib_modules()` in infer.rs.**

In the Iter module section (around line 836-842), add entries for all 12 new methods. Use `Ptr` (via `Ty::Con(TyCon::new("Ptr"))`) for iterator handle types. The existing `Iter.from` returns `ListIterator` -- keep that. New methods:

```rust
// Combinators (all take iterator + optional args, return iterator handle)
// Iter.map: fn(Ptr, fn(T) -> U) -> Ptr
iter_mod.insert("map".to_string(), Scheme {
    vars: vec![t_var, u_var],
    ty: Ty::fun(vec![
        Ty::Con(TyCon::new("Ptr")),
        Ty::fun(vec![Ty::Var(t_var)], Ty::Var(u_var)),
    ], Ty::Con(TyCon::new("Ptr"))),
});

// Iter.filter: fn(Ptr, fn(T) -> Bool) -> Ptr
iter_mod.insert("filter".to_string(), Scheme {
    vars: vec![t_var],
    ty: Ty::fun(vec![
        Ty::Con(TyCon::new("Ptr")),
        Ty::fun(vec![Ty::Var(t_var)], Ty::bool()),
    ], Ty::Con(TyCon::new("Ptr"))),
});

// Iter.take: fn(Ptr, Int) -> Ptr
iter_mod.insert("take".to_string(), Scheme::mono(
    Ty::fun(vec![Ty::Con(TyCon::new("Ptr")), Ty::int()], Ty::Con(TyCon::new("Ptr")))
));

// Iter.skip: fn(Ptr, Int) -> Ptr
iter_mod.insert("skip".to_string(), Scheme::mono(
    Ty::fun(vec![Ty::Con(TyCon::new("Ptr")), Ty::int()], Ty::Con(TyCon::new("Ptr")))
));

// Iter.enumerate: fn(Ptr) -> Ptr
iter_mod.insert("enumerate".to_string(), Scheme::mono(
    Ty::fun(vec![Ty::Con(TyCon::new("Ptr"))], Ty::Con(TyCon::new("Ptr")))
));

// Iter.zip: fn(Ptr, Ptr) -> Ptr
iter_mod.insert("zip".to_string(), Scheme::mono(
    Ty::fun(vec![Ty::Con(TyCon::new("Ptr")), Ty::Con(TyCon::new("Ptr"))], Ty::Con(TyCon::new("Ptr")))
));

// Terminals
// Iter.count: fn(Ptr) -> Int
iter_mod.insert("count".to_string(), Scheme::mono(
    Ty::fun(vec![Ty::Con(TyCon::new("Ptr"))], Ty::int())
));

// Iter.sum: fn(Ptr) -> Int
iter_mod.insert("sum".to_string(), Scheme::mono(
    Ty::fun(vec![Ty::Con(TyCon::new("Ptr"))], Ty::int())
));

// Iter.any: fn(Ptr, fn(T) -> Bool) -> Bool
iter_mod.insert("any".to_string(), Scheme {
    vars: vec![t_var],
    ty: Ty::fun(vec![
        Ty::Con(TyCon::new("Ptr")),
        Ty::fun(vec![Ty::Var(t_var)], Ty::bool()),
    ], Ty::bool()),
});

// Iter.all: fn(Ptr, fn(T) -> Bool) -> Bool
iter_mod.insert("all".to_string(), Scheme {
    vars: vec![t_var],
    ty: Ty::fun(vec![
        Ty::Con(TyCon::new("Ptr")),
        Ty::fun(vec![Ty::Var(t_var)], Ty::bool()),
    ], Ty::bool()),
});

// Iter.find: fn(Ptr, fn(T) -> Bool) -> Option<T>
// Use Ptr for the Option return (it's a MeshOption pointer at runtime)
iter_mod.insert("find".to_string(), Scheme {
    vars: vec![t_var],
    ty: Ty::fun(vec![
        Ty::Con(TyCon::new("Ptr")),
        Ty::fun(vec![Ty::Var(t_var)], Ty::bool()),
    ], Ty::Con(TyCon::new("Ptr"))),
});

// Iter.reduce: fn(Ptr, T, fn(T, T) -> T) -> T
// At runtime: fn(ptr, u64, fn_ptr, env_ptr) -> u64
// For type checking, use a generic approach:
iter_mod.insert("reduce".to_string(), Scheme {
    vars: vec![t_var],
    ty: Ty::fun(vec![
        Ty::Con(TyCon::new("Ptr")),
        Ty::Var(t_var),
        Ty::fun(vec![Ty::Var(t_var), Ty::Var(t_var)], Ty::Var(t_var)),
    ], Ty::Var(t_var)),
});
```

**IMPORTANT:** Create fresh type variables for each entry. Look at how `iter_t_var` is created for `Iter.from` and follow the same pattern. Each `Scheme` that uses type variables needs its own fresh vars from `ctx.fresh_var()`. Since `stdlib_modules()` doesn't take a context, use manual TyVar IDs starting from a high number (e.g., 91200+) that won't collide. Look at how existing vars are created -- the `iter_t_var` for Iter.from uses a manually-chosen ID.

**Step 2: Add `map_builtin_name` entries in lower.rs.**

Before the `_ => name.to_string()` catch-all (around line 9862), add:
```rust
"iter_map" => "mesh_iter_map".to_string(),
"iter_filter" => "mesh_iter_filter".to_string(),
"iter_take" => "mesh_iter_take".to_string(),
"iter_skip" => "mesh_iter_skip".to_string(),
"iter_enumerate" => "mesh_iter_enumerate".to_string(),
"iter_zip" => "mesh_iter_zip".to_string(),
"iter_count" => "mesh_iter_count".to_string(),
"iter_sum" => "mesh_iter_sum".to_string(),
"iter_any" => "mesh_iter_any".to_string(),
"iter_all" => "mesh_iter_all".to_string(),
"iter_find" => "mesh_iter_find".to_string(),
"iter_reduce" => "mesh_iter_reduce".to_string(),
```

**Step 3: Register Iterator impls for adapter types in builtins.rs (if needed for for-in).**

This step is likely NOT needed for Phase 78 since adapters are consumed by terminal operations, not by for-in loops. However, if the type checker needs to know that adapter handles implement Iterator (e.g., for pipe chaining type inference), register impls following the ListIterator pattern. Skip this unless needed -- the Ptr type in Iter method signatures should suffice.
  </action>
  <verify>
`cargo build -p mesh-typeck` compiles. `cargo test -p mesh-typeck` passes. `cargo build -p mesh-codegen` compiles. Verify that `map_builtin_name("iter_map")` returns `"mesh_iter_map"`. Verify that `stdlib_modules()["Iter"]` contains all 13 methods (from + 12 new).
  </verify>
  <done>
Type checker recognizes all 12 new Iter methods with correct signatures. MIR lowerer maps all 12 iter_* names to mesh_iter_* runtime names. Typeck and codegen crates compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Intrinsic declarations, adapter type registration, and resolve_iterator_fn mappings</name>
  <files>
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-codegen/src/mir/types.rs
    crates/mesh-codegen/src/codegen/expr.rs
    crates/mesh-rt/src/lib.rs
  </files>
  <action>
**Step 1: Declare all new runtime functions in intrinsics.rs.**

Add after the Phase 76 iterator intrinsics (around line 821):

```rust
// ── Phase 78: Lazy Combinators & Terminals ────────────────────────
// Combinators: adapter constructors
// mesh_iter_map(source: ptr, fn_ptr: ptr, env_ptr: ptr) -> ptr
module.add_function("mesh_iter_map", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(Linkage::External));
// mesh_iter_filter(source: ptr, fn_ptr: ptr, env_ptr: ptr) -> ptr
module.add_function("mesh_iter_filter", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(Linkage::External));
// mesh_iter_take(source: ptr, n: i64) -> ptr
module.add_function("mesh_iter_take", ptr_type.fn_type(&[ptr_type.into(), i64_type.into()], false), Some(Linkage::External));
// mesh_iter_skip(source: ptr, n: i64) -> ptr
module.add_function("mesh_iter_skip", ptr_type.fn_type(&[ptr_type.into(), i64_type.into()], false), Some(Linkage::External));
// mesh_iter_enumerate(source: ptr) -> ptr
module.add_function("mesh_iter_enumerate", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
// mesh_iter_zip(source_a: ptr, source_b: ptr) -> ptr
module.add_function("mesh_iter_zip", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(Linkage::External));

// Terminals
// mesh_iter_count(iter: ptr) -> i64
module.add_function("mesh_iter_count", i64_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
// mesh_iter_sum(iter: ptr) -> i64
module.add_function("mesh_iter_sum", i64_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
// mesh_iter_any(iter: ptr, fn_ptr: ptr, env_ptr: ptr) -> i8
module.add_function("mesh_iter_any", i8_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(Linkage::External));
// mesh_iter_all(iter: ptr, fn_ptr: ptr, env_ptr: ptr) -> i8
module.add_function("mesh_iter_all", i8_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(Linkage::External));
// mesh_iter_find(iter: ptr, fn_ptr: ptr, env_ptr: ptr) -> ptr (MeshOption)
module.add_function("mesh_iter_find", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(Linkage::External));
// mesh_iter_reduce(iter: ptr, init: i64, fn_ptr: ptr, env_ptr: ptr) -> i64
module.add_function("mesh_iter_reduce", i64_type.fn_type(&[ptr_type.into(), i64_type.into(), ptr_type.into(), ptr_type.into()], false), Some(Linkage::External));
```

**IMPORTANT:** `i8_type` may need to be obtained: `let i8_type = context.i8_type();`. Check how existing intrinsics use i8 -- the `mesh_iter_any`/`mesh_iter_all` return `i8` (Bool). Actually, review how the codegen handles Bool returns -- they may need to be `i64` if the codegen doesn't handle i8->i64 conversion. Check what `mesh_list_any`/`mesh_list_all` use for their return type in intrinsics. If they use i64, use i64 for consistency. If they use i8, use i8.

Also: `mesh_iter_reduce` takes `init` as i64 and returns i64 because all Mesh values are 64-bit (integers ARE i64, pointers fit in i64). Closures are auto-split by codegen, so the caller passes `(iter, init, fn_ptr, env_ptr)` -- no closure struct.

**Step 2: Register adapter type names in types.rs.**

In the `resolve_con` function (around line 85), add adapter type names to the MirType::Ptr match:
```rust
| "MapAdapterIterator" | "FilterAdapterIterator" | "TakeAdapterIterator"
| "SkipAdapterIterator" | "EnumerateAdapterIterator" | "ZipAdapterIterator" => MirType::Ptr,
```

Note: These names should match what the type checker uses. Since we're using `Ty::Con(TyCon::new("Ptr"))` in stdlib_modules for all iterator returns, these adapter type names might not appear in practice. BUT -- if any codegen path generates Iterator__next__MapAdapterIterator mangled names, these must resolve. Add them defensively.

**Step 3: Add resolve_iterator_fn mappings in expr.rs.**

In the `resolve_iterator_fn` match (around line 3780-3788), add mappings for adapter types so that for-in (or any code that calls Iterator::next on an adapter) resolves correctly:
```rust
"Iterator__next__MapAdapterIterator" => "mesh_iter_map_next",
"Iterator__next__FilterAdapterIterator" => "mesh_iter_filter_next",
"Iterator__next__TakeAdapterIterator" => "mesh_iter_take_next",
"Iterator__next__SkipAdapterIterator" => "mesh_iter_skip_next",
"Iterator__next__EnumerateAdapterIterator" => "mesh_iter_enumerate_next",
"Iterator__next__ZipAdapterIterator" => "mesh_iter_zip_next",
```

Also add the `_next` functions as intrinsic declarations in intrinsics.rs (they need to be callable from LLVM IR if resolve_iterator_fn finds them):
```rust
// Adapter _next functions (for resolve_iterator_fn dispatch)
module.add_function("mesh_iter_map_next", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
module.add_function("mesh_iter_filter_next", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
module.add_function("mesh_iter_take_next", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
module.add_function("mesh_iter_skip_next", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
module.add_function("mesh_iter_enumerate_next", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
module.add_function("mesh_iter_zip_next", ptr_type.fn_type(&[ptr_type.into()], false), Some(Linkage::External));
```

**Step 4: Add re-exports in lib.rs for new iter functions.**

In `crates/mesh-rt/src/lib.rs`, add a `pub use iter::*;` or specific re-exports for the new functions. This ensures the linker can find them. At minimum:
```rust
pub use iter::{
    mesh_iter_map, mesh_iter_map_next,
    mesh_iter_filter, mesh_iter_filter_next,
    mesh_iter_take, mesh_iter_take_next,
    mesh_iter_skip, mesh_iter_skip_next,
    mesh_iter_enumerate, mesh_iter_enumerate_next,
    mesh_iter_zip, mesh_iter_zip_next,
    mesh_iter_count, mesh_iter_sum, mesh_iter_any, mesh_iter_all, mesh_iter_find, mesh_iter_reduce,
    mesh_iter_generic_next,
};
```

**Step 5: Update intrinsics test** in intrinsics.rs to assert the new functions exist.
  </action>
  <verify>
`cargo build --workspace` compiles cleanly. `cargo test --workspace` passes. Verify that all 18+ new intrinsic declarations exist. Verify that adapter type names resolve to MirType::Ptr. Verify resolve_iterator_fn handles adapter types.
  </verify>
  <done>
All 18+ intrinsic declarations exist with correct LLVM signatures. Adapter types resolve to MirType::Ptr. resolve_iterator_fn maps adapter next calls. map_builtin_name maps all 12 iter methods. Full workspace builds and tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` -- full workspace compiles
2. `cargo test --workspace` -- all existing tests pass (zero regressions)
3. Type checker correctly infers types for `Iter.map(iter, fn)`, `Iter.count(iter)` etc.
4. MIR lowerer resolves `iter_map` -> `mesh_iter_map` for all 12 methods
5. Intrinsic declarations match runtime function signatures
</verification>

<success_criteria>
- All 12 Iter methods have type signatures in stdlib_modules
- All 12 iter_* names map to mesh_iter_* in map_builtin_name
- All runtime functions have LLVM extern declarations with matching parameter types
- Adapter types resolve to MirType::Ptr
- Full workspace builds with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/78-lazy-combinators-terminals/78-02-SUMMARY.md`
</output>
