---
phase: 96-compiler-additions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-common/src/token.rs
  - crates/mesh-lexer/src/lib.rs
  - crates/mesh-parser/src/syntax_kind.rs
  - crates/mesh-parser/src/parser/expressions.rs
  - crates/mesh-parser/src/ast/expr.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/mir/mod.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Developer can write :name, :email, :asc atom literals and they compile without errors"
    - "Atom literals have a distinct Atom type recognized by the type checker, separate from String"
    - "Atom literals compile to string constants at the LLVM level and can be printed/compared"
  artifacts:
    - path: "crates/mesh-common/src/token.rs"
      provides: "Atom variant in TokenKind enum"
      contains: "Atom"
    - path: "crates/mesh-lexer/src/lib.rs"
      provides: "Lexer rule for :identifier atom literals"
      contains: "TokenKind::Atom"
    - path: "crates/mesh-parser/src/syntax_kind.rs"
      provides: "ATOM_LITERAL SyntaxKind and mapping"
      contains: "ATOM_LITERAL"
    - path: "crates/mesh-parser/src/ast/expr.rs"
      provides: "AtomLiteral AST node and Expr::AtomLiteral variant"
      contains: "AtomLiteral"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Atom type inference returning Ty::Con(TyCon::new(\"Atom\"))"
      contains: "Atom"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Atom lowering to MirExpr::StringLit"
      contains: "AtomLiteral"
  key_links:
    - from: "crates/mesh-lexer/src/lib.rs"
      to: "crates/mesh-common/src/token.rs"
      via: "TokenKind::Atom variant used in lex_colon"
      pattern: "TokenKind::Atom"
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-parser/src/ast/expr.rs"
      via: "Expr::AtomLiteral match arm in infer_expr"
      pattern: "Expr::AtomLiteral"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/expr.rs"
      via: "Atom lowers to StringLit which codegen already handles"
      pattern: "StringLit"
---

<objective>
Add atom literal syntax (`:name`, `:email`, `:asc`) to the Mesh compiler, spanning lexer through codegen.

Purpose: Atoms provide a typed alternative to raw strings for field references in the ORM query builder. The distinct `Atom` type enables compile-time validation that field names are valid in later phases (e.g., `Query.where(:name, "Alice")` instead of `Query.where("name", "Alice")`).

Output: Working atom literals that lex, parse, type-check as `Atom` type, and compile to string constants at the LLVM level.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/096-compiler-additions/96-RESEARCH.md

@crates/mesh-common/src/token.rs
@crates/mesh-lexer/src/lib.rs
@crates/mesh-parser/src/syntax_kind.rs
@crates/mesh-parser/src/parser/expressions.rs
@crates/mesh-parser/src/ast/expr.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/mir/mod.rs
@crates/mesh-codegen/src/codegen/expr.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Atom token to lexer and parser infrastructure</name>
  <files>
    crates/mesh-common/src/token.rs
    crates/mesh-lexer/src/lib.rs
    crates/mesh-parser/src/syntax_kind.rs
    crates/mesh-parser/src/parser/expressions.rs
    crates/mesh-parser/src/ast/expr.rs
  </files>
  <action>
1. In `crates/mesh-common/src/token.rs`:
   - Add `Atom` variant to `TokenKind` enum in the Literals section (currently 7 literals, becomes 8). Add doc comment: `/// Atom literal, e.g. ':name', ':email', ':asc'.`
   - Update `token_kind_variant_count` test: change literals count from 7 to 8, total from 96 to 97.
   - Add `TokenKind::Atom` to the `keyword_from_str_recognizes_all_keywords` test is NOT needed (atoms are not keywords). But add `TokenKind::Atom` to the exhaustive lists if any exist.

2. In `crates/mesh-lexer/src/lib.rs`:
   - Modify `lex_colon` method. Currently it handles `:` -> Colon and `::` -> ColonColon. Add a third branch: after consuming the first `:`, if the next char is NOT `:` but IS `is_ident_start(c)` (lowercase letter or underscore), consume identifier chars with `eat_while(is_ident_continue)` and emit `TokenKind::Atom`. The check for `is_ident_start` must require a lowercase letter or underscore (NOT uppercase, to avoid conflict with `::Module` patterns). The atom token spans from the colon through the identifier end.
   - Ensure there is no whitespace between `:` and the identifier (the lexer already handles this naturally since it reads character-by-character).

3. In `crates/mesh-parser/src/syntax_kind.rs`:
   - Add `ATOM_LITERAL` to the Literals section (after `INTERPOLATION_END`).
   - Add mapping in `From<TokenKind> for SyntaxKind`: `TokenKind::Atom => SyntaxKind::ATOM_LITERAL`.
   - Update `all_token_kinds_convert_to_syntax_kind` test: add `TokenKind::Atom` to the list, update count assertion from 96 to 97.
   - Add `SyntaxKind::ATOM_LITERAL` to the composite node kinds test list in `syntax_kind_has_enough_variants` if appropriate (it's a leaf token, so it may not be needed there -- only add to composite test if ATOM_LITERAL is used as a composite node kind).

4. In `crates/mesh-parser/src/parser/expressions.rs`:
   - In the prefix expression parsing (the match on `current` SyntaxKind), add a case for `SyntaxKind::ATOM_LITERAL`. When encountered, create a marker, bump the token, and close as `SyntaxKind::ATOM_LITERAL` (similar to how `INT_LITERAL` or `FLOAT_LITERAL` are handled as LITERAL nodes). Wrap in an ATOM_LITERAL node kind. Alternatively, if atoms should be wrapped in a composite node for AST consistency, add an `ATOM_EXPR` composite node kind. Check how `LITERAL` wrapping works and follow the same pattern -- if literals get wrapped in a LITERAL composite node, atoms should get their own `ATOM_EXPR` composite node. Research decision: Use a dedicated `ATOM_EXPR` composite node for consistency. Add it to SyntaxKind enum.

5. In `crates/mesh-parser/src/ast/expr.rs`:
   - Add `ast_node!(AtomLiteral, ATOM_EXPR);` (or ATOM_LITERAL depending on step 4).
   - Implement accessor method: `pub fn atom_text(&self) -> Option<String>` that extracts the atom name by finding the ATOM_LITERAL token child and stripping the leading `:` from its text.
   - Add `AtomLiteral(AtomLiteral)` variant to the `Expr` enum.
   - Add `SyntaxKind::ATOM_EXPR => Some(Expr::AtomLiteral(AtomLiteral { syntax: node }))` to `Expr::cast()`.
   - Add `Expr::AtomLiteral(n) => &n.syntax` to `Expr::syntax()`.
  </action>
  <verify>
    `cargo test -p mesh-common` passes (token count test updated).
    `cargo test -p mesh-lexer` passes (atom tokens are lexed).
    `cargo test -p mesh-parser` passes (syntax kind tests updated, atom expressions parse).
    Run a quick manual verification: create a test source with `:name` and confirm the lexer emits an Atom token.
  </verify>
  <done>
    `:name` lexes as a single `Atom` token. The parser produces an `ATOM_EXPR` node. The AST provides `AtomLiteral` with `atom_text()` returning `"name"`. All crate tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Atom type checking, MIR lowering, LLVM codegen, and e2e test</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/mir/mod.rs
    crates/mesh-codegen/src/codegen/expr.rs
    crates/meshc/tests/e2e.rs
    crates/mesh-repl/src/jit.rs
  </files>
  <action>
1. In `crates/mesh-typeck/src/infer.rs`:
   - In the `infer_expr` function (the main expression type inference), add a match arm for `Expr::AtomLiteral(_atom)`. Return `Ty::Con(TyCon::new("Atom"))`. This gives atoms a distinct type from `String`. Do NOT add Atom to any trait implementations (no Display, no Eq, etc.) for now -- atoms are opaque typed values. They can be passed as function arguments where `Atom` type is expected.
   - Ensure atoms can be used in string interpolation or at minimum can be printed. If the existing `to_string` resolution for unknown types handles this, no extra work needed. If not, register a basic `Display` impl for Atom that delegates to the string value. Check how String's Display works and follow the same pattern if needed. Research note: atoms lower to StringLit at MIR level, so they're already strings at runtime. The type checker just needs to allow `Atom` in contexts where printing is expected.

2. In `crates/mesh-codegen/src/mir/lower.rs`:
   - In the `lower_expr` function, add a match arm for `Expr::AtomLiteral(atom)`. Extract the atom name via `atom.atom_text()`. Lower to `MirExpr::StringLit(atom_name, MirType::String)`. This is the key design decision: atoms ARE strings at runtime. Do NOT add a MirType::Atom variant -- use MirType::String. The Atom distinction exists only in the type checker.

3. In `crates/mesh-codegen/src/codegen/expr.rs`:
   - No changes needed. `MirExpr::StringLit` is already handled by codegen. Atoms compile to the same LLVM global string constants as regular strings.

4. In `crates/mesh-codegen/src/mir/mod.rs`:
   - No changes needed to MirExpr or MirType enums. Atoms use existing StringLit.

5. In `crates/mesh-repl/src/jit.rs`:
   - If any JIT symbol registrations are needed for atom support, add them. Likely no changes needed since atoms use existing string infrastructure.

6. In `crates/meshc/tests/e2e.rs`:
   - Add an e2e test `e2e_atom_literals` that compiles and runs a Mesh program using atom literals:
     ```
     let name = :name
     let email = :email
     IO.puts(":name atom works")
     ```
   - Verify the program compiles and runs without errors, printing the expected output.
   - Add a test `e2e_atom_type_distinct` that verifies atoms have a distinct type (if possible to test via error message -- e.g., passing an atom where a String is expected should produce a type error, or passing a string where Atom is expected should error).
  </action>
  <verify>
    `cargo test -p mesh-typeck` passes.
    `cargo test -p mesh-codegen` passes.
    `cargo test -p meshc --test e2e -- e2e_atom` passes.
    `cargo build` succeeds with no new warnings.
  </verify>
  <done>
    Atom literals type-check as `Atom` type, lower to string constants in MIR, compile to LLVM string globals, and execute correctly. E2e test confirms atoms work end-to-end. The `Atom` type is distinct from `String` in the type checker.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with no regressions
2. A Mesh program with `:name`, `:email`, `:asc` compiles and runs
3. Atoms have type `Atom` (not `String`) in type checker diagnostics
4. Existing programs (no atoms) compile identically -- zero regressions
</verification>

<success_criteria>
- `:name` lexes as single Atom token (not Colon + Ident)
- `::name` still lexes as ColonColon + Ident (no ambiguity)
- Atom literals infer as `Atom` type, distinct from `String`
- Atoms compile to string constants at LLVM level (verified by e2e test output)
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/096-compiler-additions/96-01-SUMMARY.md`
</output>
