---
phase: 96-compiler-additions
plan: 05
type: execute
wave: 5
depends_on: ["96-04"]
files_modified:
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-rt/src/iter.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Map.collect produces a Map with correct string key type when iterating over string-keyed tuples"
    - "from_row and from_json trait methods resolve correctly when called from a different module than the struct definition"
  artifacts:
    - path: "crates/mesh-rt/src/iter.rs"
      provides: "Fixed mesh_map_collect that sets string key_type on collected maps"
      contains: "mesh_map_ensure_string_keys"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Fixed Map.collect type inference for string key propagation"
      contains: "map_collect"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Fixed cross-module from_row/from_json resolution"
      contains: "FromRow__"
  key_links:
    - from: "crates/mesh-rt/src/iter.rs"
      to: "crates/mesh-rt/src/collections/map.rs"
      via: "mesh_map_collect calls mesh_map_ensure_string_keys or sets key_type after collection"
      pattern: "string_key"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/expr.rs"
      via: "Correct trait method names generated without double module qualification"
      pattern: "FromRow__from_row__"
---

<objective>
Fix two known compiler bugs: Map.collect string key propagation (COMP-07) and cross-module from_row/from_json resolution (COMP-08).

Purpose: Map.collect currently assumes integer keys, which breaks when collecting string-keyed tuples (e.g., from Map.to_list() |> ... |> Map.collect()). Cross-module from_row resolution fails when calling `User.from_row(row)` from a module different than where User is defined. Both bugs will cause failures in the ORM which heavily uses Map operations and cross-module struct hydration.

Output: Map.collect correctly handles string keys. from_row/from_json works across module boundaries.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/096-compiler-additions/96-RESEARCH.md
@.planning/phases/096-compiler-additions/96-04-SUMMARY.md

@crates/mesh-rt/src/iter.rs
@crates/mesh-rt/src/collections/map.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Map.collect string key type propagation</name>
  <files>
    crates/mesh-rt/src/iter.rs
    crates/mesh-rt/src/collections/map.rs
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
The bug: `mesh_map_collect` in `crates/mesh-rt/src/iter.rs` creates a new map via `mesh_map_new()` which defaults to integer key_type (0). When string-keyed tuples are inserted via `mesh_map_put`, the key_type remains 0 (integer), causing subsequent lookups with `mesh_map_get` to use integer comparison instead of string comparison. This makes the collected map unusable for string-key access.

Fix approach -- there are two parts:

1. **Runtime fix** in `crates/mesh-rt/src/iter.rs`:
   - The issue is that `mesh_map_collect` doesn't know whether keys are strings or integers at collection time. The runtime `mesh_map_put` function does NOT auto-detect key type.
   - Solution A: Add a `mesh_map_collect_string_keys` variant that creates the map with string key_type from the start. The codegen emits this variant when the type checker knows the key type is String.
   - Solution B: Modify `mesh_map_collect` to detect key type from the first element. If the first tuple's key is a string pointer (heuristic: check if it's a valid MeshString pointer), set key_type to 1.
   - Solution C: Look at how `mesh_map_ensure_string_keys` works in `crates/mesh-rt/src/collections/map.rs` (line ~107). This function already exists to ensure a map has string key_type. Call it on the result after collection.
   - **Recommended: Solution A** -- cleanest and most correct. Add `mesh_map_collect_string_keys` in iter.rs that calls `mesh_map_new()` then immediately sets `key_type = 1` before collecting elements. The codegen picks which collect function to call based on the type checker's knowledge of the Map's key type.

2. **Codegen fix** in `crates/mesh-codegen/src/mir/lower.rs`:
   - At the call site where `map_collect` is lowered (search for `"map_collect"` in lower.rs around line 10002), check the inferred key type of the Map being collected into.
   - If the key type resolves to `String`, emit a call to `mesh_map_collect_string_keys` instead of `mesh_map_collect`.
   - If the key type resolves to `Int` or is unknown, continue using `mesh_map_collect` (integer keys).

3. **Type checker** in `crates/mesh-typeck/src/infer.rs`:
   - Verify that `Map.collect` signature (around line 407-408) correctly propagates the key type variable. Currently: `Scheme { vars: vec![k_var, v_var], ty: Ty::fun(vec![Ty::Con(TyCon::new("Ptr"))], map_kv.clone()) }`. This allows the return type to be `Map<K, V>` where K can unify with String. The type checker side should already work -- the issue is purely at runtime. Verify this is the case; if the type checker is also losing the key type, fix the inference.

4. **Runtime implementation** in `crates/mesh-rt/src/iter.rs`:
   - Add `mesh_map_collect_string_keys`:
     ```rust
     #[no_mangle]
     pub extern "C" fn mesh_map_collect_string_keys(iter: *mut u8) -> *mut u8 {
         unsafe {
             let mut map = mesh_map_new();
             // Set key_type to string (1)
             let map_ref = map as *mut MeshMap;
             (*map_ref).key_type = KEY_TYPE_STRING;
             loop {
                 let option = mesh_iter_generic_next(iter);
                 let opt_ref = option as *mut MeshOption;
                 if (*opt_ref).tag == 1 { break; }
                 let tuple_ptr = (*opt_ref).value as *mut u8;
                 let key = *((tuple_ptr as *const u64).add(1));
                 let val = *((tuple_ptr as *const u64).add(2));
                 map = mesh_map_put(map, key, val);
             }
             map
         }
     }
     ```
   - Export it in `crates/mesh-rt/src/lib.rs`.
   - Register in `crates/mesh-codegen/src/codegen/intrinsics.rs`.
   - Register in `crates/mesh-repl/src/jit.rs`.

5. **E2e test** in `crates/meshc/tests/e2e.rs`:
   - Add `e2e_map_collect_string_keys` test:
     ```
     let m = %{"a" => 1, "b" => 2, "c" => 3}
     let pairs = Map.to_list(m)
     let collected = Map.collect(pairs.iter())
     IO.puts(Int.to_string(Map.get(collected, "a")))
     IO.puts(Int.to_string(Map.get(collected, "b")))
     ```
     Expected output: `1\n2`
     This test currently fails due to the bug -- the collected map has integer key_type so `Map.get(collected, "a")` doesn't find the key.
  </action>
  <verify>
    `cargo test -p mesh-rt` passes.
    `cargo test -p meshc --test e2e -- e2e_map_collect_string_keys` passes.
    Existing `e2e_map_collect` tests still pass.
  </verify>
  <done>
    `Map.collect` on string-keyed tuple iterators produces a Map with correct string key_type. `Map.get(collected_map, "key")` works correctly after collection. E2e test confirms string key roundtrip through collect.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix cross-module from_row and from_json resolution</name>
  <files>
    crates/mesh-codegen/src/mir/lower.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
The bug: When `User.from_row(row)` is called from a different module than where `User` is defined (e.g., calling from `Queries` module where User is defined in `Models` module), the MIR lowerer may generate an incorrect function name. The expected name is `FromRow__from_row__User` (unqualified, global trait method name). But the `qualify_name` function in lower.rs may prepend a module prefix, producing `Queries__FromRow__from_row__User` which doesn't exist.

Investigation and fix in `crates/mesh-codegen/src/mir/lower.rs`:

1. **Check `qualify_name` function** (around line 333):
   - It already has BUILTIN_PREFIXES that skip module qualification: `["mesh_", "Ord__", "Eq__", "Display__", "Debug__", "Hash__", "Default__", "Add__", "Sub__", "Mul__", "Div__", "Rem__", "Neg__"]`.
   - The bug is that `FromRow__` and `FromJson__` and `ToJson__` are NOT in this list. So `FromRow__from_row__User` gets qualified to `Module__FromRow__from_row__User`.
   - Fix: Add `"FromRow__"`, `"FromJson__"`, `"ToJson__"` to the `BUILTIN_PREFIXES` array.

2. **Also check for the future Schema trait** -- add `"Schema__"` to BUILTIN_PREFIXES preemptively so schema metadata functions are never module-prefixed. Actually, schema metadata uses `{StructName}____table__` convention, not `Schema__` prefix. Check if these need to be in BUILTIN_PREFIXES too. They should be treated as pub functions (registered in pub_functions) since they're callable cross-module.

3. **Verify from_json has the same fix** -- the same `qualify_name` applies. `FromJson__from_json__User` should also not be module-prefixed.

4. **E2e test** in `crates/meshc/tests/e2e.rs`:
   - Add `e2e_cross_module_from_row` test using a multi-file project:
     Create a test that defines a struct with `deriving(Row)` in one module and calls `StructName.from_row(row)` from another module. Use the `build_and_run_project` test helper if available, or create the appropriate fixture structure.
   - If multi-file e2e tests are complex to set up, add a simpler test that at minimum verifies `FromRow__from_row__` is in the BUILTIN_PREFIXES by checking that a struct with deriving(Row) used in a function context resolves correctly.
   - At minimum, verify the BUILTIN_PREFIXES change doesn't regress existing from_row tests.

5. **BUILTIN_PREFIXES update**:
   ```rust
   const BUILTIN_PREFIXES: &[&str] = &[
       "mesh_", "Ord__", "Eq__", "Display__", "Debug__", "Hash__",
       "Default__", "Add__", "Sub__", "Mul__", "Div__", "Rem__", "Neg__",
       "FromRow__", "FromJson__", "ToJson__",
   ];
   ```
  </action>
  <verify>
    `cargo test -p mesh-codegen` passes.
    `cargo test -p meshc --test e2e` passes (all existing e2e tests, no regressions).
    If a cross-module test was added, it passes.
  </verify>
  <done>
    `FromRow__`, `FromJson__`, and `ToJson__` prefixes are excluded from module name qualification. Cross-module `User.from_row(row)` resolves to the correct unqualified trait method name. No regressions in existing from_row/from_json tests.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with no regressions
2. Map.collect with string keys produces Map with string key_type
3. Map.get on collected string-key map returns correct values
4. from_row/from_json work when called from different module than struct definition
5. All existing Map, from_row, and from_json e2e tests pass unchanged
</verification>

<success_criteria>
- `Map.collect` on `Map.to_list(string_keyed_map).iter()` roundtrips correctly
- `Map.get(collected_map, "key")` finds string keys after collect
- `User.from_row(row)` works from any module, not just the defining module
- `BUILTIN_PREFIXES` includes `FromRow__`, `FromJson__`, `ToJson__`
- All 280+ existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/096-compiler-additions/96-05-SUMMARY.md`
</output>
