---
phase: 96-compiler-additions
plan: 03
type: execute
wave: 3
depends_on: ["96-02"]
files_modified:
  - crates/mesh-parser/src/syntax_kind.rs
  - crates/mesh-parser/src/parser/expressions.rs
  - crates/mesh-parser/src/ast/expr.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/mod.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/expr.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Developer can write %{user | name: \"Bob\"} to produce a new struct with the name field changed and all other fields copied"
    - "The type checker validates that override fields exist in the struct and have matching types"
    - "The struct update expression returns the same struct type as the base expression"
  artifacts:
    - path: "crates/mesh-parser/src/syntax_kind.rs"
      provides: "STRUCT_UPDATE_EXPR composite node kind"
      contains: "STRUCT_UPDATE_EXPR"
    - path: "crates/mesh-parser/src/ast/expr.rs"
      provides: "StructUpdate AST node with base and override fields accessors"
      contains: "StructUpdate"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Struct update type checking: base must be struct, overrides must be valid fields"
      contains: "StructUpdate"
    - path: "crates/mesh-codegen/src/mir/mod.rs"
      provides: "MirExpr::StructUpdate variant"
      contains: "StructUpdate"
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "LLVM codegen for struct update: alloc, copy base, overwrite fields"
      contains: "StructUpdate"
  key_links:
    - from: "crates/mesh-parser/src/parser/expressions.rs"
      to: "crates/mesh-parser/src/ast/expr.rs"
      via: "parse_map_literal disambiguates %{ident BAR ...} as STRUCT_UPDATE_EXPR"
      pattern: "STRUCT_UPDATE_EXPR"
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "Type checker validates struct fields, MIR lowers to StructUpdate"
      pattern: "StructUpdate"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/expr.rs"
      via: "MIR StructUpdate variant triggers codegen field copy+overwrite"
      pattern: "StructUpdate"
---

<objective>
Add struct update syntax (`%{user | name: "Bob"}`) to the Mesh compiler, spanning parser through LLVM codegen.

Purpose: Struct update expressions enable immutable data transformation -- creating a new struct with specific fields changed while copying all others. This is essential for ORM changesets where you modify specific fields of a record without mutating the original: `%{changeset | changes: new_changes}`.

Output: Working struct update expressions that parse, type-check (validating field existence and types), lower to MIR, and compile to efficient LLVM IR that allocates a new struct with overridden fields.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/096-compiler-additions/96-RESEARCH.md
@.planning/phases/096-compiler-additions/96-02-SUMMARY.md

@crates/mesh-parser/src/syntax_kind.rs
@crates/mesh-parser/src/parser/expressions.rs
@crates/mesh-parser/src/ast/expr.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/mod.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/codegen/expr.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parse struct update syntax with disambiguation from map literals</name>
  <files>
    crates/mesh-parser/src/syntax_kind.rs
    crates/mesh-parser/src/parser/expressions.rs
    crates/mesh-parser/src/ast/expr.rs
  </files>
  <action>
1. In `crates/mesh-parser/src/syntax_kind.rs`:
   - Add `STRUCT_UPDATE_EXPR` to the composite node kinds section (near STRUCT_LITERAL).
   - Update the `syntax_kind_has_enough_variants` test to include `SyntaxKind::STRUCT_UPDATE_EXPR` and adjust the count assertion.

2. In `crates/mesh-parser/src/parser/expressions.rs`:
   - Modify `parse_map_literal` function. Currently `%{` always starts a map literal with `key => value` entries. Add disambiguation:
     a. After consuming `%{`, if the first token sequence is `expr BAR` (an expression followed by the `|` bar token), this is a struct update expression, not a map literal.
     b. The disambiguation is: after `%{`, parse the first expression. If the token after that expression is `BAR` (the `|` token, SyntaxKind::BAR), switch to struct update parsing. If it's `FAT_ARROW` (`=>`), continue as map literal. If it's `COMMA` or `R_BRACE`, it's an error or edge case.
     c. For struct update parsing after seeing `BAR`: consume the BAR, then parse comma-separated `ident: expr` field overrides (same format as struct literal fields -- `STRUCT_LITERAL_FIELD` nodes with `name: value` syntax). These use `IDENT COLON expr` format (keyword-like syntax, NOT `=>` fat arrow).
     d. Consume closing `R_BRACE` (`}`).
     e. Close the node as `STRUCT_UPDATE_EXPR`.
   - Alternative simpler approach: In `parse_map_literal`, after `%{`, peek at the token stream. If the pattern is `IDENT BAR` (identifier followed by bar), start a struct update. If `IDENT FAT_ARROW` or `STRING FAT_ARROW`, start a map literal. This avoids needing to parse a full expression first.
   - Use the simpler approach if the base expression is always expected to be an identifier or a simple expression. Per research recommendation, allow any expression as the base, so the full-expression-then-check approach is better.

3. In `crates/mesh-parser/src/ast/expr.rs`:
   - Add `ast_node!(StructUpdate, STRUCT_UPDATE_EXPR);`
   - Implement accessors:
     - `pub fn base_expr(&self) -> Option<Expr>` -- the first child expression (the struct being updated)
     - `pub fn override_fields(&self) -> Vec<StructLiteralField>` -- reuse the existing StructLiteralField AST node for `name: value` pairs
   - Add `StructUpdate(StructUpdate)` variant to `Expr` enum.
   - Add the cast arm and syntax arm for `StructUpdate`.
  </action>
  <verify>
    `cargo test -p mesh-parser` passes.
    Manually verify parsing of `%{user | name: "Bob"}` produces a `STRUCT_UPDATE_EXPR` node with base `user` and one override field.
  </verify>
  <done>
    `%{expr | field: value, ...}` parses as `STRUCT_UPDATE_EXPR` with base expression and override fields. `%{key => value}` still parses as `MAP_LITERAL`. No ambiguity between the two forms.
  </done>
</task>

<task type="auto">
  <name>Task 2: Type check, MIR lower, and codegen struct update with e2e tests</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/mod.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/expr.rs
    crates/meshc/tests/e2e.rs
  </files>
  <action>
1. In `crates/mesh-typeck/src/infer.rs`:
   - In `infer_expr`, add a match arm for `Expr::StructUpdate(update)`:
     a. Infer the type of the base expression. It MUST resolve to a struct type (`Ty::Con(tycon)` where tycon names a registered struct). If not a struct, emit a type error.
     b. Look up the struct's field definitions from the TypeRegistry.
     c. For each override field in `update.override_fields()`:
        - Verify the field name exists in the struct. If not, emit "no such field" error.
        - Infer the type of the override value expression.
        - Unify the override value type with the struct's declared field type. If mismatch, emit type error.
     d. Return the same type as the base expression (the struct type). Struct update produces the same type -- it creates a new instance, not a different type.

2. In `crates/mesh-codegen/src/mir/mod.rs`:
   - Add a `StructUpdate` variant to `MirExpr`:
     ```rust
     StructUpdate {
         base: Box<MirExpr>,
         overrides: Vec<(String, MirExpr)>,
         ty: MirType,
     },
     ```
   - Add the `ty()` accessor for this variant in the `ty()` method.

3. In `crates/mesh-codegen/src/mir/lower.rs`:
   - In `lower_expr`, add a match arm for `Expr::StructUpdate(update)`:
     a. Lower the base expression.
     b. Lower each override field expression.
     c. Produce `MirExpr::StructUpdate { base, overrides, ty }` where ty is the struct MirType.

4. In `crates/mesh-codegen/src/codegen/expr.rs`:
   - In `codegen_expr`, add a match arm for `MirExpr::StructUpdate { base, overrides, ty }`:
     a. Codegen the base expression to get the base struct pointer.
     b. Look up the struct's field layout from `self.struct_types` (same as `codegen_struct_lit`).
     c. Allocate a new struct on the GC heap (same allocation pattern as struct literal).
     d. For each field in the struct definition:
        - If the field is in the `overrides` map: codegen the override value and store it.
        - If the field is NOT in overrides: load the value from the base struct pointer (using GEP with the field's index) and store it in the new struct.
     e. Return the pointer to the new struct.
   - Follow the existing `codegen_struct_lit` pattern closely for allocation and field storage. The difference is that some fields come from override expressions and others from loading the base struct.

5. In `crates/meshc/tests/e2e.rs`:
   - Add `e2e_struct_update_basic` test:
     ```
     struct User do
       name :: String
       email :: String
       age :: Int
     end

     let user = User { name: "Alice", email: "alice@example.com", age: 30 }
     let updated = %{user | name: "Bob", age: 25}
     IO.puts(updated.name)
     IO.puts(updated.email)
     IO.puts(Int.to_string(updated.age))
     ```
     Expected output: `Bob\nalice@example.com\n25`

   - Add `e2e_struct_update_single_field` test updating only one field:
     ```
     struct Point do
       x :: Int
       y :: Int
     end

     let p = Point { x: 1, y: 2 }
     let p2 = %{p | x: 10}
     IO.puts(Int.to_string(p2.x))
     IO.puts(Int.to_string(p2.y))
     ```
     Expected output: `10\n2`

   - Add `e2e_struct_update_original_unchanged` test verifying immutability:
     ```
     struct Config do
       host :: String
       port :: Int
     end

     let c1 = Config { host: "localhost", port: 8080 }
     let c2 = %{c1 | port: 9090}
     IO.puts(c1.host)
     IO.puts(Int.to_string(c1.port))
     IO.puts(c2.host)
     IO.puts(Int.to_string(c2.port))
     ```
     Expected output: `localhost\n8080\nlocalhost\n9090`
  </action>
  <verify>
    `cargo test -p mesh-typeck` passes.
    `cargo test -p mesh-codegen` passes.
    `cargo test -p meshc --test e2e -- e2e_struct_update` passes.
    `cargo build` succeeds with no new warnings.
  </verify>
  <done>
    `%{user | name: "Bob"}` type-checks (validates field exists, type matches), lowers to MIR StructUpdate, compiles to LLVM IR that allocates new struct and copies/overwrites fields. Original struct is unchanged (immutable). E2e tests confirm all behaviors.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with no regressions
2. `%{user | name: "Bob"}` compiles and produces new struct with updated field
3. Original struct is unmodified after update expression
4. Type errors emitted for: non-struct base, non-existent field, wrong field type
5. Map literals `%{key => value}` still work -- no disambiguation regressions
</verification>

<success_criteria>
- `%{struct | field: value}` parses as STRUCT_UPDATE_EXPR (not MAP_LITERAL)
- `%{key => value}` still parses as MAP_LITERAL
- Type checker validates field existence and type compatibility
- Codegen produces new struct with base fields copied and overrides applied
- Original struct unchanged (immutability verified by e2e test)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/096-compiler-additions/96-03-SUMMARY.md`
</output>
