---
phase: 105-verify-mesher-runtime
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mesher/mesher
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-rt/src/db/pg.rs
  - crates/mesh-rt/src/db/pool.rs
autonomous: false
user_setup:
  - service: postgresql
    why: "Mesher connects to PostgreSQL for all data persistence"
    env_vars:
      - name: DATABASE_URL
        source: "Local PostgreSQL instance -- postgres://mesh:mesh@localhost:5432/mesher"
    dashboard_config:
      - task: "Create database 'mesher' and role 'mesh' with password 'mesh'"
        location: "psql or pgAdmin"

must_haves:
  truths:
    - "Mesher binary starts without segfault or panic and prints startup messages"
    - "Mesher connects to PostgreSQL and creates partitions successfully"
    - "Database schema is created via meshc migrate up"
    - "OrgService, ProjectService, and UserService start without crash"
    - "HTTP server binds to port 8080 and WebSocket server binds to port 8081"
  artifacts:
    - path: "mesher/mesher"
      provides: "Compiled Mesher binary"
  key_links:
    - from: "mesher/main.mpl"
      to: "PostgreSQL"
      via: "Pool.open with connection string"
      pattern: "Pool\\.open"
    - from: "mesher/main.mpl"
      to: "Storage.Schema"
      via: "create_partitions_ahead"
      pattern: "create_partitions_ahead"
---

<objective>
Start the Mesher binary against a PostgreSQL database and verify it boots cleanly through all startup phases: database connection, migration, partition creation, service actor startup, and HTTP/WS server binding.

Purpose: Validate that the compiled Mesher binary (from Phase 104) executes without runtime crashes, correctly connects to PostgreSQL, and reaches a fully operational state. This is the first step of runtime verification -- if the binary cannot start, no endpoint testing is possible.

Output: Running Mesher process with all services initialized, ready for endpoint testing in Plan 02.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/104-fix-mesher-compilation-errors/104-01-SUMMARY.md

# Key source files for understanding startup sequence
@mesher/main.mpl
@mesher/storage/schema.mpl
@mesher/storage/queries.mpl
@mesher/migrations/20260216120000_create_initial_schema.mpl
@mesher/services/org.mpl
@mesher/services/project.mpl
@mesher/services/user.mpl
@mesher/ingestion/ws_handler.mpl

# Compiler/runtime source for fixing runtime issues
@crates/mesh-rt/src/lib.rs
@crates/mesh-rt/src/db/pg.rs
@crates/mesh-rt/src/db/pool.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up PostgreSQL database and run Mesher migration</name>
  <files>mesher/migrations/20260216120000_create_initial_schema.mpl</files>
  <action>
Set up the PostgreSQL environment for Mesher and apply the initial schema migration.

**Step 1: Verify PostgreSQL is running**
Check that PostgreSQL is accessible on localhost:5432. If not, start it (macOS: `brew services start postgresql` or equivalent).

**Step 2: Create database and role**
Use `psql` to create the Mesher database and role if they don't exist:
```sql
CREATE ROLE mesh WITH LOGIN PASSWORD 'mesh';
CREATE DATABASE mesher OWNER mesh;
GRANT ALL PRIVILEGES ON DATABASE mesher TO mesh;
```
Also ensure the `mesh` role can create extensions by granting the necessary privileges:
```sql
-- Connect to mesher database first
\c mesher
GRANT ALL ON SCHEMA public TO mesh;
```

**Step 3: Run migrations**
```bash
cd mesher && DATABASE_URL="postgres://mesh:mesh@localhost:5432/mesher" cargo run --release -- migrate up
```
This will compile and execute the initial schema migration that creates all 10 tables (organizations, users, org_memberships, sessions, projects, api_keys, issues, events, alert_rules, alerts) plus indexes and the pgcrypto extension.

**Step 4: Verify schema**
Connect with psql and verify tables exist:
```bash
psql -U mesh -d mesher -c "\dt"
```
Should show all 10 tables plus the `_mesh_migrations` tracking table.

**If migration fails:**
- Check if `pgcrypto` extension is available (may need `CREATE EXTENSION IF NOT EXISTS pgcrypto` as superuser first)
- Check if `gen_random_bytes` function is available (depends on pgcrypto)
- Fix any SQL errors in the migration or compiler codegen issues
  </action>
  <verify>
- `psql -U mesh -d mesher -c "\dt"` shows 11 tables (10 data tables + _mesh_migrations)
- `psql -U mesh -d mesher -c "SELECT * FROM _mesh_migrations"` shows one row for version 20260216120000
  </verify>
  <done>
Database "mesher" exists with all required tables, indexes, and extensions. Migration tracking shows the initial schema migration as applied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Start Mesher binary and verify full startup sequence</name>
  <files>mesher/mesher, crates/mesh-rt/src/lib.rs, crates/mesh-rt/src/db/pg.rs, crates/mesh-rt/src/db/pool.rs, crates/mesh-codegen/src/mir/lower.rs, crates/mesh-typeck/src/infer.rs</files>
  <action>
Start the compiled Mesher binary and verify it completes the full startup sequence without crashes.

**Step 1: Rebuild Mesher to ensure fresh binary**
```bash
cd /Users/sn0w/Documents/dev/snow && cargo run --release -- build mesher
```

**Step 2: Start the Mesher binary**
```bash
cd /Users/sn0w/Documents/dev/snow/mesher && ./mesher
```

The expected startup sequence (from main.mpl) is:
1. `[Mesher] Connecting to PostgreSQL...` -- Pool.open connecting to postgres://mesh:mesh@localhost:5432/mesher
2. `[Mesher] Partitions created (7 days ahead)` -- create_partitions_ahead(pool, 7)
3. `[Mesher] Running in standalone mode (no distribution)` -- No MESHER_NODE_NAME env var
4. `[Mesher] OrgService started` -- OrgService.start(pool)
5. `[Mesher] ProjectService started` -- ProjectService.start(pool)
6. `[Mesher] UserService started` -- UserService.start(pool)
7. `[Mesher] Foundation ready` -- Pipeline started
8. `[Mesher] WebSocket server starting on :8081` -- Ws.serve binding
9. `[Mesher] HTTP server starting on :8080` -- HTTP.serve binding (blocks)

**Step 3: Diagnose and fix any crashes**
If the binary crashes at ANY point in the startup sequence, diagnose the issue:

- **Segfault on startup**: Likely LLVM codegen issue. Check the last printed message to identify which function crashed. Common causes: incorrect struct field offset calculation, wrong function pointer in service dispatch, or GC issue with pool handles.

- **"Failed to connect to PostgreSQL"**: Check connection string, PostgreSQL is running, and the `mesh` role has access.

- **Panic in partition creation**: The `create_partitions_loop` function does recursive calls and uses `?` operator. Check if `Repo.query_raw` is correctly wired in the runtime for the date formatting query.

- **Service start crash**: Services use the `service` macro which desugars to actor spawn + GenServer loop. Check if the runtime's service dispatch is correctly handling the init function return value.

- **HTTP/WS bind failure**: Port already in use. Kill existing processes on 8080/8081.

**Fixing runtime issues:**
If crashes are found, they'll likely be in the Rust runtime (`crates/mesh-rt/`) or the compiler's codegen (`crates/mesh-codegen/`). Common patterns to fix:

1. **Type mismatch in runtime function signatures**: The compiled Mesh code calls extern "C" functions in mesh-rt. If the typeck signature doesn't match the runtime function's actual parameter/return types, you get segfaults. Check `snow_repo_*` functions in the runtime match what the typeck expects.

2. **Missing runtime functions**: If the MIR lowerer emits calls to functions that don't exist in mesh-rt, you get link errors or segfaults. Check `snow_*` extern functions are exported correctly.

3. **GC interaction issues**: Pool handles are opaque u64 values that must not be traced by GC. If a codegen change accidentally treats them as pointers, GC will corrupt them.

After fixing, rebuild with `cargo build --release` and re-run the Mesher binary. Iterate until full startup succeeds.
  </action>
  <verify>
- Mesher binary prints all startup messages through "[Mesher] HTTP server starting on :8080"
- No segfault, no panic, no error messages
- Process remains running (HTTP.serve blocks the main actor)
- `curl -s http://localhost:8080/api/v1/orgs/00000000-0000-0000-0000-000000000000/members 2>/dev/null` returns a response (even if error, proves HTTP server is listening)
- `echo -n "" | nc -w 1 localhost 8081` connects without error (proves WS server is listening)
  </verify>
  <done>
Mesher binary starts cleanly, connects to PostgreSQL, creates partitions, starts all 3 services, and binds HTTP (8080) and WebSocket (8081) servers without any runtime crashes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify Mesher is running</name>
  <files>mesher/mesher</files>
  <action>
Human verification checkpoint. Verify the Mesher binary started correctly and is serving requests.
  </action>
  <verify>
1. Check that Mesher printed all startup messages:
   - "[Mesher] Connecting to PostgreSQL..."
   - "[Mesher] Partitions created (7 days ahead)"
   - "[Mesher] OrgService started"
   - "[Mesher] ProjectService started"
   - "[Mesher] UserService started"
   - "[Mesher] Foundation ready"
   - "[Mesher] WebSocket server starting on :8081"
   - "[Mesher] HTTP server starting on :8080"
2. Verify HTTP is responding: `curl -s http://localhost:8080/`
3. Verify WS port is open: `nc -z localhost 8081`
  </verify>
  <done>Mesher is running with all services started, HTTP on 8080, WebSocket on 8081. Type "approved" to continue to Plan 02 (endpoint testing), or describe any issues.</done>
</task>

</tasks>

<verification>
- Mesher binary starts and runs without crashing
- PostgreSQL connection established via Pool.open
- All 10 database tables exist with correct schema
- Partition creation succeeds for 7 days ahead
- Three service actors (OrgService, ProjectService, UserService) start
- HTTP server bound to port 8080
- WebSocket server bound to port 8081
</verification>

<success_criteria>
VER-01 is satisfied: Mesher binary starts without runtime crashes and successfully connects to a PostgreSQL database (prints connection confirmation and serves first request).
</success_criteria>

<output>
After completion, create `.planning/phases/105-verify-mesher-runtime/105-01-SUMMARY.md`
</output>
