---
phase: 105-verify-mesher-runtime
plan: 02
type: execute
wave: 2
depends_on: ["105-01"]
files_modified:
  - mesher/storage/queries.mpl
  - mesher/services/org.mpl
  - mesher/services/project.mpl
  - mesher/services/user.mpl
  - mesher/api/team.mpl
  - mesher/api/search.mpl
  - mesher/api/dashboard.mpl
  - mesher/api/detail.mpl
  - mesher/api/alerts.mpl
  - mesher/api/settings.mpl
  - mesher/ingestion/routes.mpl
  - mesher/ingestion/ws_handler.mpl
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-rt/src/db/pg.rs
  - crates/mesh-rt/src/db/pool.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-typeck/src/infer.rs
autonomous: false
user_setup: []

must_haves:
  truths:
    - "HTTP POST to create organization returns 200/201 with ID"
    - "HTTP POST to create project returns 200/201 with ID"
    - "HTTP GET to list organizations returns JSON array"
    - "HTTP GET to list projects returns JSON array"
    - "HTTP POST to create user returns 200/201 with ID"
    - "WebSocket connection to port 8081 completes upgrade handshake"
    - "Data persists to PostgreSQL after POST operations"
  artifacts:
    - path: "mesher/mesher"
      provides: "Working Mesher binary with verified endpoints"
  key_links:
    - from: "HTTP POST /api/v1/events"
      to: "Storage.Queries.upsert_issue"
      via: "EventProcessor -> StorageWriter -> queries"
      pattern: "upsert_issue"
    - from: "HTTP GET /api/v1/orgs/:org_id/members"
      to: "Storage.Queries.get_members_with_users"
      via: "Api.Team handler -> queries"
      pattern: "get_members_with_users"
    - from: "WebSocket /ingest"
      to: "EventProcessor.process_event"
      via: "ws_on_message -> handle_ingest_message"
      pattern: "process_event"
---

<objective>
Test all Mesher HTTP API endpoints (GET and POST) and WebSocket connectivity end-to-end against the running Mesher instance from Plan 01.

Purpose: Verify that the ORM rewrite (phases 96-103) preserved correct runtime behavior for all endpoints. This completes VER-02 (HTTP endpoints) and VER-03 (WebSocket endpoints) from the v10.1 requirements.

Output: All endpoints verified working, or runtime issues identified and fixed.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/105-verify-mesher-runtime/105-01-SUMMARY.md

# HTTP endpoint handlers
@mesher/main.mpl
@mesher/api/team.mpl
@mesher/api/search.mpl
@mesher/api/dashboard.mpl
@mesher/api/detail.mpl
@mesher/api/alerts.mpl
@mesher/api/settings.mpl
@mesher/ingestion/routes.mpl
@mesher/ingestion/ws_handler.mpl

# Service actors
@mesher/services/org.mpl
@mesher/services/project.mpl
@mesher/services/user.mpl

# Query layer
@mesher/storage/queries.mpl

# Compiler/runtime for fixing issues
@crates/mesh-rt/src/lib.rs
@crates/mesh-rt/src/db/pg.rs
@crates/mesh-rt/src/db/pool.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test HTTP POST and GET endpoints for core CRUD operations</name>
  <files>mesher/storage/queries.mpl, mesher/services/org.mpl, mesher/services/project.mpl, mesher/services/user.mpl, mesher/api/team.mpl, crates/mesh-rt/src/lib.rs, crates/mesh-rt/src/db/pg.rs, crates/mesh-codegen/src/mir/lower.rs</files>
  <action>
With Mesher running from Plan 01, systematically test the core CRUD endpoints. The Mesher HTTP API does NOT have direct CRUD REST endpoints for orgs/projects/users -- those are managed through the service actors internally. The exposed HTTP endpoints are for team management, API keys, search, dashboard, event ingestion, alerts, and settings.

**The testing strategy is to exercise representative endpoints from each API module.**

**Test Group A: Team Management (Api.Team module)**

1. First, we need seed data. Use psql to insert directly since there are no HTTP endpoints for creating orgs/users:
```bash
# Create an org
psql -U mesh -d mesher -c "INSERT INTO organizations (id, name, slug) VALUES ('11111111-1111-1111-1111-111111111111', 'Test Org', 'test-org') ON CONFLICT DO NOTHING"

# Create a user
psql -U mesh -d mesher -c "INSERT INTO users (id, email, password_hash, display_name) VALUES ('22222222-2222-2222-2222-222222222222', 'test@example.com', crypt('password123', gen_salt('bf', 12)), 'Test User') ON CONFLICT DO NOTHING"

# Create a project under the org
psql -U mesh -d mesher -c "INSERT INTO projects (id, org_id, name, platform) VALUES ('33333333-3333-3333-3333-333333333333', '11111111-1111-1111-1111-111111111111', 'Test Project', 'javascript') ON CONFLICT DO NOTHING"
```

2. Test POST add member to org:
```bash
curl -s -X POST http://localhost:8080/api/v1/orgs/11111111-1111-1111-1111-111111111111/members \
  -H "Content-Type: application/json" \
  -d '{"user_id":"22222222-2222-2222-2222-222222222222","role":"admin"}'
```
Expected: `{"id":"<uuid>"}` with status 201

3. Test GET list members:
```bash
curl -s http://localhost:8080/api/v1/orgs/11111111-1111-1111-1111-111111111111/members
```
Expected: JSON array with one member object containing email, display_name, role

**Test Group B: API Keys (Api.Team module)**

4. Test POST create API key:
```bash
curl -s -X POST http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/api-keys \
  -H "Content-Type: application/json" \
  -d '{"label":"test-key"}'
```
Expected: `{"key_value":"mshr_..."}` with status 201

5. Test GET list API keys:
```bash
curl -s http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/api-keys
```
Expected: JSON array with one key object

**Test Group C: Dashboard (Api.Dashboard module)**

6. Test GET project health:
```bash
curl -s http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/dashboard/health
```
Expected: JSON with unresolved_count, events_24h, new_today (all "0")

7. Test GET event volume:
```bash
curl -s "http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/dashboard/volume?bucket=hour"
```
Expected: JSON array (empty if no events yet, that's OK)

**Test Group D: Settings (Api.Settings module)**

8. Test GET project settings:
```bash
curl -s http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/settings
```
Expected: JSON with retention_days and sample_rate

9. Test POST update settings:
```bash
curl -s -X POST http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/settings \
  -H "Content-Type: application/json" \
  -d '{"retention_days":30}'
```
Expected: 200 response

**Test Group E: Search (Api.Search module)**

10. Test GET search issues (empty result is fine):
```bash
curl -s "http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/issues"
```
Expected: JSON array (empty `[]` is correct for no issues)

**Diagnosing and fixing failures:**
- If an endpoint returns no response or the connection resets, the actor handling the request crashed. Check the Mesher console for panic messages.
- If an endpoint returns `{"error":"..."}`, the query layer had an issue. Check the SQL query and the Repo/Pool runtime functions.
- If the Mesher process itself crashes (exits), a fatal runtime error occurred. Diagnose via the last console output, fix in mesh-rt or mesh-codegen, rebuild, and restart.

**Important runtime-level bugs to watch for:**
1. **Service call/cast dispatch**: The `service` macro generates GenServer-style receive loops. If the message pattern matching is wrong, calls will timeout or crash.
2. **PipelineRegistry lookup**: Many handlers call `get_registry()` which does `Process.whereis("mesher_registry")`. If the pipeline didn't register correctly, this returns 0 (null PID) and subsequent calls crash.
3. **Query parameter binding**: Repo.query_raw and Repo.execute_raw pass parameters as `List<String>`. If the runtime function expects a different format, queries will fail.
4. **Result unwrapping in handlers**: Many handlers use `case result do Ok(x) -> ... Err(e) -> ...`. If the compiled pattern matching has codegen issues with Result types, the handler will crash.

After fixing any issues, rebuild with `cargo build --release && cargo run --release -- build mesher`, restart Mesher, and re-run the failing tests.
  </action>
  <verify>
At minimum these must succeed (non-crash responses with valid JSON):
- `curl -s -X POST http://localhost:8080/api/v1/orgs/.../members -d '{...}'` returns JSON with id or error
- `curl -s http://localhost:8080/api/v1/orgs/.../members` returns JSON array
- `curl -s http://localhost:8080/api/v1/projects/.../api-keys` returns JSON array
- `curl -s http://localhost:8080/api/v1/projects/.../dashboard/health` returns JSON object
- `curl -s http://localhost:8080/api/v1/projects/.../settings` returns JSON object
- `curl -s http://localhost:8080/api/v1/projects/.../issues` returns JSON array
- Mesher process did not crash during any of the above tests
  </verify>
  <done>
Representative HTTP endpoints from all major API modules (team, API keys, dashboard, settings, search) return valid JSON responses. POST operations persist data. GET operations retrieve it. No runtime crashes during testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test WebSocket connectivity and event ingestion endpoint</name>
  <files>mesher/ingestion/ws_handler.mpl, mesher/ingestion/routes.mpl, crates/mesh-rt/src/lib.rs, crates/mesh-codegen/src/mir/lower.rs</files>
  <action>
Test the WebSocket server and the HTTP event ingestion endpoint.

**Step 1: Test WebSocket handshake**
Use websocat, wscat, or a manual curl-based WebSocket upgrade to verify the WS server on port 8081 accepts connections:

```bash
# If websocat is available:
echo '{"test":"hello"}' | websocat --no-close -1 ws://localhost:8081/ingest -H "x-sentry-auth: test"
# Expected: {"error":"..."} or {"status":"accepted"} (depends on auth validation)

# Or test with curl upgrade request:
curl -s -i \
  -H "Connection: Upgrade" \
  -H "Upgrade: websocket" \
  -H "Sec-WebSocket-Version: 13" \
  -H "Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==" \
  http://localhost:8081/ingest
# Expected: HTTP/1.1 101 Switching Protocols with Sec-WebSocket-Accept header
```

**Step 2: Test the stream subscription path**
```bash
# If websocat is available:
echo '' | websocat --no-close -1 ws://localhost:8081/stream/projects/33333333-3333-3333-3333-333333333333
# Expected: connection accepted (may hang waiting for events, that's correct)
```

**Step 3: Test HTTP event ingestion endpoint**
First, create an API key for authentication:
```bash
# Get API key from the key created in Task 1, or create via psql:
psql -U mesh -d mesher -c "INSERT INTO api_keys (project_id, key_value, label) VALUES ('33333333-3333-3333-3333-333333333333', 'mshr_testkey123', 'test') ON CONFLICT DO NOTHING"
```

Then test POST /api/v1/events:
```bash
curl -s -X POST http://localhost:8080/api/v1/events \
  -H "Content-Type: application/json" \
  -H "x-sentry-auth: Sentry sentry_key=mshr_testkey123" \
  -d '{"message":"Test error","level":"error","platform":"javascript"}'
```
Expected: `{"status":"accepted"}` with 202 status, or an error message (not a crash).

**Step 4: Verify event was persisted**
```bash
psql -U mesh -d mesher -c "SELECT id, message, level FROM events LIMIT 5"
```
If the event was processed correctly, it should appear in the events table.

**Step 5: Test event search after ingestion**
```bash
curl -s "http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/issues"
```
If ingestion succeeded, there should now be at least one issue.

**Diagnosing WebSocket issues:**
- If the WS handshake fails, check if the runtime's Ws.serve correctly implements RFC 6455 handshake on port 8081.
- If connection is rejected (0 returned from on_connect), check the auth header validation in ws_handler.mpl.
- If connection drops immediately after handshake, the actor crashed during ws_on_connect processing.

**Diagnosing event ingestion issues:**
- The ingestion flow is: HTTP handler -> authenticate_request (checks API key) -> RateLimiter.check_limit -> EventProcessor.process_event -> StorageWriter -> SQL queries.
- Each step involves service actor calls. If any service actor hasn't started or the PipelineRegistry lookup fails, the chain breaks.
- Check the Mesher console for any error output after sending the event.

After fixing any issues, rebuild and restart as in Task 1.
  </action>
  <verify>
- WebSocket connection to ws://localhost:8081/ingest completes the HTTP 101 upgrade
- HTTP POST /api/v1/events returns a JSON response (202 accepted or structured error)
- Mesher process remains running after all WebSocket and HTTP tests
- No segfaults or panics observed during testing
  </verify>
  <done>
WebSocket server accepts connections and completes upgrade handshake. HTTP event ingestion endpoint accepts requests. Mesher process stable throughout all testing.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify all endpoints and runtime stability</name>
  <files>mesher/mesher</files>
  <action>
Human verification checkpoint. Confirm all endpoints are working and Mesher is stable.
  </action>
  <verify>
1. Confirm Mesher is still running (no crashes during testing)
2. Test a GET endpoint: `curl -s http://localhost:8080/api/v1/projects/33333333-3333-3333-3333-333333333333/dashboard/health`
3. Test a POST endpoint: `curl -s -X POST http://localhost:8080/api/v1/orgs/11111111-1111-1111-1111-111111111111/members -H "Content-Type: application/json" -d '{"user_id":"22222222-2222-2222-2222-222222222222","role":"member"}'`
4. Test WebSocket: `nc -z localhost 8081` (should connect)
5. Check database has data: `psql -U mesh -d mesher -c "SELECT count(*) FROM organizations"`
  </verify>
  <done>All HTTP and WebSocket endpoints verified working. Mesher process stable. Type "approved" if all endpoints work, or describe issues found.</done>
</task>

</tasks>

<verification>
- HTTP GET endpoints return valid JSON responses with correct structure
- HTTP POST endpoints accept JSON payloads and return success responses
- POST operations persist data to PostgreSQL (verifiable via psql)
- WebSocket endpoint accepts connections and completes upgrade handshake
- Event ingestion (POST /api/v1/events) processes events through the full pipeline
- Mesher process remains stable throughout all testing (no crashes)
</verification>

<success_criteria>
VER-02 satisfied: HTTP GET endpoints return valid JSON responses with correct status codes. HTTP POST endpoints accept JSON payloads and persist data to the database.
VER-03 satisfied: WebSocket endpoint accepts connections, completes the upgrade handshake, and responds to messages.
</success_criteria>

<output>
After completion, create `.planning/phases/105-verify-mesher-runtime/105-02-SUMMARY.md`
</output>
