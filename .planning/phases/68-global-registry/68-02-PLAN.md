---
phase: 68-global-registry
plan: 02
type: execute
wave: 2
depends_on: ["68-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/codegen/expr.rs
autonomous: true

must_haves:
  truths:
    - "Snow source code `Global.register(name, pid)` type-checks and compiles to snow_global_register call"
    - "Snow source code `Global.whereis(name)` type-checks and compiles to snow_global_whereis call"
    - "Snow source code `Global.unregister(name)` type-checks and compiles to snow_global_unregister call"
    - "String arguments are unpacked to (ptr, len) pairs at codegen using the existing codegen_unpack_string pattern"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Global module type signatures in stdlib_modules()"
      contains: "Global"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Global in STDLIB_MODULES, map_builtin_name entries for global_register/whereis/unregister"
      contains: "\"Global\""
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for snow_global_register, snow_global_whereis, snow_global_unregister"
      contains: "snow_global_register"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "Codegen for Global.* calls with string argument unpacking"
      contains: "snow_global_register"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Type checker validates Global.* calls; MIR lowering converts to global_register/whereis/unregister"
      pattern: "\"Global\".*global_register"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/expr.rs"
      via: "map_builtin_name maps global_register -> snow_global_register; codegen emits LLVM call"
      pattern: "snow_global_register"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/intrinsics.rs"
      via: "codegen looks up intrinsic declaration by name to emit the call"
      pattern: "get_intrinsic.*snow_global"
---

<objective>
Add the "Global" module to the Snow compiler so that `Global.register(name, pid)`, `Global.whereis(name)`, and `Global.unregister(name)` compile from Snow source to LLVM IR calling the runtime extern "C" functions from Plan 01.

Purpose: Without compiler integration, users cannot call the global registry from Snow source code. This plan connects the language surface to the runtime, following the exact same pattern used for Node, Process, Timer, and other stdlib modules.

Output: Four compiler crate files modified. Snow programs using `Global.*` type-check, lower to MIR, and compile to correct LLVM IR.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/68-global-registry/68-RESEARCH.md
@.planning/phases/68-global-registry/68-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs (build_module_types, Node/Process module patterns)
@crates/snow-codegen/src/mir/lower.rs (STDLIB_MODULES, map_builtin_name, lower_field_access)
@crates/snow-codegen/src/codegen/intrinsics.rs (declare_intrinsics pattern)
@crates/snow-codegen/src/codegen/expr.rs (codegen_node_string_call, codegen_unpack_string patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Global module to type checker and MIR lowering</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
1. **Type checker** (`infer.rs`): In `build_module_types` (or `stdlib_modules` -- find where Node/Process modules are defined, around line 762+), add a Global module with three function type signatures:

   ```rust
   // Global module (Phase 68)
   let mut global_mod = HashMap::new();
   // Global.register: fn(String, Int) -> Int  (name, pid -> 0 success, 1 error)
   global_mod.insert("register".to_string(), Scheme::mono(Ty::fun(
       vec![Ty::string(), Ty::int()],
       Ty::int(),
   )));
   // Global.whereis: fn(String) -> Int  (name -> pid raw u64, 0 if not found)
   global_mod.insert("whereis".to_string(), Scheme::mono(Ty::fun(
       vec![Ty::string()],
       Ty::int(),
   )));
   // Global.unregister: fn(String) -> Int  (name -> 0 success, 1 not found)
   global_mod.insert("unregister".to_string(), Scheme::mono(Ty::fun(
       vec![Ty::string()],
       Ty::int(),
   )));
   modules.insert("Global".to_string(), global_mod);
   ```

   Also add `"Global"` to `STDLIB_MODULE_NAMES` (the constant that the type checker uses to recognize module names).

2. **MIR lowering** (`lower.rs`):
   - Add `"Global"` to the `STDLIB_MODULES` constant (line 9274).
   - In `map_builtin_name`, add mappings:
     - `"global_register"` -> `"snow_global_register"`
     - `"global_whereis"` -> `"snow_global_whereis"`
     - `"global_unregister"` -> `"snow_global_unregister"`

   The existing `lower_field_access` mechanism will automatically convert `Global.register(...)` to a call to `global_register(...)`, and then `map_builtin_name` maps that to `snow_global_register`.
  </action>
  <verify>
`cargo build -p snow-typeck -p snow-codegen` compiles. Verify the map_builtin_name entries by searching the file for "snow_global".
  </verify>
  <done>
Global module type signatures exist in the type checker. "Global" is in STDLIB_MODULES. All three function names are mapped to their snow_ runtime equivalents. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add LLVM intrinsic declarations and codegen for Global.* calls</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/codegen/expr.rs
  </files>
  <action>
1. **Intrinsic declarations** (`intrinsics.rs`): Add three LLVM function declarations following the exact pattern of existing intrinsics (e.g., snow_node_connect):

   ```rust
   // Phase 68: Global Registry
   // snow_global_register(name_ptr: ptr, name_len: i64, pid: i64) -> i64
   module.add_function("snow_global_register",
       i64_type.fn_type(&[ptr_type.into(), i64_type.into(), i64_type.into()], false),
       Some(Linkage::External));

   // snow_global_whereis(name_ptr: ptr, name_len: i64) -> i64
   module.add_function("snow_global_whereis",
       i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false),
       Some(Linkage::External));

   // snow_global_unregister(name_ptr: ptr, name_len: i64) -> i64
   module.add_function("snow_global_unregister",
       i64_type.fn_type(&[ptr_type.into(), i64_type.into()], false),
       Some(Linkage::External));
   ```

2. **Codegen** (`expr.rs`): Add special handling for Global.* calls in the function call codegen path. All three functions take string arguments that need ptr+len unpacking via the existing `codegen_unpack_string` helper.

   In the call codegen dispatch (where `snow_node_connect`, `snow_node_start` etc. are handled), add:

   - `"snow_global_register"`: Use `codegen_unpack_string` to extract (name_ptr, name_len) from the first argument (a SnowString). The second argument (pid) is already an i64. Call the intrinsic with `[name_ptr, name_len, pid_val]`.

   - `"snow_global_whereis"`: Use `codegen_unpack_string` on the single string argument. Call with `[name_ptr, name_len]`.

   - `"snow_global_unregister"`: Same as whereis -- unpack string, call with `[name_ptr, name_len]`.

   The pattern is identical to `codegen_node_string_call` which handles `snow_node_connect` and `snow_node_monitor`. For `snow_global_register` which takes an additional pid argument, handle it like a two-arg variant (unpack first string arg, pass second arg through directly).

   Specifically:
   - For `snow_global_whereis` and `snow_global_unregister`: reuse `codegen_node_string_call` directly (single string arg -> ptr, len call), OR add them to the match that routes to that helper.
   - For `snow_global_register`: create a small codegen helper or inline it: unpack first arg string, keep second arg as-is, call intrinsic with 3 args [ptr, len, pid].
  </action>
  <verify>
`cargo build -p snow-codegen` compiles. All existing tests pass: `cargo test -p snow-codegen`. Write a small test Snow program (manually or via existing test infrastructure) that uses `Global.register("test", 1)` and verify it compiles without errors.
  </verify>
  <done>
All three Global.* functions have LLVM intrinsic declarations. Codegen correctly unpacks string arguments and emits calls to the runtime functions. A Snow program using Global.register/whereis/unregister compiles to correct LLVM IR. Zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` (full workspace) compiles without errors
2. `cargo test` -- all existing tests pass
3. `Global.register("name", pid)` in Snow source type-checks, lowers to MIR, and compiles to `snow_global_register(ptr, len, pid)` LLVM call
4. `Global.whereis("name")` compiles to `snow_global_whereis(ptr, len)` LLVM call
5. `Global.unregister("name")` compiles to `snow_global_unregister(ptr, len)` LLVM call
6. String arguments correctly unpacked from SnowString to (ptr, len) pairs
</verification>

<success_criteria>
Snow programs using `Global.register`, `Global.whereis`, and `Global.unregister` compile from source to native code via LLVM. The compiler pipeline (type check -> MIR lower -> LLVM codegen) handles all three functions correctly with string argument unpacking. Zero regressions in existing test suite.
</success_criteria>

<output>
After completion, create `.planning/phases/68-global-registry/68-02-SUMMARY.md`
</output>
