---
phase: 68-global-registry
plan: 03
type: execute
wave: 2
depends_on: ["68-01"]
files_modified:
  - crates/snow-rt/src/dist/node.rs
  - crates/snow-rt/src/dist/global.rs
autonomous: true

must_haves:
  truths:
    - "When a new node connects, both sides exchange their global registry snapshots and merge them"
    - "After sync exchange, both nodes have the union of all globally registered names"
    - "Duplicate names in sync are handled idempotently (skip already-registered names)"
    - "Wire format roundtrip tests prove DIST_GLOBAL_REGISTER, DIST_GLOBAL_UNREGISTER, and DIST_GLOBAL_SYNC encode/decode correctly"
    - "GlobalRegistry unit tests cover register, whereis, unregister, cleanup_node, cleanup_process, snapshot, and merge_snapshot"
  artifacts:
    - path: "crates/snow-rt/src/dist/node.rs"
      provides: "send_global_sync function called after send_peer_list on new connections"
      contains: "send_global_sync"
    - path: "crates/snow-rt/src/dist/global.rs"
      provides: "Unit tests for GlobalRegistry and wire format roundtrip tests"
      contains: "#[cfg(test)]"
  key_links:
    - from: "crates/snow-rt/src/dist/node.rs"
      to: "crates/snow-rt/src/dist/global.rs"
      via: "send_global_sync calls global_name_registry().snapshot() and writes DIST_GLOBAL_SYNC to session"
      pattern: "send_global_sync.*snapshot"
    - from: "crates/snow-rt/src/dist/node.rs (accept loop)"
      to: "send_global_sync"
      via: "Called right after send_peer_list in server accept path"
      pattern: "send_peer_list.*send_global_sync"
    - from: "crates/snow-rt/src/dist/node.rs (connect)"
      to: "send_global_sync"
      via: "Called right after send_peer_list in client connect path"
      pattern: "send_peer_list.*send_global_sync"
---

<objective>
Add global registry sync on node connect (so newly joined nodes learn about all existing global names) and comprehensive tests for the GlobalRegistry data structure, wire format encoding/decoding, and sync logic.

Purpose: Without sync-on-connect, a node joining an existing cluster would not know about any globally registered names. Without tests, we have no confidence that the data structure, wire format, and cleanup logic are correct. This plan closes those gaps.

Output: `send_global_sync` function called at both connection sites, unit tests for all GlobalRegistry methods, wire format roundtrip tests for all three DIST_GLOBAL_* message types.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/68-global-registry/68-RESEARCH.md
@.planning/phases/68-global-registry/68-01-SUMMARY.md
@crates/snow-rt/src/dist/node.rs (send_peer_list pattern, accept loop at line 2071, connect at line 2278)
@crates/snow-rt/src/dist/global.rs (GlobalRegistry, snapshot, merge_snapshot, broadcast functions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add send_global_sync on node connect</name>
  <files>
    crates/snow-rt/src/dist/node.rs
    crates/snow-rt/src/dist/global.rs
  </files>
  <action>
1. **Create `send_global_sync` function** in `dist/global.rs` (or `dist/node.rs` -- wherever broadcast functions live after Plan 01):

   ```rust
   /// Send our global registry snapshot to a newly connected node.
   /// Called right after send_peer_list on both server and client sides.
   pub(crate) fn send_global_sync(session: &Arc<NodeSession>) {
       let registry = global_name_registry();
       let snapshot = registry.snapshot();

       if snapshot.is_empty() {
           return; // Nothing to sync
       }

       let mut payload = Vec::new();
       payload.push(DIST_GLOBAL_SYNC);
       payload.extend_from_slice(&(snapshot.len() as u32).to_le_bytes());

       for (name, pid, node_name) in &snapshot {
           let name_bytes = name.as_bytes();
           payload.extend_from_slice(&(name_bytes.len() as u16).to_le_bytes());
           payload.extend_from_slice(name_bytes);
           payload.extend_from_slice(&pid.as_u64().to_le_bytes());
           let node_bytes = node_name.as_bytes();
           payload.extend_from_slice(&(node_bytes.len() as u16).to_le_bytes());
           payload.extend_from_slice(node_bytes);
       }

       let mut stream = session.stream.lock().unwrap();
       let _ = write_msg(&mut *stream, &payload);
   }
   ```

   If placed in `global.rs`, import the necessary types (`NodeSession`, `write_msg`, `DIST_GLOBAL_SYNC`). If placed in `node.rs`, import `global_name_registry`. Use whichever location is cleaner given Plan 01's organization. The function needs `Arc<NodeSession>` for the stream lock.

2. **Hook into both connection paths** in `dist/node.rs`:

   **Server accept path** (around line 2071):
   ```rust
   Ok(session) => {
       spawn_session_threads(&session);
       send_peer_list(&session);
       crate::dist::global::send_global_sync(&session);  // Phase 68
   }
   ```

   **Client connect path** (around line 2278):
   ```rust
   Ok(session) => {
       spawn_session_threads(&session);
       send_peer_list(&session);
       crate::dist::global::send_global_sync(&session);  // Phase 68
       0
   }
   ```

   Both sides send their snapshot, so after mutual exchange both nodes have the union of all known global names. The DIST_GLOBAL_SYNC handler (from Plan 01) calls `merge_snapshot` which is idempotent (skips already-registered names).
  </action>
  <verify>
`cargo build -p snow-rt` compiles. All existing tests pass: `cargo test -p snow-rt`.
  </verify>
  <done>
send_global_sync exists and is called at both connection sites (server accept and client connect) right after send_peer_list. Newly connecting nodes will exchange their global registry snapshots bidirectionally.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive unit tests for GlobalRegistry and wire format</name>
  <files>
    crates/snow-rt/src/dist/global.rs
  </files>
  <action>
Add a `#[cfg(test)] mod tests` block in `global.rs` with the following test cases. Follow the in-memory testing pattern used by existing dist tests (e.g., `test_send_peer_list_wire_format_roundtrip` in node.rs) -- no network I/O, no NODE_STATE dependency, pure data structure and wire format verification.

**GlobalRegistry data structure tests:**

1. `test_register_and_whereis` -- Register a name, verify whereis returns the correct PID. Register a second name for a different PID, verify both resolve correctly.

2. `test_register_duplicate_name_rejected` -- Register a name, attempt to register the same name with a different PID. Verify the second registration returns Err and the original mapping is preserved.

3. `test_unregister` -- Register a name, verify whereis returns Some. Unregister it, verify whereis returns None. Verify unregister returns true for existing name, false for non-existent name.

4. `test_cleanup_process` -- Register two names for the same PID and one for a different PID. Call cleanup_process for the first PID. Verify only the first PID's names are removed, the other PID's name remains.

5. `test_cleanup_node` -- Register names on two different nodes. Call cleanup_node for one node. Verify only that node's names are removed, the other node's names remain.

6. `test_snapshot_and_merge` -- Register several names. Take a snapshot. Create a new empty GlobalRegistry. Call merge_snapshot with the snapshot. Verify all names resolve correctly in the new registry.

7. `test_merge_snapshot_idempotent` -- Register name "a". Take snapshot. Merge the same snapshot again. Verify "a" still resolves to the same PID (not duplicated or errored).

8. `test_merge_snapshot_skips_existing_names` -- Register name "a" with PID-1. Merge a snapshot containing name "a" with PID-2. Verify "a" still resolves to PID-1 (existing registration wins).

**Wire format roundtrip tests:**

9. `test_dist_global_register_wire_format` -- Build a DIST_GLOBAL_REGISTER payload manually (tag + name_len + name + pid + node_name_len + node_name). Parse it back using the same logic as the reader loop handler. Verify all fields match.

10. `test_dist_global_unregister_wire_format` -- Same for DIST_GLOBAL_UNREGISTER (tag + name_len + name).

11. `test_dist_global_sync_wire_format` -- Build a DIST_GLOBAL_SYNC payload with multiple entries. Parse it back. Verify all entries match.

12. `test_dist_global_sync_empty` -- Verify sync with count=0 produces a valid minimal payload and parses to an empty list.

Use `ProcessId(N)` for test PIDs (direct construction from u64).
  </action>
  <verify>
`cargo test -p snow-rt` -- all tests pass including the new global registry tests. Run with `-- --nocapture` to see test output if needed.
  </verify>
  <done>
12 unit tests covering all GlobalRegistry methods (register, whereis, unregister, cleanup_process, cleanup_node, snapshot, merge_snapshot) and all three wire format types (DIST_GLOBAL_REGISTER, DIST_GLOBAL_UNREGISTER, DIST_GLOBAL_SYNC) including edge cases (duplicates, idempotent merge, empty sync). All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` compiles
2. `cargo test -p snow-rt` -- all tests pass (existing + ~12 new)
3. send_global_sync is called at both connection code paths
4. Wire format roundtrip tests confirm encode/decode correctness for all three message types
5. Data structure tests confirm all GlobalRegistry operations work correctly
6. Idempotent merge verified (sync arriving twice doesn't corrupt state)
</verification>

<success_criteria>
Global registry synchronization on node connect is operational. When a new node joins the cluster, it receives a snapshot of all globally registered names from connected nodes and sends its own snapshot back. Comprehensive unit tests prove the data structure and wire format correctness. The full phase 68 success criteria are met: (1) Global.register makes names visible cluster-wide, (2) Global.whereis returns correct PIDs from any node, (3) node disconnect cleans up registrations.
</success_criteria>

<output>
After completion, create `.planning/phases/68-global-registry/68-03-SUMMARY.md`
</output>
