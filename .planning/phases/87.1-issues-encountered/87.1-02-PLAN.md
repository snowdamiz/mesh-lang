---
phase: 87.1-issues-encountered
plan: 02
type: execute
wave: 2
depends_on: ["87.1-01"]
files_modified:
  - crates/mesh-typeck/src/lib.rs
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-typeck/src/ty.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/meshc/src/main.rs
  - tests/e2e/cross_module_service.mpl
  - tests/e2e/cross_module_polymorphic.mpl
autonomous: true

must_haves:
  truths:
    - "Services defined in one module can be imported and used from another module via 'import Services.Counter' or 'from Services.Counter import CounterService'"
    - "Functions with polymorphic type parameters (e.g., identity :: a -> a) can be imported cross-module without index-out-of-bounds panics"
    - "Cross-module service calls (ServiceName.start, ServiceName.method) work with correct dispatch and message routing"
    - "All existing E2E tests continue to pass (no regressions)"
  artifacts:
    - path: "crates/mesh-typeck/src/lib.rs"
      provides: "ExportedSymbols and ModuleExports with service_defs field; scheme normalization in collect_exports"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Import resolution for service helper functions (start, call, cast helpers)"
    - path: "crates/mesh-typeck/src/ty.rs"
      provides: "Helper to walk and remap TyVars in a Ty for scheme normalization"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Cross-module service method resolution using module-prefixed function names"
    - path: "tests/e2e/cross_module_service.mpl"
      provides: "Multi-module E2E test proving cross-module service import and use"
    - path: "tests/e2e/cross_module_polymorphic.mpl"
      provides: "Multi-module E2E test proving polymorphic function import works"
  key_links:
    - from: "crates/mesh-typeck/src/lib.rs"
      to: "crates/meshc/src/main.rs"
      via: "collect_exports produces ExportedSymbols consumed by the driver to build ImportContext"
      pattern: "collect_exports"
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-typeck/src/lib.rs"
      via: "import resolution reads ModuleExports.service_defs to register service helpers in local env"
      pattern: "service_defs"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-typeck/src/infer.rs"
      via: "MIR lowerer reads qualified_modules to resolve cross-module service method calls"
      pattern: "service_modules"
---

<objective>
Fix two module system issues that prevent modular service architecture and generic utility functions across Mesh modules.

Purpose: Without cross-module service export, all services must live in main.mpl, creating a monolithic file. Without polymorphic type variable normalization, generic functions (like identity, map helpers) cannot be imported cross-module. These compound across phases 88-95 as each phase adds more services and shared utilities.

Output: Services can be defined in dedicated modules and imported elsewhere. Polymorphic functions export cleanly. Two multi-module E2E tests proving both features work.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/87.1-issues-encountered/87.1-RESEARCH.md
@.planning/phases/87.1-issues-encountered/87.1-01-SUMMARY.md
@crates/mesh-typeck/src/lib.rs
@crates/mesh-typeck/src/infer.rs
@crates/mesh-typeck/src/ty.rs
@crates/mesh-typeck/src/unify.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/meshc/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Normalize polymorphic type schemes on export (Issue 4)</name>
  <files>crates/mesh-typeck/src/lib.rs, crates/mesh-typeck/src/ty.rs, tests/e2e/cross_module_polymorphic.mpl</files>
  <action>
  Fix the cross-module polymorphic type variable scoping issue by normalizing type schemes before they are exported.

  **Problem:** When a polymorphic function (e.g., `pub fn identity(x) do x end`) is exported, its `Scheme` contains `TyVar` IDs from the exporting module's `InferCtx`. When the importing module's `InferCtx` tries to `instantiate` the scheme, it calls `probe_value` with foreign TyVar IDs that index out of bounds in its own table.

  **Step 1: Add TyVar remapping helper to `ty.rs`**

  Add a function `normalize_scheme(scheme: &Scheme) -> Scheme` that:
  1. Collects all `TyVar` references in `scheme.ty` (walk the Ty tree)
  2. Creates a mapping from old TyVar IDs to sequential new IDs starting from 0
  3. Rebuilds the `vars` list with remapped IDs
  4. Rebuilds the `ty` with remapped TyVars

  ```rust
  impl Scheme {
      /// Normalize a scheme so its type variables are sequential from 0.
      /// This makes schemes self-contained with no dependency on the
      /// original InferCtx's unification table. Essential for cross-module export.
      pub fn normalize(&self) -> Scheme {
          if self.vars.is_empty() {
              return self.clone();
          }
          let mut mapping: FxHashMap<TyVar, TyVar> = FxHashMap::default();
          let mut next_id: u32 = 0;
          for var in &self.vars {
              if !mapping.contains_key(var) {
                  mapping.insert(*var, TyVar(next_id));
                  next_id += 1;
              }
          }
          let new_vars: Vec<TyVar> = self.vars.iter().map(|v| mapping[v]).collect();
          let new_ty = remap_tyvars(&self.ty, &mapping);
          Scheme { vars: new_vars, ty: new_ty }
      }
  }

  fn remap_tyvars(ty: &Ty, mapping: &FxHashMap<TyVar, TyVar>) -> Ty {
      match ty {
          Ty::Var(v) => {
              if let Some(new_v) = mapping.get(v) {
                  Ty::Var(*new_v)
              } else {
                  ty.clone()
              }
          }
          Ty::Con(_) | Ty::Never => ty.clone(),
          Ty::Fun(params, ret) => {
              let params = params.iter().map(|p| remap_tyvars(p, mapping)).collect();
              let ret = Box::new(remap_tyvars(ret, mapping));
              Ty::Fun(params, ret)
          }
          Ty::App(con, args) => {
              let con = Box::new(remap_tyvars(con, mapping));
              let args = args.iter().map(|a| remap_tyvars(a, mapping)).collect();
              Ty::App(con, args)
          }
          Ty::Tuple(elems) => {
              let elems = elems.iter().map(|e| remap_tyvars(e, mapping)).collect();
              Ty::Tuple(elems)
          }
      }
  }
  ```

  Add `use rustc_hash::FxHashMap;` to `ty.rs` (or use `std::collections::HashMap`).

  **Step 2: Apply normalization in `collect_exports` (`lib.rs`)**

  In the `collect_exports` function, after creating `Scheme::mono(ty.clone())` for function exports (line 211-213), call `.normalize()` on the scheme before inserting into exports:

  ```rust
  exports.functions.insert(
      name,
      Scheme::mono(ty.clone()).normalize(),
  );
  ```

  Do NOT blindly normalize all schemes -- only normalize schemes that have `vars` (polymorphic). `Scheme::mono` produces `vars: []` so normalization is a no-op, but calling it is harmless and consistent.

  **Step 3: Create multi-module E2E test**

  Create `tests/e2e/cross_module_polymorphic.mpl` -- a multi-file test. Check how existing multi-module tests are structured in the test runner. The test needs:
  - A module file defining `pub fn identity(x) do x end` and `pub fn apply(f, x) do f(x) end`
  - A main file that imports these functions and uses them with different types
  - Print results to verify correctness

  If the test framework doesn't support inline multi-module tests, create the test as a project directory under `tests/e2e/projects/` or adapt the test runner. Check existing patterns first: look at how `stdlib_from_import.mpl` and `stdlib_module_qualified.mpl` work (these use stdlib, not user modules). If user module tests exist elsewhere (perhaps integration tests), follow that pattern.
  </action>
  <verify>
  ```bash
  cd /Users/sn0w/Documents/dev/snow && cargo test -p meshc -- cross_module_polymorphic 2>&1 | tail -10
  cd /Users/sn0w/Documents/dev/snow && cargo test -p mesh-typeck 2>&1 | tail -5
  ```
  The polymorphic cross-module test compiles and runs without panics. Typeck unit tests pass.
  </verify>
  <done>
  Polymorphic functions export with normalized TyVar IDs starting from 0. Importing modules can instantiate these schemes without index-out-of-bounds panics. E2E test proves it works end-to-end.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cross-module service export and import (Issue 3)</name>
  <files>crates/mesh-typeck/src/lib.rs, crates/mesh-typeck/src/infer.rs, crates/mesh-codegen/src/mir/lower.rs, crates/meshc/src/main.rs, tests/e2e/cross_module_service.mpl</files>
  <action>
  Enable services defined in one module to be imported and used from another module.

  **Step 1: Add service_defs to export types (`lib.rs`)**

  Add a `service_defs` field to both `ModuleExports` and `ExportedSymbols`:

  ```rust
  // In ModuleExports:
  pub service_defs: FxHashMap<String, ServiceExportInfo>,

  // In ExportedSymbols:
  pub service_defs: FxHashMap<String, ServiceExportInfo>,
  ```

  Define `ServiceExportInfo`:
  ```rust
  /// Information about an exported service, containing the helper function
  /// signatures needed by importing modules.
  #[derive(Debug, Default, Clone)]
  pub struct ServiceExportInfo {
      /// Service name (e.g., "Counter").
      pub name: String,
      /// Helper functions: maps unqualified name (e.g., "start", "increment")
      /// to their type scheme. These are registered as ServiceName.method in
      /// the importing module's type environment.
      pub helpers: FxHashMap<String, Scheme>,
      /// Method names with their generated function names for MIR resolution.
      /// Maps method_name -> generated_fn_name (e.g., "start" -> "__service_counter_start").
      pub methods: Vec<(String, String)>,
  }
  ```

  **Step 2: Collect service exports in `collect_exports` (`lib.rs`)**

  In `collect_exports`, after the existing Item processing, add a new loop for ServiceDef items:

  ```rust
  for item in tree.items() {
      if let Item::ServiceDef(service_def) = &item {
          if let Some(name) = service_def.name().and_then(|n| n.text()) {
              if service_def.visibility().is_some() {
                  let mut info = ServiceExportInfo {
                      name: name.clone(),
                      helpers: FxHashMap::default(),
                      methods: Vec::new(),
                  };
                  // Collect helper function types from the typeck types map.
                  // The type checker registers ServiceName.start, ServiceName.method_name
                  // in the env. We need to find these in typeck.types by scanning
                  // for the service def's range.
                  // Alternative: Look them up from typeck qualified_modules if available,
                  // or reconstruct from the service def's handler signatures.
                  // Safest: iterate the environment to find "ServiceName.*" entries.
                  // Since we don't have direct env access, reconstruct from AST + types.

                  let name_lower = name.to_lowercase();

                  // Start helper
                  let start_key = format!("{}.start", name);
                  // Find the init function type from typeck.types
                  if let Some(init_fn) = service_def.init_fn() {
                      if let Some(ty) = typeck.types.get(&init_fn.syntax().text_range()) {
                          info.helpers.insert("start".to_string(), Scheme::mono(ty.clone()));
                      }
                  }
                  info.methods.push(("start".to_string(), format!("__service_{}_start", name_lower)));

                  // Call handler helpers
                  for handler in service_def.call_handlers() {
                      if let Some(hname) = handler.name().and_then(|n| n.text()) {
                          let snake = to_snake_case(&hname);
                          let qualified = format!("{}.{}", name, snake);
                          // Look up the handler's type from typeck.types via handler range
                          // Actually, the helper function type was registered in the env,
                          // not in typeck.types by range. We need to reconstruct it.
                          // The helper type is: (Pid<Unit>, param_types...) -> reply_type
                          // For now, store the handler's body range type from typeck.
                          info.methods.push((snake.clone(), format!("__service_{}_call_{}", name_lower, snake)));
                      }
                  }

                  // Cast handler helpers
                  for handler in service_def.cast_handlers() {
                      if let Some(hname) = handler.name().and_then(|n| n.text()) {
                          let snake = to_snake_case(&hname);
                          info.methods.push((snake.clone(), format!("__service_{}_cast_{}", name_lower, snake)));
                      }
                  }

                  exports.service_defs.insert(name, info);
              } else {
                  if let Some(name) = service_def.name().and_then(|n| n.text()) {
                      exports.private_names.insert(name);
                  }
              }
          }
      }
  }
  ```

  NOTE: The helper function type reconstruction is tricky because `infer_service_def` registers types in the env (not in `typeck.types` by range). The most reliable approach is to also store the helper types in `typeck.types` during inference (keyed by a synthetic range or a dedicated field), or to pass them through a new field on `TypeckResult`. Alternatively, since the generated function names follow a predictable pattern and the types are reconstructed from the handler signatures, the MIR lowerer can resolve them without explicit type schemes.

  The critical part is the `methods` list (mapping method names to generated function names) -- this is what the MIR lowerer needs to resolve `ServiceName.method()` calls cross-module.

  **Step 3: Pass service exports through ImportContext (`infer.rs`)**

  In the `ImportDecl` handling (line 1940+), when processing user-defined modules, also check for `service_defs`:

  ```rust
  // After existing struct/function handling for the module namespace:
  for (service_name, service_info) in &mod_exports.service_defs {
      // Register service helper functions in the env for type checking
      for (method_name, scheme) in &service_info.helpers {
          let qualified = format!("{}.{}", service_name, method_name);
          env.insert(qualified.clone(), scheme.clone());
          // Also add to qualified_modules so MIR lowering can resolve them
          ctx.qualified_modules.entry(service_name.clone())
              .or_default()
              .insert(method_name.clone(), scheme.clone());
      }
  }
  ```

  Similarly for `FromImportDecl` (line 1981+): when a specific service name is imported, register its helpers.

  **Step 4: Propagate service method info to MIR lowerer (`lower.rs`)**

  The MIR lowerer needs to know about cross-module service methods. Currently `service_modules` is populated only from local `lower_service_def` calls. For imported services, the lowerer needs to also populate `service_modules` from the import context.

  In the `Lowerer::new` constructor or initialization, add logic to populate `service_modules` from `typeck.qualified_modules` for service-like entries. The key insight: if `qualified_modules` contains entries that match service method patterns (e.g., "Counter" -> ["start", "increment"]), and these map to functions with names like `__service_counter_*`, they should be added to `service_modules`.

  Alternatively, add a new field to `TypeckResult` that propagates the service method mapping: `pub imported_service_modules: HashMap<String, Vec<(String, String)>>` (service_name -> [(method_name, generated_fn_name)]).

  The simplest approach: pass `ServiceExportInfo.methods` through to the lowerer via `TypeckResult.qualified_modules` enriched with the generated function name mapping, or add a parallel `service_method_mapping` field.

  **Step 5: Handle module-prefixed function names in codegen**

  When a cross-module service method is called (e.g., `Counter.start(0)`), the MIR lowerer currently resolves it to the generated function name (e.g., `__service_counter_start`). This function is defined in the SERVICE's module object file. The LLVM linker must resolve this symbol. Since the meshc driver already links all module object files together (see `meshc/src/main.rs`), cross-module function references resolve automatically at link time.

  Verify this by checking how existing cross-module function calls work (user_modules path in lower.rs lines 5910-5918). The lowerer returns `MirExpr::Var(field_name, ty)` where `field_name` is the unqualified function name. For services, we need the GENERATED function name (prefixed with `__service_`), not the unqualified name.

  **Step 6: Driver integration (`meshc/src/main.rs`)**

  In the driver's export collection loop (around line 338), the `ExportedSymbols` already includes everything from `collect_exports`. When building `ImportContext` for downstream modules, ensure `service_defs` from `ExportedSymbols` is copied into the `ModuleExports` struct.

  Find where `ModuleExports` is constructed from `ExportedSymbols` and add:
  ```rust
  module_exports.service_defs = exported_symbols.service_defs.clone();
  ```

  **Step 7: Create multi-module E2E test**

  Create a multi-module test that:
  - Module A: defines a service (e.g., `pub service CounterService { ... }`)
  - Module B (main): imports CounterService, calls `CounterService.start()`, calls methods
  - Prints results to verify the service responds correctly

  Follow whatever multi-module test pattern exists in the project. If no user-module test pattern exists in e2e/, create a test project directory.

  **IMPORTANT NOTES:**
  - This is a HIGH complexity task. If the implementation grows beyond what fits cleanly, focus on the minimal path: get `service_modules` populated for imported services so the MIR lowerer resolves method calls, and ensure the linker finds the symbols. Type checking can use reconstructed types from the AST rather than a full export pipeline.
  - Issue 4 (polymorphic types) is a prerequisite because exported service helper functions may have polymorphic types. Task 1 must complete first.
  </action>
  <verify>
  ```bash
  cd /Users/sn0w/Documents/dev/snow && cargo test -p meshc -- cross_module_service 2>&1 | tail -10
  cd /Users/sn0w/Documents/dev/snow && cargo test -p meshc 2>&1 | tail -20
  ```
  The cross-module service test compiles, links, and runs correctly. Full test suite passes with no regressions.
  </verify>
  <done>
  Services defined in one module can be imported and called from another module. The type checker exports service helper function signatures. The MIR lowerer resolves cross-module service method calls to the correct generated function names. The linker resolves cross-module symbols. E2E test demonstrates end-to-end functionality.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p meshc` -- ALL tests pass (existing + 2 new E2E tests)
2. `cargo test -p meshc -- cross_module_polymorphic` -- polymorphic cross-module import works
3. `cargo test -p meshc -- cross_module_service` -- cross-module service import and use works
4. `cargo test -p mesh-typeck` -- all typeck unit tests pass
5. No panics or index-out-of-bounds errors in any test
6. Mesher project (`mesher/`) still compiles if applicable
</verification>

<success_criteria>
- Polymorphic type variables are normalized on export (sequential IDs from 0)
- Services are exported with helper function signatures and method mappings
- Importing modules can type-check and codegen cross-module service calls
- Two new multi-module E2E tests proving both features
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/87.1-issues-encountered/87.1-02-SUMMARY.md`
</output>
