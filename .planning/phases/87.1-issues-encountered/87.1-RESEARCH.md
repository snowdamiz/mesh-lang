# Phase 87.1: Issues Encountered -- Research

**Question:** What do I need to know to PLAN this phase well?
**Phase:** 87.1 -- Urgent compiler/runtime fixes discovered during Phase 87 (Foundation)
**Confidence:** HIGH -- All issues traced to specific source files, root causes identified, fixes scoped

## Executive Summary

Phase 87 (Foundation) built the Mesher data model, storage layer, and services, but encountered 6 compiler/runtime issues requiring workarounds. These issues fall into three categories: **codegen bugs** (? operator, Err(e) binding, List.find Option matching), **module system gaps** (cross-module service export, polymorphic type variables across modules), and **runtime limitations** (Timer.send_after thread spawning, Map.collect key typing). Fixing these before Phase 88 (Ingestion Pipeline) will eliminate compounding workarounds that would otherwise spread through phases 88-95.

The issues are not independent -- they share common codegen infrastructure and will compound. The ? operator bug forces explicit case matching everywhere. The cross-module service gap forces all services into main.mpl. The polymorphic type variable scoping forces buffer logic into main.mpl. As phases add more services, more cross-module functions, and more error handling, these workarounds will multiply.

## Issue Analysis

### Issue 1: ? Operator LLVM Codegen Bug (CRITICAL)

**Symptom:** Using `?` in a function returning `Result<T, String>` produces LLVM verification error: `ret ptr %call` when the function return type is `{ i8, ptr }` (Result struct).

**Root cause location:** `crates/mesh-codegen/src/codegen/expr.rs` (lines 1711-1719) and `crates/mesh-codegen/src/mir/lower.rs` (lines 8009+).

**Root cause analysis:**
The MIR lowering for `?` (in `lower_try_result`, line 8009+) correctly creates a `Match` with two arms: Ok(val) unwraps to val, Err(e) creates `Return(ConstructVariant("Err", [e]))`. The LLVM codegen for `Return` (line 1711) calls `codegen_expr(inner)` to get the return value, then `build_return(Some(&val))`.

The type mismatch occurs because the inner expression produces a value whose LLVM type is `ptr` (a raw pointer from the function call result or the variant field extraction), but the function's declared LLVM return type is `{ i8, ptr }` (the Result struct layout). LLVM verifies that `ret` instructions match the function signature and rejects the mismatch.

The specific failure path: when `codegen_construct_variant` constructs the Err variant for early return, it should allocate a `{ i8, ptr }` struct, set the tag to the Err tag value, store the error value, load the full struct, and return it. The issue is that the value flowing through the match arm codegen preserves the pointer type from the scrutinee call result rather than constructing a fresh struct value.

**Fix approach:** In `codegen_return`, when the inner expression produces a `ptr` but the function's return type is a struct type (like `{ i8, ptr }`), load the struct from the pointer before returning. Alternatively, ensure `codegen_construct_variant` always produces a value matching the function's declared LLVM return type, not a pointer to one.

**Complexity:** MEDIUM -- The fix is localized to the return codegen path. Need to verify that the fix handles all return type combinations (struct, sum type, primitive) correctly.

**Files to modify:**
- `crates/mesh-codegen/src/codegen/expr.rs` -- `codegen_return` function (line 1711)
- Potentially `codegen_construct_variant` if the type inference for the variant is incorrect

**Impact on future phases:** CRITICAL. Every function that returns `Result<T, String>` and uses `?` is affected. Phase 88 (Ingestion Pipeline) will have 10+ functions returning Result types for HTTP handling, validation, and database operations. Without this fix, every single one needs explicit `case` matching instead of `?`.

---

### Issue 2: Err(e) Variable Binding Alloca Domination (HIGH)

**Symptom:** Pattern matching `Err(e) -> ...` where `e` is bound as a variable produces LLVM verification error about alloca not dominating all uses.

**Root cause location:** `crates/mesh-codegen/src/codegen/pattern.rs` (lines 146-210, `codegen_leaf` function).

**Root cause analysis:**
In `codegen_leaf`, variable bindings from pattern matching are allocated at the current insertion point (line 179: `build_alloca(llvm_ty, name)`). When this alloca is created inside a case block (e.g., `handler_1` block from a switch on the Result tag), the alloca only exists in that control flow path. If a subsequent instruction (like a return) references this variable from a block that doesn't dominate the alloca's block, LLVM's verification fails.

The guard codegen (`codegen_guard`, line 429+) already has the correct fix: it places allocas in the function's entry block using `position_before(&first_instr)` on the entry block, which ensures the alloca dominates all uses throughout the function.

**Fix approach:** Apply the same entry-block alloca placement pattern from `codegen_guard` to `codegen_leaf`. Move the `build_alloca` call to the function entry block (position before first instruction), then restore the insertion point to the current block for the `build_store`.

**Complexity:** LOW -- The pattern already exists in `codegen_guard` (line 438-447). Copy the same approach to `codegen_leaf`.

**Files to modify:**
- `crates/mesh-codegen/src/codegen/pattern.rs` -- `codegen_leaf` function (lines 156-210)

**Impact on future phases:** HIGH. This bug prevents binding error values in Result pattern matching (forces `Err(_)` instead of `Err(e)`). Phase 88 needs to inspect error values for HTTP error responses (e.g., returning specific error messages to clients).

---

### Issue 3: Cross-Module Service Export (HIGH)

**Symptom:** Services defined in one module cannot be used from another module. `from Services.Org import OrgService` fails because services are not in `ModuleExports`.

**Root cause location:** `crates/mesh-typeck/src/lib.rs` (lines 80-95, `ModuleExports` struct; lines 194-256, `collect_exported_symbols` function).

**Root cause analysis:**
The `ModuleExports` struct contains:
- `functions: FxHashMap<String, Scheme>`
- `struct_defs: FxHashMap<String, StructDefInfo>`
- `sum_type_defs: FxHashMap<String, SumTypeDefInfo>`
- `private_names: FxHashSet<String>`

There is no field for service definitions. The `collect_exported_symbols` function (line 194+) iterates over AST items and handles `FnDef`, `StructDef`, `SumTypeDef`, and `InterfaceDef`, but has no case for `ServiceDef`.

When a service is type-checked (line 6560+), it registers helper functions (`ServiceName.start`, `ServiceName.method_name`) in the local type environment via `env.insert()`. These never make it into the exported symbols because the export collection step doesn't know about them.

The MIR lowering also creates service-specific functions (init, handlers, loop) with module-prefixed names, but the linker only resolves these within the same compilation unit.

**Fix approach:** Multi-step fix:
1. Add a `service_defs` field to `ModuleExports` and `ExportedSymbols` containing the service's generated helper function signatures (start, call helpers, cast helpers)
2. In `collect_exported_symbols`, handle `Item::ServiceDef` and extract the helper function types from the typeck result
3. During import resolution in the importing module, register the service helper functions in the local type environment
4. In MIR lowering, generate cross-module service call/cast code that references the correct function names (module-prefixed)
5. Ensure the linker resolves cross-module service function references

**Complexity:** HIGH -- This touches the typechecker (export collection, import resolution), MIR lowering (cross-module service dispatch), and potentially the linker. The service's internal dispatch loop stays in the defining module; only the client-side call/cast helpers need cross-module visibility.

**Files to modify:**
- `crates/mesh-typeck/src/lib.rs` -- `ModuleExports`, `ExportedSymbols`, `collect_exported_symbols`
- `crates/mesh-typeck/src/infer.rs` -- Import resolution for service helpers
- `crates/mesh-codegen/src/mir/lower.rs` -- Cross-module service function name resolution
- `crates/meshc/src/main.rs` -- Module export collection (line 442+)

**Impact on future phases:** HIGH. Every phase adds services. Without this fix, all services must live in main.mpl, creating a monolithic file that will grow to thousands of lines by Phase 92 (Alerting). Phase 88 alone adds EventRouter and Processor services.

---

### Issue 4: Polymorphic Type Variables Across Module Boundaries (HIGH)

**Symptom:** Functions with inferred (polymorphic) type parameters cause an index-out-of-bounds panic when imported cross-module.

**Root cause location:** `crates/mesh-typeck/src/unify.rs` (lines 18-47, `InferCtx`; line 112, `fresh_var`; lines 466-478, `instantiate`).

**Root cause analysis:**
Each module gets its own `InferCtx` with its own `InPlaceUnificationTable<TyVar>`. Type variables (`TyVar`) have numeric IDs that are indices into this table. When a function with a polymorphic type scheme (e.g., `forall a. (List<a>, (a -> Bool)) -> Option<a>`) is exported, its `Scheme` contains `TyVar` references with IDs specific to the exporting module's table.

When the importing module's `InferCtx` tries to `instantiate` the scheme (line 466+), it iterates over `scheme.vars` and calls `self.fresh_var()` for each, then calls `apply_substitution`. The substitution correctly maps old TyVars to new ones. However, if there are unresolved `TyVar` references in the scheme's type that are NOT in the `vars` list (e.g., partially resolved types), `apply_substitution` calls `self.table.probe_value(*v)` (line 492) with the foreign TyVar ID, which indexes out of bounds in the importing module's smaller table.

Even for well-formed schemes, the `Scheme.vars` uses `TyVar` values from the exporting module. While `instantiate` creates fresh variables for substitution, the old TyVar values are still passed to `probe_value` during `apply_substitution` if the substitution map doesn't cover them.

**Fix approach:** Two options:
1. **Normalize schemes on export** -- Before adding a scheme to `ExportedSymbols`, resolve all type variables and re-number them starting from 0 using a fresh, isolated mapping. This makes schemes self-contained with no dependency on the original InferCtx.
2. **Use named type parameters** -- Replace `TyVar` references in exported schemes with named placeholder types (e.g., `Ty::Param("a")`) that don't reference any unification table. This is more invasive but cleaner long-term.

Recommend option 1 (normalize on export) as it's the minimal change.

**Complexity:** MEDIUM -- Option 1 requires adding a normalization step in `collect_exported_symbols` that walks the scheme's type tree, collects all TyVars, and remaps them to sequential IDs starting from 0. The `vars` list is rebuilt with the remapped IDs.

**Files to modify:**
- `crates/mesh-typeck/src/lib.rs` -- Add scheme normalization in `collect_exported_symbols`
- `crates/mesh-typeck/src/ty.rs` -- Helper to walk/remap TyVars in a Ty
- Potentially `crates/mesh-typeck/src/unify.rs` -- Ensure `instantiate` handles edge cases

**Impact on future phases:** HIGH. This prevents exporting any generic function across modules. Phase 88+ will need generic utility functions (e.g., `validate<T>`, `transform<T>`, list manipulation helpers). Without this fix, all functions used cross-module must have fully concrete type signatures, limiting code reuse.

---

### Issue 5: List.find Option Pattern Matching Codegen Bug (MEDIUM)

**Symptom:** `case List.find(xs, predicate) do Some(x) -> ... | None -> ... end` produces LLVM verification error.

**Root cause location:** `crates/mesh-codegen/src/codegen/expr.rs` (lines 1370-1400, `codegen_match`) and `crates/mesh-codegen/src/codegen/pattern.rs` (line 585+, `navigate_access_path`).

**Root cause analysis:**
`List.find` returns a heap-allocated `MeshOption` pointer (`*mut u8` -> `ptr` in LLVM). The LLVM type for `Option<T>` is `{ i8, ptr }` (inline struct). When the return value of `List.find` is used directly as a match scrutinee:

1. `codegen_match` gets `scrutinee_val` as a `ptr` (heap pointer to MeshOption)
2. At lines 1384-1390, it detects that the scrutinee is a pointer to a sum type and uses it directly as `scrutinee_alloca`
3. The pattern compiler does `build_struct_gep(sum_layout, switch_ptr, 0, "tag_ptr")` to read the tag

The issue is that using the raw heap pointer as `scrutinee_alloca` means all GEP operations use this pointer, but the pointer may not have the correct alignment guarantees that `build_struct_gep` expects for `{ i8, ptr }` layout. Additionally, the interaction between the heap-allocated `MeshOption` layout and the codegen's expected inline struct layout may produce incorrect field offsets when padding differs.

The `MeshOption` struct in Rust is `#[repr(C)] struct MeshOption { tag: u8, value: *mut u8 }`, which has alignment padding between `tag` (1 byte) and `value` (8 bytes), giving an actual layout of `[u8 tag, 7 bytes padding, *mut u8 value]` (16 bytes total). The LLVM struct type `{ i8, ptr }` also has this padding when used with `build_struct_gep`, so the layouts should match. The bug may be more subtle -- related to LLVM's verification of GEP on an opaque pointer vs. a typed alloca.

Alternatively, this may be the same underlying issue as Issue 2 (alloca domination): when binding `x` in `Some(x)`, the alloca for `x` is placed inside the case block, not the entry block.

**Fix approach:** First, verify if Issue 2's fix (entry-block allocas in `codegen_leaf`) also fixes this issue. If not, the match scrutinee handling needs to load the heap-allocated struct into a local alloca before pattern matching, ensuring the GEP operates on a well-typed alloca rather than a raw heap pointer.

**Complexity:** LOW-MEDIUM -- Likely fixed by Issue 2, or requires adding a load-to-alloca step in `codegen_match` for heap pointer scrutinees.

**Files to modify:**
- `crates/mesh-codegen/src/codegen/expr.rs` -- `codegen_match` (lines 1384-1400)
- `crates/mesh-codegen/src/codegen/pattern.rs` -- `codegen_leaf` (if Issue 2 fix doesn't resolve it)

**Impact on future phases:** MEDIUM. Phase 88 will use `List.find` for looking up events in processing lists, finding matching rules, etc. The workaround (`List.filter` + `List.length` + `List.get`) is verbose but functional.

---

### Issue 6: Timer.send_after Service Dispatch Incompatibility (MEDIUM)

**Symptom:** `Timer.send_after` delivers raw message bytes that don't match service cast dispatch tags, causing the message to be silently dropped by the service dispatch loop.

**Root cause location:** `crates/mesh-rt/src/actor/mod.rs` (lines 585-602, `mesh_timer_send_after`) and `crates/mesh-codegen/src/codegen/expr.rs` (lines 2974-3050, `codegen_service_loop`).

**Root cause analysis:**
Service dispatch uses a type-tagged message protocol: each message has a `[u64 type_tag][u64 caller_pid][i64... args]` header. The `type_tag` selects which handler to invoke via a switch instruction in the generated service loop (line 2999+).

`mesh_timer_send_after` (line 585) deep-copies the raw message bytes and sends them via `mesh_actor_send`. The bytes are the raw payload from the caller (e.g., the bytes of a string "flush"), which don't contain the correct `type_tag` header. When the service loop reads the first 8 bytes as `type_tag`, it gets garbage, which doesn't match any handler and falls through to the default branch (which is a no-op/panic).

**Secondary issue:** `mesh_timer_send_after` spawns an OS thread per call (line 597: `std::thread::spawn`). For recurring timers (e.g., 5-second flush intervals for each project's StorageWriter), this creates and destroys an OS thread every 5 seconds per writer. With 100 projects, that's 20 OS threads created/destroyed per second.

**Fix approach:** Two independent fixes:
1. **Message format:** Make `Timer.send_after` wrap the message in the correct service dispatch format. This requires the caller to provide the `type_tag` for the target handler. Alternatively, add a `Timer.send_after_cast(pid, handler_tag, ms)` variant that constructs the correct message format.
2. **Thread pooling:** Replace the per-call `thread::spawn` with a timer wheel or a single timer thread that manages a priority queue of pending timers. This eliminates the thread creation overhead.

The current workaround (flush_ticker actor with `Timer.sleep` + recursive call) is functional and avoids both issues, but it ties up an actor coroutine per timer.

**Complexity:** MEDIUM for message format fix, HIGH for timer wheel. Recommend fixing the message format first and deferring the timer wheel to a later phase.

**Files to modify:**
- `crates/mesh-rt/src/actor/mod.rs` -- `mesh_timer_send_after` (add type_tag parameter or new function)
- `crates/mesh-codegen/src/codegen/expr.rs` -- Codegen for Timer.send_after calls (pass type_tag)
- `crates/mesh-codegen/src/mir/lower.rs` -- MIR lowering for Timer.send_after (include handler tag)
- `crates/mesh-typeck/src/builtins.rs` -- Update Timer.send_after type signature

**Impact on future phases:** MEDIUM. Phase 92 (Alerting) uses a timer-driven evaluator. Phase 93 (Data Retention) uses daily timer for cleanup. The flush_ticker actor pattern works but is verbose. A working `Timer.send_after` with service dispatch support would simplify timer patterns throughout.

---

### Issue 7: Map.collect Integer Key Assumption (LOW)

**Symptom:** `Map.collect(iter)` always creates a map with integer key type, even when keys are strings.

**Root cause location:** `crates/mesh-rt/src/iter.rs` (lines 543-559, `mesh_map_collect`) and `crates/mesh-rt/src/collections/map.rs` (lines 96-98, `mesh_map_new`).

**Root cause analysis:**
`mesh_map_collect` calls `mesh_map_new()` which creates a map with `KEY_TYPE_INT` (line 97). The collected key-value pairs are inserted via `mesh_map_put(map, key, val)` where `key` is a raw `u64`. For string keys, `key` is actually a pointer to a string (cast to u64), but the map's internal key comparison uses integer equality, not string comparison. So string key lookups fail because pointer values are compared instead of string contents.

**Fix approach:** Either:
1. Add a `mesh_map_collect_typed(iter, key_type)` variant that accepts the key type
2. Detect the key type from the first element's type tag (requires runtime type information on the elements)
3. Have the codegen pass the key type when lowering `Map.collect`

Option 3 is cleanest: the compiler knows the type of the keys at compile time and can pass it to the runtime.

**Complexity:** LOW -- Add a key_type parameter to `mesh_map_collect` and have the codegen pass it based on the type information from the iterator's element type.

**Files to modify:**
- `crates/mesh-rt/src/iter.rs` -- `mesh_map_collect` (add key_type parameter)
- `crates/mesh-codegen/src/codegen/intrinsics.rs` -- Update intrinsic declaration
- `crates/mesh-codegen/src/mir/lower.rs` -- Pass key type when lowering Map.collect
- `crates/mesh-codegen/src/codegen/expr.rs` -- Codegen for Map.collect call

**Impact on future phases:** LOW-MEDIUM. Phase 89 (Error Grouping) uses Map for fingerprint caches with string keys. The workaround (manual `Map.put` in a fold) works. Phase 91 (REST API) aggregates query results into maps. The fix is small but the workaround is tolerable.

## Priority Assessment

### Priority Matrix

| Issue | Severity | Fix Complexity | Phase 88 Impact | Cumulative Impact (88-95) |
|-------|----------|---------------|-----------------|--------------------------|
| 1. ? operator codegen | CRITICAL | MEDIUM | Blocks idiomatic error handling | Every Result-returning function |
| 2. Err(e) alloca domination | HIGH | LOW | Blocks error value inspection | Error responses, logging |
| 3. Cross-module service export | HIGH | HIGH | Forces monolithic main.mpl | Compounds each phase |
| 4. Polymorphic types cross-module | HIGH | MEDIUM | Blocks generic utility functions | Code reuse throughout |
| 5. List.find Option matching | MEDIUM | LOW-MEDIUM | Workaround available | Common pattern |
| 6. Timer.send_after dispatch | MEDIUM | MEDIUM | Workaround available | 3+ phases use timers |
| 7. Map.collect key typing | LOW | LOW | Workaround available | 2-3 phases use Map.collect |

### Recommended Fix Order

**Batch 1 -- Codegen Fixes (Issues 1, 2, 5):** These share the same codebase (`crates/mesh-codegen/src/codegen/`) and address the most impactful pain points. Issue 2 is the easiest and may fix Issue 5. Issue 1 is the most critical.

**Batch 2 -- Module System Fixes (Issues 3, 4):** These share the typechecker codebase (`crates/mesh-typeck/src/`). Issue 4 (polymorphic type scoping) is a prerequisite for Issue 3 (service export) because exported service helper functions may have polymorphic types.

**Batch 3 -- Runtime Fixes (Issues 6, 7):** These are in the runtime (`crates/mesh-rt/src/`). Lower priority because workarounds are functional and straightforward.

## Related Issues Not Listed

During investigation, I identified these related concerns:

1. **No mutable variable assignment** -- Mesh has no `let mut` or reassignment. This is a language design choice, not a bug. The workaround (recursive helper functions) is verbose but idiomatic for functional languages. Not a fix target for this phase.

2. **Row struct all-String fields** -- PostgreSQL text protocol returns everything as strings. Row structs use `String` for all fields. This is a known limitation of the `deriving(Row)` macro. Not a fix target (would require binary protocol support).

3. **UUID columns cast to ::text** -- Required for `deriving(Row)` compatibility. Not a bug, just a workaround for the all-String field limitation above.

4. **Conservative GC** -- Noted in PROJECT.md as tech debt. Not related to Phase 87 issues but could affect Phase 88+ if memory usage grows with many actors.

## Risk Assessment

**Risk of fixing:** LOW. The codegen fixes (Batch 1) are well-isolated to specific code paths in `expr.rs` and `pattern.rs`. The module system fixes (Batch 2) are more invasive but the type system is well-tested with 700+ unit tests. The runtime fixes (Batch 3) are straightforward parameter additions.

**Risk of NOT fixing:** HIGH. Without the ? operator fix, Phase 88 will require approximately 30-40 explicit `case` blocks instead of `?`. Without cross-module services, main.mpl will grow to 1000+ lines by Phase 92. Without polymorphic type variable fixes, utility functions must be copy-pasted into each module.

**Test coverage:** The project has E2E tests in `tests/e2e/` and unit tests in each crate. Each fix should include:
- A new E2E test (`.mpl` file) that exercises the fixed behavior
- Regression tests to ensure existing code still compiles

## Implications for Planning

### Scope Recommendation

This phase should fix Issues 1-5 (Codegen + Module System). Issues 6-7 (Runtime) can be deferred to Phase 88 or later since their workarounds are simple and functional.

**Minimum viable phase:** Issues 1, 2, 5 (codegen batch) -- unblocks idiomatic Result handling.
**Full recommended phase:** Issues 1, 2, 3, 4, 5 -- unblocks both idiomatic Result handling AND modular service architecture.

### Plan Structure Recommendation

- **Plan 87.1-01:** Codegen fixes (Issues 1, 2, 5) -- ? operator, Err(e) binding, List.find Option matching
- **Plan 87.1-02:** Module system fixes (Issues 3, 4) -- cross-module service export, polymorphic type variable scoping
- **Plan 87.1-03 (optional):** Runtime fixes (Issues 6, 7) -- Timer.send_after dispatch, Map.collect key typing

### Key Files Summary

| Crate | File | Issues |
|-------|------|--------|
| mesh-codegen | `src/codegen/expr.rs` | 1, 5, 6 |
| mesh-codegen | `src/codegen/pattern.rs` | 2, 5 |
| mesh-codegen | `src/codegen/types.rs` | (reference for type layouts) |
| mesh-codegen | `src/mir/lower.rs` | 1, 6, 7 |
| mesh-typeck | `src/lib.rs` | 3, 4 |
| mesh-typeck | `src/infer.rs` | 3 |
| mesh-typeck | `src/unify.rs` | 4 |
| mesh-typeck | `src/ty.rs` | 4 |
| mesh-rt | `src/actor/mod.rs` | 6 |
| mesh-rt | `src/iter.rs` | 7 |
| mesh-rt | `src/collections/map.rs` | 7 |

### Verification Approach

After fixes, verify by:
1. Existing E2E test suite passes (`cargo test` in meshc)
2. New E2E tests for each fixed issue compile and run
3. Mesher project (`mesher/`) still compiles with `meshc build mesher/`
4. Mesher code can be refactored to use `?` operator and cross-module services (verification of fix effectiveness)

---

*Researched: 2026-02-14*
*Source: Direct analysis of Mesh compiler source code (crates/mesh-{codegen,typeck,rt}), Mesher application code (mesher/), Phase 87 plans and verification report*
