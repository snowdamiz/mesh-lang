---
phase: 87.1-issues-encountered
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-codegen/src/codegen/expr.rs
  - crates/mesh-codegen/src/codegen/pattern.rs
  - tests/e2e/try_operator_result.mpl
  - tests/e2e/err_binding_pattern.mpl
  - tests/e2e/list_find_option_match.mpl
autonomous: true

must_haves:
  truths:
    - "Functions returning Result<T, String> can use the ? operator without LLVM verification errors"
    - "Pattern matching Err(e) binds the error value correctly without alloca domination failures"
    - "case List.find(xs, pred) do Some(x) -> ... | None -> ... end compiles and runs correctly"
    - "All existing E2E tests continue to pass (no regressions)"
  artifacts:
    - path: "crates/mesh-codegen/src/codegen/expr.rs"
      provides: "Fixed codegen_return that handles ptr-to-struct type mismatch for Result returns"
    - path: "crates/mesh-codegen/src/codegen/pattern.rs"
      provides: "Fixed codegen_leaf with entry-block alloca placement for pattern variable bindings"
    - path: "tests/e2e/try_operator_result.mpl"
      provides: "E2E test proving ? operator works in Result-returning functions"
    - path: "tests/e2e/err_binding_pattern.mpl"
      provides: "E2E test proving Err(e) variable binding works in pattern matching"
    - path: "tests/e2e/list_find_option_match.mpl"
      provides: "E2E test proving List.find Option pattern matching works"
  key_links:
    - from: "crates/mesh-codegen/src/codegen/expr.rs"
      to: "crates/mesh-codegen/src/codegen/pattern.rs"
      via: "codegen_match calls codegen_leaf for pattern variable bindings"
      pattern: "codegen_leaf"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-codegen/src/codegen/expr.rs"
      via: "lower_try_result generates MirExpr::Return(ConstructVariant) consumed by codegen_return"
      pattern: "codegen_return"
---

<objective>
Fix three LLVM codegen bugs that prevent idiomatic Result/Option handling in Mesh.

Purpose: The ? operator, Err(e) binding, and List.find Option matching all produce LLVM verification errors during compilation. These force verbose workarounds (explicit case blocks, Err(_) wildcards, List.filter+List.length+List.get chains) that will compound across phases 88-95. Fixing them unblocks idiomatic error handling for the entire Mesher codebase.

Output: Three codegen fixes with E2E tests proving each issue is resolved, plus full regression suite passing.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/87.1-issues-encountered/87.1-RESEARCH.md
@crates/mesh-codegen/src/codegen/expr.rs
@crates/mesh-codegen/src/codegen/pattern.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Err(e) alloca domination and List.find Option matching (Issues 2 & 5)</name>
  <files>crates/mesh-codegen/src/codegen/pattern.rs, crates/mesh-codegen/src/codegen/expr.rs, tests/e2e/err_binding_pattern.mpl, tests/e2e/list_find_option_match.mpl</files>
  <action>
  Fix the `codegen_leaf` function in `pattern.rs` (lines 146-210) to place variable binding allocas in the function entry block, matching the pattern already used by `codegen_guard` (lines 429-461).

  Current broken code in `codegen_leaf` (line 179-182):
  ```rust
  let alloca = self.builder.build_alloca(llvm_ty, name).map_err(|e| e.to_string())?;
  ```
  This places the alloca at the current insertion point (inside a case block), causing LLVM's domination check to fail when subsequent code references the variable.

  Fix: Before the alloca, save the current block, get the function's entry block, position the builder at the entry block (before the first instruction), build the alloca there, then restore the builder position to the current block before the store. Copy the exact pattern from `codegen_guard` lines 438-456:
  ```rust
  let current_bb = self.builder.get_insert_block().unwrap();
  let fn_val = self.current_function();
  let entry_bb = fn_val.get_first_basic_block().unwrap();
  if let Some(first_instr) = entry_bb.get_first_instruction() {
      self.builder.position_before(&first_instr);
  } else {
      self.builder.position_at_end(entry_bb);
  }
  let alloca = self.builder.build_alloca(llvm_ty, name).map_err(|e| e.to_string())?;
  self.builder.position_at_end(current_bb);
  ```

  For Issue 5 (List.find Option matching): This is likely the same root cause as Issue 2 -- the `Some(x)` binding creates an alloca inside the switch case block. After fixing `codegen_leaf`, test if `case List.find(xs, pred) do Some(x) -> ... | None -> ... end` compiles. If it still fails, also check `codegen_match` (lines 1384-1390) -- when the scrutinee is a direct pointer to a sum type (from a function call like List.find), it uses the pointer directly as `scrutinee_alloca`. If this causes GEP alignment issues, add a load-to-local-alloca step: allocate a local `{ i8, ptr }`, load the heap struct into it, then use that alloca as scrutinee.

  Create E2E test `tests/e2e/err_binding_pattern.mpl`:
  - Define a function returning `Result<Int, String>` that uses `case` with `Err(e)` binding
  - Verify the error value `e` is accessible and can be used (e.g., string concatenation)
  - Print success message

  Create E2E test `tests/e2e/list_find_option_match.mpl`:
  - Create a list of integers
  - Use `List.find` with a predicate
  - Pattern match the result with `Some(x)` and `None` arms
  - Print the found value or "not found"
  </action>
  <verify>
  ```bash
  cd /Users/sn0w/Documents/dev/snow && cargo test -p meshc -- err_binding 2>&1 | tail -5
  cd /Users/sn0w/Documents/dev/snow && cargo test -p meshc -- list_find_option 2>&1 | tail -5
  ```
  Both tests must compile and pass without LLVM verification errors.
  </verify>
  <done>
  Err(e) variable binding in pattern matching compiles and runs. List.find Option pattern matching compiles and runs. No LLVM alloca domination errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix ? operator LLVM codegen return type mismatch (Issue 1)</name>
  <files>crates/mesh-codegen/src/codegen/expr.rs, tests/e2e/try_operator_result.mpl</files>
  <action>
  Fix the `codegen_return` function in `expr.rs` (lines 1713-1723) to handle the ptr-to-struct type mismatch that occurs when the ? operator's early return path produces a `ptr` value but the function's declared LLVM return type is a struct (like `{ i8, ptr }` for Result).

  Current code:
  ```rust
  fn codegen_return(&mut self, inner: &MirExpr) -> Result<BasicValueEnum<'ctx>, String> {
      let val = self.codegen_expr(inner)?;
      self.builder.build_return(Some(&val)).map_err(|e| e.to_string())?;
      Ok(self.context.struct_type(&[], false).const_zero().into())
  }
  ```

  The problem: `codegen_expr(inner)` may produce a `ptr` value (from `codegen_construct_variant` which allocates the Result struct on the stack and returns a pointer), but `build_return` expects the value to match the function's return type (a struct, not a pointer to a struct).

  Fix approach: After getting `val` from `codegen_expr(inner)`, check if `val` is a pointer and the function's return type is a struct type. If so, load the struct from the pointer before returning:

  ```rust
  fn codegen_return(&mut self, inner: &MirExpr) -> Result<BasicValueEnum<'ctx>, String> {
      let val = self.codegen_expr(inner)?;

      // When the inner expression produces a pointer but the function returns
      // a struct type (e.g., Result's { i8, ptr }), load the struct value
      // from the pointer before the return instruction.
      let fn_val = self.current_function();
      let ret_ty = fn_val.get_type().get_return_type();
      let return_val = if val.is_pointer_value() {
          if let Some(ret_ty) = ret_ty {
              if ret_ty.is_struct_type() {
                  self.builder
                      .build_load(ret_ty, val.into_pointer_value(), "ret_load")
                      .map_err(|e| e.to_string())?
              } else {
                  val
              }
          } else {
              val
          }
      } else {
          val
      };

      self.builder.build_return(Some(&return_val)).map_err(|e| e.to_string())?;
      Ok(self.context.struct_type(&[], false).const_zero().into())
  }
  ```

  IMPORTANT: Also check `codegen_construct_variant` to understand what type it returns. If it returns a pointer to a heap-allocated variant struct, the fix above handles it. If the issue is instead that `codegen_construct_variant` should be returning the struct value directly (not a pointer), fix it there instead -- but the return-site fix is safer as it handles all cases.

  Create E2E test `tests/e2e/try_operator_result.mpl`:
  - Define a helper function returning `Result<Int, String>` (e.g., parse-like function)
  - Define a function returning `Result<String, String>` that calls the helper with `?`
  - Call the function with both Ok and Err inputs
  - Print results to verify both paths work

  After the fix, run the FULL test suite to check for regressions. The return-site change affects ALL returns, not just Result types, so any regression will show up in existing tests.
  </action>
  <verify>
  ```bash
  cd /Users/sn0w/Documents/dev/snow && cargo test -p meshc -- try_operator_result 2>&1 | tail -5
  cd /Users/sn0w/Documents/dev/snow && cargo test -p meshc 2>&1 | tail -20
  ```
  The try_operator_result test must pass. The full test suite must pass with no regressions.
  </verify>
  <done>
  The ? operator works in functions returning Result<T, String>. Functions can chain multiple ? calls. All existing E2E tests still pass (no regressions from the return codegen change).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p meshc` -- ALL tests pass (existing + 3 new E2E tests)
2. `cargo test -p meshc -- try_operator` -- ? operator test compiles and runs
3. `cargo test -p meshc -- err_binding` -- Err(e) binding test compiles and runs
4. `cargo test -p meshc -- list_find_option` -- List.find Option matching test compiles and runs
5. No LLVM verification errors in any test output
</verification>

<success_criteria>
- Three codegen bugs fixed (? operator, Err(e) binding, List.find Option matching)
- Three new E2E tests proving each fix
- Zero regressions in existing test suite
- Mesher project (`mesher/`) still compiles if applicable
</success_criteria>

<output>
After completion, create `.planning/phases/87.1-issues-encountered/87.1-01-SUMMARY.md`
</output>
