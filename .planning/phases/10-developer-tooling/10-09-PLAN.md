---
phase: 10-developer-tooling
plan: 09
type: execute
wave: 2
depends_on: ["10-08"]
files_modified:
  - crates/snow-lsp/src/server.rs
  - crates/snow-lsp/src/analysis.rs
  - crates/snow-lsp/src/definition.rs
autonomous: true

must_haves:
  truths:
    - "Go-to-definition on a function name jumps to its definition"
    - "Go-to-definition on a variable name jumps to its let binding"
    - "Go-to-definition on a type name jumps to its struct/type definition"
  artifacts:
    - path: "crates/snow-lsp/src/definition.rs"
      provides: "Go-to-definition resolution via CST traversal"
      contains: "fn find_definition"
  key_links:
    - from: "crates/snow-lsp/src/server.rs"
      to: "crates/snow-lsp/src/definition.rs"
      via: "goto_definition handler calls find_definition"
      pattern: "find_definition"
    - from: "crates/snow-lsp/src/definition.rs"
      to: "crates/snow-parser/src/lib.rs"
      via: "CST traversal to find definition nodes"
      pattern: "SyntaxNode"
---

<objective>
Add go-to-definition support to the LSP server by resolving identifiers to their definition sites via CST traversal.

Purpose: Go-to-definition is one of the three required LSP features (alongside diagnostics and hover). It enables code navigation in editors.
Output: Go-to-definition for functions, variables, types, and module members.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-08-SUMMARY.md
@crates/snow-lsp/src/server.rs
@crates/snow-lsp/src/analysis.rs
@crates/snow-parser/src/syntax_kind.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Go-to-definition via CST traversal</name>
  <files>
    crates/snow-lsp/src/definition.rs
    crates/snow-lsp/src/server.rs
    crates/snow-lsp/src/analysis.rs
    crates/snow-lsp/src/lib.rs
  </files>
  <action>
1. Create `crates/snow-lsp/src/definition.rs`:

   - `pub fn find_definition(parse: &snow_parser::Parse, offset: usize) -> Option<rowan::TextRange>`:
     a. Find the token at the given byte offset in the CST
     b. Determine what kind of name reference it is:
        - NAME_REF (variable or function reference)
        - Type name (in type annotations)
        - Module-qualified name (e.g., String.length)
     c. Extract the name text from the token
     d. Walk the CST upward and backward to find the definition:

   **For variable/function references (NAME_REF):**
   - Walk up the tree to find enclosing blocks
   - In each block, search earlier siblings for:
     - LET_STMT with matching IDENT_PAT name -> return the IDENT_PAT range
     - FN_DEF with matching NAME -> return the NAME range
   - If not found in current block, walk to parent block and repeat
   - For top-level: search all FN_DEF, ACTOR_DEF, SERVICE_DEF names in SOURCE_FILE

   **For type names:**
   - Search SOURCE_FILE for STRUCT_DEF, TYPE_ALIAS_DEF, SUM_TYPE_DEF with matching name
   - Return the name token range

   **For module-qualified names (e.g., String.length):**
   - If base is a known module (from MODULE_DEF), find the module, then find the function within
   - For built-in modules (String, List, Map, etc.): return None (no source definition)

2. Store the parsed CST in AnalysisResult so go-to-definition can traverse it.

3. Implement `goto_definition()` in server.rs:
   ```rust
   async fn goto_definition(&self, params: GotoDefinitionParams) -> Result<Option<GotoDefinitionResponse>> {
       let uri = params.text_document_position_params.text_document.uri.to_string();
       let position = params.text_document_position_params.position;
       // Look up document analysis
       // Convert LSP position to byte offset
       // Call find_definition
       // Convert TextRange back to LSP Location
       // Return GotoDefinitionResponse::Scalar(location)
   }
   ```

4. Add `pub mod definition;` to lib.rs.

5. Write tests:
   - Find definition of variable used after let binding
   - Find definition of function called after fn def
   - Find definition of type in type annotation
   - Return None for built-in functions (IO.puts, etc.)
   - Nested scopes: inner let shadows outer, go-to-definition finds inner binding
  </action>
  <verify>
`cargo test -p snow-lsp` passes. Go-to-definition tests find correct definition locations.
  </verify>
  <done>
Go-to-definition resolves variable references to let bindings, function calls to fn definitions, and type names to struct/type definitions. Module-qualified names resolve within user modules. Built-ins return None.
  </done>
</task>

<task type="auto">
  <name>Task 2: LSP integration tests</name>
  <files>
    crates/snow-lsp/src/analysis.rs
  </files>
  <action>
1. Add comprehensive integration tests for the full LSP analysis pipeline:

   **Diagnostics tests:**
   - Valid program: zero diagnostics
   - Type mismatch: diagnostic with E0001 code, correct range, error severity
   - Parse error: diagnostic with P0001 code, correct range
   - Warning (redundant arm): diagnostic with W0001 code, warning severity
   - Multiple errors: all diagnostics reported

   **Hover tests:**
   - Hover over integer literal: shows "Int"
   - Hover over string literal: shows "String"
   - Hover over function call: shows return type
   - Hover over function name at definition: shows full signature
   - Hover over let-bound variable: shows inferred type
   - Hover over empty space: returns None

   **Go-to-definition tests:**
   - Function defined at line 1, called at line 5: definition at line 1
   - Let binding at line 3, used at line 7: definition at line 3
   - Variable shadowing: inner scope definition found
   - Struct name used in type annotation: resolves to struct definition
   - Unknown identifier: returns None

   **Position conversion tests:**
   - Single-line source: offset 0 = (0,0), offset 5 = (0,5)
   - Multi-line source: first char of line 2 = (1, 0)
   - UTF-16 edge cases: ASCII-only (all 1:1 mapping)

2. All tests should use analyze_document() directly (no need for actual LSP protocol in unit tests).
  </action>
  <verify>
`cargo test -p snow-lsp` passes. All diagnostics, hover, and go-to-definition tests pass.
  </verify>
  <done>
Comprehensive test suite covering diagnostics (errors, warnings, multiple), hover (all expression types), go-to-definition (functions, variables, types, shadowing), and position conversion.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-lsp` -- all tests pass
2. `cargo build --workspace` -- workspace compiles
3. Go-to-definition resolves for functions, variables, and types
</verification>

<success_criteria>
- Go-to-definition works for function calls, variable references, and type names
- LSP integration tests verify diagnostics, hover, and go-to-definition
- All existing LSP functionality (diagnostics, hover) still works
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-09-SUMMARY.md`
</output>
