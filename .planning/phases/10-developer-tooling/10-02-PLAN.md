---
phase: 10-developer-tooling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/snow-fmt/Cargo.toml
  - crates/snow-fmt/src/lib.rs
  - crates/snow-fmt/src/ir.rs
  - crates/snow-fmt/src/printer.rs
  - crates/snow-fmt/src/walker.rs
autonomous: true

must_haves:
  truths:
    - "Formatting a valid Snow source file produces correctly indented output with 2-space indentation"
    - "Formatting is idempotent: format(format(source)) == format(source)"
    - "Comments are preserved in their original positions relative to code"
    - "The formatter respects 100-column line width default"
  artifacts:
    - path: "crates/snow-fmt/src/lib.rs"
      provides: "Public format_source() API"
      exports: ["format_source", "FormatConfig"]
    - path: "crates/snow-fmt/src/ir.rs"
      provides: "Wadler-Lindig format IR types"
      contains: "enum FormatIR"
    - path: "crates/snow-fmt/src/walker.rs"
      provides: "CST-to-FormatIR walker"
      contains: "fn walk_node"
    - path: "crates/snow-fmt/src/printer.rs"
      provides: "FormatIR-to-String renderer respecting line width"
      contains: "fn print"
  key_links:
    - from: "crates/snow-fmt/src/lib.rs"
      to: "crates/snow-parser/src/lib.rs"
      via: "parse() call to get CST"
      pattern: "snow_parser::parse"
    - from: "crates/snow-fmt/src/walker.rs"
      to: "crates/snow-fmt/src/ir.rs"
      via: "walker produces FormatIR nodes"
      pattern: "FormatIR"
    - from: "crates/snow-fmt/src/printer.rs"
      to: "crates/snow-fmt/src/ir.rs"
      via: "printer consumes FormatIR"
      pattern: "FormatIR"
---

<objective>
Create the snow-fmt crate implementing a CST-based code formatter using Wadler-Lindig document IR for Snow source code.

Purpose: A canonical code formatter (like gofmt/rustfmt) eliminates style debates and ensures consistent code across the Snow ecosystem. The CST-based approach preserves comments and trivia.
Output: snow-fmt crate with FormatIR, CST walker, printer, and format_source() public API.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-RESEARCH.md
@crates/snow-parser/src/lib.rs
@crates/snow-parser/src/syntax_kind.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snow-fmt crate with FormatIR and printer</name>
  <files>
    Cargo.toml
    crates/snow-fmt/Cargo.toml
    crates/snow-fmt/src/lib.rs
    crates/snow-fmt/src/ir.rs
    crates/snow-fmt/src/printer.rs
  </files>
  <action>
1. Add `"crates/snow-fmt"` to workspace members in root Cargo.toml.

2. Create `crates/snow-fmt/Cargo.toml`:
   - Dependencies: snow-parser (path), snow-common (path), rowan (workspace)
   - Dev-dependencies: insta (workspace)

3. Create `crates/snow-fmt/src/ir.rs` with the Wadler-Lindig format IR:
```rust
pub enum FormatIR {
    Text(String),          // Literal text
    Space,                 // Single space (can be replaced by newline in break mode)
    Hardline,              // Always a newline
    Indent(Box<FormatIR>), // Increase indent for child
    Group(Box<FormatIR>),  // Try flat first, break if exceeds width
    IfBreak {              // Different content based on break mode
        flat: Box<FormatIR>,
        broken: Box<FormatIR>,
    },
    Concat(Vec<FormatIR>), // Sequence of IR nodes
    Empty,                 // Nothing
}
```
Add helper constructors: `text(s)`, `space()`, `hardline()`, `indent(ir)`, `group(ir)`, `concat(vec)`, `if_break(flat, broken)`.

4. Create `crates/snow-fmt/src/printer.rs` implementing the Wadler-Lindig algorithm:
   - `pub fn print(ir: &FormatIR, config: &FormatConfig) -> String`
   - `FormatConfig` struct with `indent_size: usize` (default 2) and `max_width: usize` (default 100)
   - The printer walks the IR with a stack of `(indent_level, break_mode, ir_node)` triples
   - For `Group`: measure flat width; if fits on remaining line, render flat; otherwise render broken
   - For `Space` in flat mode: emit " "; in broken mode: emit newline + indent
   - For `Indent`: increase current indent by config.indent_size
   - For `Hardline`: always emit newline + indent
   - For `IfBreak`: emit flat variant in flat mode, broken variant in broken mode

5. Create `crates/snow-fmt/src/lib.rs`:
   - `pub mod ir;`
   - `pub mod printer;`
   - `pub mod walker;` (declare module, will be implemented in Task 2)
   - Re-export `FormatConfig` and `format_source()`
   - `format_source(source: &str, config: &FormatConfig) -> String` that parses, walks CST, prints

6. Write unit tests for the printer in printer.rs:
   - Test that `Group(Concat([Text("a"), Space, Text("b")]))` renders as "a b" when it fits
   - Test that a group exceeding max_width breaks across lines with proper indentation
   - Test `Hardline` always produces newlines
   - Test `IfBreak` selects correct variant
  </action>
  <verify>
`cargo test -p snow-fmt` passes (printer unit tests). `cargo check -p snow-fmt` compiles.
  </verify>
  <done>
snow-fmt crate exists with FormatIR enum, Wadler-Lindig printer, and FormatConfig. Printer unit tests verify flat/broken rendering logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: CST walker that converts Snow syntax tree to FormatIR</name>
  <files>
    crates/snow-fmt/src/walker.rs
    crates/snow-fmt/src/lib.rs
  </files>
  <action>
1. Create `crates/snow-fmt/src/walker.rs` implementing `walk_node(node: &SyntaxNode) -> FormatIR`:
   - Walk the rowan CST in token order (preserving trivia/comments)
   - For each SyntaxKind, produce appropriate FormatIR:

   **Top-level items** (FN_DEF, ACTOR_DEF, MODULE_DEF, STRUCT_DEF, etc.):
   - Emit keyword + name + params, then Group(Indent(body)), then "end"
   - Separate top-level items with Hardline + Hardline (blank line between)

   **do/end blocks:**
   - `do` keyword on same line, body indented, `end` on own line at parent indent
   - Pattern: `Group(Concat([Text("do"), Indent(Hardline + body), Hardline, Text("end")]))`

   **Expressions:**
   - Binary ops: `Group(Concat([lhs, Space, op, Space, rhs]))` -- allows line break before operator
   - Pipe operator: always break after `|>` (Hardline + Indent for chained pipes)
   - Function calls: `name(Group(args))` where args are comma-separated with IfBreak
   - If/else: `if cond do ... else ... end` with standard indentation

   **Let bindings:**
   - `let name = expr` on one line if fits, break after `=` if not

   **Match/case:**
   - Each arm on its own line, indented within do/end

   **Comments:**
   - CRITICAL: Process ALL tokens including trivia tokens in CST order
   - Comments (COMMENT SyntaxKind) emit as Text with their original content
   - Preserve comment position: if comment was on its own line, keep it on own line
   - If comment was after code on same line, keep it after code with spaces

   **Trivia handling:**
   - Walk `children_with_tokens()` to get both nodes and tokens in order
   - For tokens: emit Text with token text, appropriate spacing
   - For NEWLINE tokens: track but don't blindly emit (formatter controls newlines)
   - Preserve blank lines between top-level items (max 1 blank line)

2. Wire `walk_node` into `format_source()` in lib.rs:
   ```rust
   pub fn format_source(source: &str, config: &FormatConfig) -> String {
       let parse = snow_parser::parse(source);
       let root = parse.syntax();
       let ir = walker::walk_node(&root);
       printer::print(&ir, config)
   }
   ```

3. Write integration tests that format known Snow snippets and verify output:
   - Simple `let x = 1` stays on one line
   - `fn add(a, b) do ... end` formats with 2-space indent
   - Long expressions break across lines at 100 columns
   - Comments are preserved
   - Idempotency: `format_source(format_source(src)) == format_source(src)` for 5+ test cases
   - Blank line between top-level functions is preserved (exactly one)
  </action>
  <verify>
`cargo test -p snow-fmt` passes (all walker + integration tests). Idempotency tests pass for all test cases.
  </verify>
  <done>
CST walker converts Snow syntax tree to FormatIR for all major constructs. Comments preserved. Formatting is idempotent. Integration tests verify correct output.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-fmt` -- all unit and integration tests pass
2. `cargo check --workspace` -- workspace compiles with new crate
3. Idempotency: `format(format(x)) == format(x)` for all test inputs
4. Comments survive formatting unchanged
</verification>

<success_criteria>
- snow-fmt crate exists with FormatIR, printer, and CST walker
- format_source() formats Snow code with 2-space indent and 100-col width
- Formatting is idempotent
- Comments are preserved in correct positions
- All workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-02-SUMMARY.md`
</output>
