---
phase: 10-developer-tooling
plan: 07
type: execute
wave: 2
depends_on: ["10-06"]
files_modified:
  - crates/snow-pkg/src/scaffold.rs
  - crates/snow-pkg/src/lib.rs
  - crates/snowc/src/main.rs
  - crates/snowc/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Running snowc init <name> creates a project directory with snow.toml and main.snow"
    - "Running snowc deps in a project with snow.toml resolves dependencies and creates snow.lock"
    - "Running snowc deps when snow.lock exists and is fresh skips resolution"
  artifacts:
    - path: "crates/snow-pkg/src/scaffold.rs"
      provides: "Project scaffolding for snowc init"
      contains: "fn scaffold_project"
    - path: "crates/snowc/src/main.rs"
      provides: "init and deps subcommands"
      contains: "Init"
  key_links:
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-pkg/src/lib.rs"
      via: "scaffold_project and resolve_dependencies calls"
      pattern: "snow_pkg::scaffold_project"
---

<objective>
Add `snowc init` for project scaffolding and `snowc deps` for dependency resolution to the CLI.

Purpose: Project initialization creates the standard Snow project layout. Dependency resolution fetches and locks git-based dependencies.
Output: snowc init and snowc deps subcommands.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-06-SUMMARY.md
@crates/snowc/src/main.rs
@crates/snow-pkg/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffolding (snowc init)</name>
  <files>
    crates/snow-pkg/src/scaffold.rs
    crates/snow-pkg/src/lib.rs
  </files>
  <action>
1. Create `crates/snow-pkg/src/scaffold.rs`:
   - `pub fn scaffold_project(name: &str, dir: &Path) -> Result<(), String>`
   - Creates directory structure (minimal layout per discretion):
     ```
     <name>/
       snow.toml
       main.snow
     ```
   - snow.toml content:
     ```toml
     [package]
     name = "<name>"
     version = "0.1.0"

     [dependencies]
     ```
   - main.snow content:
     ```
     fn main() do
       IO.puts("Hello from Snow!")
     end
     ```
   - If directory already exists: return error "Directory '<name>' already exists"
   - Print: "Created project '<name>'"

2. Add `pub mod scaffold;` to lib.rs and re-export `scaffold_project`.

3. Write tests:
   - scaffold_project creates correct directory structure
   - snow.toml is valid (can be parsed by Manifest::from_str)
   - Error when directory exists
  </action>
  <verify>
`cargo test -p snow-pkg` passes. Scaffold creates correct files.
  </verify>
  <done>
scaffold_project creates a minimal Snow project with snow.toml and main.snow. Error handling for existing directories.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add snowc init and snowc deps subcommands</name>
  <files>
    crates/snowc/src/main.rs
    crates/snowc/Cargo.toml
  </files>
  <action>
1. Add `snow-pkg = { path = "../snow-pkg" }` to snowc Cargo.toml dependencies.

2. Add `Init` and `Deps` variants to the `Commands` enum:
   ```rust
   /// Initialize a new Snow project
   Init {
       /// Project name (creates directory with this name)
       name: String,
   },
   /// Resolve and fetch dependencies
   Deps {
       /// Project directory (default: current directory)
       #[arg(default_value = ".")]
       dir: PathBuf,
   },
   ```

3. Implement Init handler:
   ```rust
   Commands::Init { name } => {
       let dir = std::env::current_dir().unwrap_or_default();
       if let Err(e) = snow_pkg::scaffold_project(&name, &dir) {
           eprintln!("error: {}", e);
           process::exit(1);
       }
   }
   ```

4. Implement Deps handler:
   - Read snow.toml from dir
   - Call resolve_dependencies()
   - Write snow.lock to dir
   - Print summary: "Resolved N dependencies" or "No dependencies"
   - If snow.lock already exists and matches current snow.toml (compare dependency specs): print "Dependencies up to date" and skip

5. Update the `build` command to check for snow.toml:
   - If snow.toml exists in the project dir but snow.lock is missing, warn: "Run `snowc deps` first to resolve dependencies"
   - This is just a warning, don't block the build (deps might be path-based and already present)

6. Write tests:
   - `snowc init myproject` creates directory with expected files
   - `snowc deps` in a project with no dependencies succeeds
   - `snowc deps` in a project with path dependencies resolves and creates snow.lock
  </action>
  <verify>
`cargo test -p snowc` passes. `cargo build -p snowc` compiles. `./target/debug/snowc init test-project` creates project structure.
  </verify>
  <done>
`snowc init <name>` creates project scaffolds. `snowc deps` resolves dependencies and generates snow.lock. Build command warns about missing snow.lock.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-pkg` -- scaffold tests pass
2. `cargo test -p snowc` -- CLI integration tests pass
3. `cargo build --workspace` -- workspace compiles
4. Manual: `snowc init hello && cd hello && snowc build .` works end-to-end
</verification>

<success_criteria>
- `snowc init <name>` creates a valid project with snow.toml and main.snow
- `snowc deps` resolves dependencies and generates snow.lock
- Fresh lockfile skips resolution
- Integration with build command (warning for missing lock)
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-07-SUMMARY.md`
</output>
