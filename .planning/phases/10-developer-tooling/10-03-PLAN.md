---
phase: 10-developer-tooling
plan: 03
type: execute
wave: 2
depends_on: ["10-02"]
files_modified:
  - crates/snowc/src/main.rs
  - crates/snowc/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Running snowc fmt <file> formats the file in-place with canonical style"
    - "Running snowc fmt --check <file> exits 0 if already formatted, exits 1 if not"
    - "Running snowc fmt on an already-formatted file produces identical output"
  artifacts:
    - path: "crates/snowc/src/main.rs"
      provides: "fmt subcommand implementation"
      contains: "Fmt"
  key_links:
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-fmt/src/lib.rs"
      via: "format_source() call from fmt subcommand"
      pattern: "snow_fmt::format_source"
---

<objective>
Add the `snowc fmt` subcommand that formats Snow source files in-place with a canonical style, with a --check mode for CI.

Purpose: The CLI integration makes the formatter accessible via the standard toolchain command, matching the gofmt/rustfmt convention.
Output: snowc fmt subcommand with in-place formatting and --check mode.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-02-SUMMARY.md
@crates/snowc/src/main.rs
@crates/snowc/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add snowc fmt subcommand with in-place and --check modes</name>
  <files>
    crates/snowc/src/main.rs
    crates/snowc/Cargo.toml
  </files>
  <action>
1. Add `snow-fmt = { path = "../snow-fmt" }` to snowc Cargo.toml dependencies.

2. Add `Fmt` variant to the `Commands` enum in main.rs:
   ```rust
   /// Format Snow source files
   Fmt {
       /// Path to a Snow source file (or directory to format all .snow files)
       path: PathBuf,
       /// Check if files are formatted (exit 1 if not, don't modify)
       #[arg(long)]
       check: bool,
       /// Line width (default: 100)
       #[arg(long, default_value = "100")]
       line_width: usize,
       /// Indent size (default: 2)
       #[arg(long, default_value = "2")]
       indent_size: usize,
   }
   ```

3. Implement the `fmt` function:
   - If path is a file: format that single file
   - If path is a directory: recursively find all `.snow` files and format each
   - For each file:
     a. Read source
     b. Create FormatConfig with user-specified line_width and indent_size
     c. Call `snow_fmt::format_source(&source, &config)`
     d. In normal mode: write formatted output back to file (only if changed, to preserve mtime)
     e. In --check mode: compare formatted output with original. If different, print filename and set exit code 1. If same, do nothing.
   - In --check mode, after processing all files: exit 0 if all formatted, exit 1 if any differ
   - Print summary: "Formatted N file(s)" or "N file(s) would be reformatted" (--check mode)

4. Wire the Fmt command in main()'s match block.

5. Write tests:
   - Create a temp .snow file with bad formatting, run fmt, verify output is canonical
   - Run fmt on already-formatted file, verify file unchanged
   - Run fmt --check on unformatted file, verify exit code 1
   - Run fmt --check on formatted file, verify exit code 0
   - Run fmt on a directory with multiple .snow files
  </action>
  <verify>
`cargo test -p snowc` passes. `cargo build -p snowc` compiles. Manual test: create `/tmp/test.snow` with unformatted code, run `./target/debug/snowc fmt /tmp/test.snow`, verify file is reformatted.
  </verify>
  <done>
`snowc fmt <path>` formats files in-place. `snowc fmt --check <path>` exits 1 if unformatted. --line-width and --indent-size options work. Directory mode recursively formats all .snow files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Formatter idempotency and edge case tests</name>
  <files>
    crates/snow-fmt/src/lib.rs
  </files>
  <action>
1. Add a comprehensive suite of idempotency tests in snow-fmt/src/lib.rs (or a tests/ directory):

   Test inputs covering all Snow constructs:
   - Empty file
   - Single let binding
   - Function with do/end block
   - Nested if/else
   - Case/match with multiple arms
   - Module with imports
   - Actor block with receive
   - Supervisor block
   - Service definition with call/cast handlers
   - Pipe operator chains
   - String interpolation
   - Comments (line comments, inline comments)
   - Long lines that need wrapping
   - Multiple blank lines between items (should collapse to 1)

2. For each test input, assert:
   ```rust
   let formatted = format_source(input, &FormatConfig::default());
   let double_formatted = format_source(&formatted, &FormatConfig::default());
   assert_eq!(formatted, double_formatted, "Idempotency failed for: {}", test_name);
   ```

3. Add snapshot tests (insta) for formatted output of representative Snow programs to catch regressions.

4. Edge cases to test:
   - File with only comments
   - Deeply nested expressions (5+ levels)
   - Very long string literals (should not be wrapped)
   - Trailing whitespace removal
   - Consistent newline at end of file (always add trailing newline)
  </action>
  <verify>
`cargo test -p snow-fmt` passes. All idempotency assertions hold. Snapshot tests match expected output.
  </verify>
  <done>
Comprehensive idempotency test suite covering all Snow language constructs. Snapshot tests for formatted output. Edge cases handled (comments-only files, deep nesting, trailing whitespace).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-fmt` -- all tests including idempotency suite
2. `cargo test -p snowc` -- CLI integration tests
3. `cargo build --workspace` -- full workspace compiles
</verification>

<success_criteria>
- `snowc fmt <file>` formats in-place by default
- `snowc fmt --check <file>` exits 1 if unformatted, 0 if formatted
- format(format(x)) == format(x) for all test inputs
- All Snow language constructs format correctly
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-03-SUMMARY.md`
</output>
