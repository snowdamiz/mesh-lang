---
phase: 10-developer-tooling
plan: 05
type: execute
wave: 2
depends_on: ["10-04"]
files_modified:
  - crates/snow-repl/src/lib.rs
  - crates/snow-repl/src/jit.rs
  - crates/snowc/src/main.rs
  - crates/snowc/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Running snowc repl starts an interactive session with a prompt"
    - "Expressions evaluate and display results with types"
    - "Actor spawn/send/receive work in the REPL"
    - "REPL exits cleanly on :quit or Ctrl-D"
  artifacts:
    - path: "crates/snowc/src/main.rs"
      provides: "repl subcommand"
      contains: "Repl"
  key_links:
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-repl/src/lib.rs"
      via: "run_repl() call from repl subcommand"
      pattern: "snow_repl::run_repl"
    - from: "crates/snow-repl/src/jit.rs"
      to: "crates/snow-rt"
      via: "Runtime initialization for actor support"
      pattern: "snow_rt_init"
---

<objective>
Integrate the REPL with actor runtime support and add the `snowc repl` CLI subcommand.

Purpose: The REPL must support actors because Snow's identity is concurrent -- users need to test spawn/send/receive interactively. The CLI integration makes the REPL accessible.
Output: snowc repl subcommand with working actor support and rustyline-based line editing.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-04-SUMMARY.md
@crates/snowc/src/main.rs
@crates/snow-repl/src/lib.rs
@crates/snow-repl/src/jit.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Actor runtime initialization and REPL loop with rustyline</name>
  <files>
    crates/snow-repl/src/lib.rs
    crates/snow-repl/src/jit.rs
  </files>
  <action>
1. Implement the full `run_repl()` loop in lib.rs using rustyline:
   ```rust
   pub fn run_repl(config: &ReplConfig) -> Result<(), String> {
       let mut editor = rustyline::DefaultEditor::new().map_err(|e| e.to_string())?;
       let mut session = session::ReplSession::new();

       println!("Snow REPL v0.1.0 (type :help for commands)");

       // Initialize actor runtime in background thread per research
       init_actor_runtime();

       let mut input_buffer = String::new();
       let mut in_multiline = false;

       loop {
           let prompt = if in_multiline { &config.continuation } else { &config.prompt };
           match editor.readline(prompt) {
               Ok(line) => {
                   if in_multiline {
                       input_buffer.push('\n');
                       input_buffer.push_str(&line);
                       if is_input_complete(&input_buffer) {
                           in_multiline = false;
                           let input = std::mem::take(&mut input_buffer);
                           process_input(&input, &mut session);
                           editor.add_history_entry(&input).ok();
                       }
                   } else if line.starts_with(':') {
                       match process_command(&line, &mut session) {
                           CommandResult::Quit => break,
                           CommandResult::Output(s) => println!("{}", s),
                           CommandResult::TypeInfo(s) => println!("{}", s),
                           CommandResult::Error(s) => eprintln!("Error: {}", s),
                           CommandResult::Continue => {}
                       }
                       editor.add_history_entry(&line).ok();
                   } else if !line.trim().is_empty() {
                       if is_input_complete(&line) {
                           process_input(&line, &mut session);
                           editor.add_history_entry(&line).ok();
                       } else {
                           in_multiline = true;
                           input_buffer = line;
                       }
                   }
               }
               Err(rustyline::error::ReadlineError::Eof) => break,
               Err(rustyline::error::ReadlineError::Interrupted) => {
                   if in_multiline {
                       in_multiline = false;
                       input_buffer.clear();
                       println!("(input cancelled)");
                   } else {
                       println!("(use :quit or Ctrl-D to exit)");
                   }
               }
               Err(e) => return Err(e.to_string()),
           }
       }

       println!("Goodbye!");
       Ok(())
   }
   ```

2. Implement `process_input()`:
   - Call `jit::jit_eval(&input, &mut session)`
   - On Ok(result): print `result.value :: result.ty`
   - On Err(msg): print error message

3. Add actor runtime initialization in jit.rs:
   - CRITICAL per research: Run scheduler in background thread, don't call `run_scheduler()` on main thread
   - Call `snow_rt_init_actor` (or equivalent) via JIT to initialize the actor system
   - The runtime init should happen ONCE at REPL startup
   - Use `extern "C"` function declarations to link against snow-rt symbols
   - The JIT's execution engine needs snow-rt symbols available. Link snow-rt statically into the REPL binary by adding snow-rt as a dependency and using `extern "C"` declarations.

4. Test actor support:
   - After runtime init, JIT-evaluated code that calls `spawn` should work
   - Messages sent between actors should be delivered
   - NOTE: Full actor E2E testing will be in Plan 10. Here, ensure the runtime initializes without crashing and basic spawn works.
  </action>
  <verify>
`cargo test -p snow-repl` passes. `cargo build -p snow-repl` compiles with rustyline and snow-rt linked.
  </verify>
  <done>
REPL loop runs with rustyline line editing, multi-line support, command processing, and actor runtime initialized in background. Expressions evaluate and display results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add snowc repl subcommand</name>
  <files>
    crates/snowc/src/main.rs
    crates/snowc/Cargo.toml
  </files>
  <action>
1. Add `snow-repl = { path = "../snow-repl" }` to snowc Cargo.toml dependencies.

2. Add `Repl` variant to the `Commands` enum:
   ```rust
   /// Start an interactive REPL
   Repl,
   ```

3. Wire in main():
   ```rust
   Commands::Repl => {
       if let Err(e) = snow_repl::run_repl(&snow_repl::ReplConfig::default()) {
           eprintln!("REPL error: {}", e);
           process::exit(1);
       }
   }
   ```

4. Implement `Default` for `ReplConfig` in snow-repl:
   - prompt: "snow> "
   - continuation: "  ... "

5. Add a basic smoke test: verify `snowc repl` command is recognized by clap (test by checking help output includes "repl").
  </action>
  <verify>
`cargo test -p snowc` passes. `cargo build -p snowc` compiles. `./target/debug/snowc repl --help` shows the repl subcommand.
  </verify>
  <done>
`snowc repl` starts the interactive REPL. Line editing via rustyline works. Multi-line input for do/end blocks works. Actor runtime is available.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-repl` -- all tests pass
2. `cargo test -p snowc` -- CLI tests pass
3. `cargo build --workspace` -- workspace compiles
4. `snowc repl` starts and `:quit` exits cleanly
</verification>

<success_criteria>
- `snowc repl` starts an interactive session with "snow> " prompt
- Simple expressions evaluate: entering `1 + 2` displays `3 :: Int`
- Multi-line input works for do/end blocks
- Actor runtime initializes so spawn/send/receive work
- :quit and Ctrl-D exit cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-05-SUMMARY.md`
</output>
