---
phase: 10-developer-tooling
plan: 10
type: execute
wave: 3
depends_on: ["10-01", "10-03", "10-05", "10-07", "10-09"]
files_modified:
  - crates/snowc/tests/tooling_e2e.rs
autonomous: false

must_haves:
  truths:
    - "snowc build --json produces valid JSON diagnostics for type errors"
    - "snowc fmt formats a Snow file and snowc fmt --check verifies it"
    - "snowc repl evaluates expressions and exits on :quit"
    - "snowc init creates a project that snowc build can compile"
    - "snowc lsp responds to initialize and provides diagnostics"
  artifacts:
    - path: "crates/snowc/tests/tooling_e2e.rs"
      provides: "End-to-end integration tests for all developer tools"
      contains: "test_fmt_idempotent"
  key_links:
    - from: "crates/snowc/tests/tooling_e2e.rs"
      to: "crates/snowc/src/main.rs"
      via: "CLI binary invocation for E2E tests"
      pattern: "Command::new"
---

<objective>
End-to-end integration tests verifying all Phase 10 developer tools work together, followed by human verification of the complete tooling experience.

Purpose: Ensure all tools are properly wired, the CLI subcommands work, and the overall developer experience meets the phase success criteria.
Output: E2E test suite, human-verified working tooling.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-01-SUMMARY.md
@.planning/phases/10-developer-tooling/10-03-SUMMARY.md
@.planning/phases/10-developer-tooling/10-05-SUMMARY.md
@.planning/phases/10-developer-tooling/10-07-SUMMARY.md
@.planning/phases/10-developer-tooling/10-09-SUMMARY.md
@crates/snowc/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: E2E integration tests for all developer tools</name>
  <files>
    crates/snowc/tests/tooling_e2e.rs
  </files>
  <action>
1. Create `crates/snowc/tests/tooling_e2e.rs` with end-to-end tests that invoke the snowc binary:

   **Error messages (--json):**
   ```rust
   #[test]
   fn test_build_json_output() {
       // Create temp dir with a Snow file containing a type error
       // Run: snowc build --json <dir>
       // Assert: stderr contains JSON with "code":"E0001"
       // Assert: JSON has spans array with start/end
   }
   ```

   **Formatter:**
   ```rust
   #[test]
   fn test_fmt_formats_file() {
       // Create temp .snow file with inconsistent formatting
       // Run: snowc fmt <file>
       // Read file back: verify it's properly formatted
   }

   #[test]
   fn test_fmt_check_formatted() {
       // Create a properly formatted .snow file
       // Run: snowc fmt --check <file>
       // Assert: exit code 0
   }

   #[test]
   fn test_fmt_check_unformatted() {
       // Create an unformatted .snow file
       // Run: snowc fmt --check <file>
       // Assert: exit code 1
   }

   #[test]
   fn test_fmt_idempotent() {
       // Format a file
       // Format it again
       // Assert: no changes (file identical after second format)
   }
   ```

   **Package manager:**
   ```rust
   #[test]
   fn test_init_creates_project() {
       // Run: snowc init test-project (in temp dir)
       // Assert: test-project/snow.toml exists and is valid TOML
       // Assert: test-project/main.snow exists
   }

   #[test]
   fn test_init_then_build() {
       // Run: snowc init test-project
       // Run: snowc build test-project
       // Assert: test-project/test-project binary exists and runs
   }
   ```

   **REPL (limited E2E -- can test help output):**
   ```rust
   #[test]
   fn test_repl_help_in_args() {
       // Run: snowc repl --help
       // Assert: output mentions "interactive" or "REPL"
   }
   ```

   **LSP (limited E2E -- can test initialization):**
   ```rust
   #[test]
   fn test_lsp_subcommand_exists() {
       // Run: snowc lsp --help
       // Assert: exit 0, mentions "LSP"
   }
   ```

2. All tests use `std::process::Command` to invoke the snowc binary built by cargo.
   Use `env!("CARGO_BIN_EXE_snowc")` or build the path from cargo target dir.

3. Use `tempfile::TempDir` for all test file creation.
  </action>
  <verify>
`cargo test -p snowc --test tooling_e2e` passes. All E2E tests green.
  </verify>
  <done>
E2E test suite verifies: JSON error output, formatter in-place + check mode + idempotency, project init + build, REPL and LSP subcommands exist.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 10 developer tooling: error message polish with --json, code formatter (snowc fmt), REPL (snowc repl), package manager (snowc init/deps), and LSP server (snowc lsp)</what-built>
  <how-to-verify>
1. Build the project: `cargo build --workspace`

2. Test error messages:
   - Create a Snow file with a type error
   - Run `snowc build <dir>` -- verify colorized error with source span
   - Run `snowc build --json <dir>` -- verify JSON output
   - Run `snowc build --no-color <dir>` -- verify no ANSI codes

3. Test formatter:
   - Create an unformatted Snow file
   - Run `snowc fmt <file>` -- verify file is reformatted with 2-space indent
   - Run `snowc fmt --check <file>` -- verify exit 0 (already formatted)
   - Modify indentation, run `snowc fmt --check <file>` -- verify exit 1

4. Test REPL:
   - Run `snowc repl`
   - Type `1 + 2` -- expect `3 :: Int`
   - Type `:type "hello"` -- expect `String`
   - Type a multi-line function (fn foo() do ... end)
   - Type `:quit` -- verify clean exit

5. Test package manager:
   - Run `snowc init hello` in a temp directory
   - Verify hello/snow.toml and hello/main.snow exist
   - Run `snowc build hello` -- verify it compiles and runs

6. Test LSP (if editor available):
   - Configure editor to use `snowc lsp` as language server
   - Open a .snow file -- verify diagnostics appear for errors
   - Hover over an expression -- verify type tooltip
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass across all crates
2. All 5 success criteria verified:
   - Error messages with source spans and fix suggestions
   - snowc fmt with idempotent formatting
   - snowc repl with expression evaluation
   - Package manager with init/deps
   - LSP server with diagnostics/hover/go-to-definition
</verification>

<success_criteria>
All Phase 10 success criteria met:
1. Compiler error messages identify problems, show source code with underlined spans, and suggest fixes
2. snowc fmt formats to canonical style, formatting is idempotent
3. snowc repl evaluates expressions with type display
4. Package manager initializes projects and resolves dependencies
5. LSP server provides diagnostics, go-to-definition, and type-on-hover
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-10-SUMMARY.md`
</output>
