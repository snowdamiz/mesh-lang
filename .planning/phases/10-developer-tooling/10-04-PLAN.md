---
phase: 10-developer-tooling
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/snow-repl/Cargo.toml
  - crates/snow-repl/src/lib.rs
  - crates/snow-repl/src/jit.rs
  - crates/snow-repl/src/session.rs
autonomous: true

must_haves:
  truths:
    - "REPL can evaluate simple expressions and display their value with type"
    - "REPL supports multi-line input for do/end blocks"
    - "Previous REPL results are accessible and types are displayed"
    - "REPL commands (:help, :type, :quit, :clear, :reset) work"
  artifacts:
    - path: "crates/snow-repl/src/lib.rs"
      provides: "REPL public API"
      exports: ["run_repl", "ReplConfig"]
    - path: "crates/snow-repl/src/jit.rs"
      provides: "JIT compilation engine for REPL inputs"
      contains: "fn jit_eval"
    - path: "crates/snow-repl/src/session.rs"
      provides: "REPL session state management"
      contains: "struct ReplSession"
  key_links:
    - from: "crates/snow-repl/src/jit.rs"
      to: "crates/snow-codegen/src/lib.rs"
      via: "LLVM JIT execution engine"
      pattern: "ExecutionEngine"
    - from: "crates/snow-repl/src/session.rs"
      to: "crates/snow-typeck/src/lib.rs"
      via: "Type checking each input"
      pattern: "snow_typeck::check"
---

<objective>
Create the snow-repl crate implementing an interactive REPL with incremental LLVM JIT compilation for evaluating Snow expressions.

Purpose: A REPL enables rapid prototyping and learning. Using LLVM JIT (not an interpreter) ensures behavior is identical to compiled code, per user decision.
Output: snow-repl crate with JIT engine, session state, multi-line support, and REPL commands.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-RESEARCH.md
@crates/snow-codegen/src/lib.rs
@crates/snow-typeck/src/lib.rs
@crates/snow-parser/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snow-repl crate with JIT engine and session management</name>
  <files>
    Cargo.toml
    crates/snow-repl/Cargo.toml
    crates/snow-repl/src/lib.rs
    crates/snow-repl/src/jit.rs
    crates/snow-repl/src/session.rs
  </files>
  <action>
1. Add `"crates/snow-repl"` to workspace members in root Cargo.toml.

2. Create `crates/snow-repl/Cargo.toml`:
   - Dependencies: snow-parser (path), snow-typeck (path), snow-codegen (path), snow-common (path), snow-lexer (path), inkwell (workspace), rustyline = "17", rowan (workspace)
   - Note: rustyline 17 needs to be added to workspace.dependencies in root Cargo.toml

3. Create `crates/snow-repl/src/session.rs` with `ReplSession`:
   ```rust
   pub struct ReplSession {
       /// Accumulated source context (previous definitions)
       definitions: Vec<String>,
       /// Counter for generating unique wrapper function names
       eval_counter: u64,
       /// History of evaluated results with types
       results: Vec<(String, String)>,  // (value_repr, type_name)
   }
   ```
   - `new()` -> empty session
   - `add_definition(source: &str)` -> stores fn/let/type definitions for future inputs
   - `wrap_expression(expr: &str) -> String` -> wraps expression in a unique `__repl_eval_N` function that includes all prior definitions as context
   - `record_result(value: String, ty: String)` -> stores in results
   - `reset()` -> clears all state

4. Create `crates/snow-repl/src/jit.rs` with the JIT evaluation engine:
   - CRITICAL per research: Create LLVM Context ONCE at startup, not per-eval. Store in ReplSession or pass as parameter.
   - `pub fn jit_eval(source: &str, session: &mut ReplSession) -> Result<EvalResult, String>`
   - `EvalResult` struct: `value: String`, `ty: String`
   - Implementation:
     a. Build full source: prepend all session.definitions, then wrap current input
     b. Parse with snow_parser::parse()
     c. If parse errors -> return Err with error message
     d. Type check with snow_typeck::check()
     e. If type errors -> return Err with rendered diagnostics
     f. Get result_type from TypeckResult
     g. Lower to MIR with snow_codegen::lower_to_mir_module()
     h. Create new LLVM Module in the persistent Context
     i. Generate LLVM IR with CodeGen
     j. Create ExecutionEngine (JIT) from module
     k. Look up and call the `__repl_eval_N` function
     l. Capture return value, format as string
     m. Return EvalResult with value and type name
   - For expressions that evaluate to a value: call the JIT'd function, read return
   - For definitions (fn, let at top level, type, struct): add to session.definitions, return "defined"
   - Detect whether input is a definition or expression by checking if it starts with fn/let/type/struct/module/actor/service keywords

5. Create `crates/snow-repl/src/lib.rs`:
   ```rust
   pub mod jit;
   pub mod session;

   pub struct ReplConfig {
       pub prompt: String,       // default: "snow> "
       pub continuation: String, // default: "  ... "
   }
   ```
   - `pub fn run_repl(config: &ReplConfig) -> Result<(), String>` -- main REPL loop (implemented in Plan 05)
   - For now, export the types and JIT engine; CLI integration comes in Plan 05

6. Write unit tests:
   - Parse detection: "1 + 2" is expression, "fn foo() do 1 end" is definition
   - Session wrapping: verify wrap_expression produces valid Snow source
   - NOTE: Full JIT tests require linking with snow-rt. Add a #[cfg(test)] integration test that compiles and evaluates "1 + 2" if LLVM is available.
  </action>
  <verify>
`cargo test -p snow-repl` passes. `cargo check -p snow-repl` compiles with all dependencies resolved.
  </verify>
  <done>
snow-repl crate exists with JIT evaluation engine, session state management, multi-line detection infrastructure, and expression/definition classification. Unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-line input handling and REPL command processing</name>
  <files>
    crates/snow-repl/src/lib.rs
    crates/snow-repl/src/session.rs
  </files>
  <action>
1. Add multi-line input detection to the REPL input processing:
   - Track "open" blocks: count `do` keywords vs `end` keywords, `fn(` vs `)`, etc.
   - When input has unmatched `do` (more do's than end's), switch to continuation mode
   - In continuation mode, display continuation prompt ("  ... ") and accumulate lines
   - When all blocks are closed (balanced do/end), submit the full multi-line input for evaluation
   - Also detect unclosed string literals (triple-quoted strings)
   - Use snow_lexer to tokenize incrementally and check for balance

2. Implement REPL command processing in lib.rs:
   - Commands start with `:` prefix
   - `:help` -> print available commands and basic usage
   - `:type <expr>` -> parse and type-check expression, display inferred type without evaluating
   - `:quit` or `:q` -> exit REPL cleanly
   - `:clear` -> clear screen (output ANSI clear sequence)
   - `:reset` -> reset session (clear all definitions and history)
   - `:load <file>` -> read file contents and evaluate each top-level item (add definitions to session)
   - Unknown command -> "Unknown command. Type :help for available commands."

3. Add `process_command(cmd: &str, session: &mut ReplSession) -> CommandResult` in lib.rs:
   ```rust
   pub enum CommandResult {
       Output(String),     // Display this text
       TypeInfo(String),   // Display type information
       Quit,               // Exit REPL
       Continue,           // No output, continue
       Error(String),      // Error message
   }
   ```

4. Implement display format for evaluation results per discretionary choice:
   - Values display as `value :: Type` (e.g., `42 :: Int`, `"hello" :: String`)
   - `:type expr` displays just `expr :: Type`
   - Definitions display as `Defined: fn_name :: (Arg1, Arg2) -> Return`

5. Write tests:
   - Multi-line detection: "fn foo() do" is incomplete, "fn foo() do\n  1\nend" is complete
   - Command parsing: ":help" recognized, ":type 1 + 2" recognized, "1 + 2" is not a command
   - Balance checking with nested blocks
  </action>
  <verify>
`cargo test -p snow-repl` passes. Multi-line detection correctly identifies incomplete inputs. Commands parse correctly.
  </verify>
  <done>
Multi-line input handling detects unmatched do/end blocks and accumulates continuation lines. REPL commands (:help, :type, :quit, :clear, :reset, :load) are implemented. Result display uses `value :: Type` format.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-repl` -- all tests pass
2. `cargo check --workspace` -- workspace compiles with new crate
3. Multi-line input correctly accumulates until blocks balanced
4. REPL commands recognized and dispatched
</verification>

<success_criteria>
- snow-repl crate exists with JIT engine and session management
- Expressions can be evaluated via JIT
- Multi-line input works for do/end blocks
- REPL commands (:help, :type, :quit, :clear, :reset, :load) implemented
- Value :: Type display format works
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-04-SUMMARY.md`
</output>
