---
phase: 10-developer-tooling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/src/error.rs
  - crates/snowc/src/main.rs
  - crates/snow-typeck/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Compiler errors show colorized output with underlined source spans by default"
    - "Running snowc build with --json produces one JSON object per line for each diagnostic"
    - "Multi-span diagnostics show both definition site and call site where applicable"
    - "Fix suggestions appear only for high-confidence cases (Option wrap, Result wrap, type conversions)"
  artifacts:
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Enhanced diagnostic rendering with color toggle and JSON output"
      contains: "render_json_diagnostic"
    - path: "crates/snowc/src/main.rs"
      provides: "CLI --json flag and --no-color flag"
      contains: "--json"
  key_links:
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-typeck/src/diagnostics.rs"
      via: "render_json_diagnostic call when --json flag set"
      pattern: "render_json_diagnostic"
---

<objective>
Polish compiler error messages to Elm/Rust quality standard with multi-span diagnostics, confident fix suggestions, colorized terminal output, and machine-readable JSON output mode.

Purpose: Error messages are the primary developer-facing interface of the compiler. High-quality diagnostics reduce debugging time and make the language approachable. The --json flag enables editor/CI integration.
Output: Enhanced diagnostics module, --json/--no-color CLI flags, multi-span support for FnArg/Return/Assignment/Annotation origins.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-typeck/src/error.rs
@crates/snowc/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance diagnostics with color toggle, multi-span, and JSON output</name>
  <files>
    crates/snow-typeck/src/diagnostics.rs
    crates/snow-typeck/src/lib.rs
  </files>
  <action>
Refactor `render_diagnostic()` in diagnostics.rs to accept a `DiagnosticOptions` struct with fields: `color: bool` (default true), `json: bool` (default false).

1. Create `DiagnosticOptions` struct with `color` and `json` fields, and a `Default` impl (color=true, json=false).

2. Update `render_diagnostic()` signature to accept `&DiagnosticOptions`. When `color` is true, use `Config::default()` (ariadne defaults to color). When false, use `Config::default().with_color(false)` (existing behavior for tests).

3. Add multi-span labels for FnArg origin: show both the function definition parameter span AND the call site argument span. For FnArg, the origin already has `param_span` and `call_site` -- add a second label "parameter declared here" at `param_span` when it differs from `call_site`. For Return origin, show both the return type annotation AND the return expression. For Assignment, show both lhs and rhs spans.

4. Create `render_json_diagnostic()` that produces a JSON object per diagnostic:
```json
{"code":"E0001","severity":"error","message":"expected Int, found String","file":"main.snow","spans":[{"start":10,"end":15,"label":"expected Int, found String"}],"fix":null}
```
Use serde_json for serialization. Add serde and serde_json as dependencies to snow-typeck Cargo.toml.

5. Add `JsonDiagnostic` struct with fields: code, severity ("error"|"warning"), message, file, spans (Vec of {start, end, label}), fix (Option<String>). Derive Serialize.

6. Update `TypeckResult::render_errors()` to accept `&DiagnosticOptions` and dispatch to either `render_diagnostic` or `render_json_diagnostic`.

7. Extend existing fix suggestions with 3 new cases per research:
   - E0004 UnboundVariable: check if a similar name exists in scope (Levenshtein distance <= 2) -- add a `suggestions` parameter to `render_diagnostic` that takes optional `&[String]` of names in scope. For now, just add the infrastructure; the actual name lookup will be "did you mean `X`?" when a suggestion list is provided.
   - E0005 NotAFunction: suggest "did you mean to call it? Use `name()`"
   - E0010 UnknownVariant: suggest nearest variant name if available (pass optional `&[String]` known variants)
  </action>
  <verify>
`cargo test -p snow-typeck` passes. Existing snapshot tests still pass (they use colorless mode). `cargo check -p snow-typeck` compiles cleanly with serde_json dependency.
  </verify>
  <done>
Diagnostics module supports color/no-color toggle, JSON output format via render_json_diagnostic, multi-span labels for FnArg/Return/Assignment origins, and 3 new fix suggestion cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --json and --no-color CLI flags to snowc build</name>
  <files>
    crates/snowc/src/main.rs
    crates/snowc/Cargo.toml
  </files>
  <action>
1. Add two new flags to the `Build` command in main.rs:
   - `--json` (bool flag): Output diagnostics as JSON (one object per line) instead of human-readable format
   - `--no-color` (bool flag): Disable colorized output

2. Update `report_diagnostics()` to accept `DiagnosticOptions` from snow-typeck and pass it through. When `--json` is set, call `render_json_diagnostic()` for each error and print one JSON object per line to stderr. When `--no-color` is set, configure `DiagnosticOptions { color: false, .. }`.

3. For parse errors in JSON mode, create a similar JSON object with code "P0001", severity "error", the parse error message, and the span.

4. Add serde_json dependency to snowc Cargo.toml for JSON parse error serialization.

5. Add integration tests in `crates/snowc/tests/` (or inline tests) that verify:
   - `snowc build --json bad_program` produces JSON output with error code and spans
   - `snowc build --no-color bad_program` produces uncolored output
   - Normal `snowc build bad_program` produces colored output (just verify it doesn't crash; color detection is terminal-dependent)
  </action>
  <verify>
`cargo test -p snowc` passes. `cargo build -p snowc` compiles. Running `./target/debug/snowc build --json /tmp/test_bad_snow_dir` (with a deliberate type error) outputs JSON to stderr.
  </verify>
  <done>
snowc build accepts --json and --no-color flags. JSON mode outputs one JSON diagnostic per line. No-color mode disables ANSI escape codes. Existing build behavior unchanged when flags not present.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` -- all existing tests pass, diagnostics render correctly
2. `cargo test -p snowc` -- CLI tests pass
3. `cargo build --workspace` -- full workspace compiles
4. Manual check: create a Snow file with a type error, run `snowc build --json` and verify JSON output
</verification>

<success_criteria>
- Diagnostics support colorized (default) and colorless modes
- --json flag produces machine-readable one-JSON-per-line output
- Multi-span labels show definition + usage for FnArg/Return/Assignment
- Fix suggestions only fire for high-confidence cases
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-01-SUMMARY.md`
</output>
