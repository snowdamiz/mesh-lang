---
phase: 10-developer-tooling
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/snow-lsp/Cargo.toml
  - crates/snow-lsp/src/lib.rs
  - crates/snow-lsp/src/server.rs
  - crates/snow-lsp/src/analysis.rs
autonomous: true

must_haves:
  truths:
    - "LSP server starts and responds to initialize request"
    - "Opening a Snow file triggers diagnostics (errors displayed in editor)"
    - "Hovering over an expression shows its inferred type"
  artifacts:
    - path: "crates/snow-lsp/src/lib.rs"
      provides: "LSP server public API"
      exports: ["run_server"]
    - path: "crates/snow-lsp/src/server.rs"
      provides: "tower-lsp Backend implementation"
      contains: "impl LanguageServer for SnowBackend"
    - path: "crates/snow-lsp/src/analysis.rs"
      provides: "Document analysis (parse + typecheck + diagnostics)"
      contains: "fn analyze_document"
  key_links:
    - from: "crates/snow-lsp/src/server.rs"
      to: "crates/snow-lsp/src/analysis.rs"
      via: "didOpen/didChange triggers analyze_document"
      pattern: "analyze_document"
    - from: "crates/snow-lsp/src/analysis.rs"
      to: "crates/snow-typeck/src/lib.rs"
      via: "Type checking for diagnostics and hover"
      pattern: "snow_typeck::check"
---

<objective>
Create the snow-lsp crate implementing an LSP server with diagnostics and type-on-hover using tower-lsp.

Purpose: An LSP server provides real-time feedback in editors (VS Code, Neovim, etc.), making Snow practical for daily development. Diagnostics and hover are the highest-value features.
Output: snow-lsp crate with tower-lsp Backend, document analysis, diagnostics publishing, and type-on-hover.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-RESEARCH.md
@crates/snow-typeck/src/lib.rs
@crates/snow-parser/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snow-lsp crate with tower-lsp server, diagnostics, and hover</name>
  <files>
    Cargo.toml
    crates/snow-lsp/Cargo.toml
    crates/snow-lsp/src/lib.rs
    crates/snow-lsp/src/server.rs
    crates/snow-lsp/src/analysis.rs
  </files>
  <action>
1. Add `"crates/snow-lsp"` to workspace members in root Cargo.toml. Add `tower-lsp = "0.20"` and `tokio = { version = "1", features = ["full"] }` to workspace.dependencies.

2. Create `crates/snow-lsp/Cargo.toml`:
   - Dependencies: snow-parser (path), snow-typeck (path), snow-common (path), tower-lsp (workspace), tokio (workspace), rowan (workspace), serde_json = "1"

3. Create `crates/snow-lsp/src/analysis.rs`:
   - `AnalysisResult` struct:
     ```rust
     pub struct AnalysisResult {
         pub diagnostics: Vec<lsp_types::Diagnostic>,
         pub types: FxHashMap<rowan::TextRange, snow_typeck::ty::Ty>,
         pub parse: snow_parser::Parse,
         pub typeck: snow_typeck::TypeckResult,
     }
     ```
   - `pub fn analyze_document(uri: &str, source: &str) -> AnalysisResult`:
     a. Parse with snow_parser::parse()
     b. Type check with snow_typeck::check()
     c. Convert parse errors to LSP Diagnostics (lsp_types::Diagnostic):
        - Convert byte offsets to line/character positions (CRITICAL: use UTF-16 offsets per LSP spec)
        - Severity: Error
        - Source: "snow"
        - Message: parse error message
     d. Convert type errors to LSP Diagnostics:
        - Use error_code() for the code field
        - Convert rowan TextRange to LSP Range (line/character with UTF-16 offsets)
        - Severity: Error (or Warning for W0001)
        - Source: "snow-typeck"
        - Include fix suggestion in diagnostic.data if available
     e. Return AnalysisResult with diagnostics and type map
   - Helper: `fn offset_to_position(source: &str, offset: usize) -> lsp_types::Position`:
     - Count newlines before offset for line number
     - Count UTF-16 code units from line start to offset for character
     - CRITICAL per research pitfall: Use UTF-16 offset conversion, not byte offsets

4. Create `crates/snow-lsp/src/server.rs`:
   - `SnowBackend` struct with `client: Client` and `documents: DashMap<String, AnalysisResult>` (or Mutex<HashMap>)
   - Actually, tower-lsp uses async. Use `tokio::sync::RwLock<HashMap<String, (String, AnalysisResult)>>` to store document text + analysis.

   Implement `LanguageServer` trait for `SnowBackend`:

   a. `initialize()`:
      - Return ServerCapabilities with:
        - textDocumentSync: Full (re-analyze on every change -- simple, correct)
        - hoverProvider: true
        - definitionProvider: true (placeholder, implemented in Plan 09)
      - Return ServerInfo with name "snow-lsp"

   b. `did_open()`:
      - Get document text from params
      - Call analyze_document()
      - Store result
      - Publish diagnostics to client

   c. `did_change()`:
      - Get new document text (full sync mode = full text in params)
      - Re-analyze
      - Store result
      - Publish diagnostics

   d. `did_close()`:
      - Remove document from store
      - Clear diagnostics (publish empty list)

   e. `hover()`:
      - Get position from params
      - Convert LSP position to byte offset in source
      - Look up smallest TextRange in typeck.types that contains this offset
      - If found: return Hover with type formatted as markdown: ` ```\n{type}\n``` `
      - If not found: return None

5. Create `crates/snow-lsp/src/lib.rs`:
   ```rust
   pub mod analysis;
   pub mod server;

   pub async fn run_server() {
       let stdin = tokio::io::stdin();
       let stdout = tokio::io::stdout();
       let (service, socket) = tower_lsp::LspService::new(|client| {
           server::SnowBackend::new(client)
       });
       tower_lsp::Server::new(stdin, stdout, socket).serve(service).await;
   }
   ```

6. Write tests:
   - analyze_document with valid Snow source produces empty diagnostics
   - analyze_document with type error produces diagnostic with correct severity and message
   - offset_to_position correctly converts byte offsets to line/character
   - UTF-16 offset handling for multi-byte characters (if any in Snow source)
  </action>
  <verify>
`cargo test -p snow-lsp` passes. `cargo check -p snow-lsp` compiles with tower-lsp and tokio.
  </verify>
  <done>
snow-lsp crate with tower-lsp Backend implementing initialize, didOpen, didChange, didClose, and hover. Document analysis converts parse/type errors to LSP diagnostics. Type-on-hover shows inferred types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add snowc lsp subcommand</name>
  <files>
    crates/snowc/src/main.rs
    crates/snowc/Cargo.toml
  </files>
  <action>
1. Add `snow-lsp = { path = "../snow-lsp" }` and `tokio = { workspace = true }` to snowc Cargo.toml dependencies.

2. Add `Lsp` variant to the `Commands` enum:
   ```rust
   /// Start the LSP server (communicates via stdin/stdout)
   Lsp,
   ```

3. Wire in main():
   ```rust
   Commands::Lsp => {
       let rt = tokio::runtime::Runtime::new().expect("Failed to create tokio runtime");
       rt.block_on(snow_lsp::run_server());
   }
   ```

4. Add a smoke test: verify `snowc lsp` is recognized by clap (check help output includes "lsp").
  </action>
  <verify>
`cargo test -p snowc` passes. `cargo build -p snowc` compiles. `./target/debug/snowc lsp --help` shows the lsp subcommand.
  </verify>
  <done>
`snowc lsp` starts the LSP server on stdin/stdout, ready for editor integration.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-lsp` -- analysis and server tests pass
2. `cargo test -p snowc` -- CLI tests pass
3. `cargo build --workspace` -- workspace compiles
4. `echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}' | snowc lsp` responds (basic smoke test)
</verification>

<success_criteria>
- LSP server starts and handles initialize/didOpen/didChange/didClose/hover
- Opening a Snow file with errors shows diagnostics
- Hovering over an expression shows its type
- snowc lsp subcommand starts the server on stdin/stdout
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-08-SUMMARY.md`
</output>
