---
phase: 10-developer-tooling
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/snow-pkg/Cargo.toml
  - crates/snow-pkg/src/lib.rs
  - crates/snow-pkg/src/manifest.rs
  - crates/snow-pkg/src/resolver.rs
  - crates/snow-pkg/src/lockfile.rs
autonomous: true

must_haves:
  truths:
    - "snow.toml can be parsed with project metadata and git-based dependencies"
    - "Dependency resolution resolves git URLs and produces a lockfile"
    - "snow.lock is deterministic: same inputs always produce same lockfile"
    - "Diamond dependency conflicts are detected and reported as errors"
  artifacts:
    - path: "crates/snow-pkg/src/lib.rs"
      provides: "Package manager public API"
      exports: ["resolve_dependencies", "Manifest"]
    - path: "crates/snow-pkg/src/manifest.rs"
      provides: "snow.toml parsing and Manifest struct"
      contains: "struct Manifest"
    - path: "crates/snow-pkg/src/resolver.rs"
      provides: "DFS dependency resolution with conflict detection"
      contains: "fn resolve"
    - path: "crates/snow-pkg/src/lockfile.rs"
      provides: "snow.lock generation and parsing"
      contains: "struct Lockfile"
  key_links:
    - from: "crates/snow-pkg/src/resolver.rs"
      to: "crates/snow-pkg/src/manifest.rs"
      via: "resolver reads Manifest to get dependency list"
      pattern: "Manifest"
    - from: "crates/snow-pkg/src/lockfile.rs"
      to: "crates/snow-pkg/src/resolver.rs"
      via: "lockfile generated from resolved dependency graph"
      pattern: "ResolvedDep"
---

<objective>
Create the snow-pkg crate implementing the package manager core: TOML manifest parsing, git-based dependency resolution, and deterministic lockfile generation.

Purpose: A package manager enables code reuse and project organization. Git-based dependencies first, designed so a central registry can be added later without breaking changes.
Output: snow-pkg crate with manifest parsing, dependency resolution, and lockfile generation.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-developer-tooling/10-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: snow.toml manifest parsing and snow.lock lockfile format</name>
  <files>
    Cargo.toml
    crates/snow-pkg/Cargo.toml
    crates/snow-pkg/src/lib.rs
    crates/snow-pkg/src/manifest.rs
    crates/snow-pkg/src/lockfile.rs
  </files>
  <action>
1. Add `"crates/snow-pkg"` to workspace members in root Cargo.toml. Add `toml = "0.8"`, `git2 = "0.19"`, `semver = "1"` to workspace.dependencies.

2. Create `crates/snow-pkg/Cargo.toml`:
   - Dependencies: toml (workspace), git2 (workspace), semver (workspace), serde (workspace), serde_json = "1"
   - Dev-dependencies: tempfile = "3"

3. Create `crates/snow-pkg/src/manifest.rs`:
   - `Manifest` struct (Deserialize via serde):
     ```rust
     #[derive(Debug, Deserialize)]
     pub struct Manifest {
         pub package: Package,
         #[serde(default)]
         pub dependencies: BTreeMap<String, Dependency>,
     }

     #[derive(Debug, Deserialize)]
     pub struct Package {
         pub name: String,
         pub version: String,
         #[serde(default)]
         pub description: Option<String>,
         #[serde(default)]
         pub authors: Vec<String>,
     }

     #[derive(Debug, Deserialize)]
     #[serde(untagged)]
     pub enum Dependency {
         Git { git: String, #[serde(default)] rev: Option<String>, #[serde(default)] branch: Option<String>, #[serde(default)] tag: Option<String> },
         Path { path: String },
     }
     ```
   - `Manifest::from_file(path: &Path) -> Result<Manifest, String>` -- read and parse snow.toml
   - `Manifest::from_str(content: &str) -> Result<Manifest, String>` -- parse from string (for testing)

   Example snow.toml:
   ```toml
   [package]
   name = "my-project"
   version = "0.1.0"
   description = "A Snow project"

   [dependencies]
   http-utils = { git = "https://github.com/user/http-utils.git", tag = "v1.0.0" }
   json-helpers = { path = "../json-helpers" }
   ```

4. Create `crates/snow-pkg/src/lockfile.rs`:
   - `Lockfile` struct:
     ```rust
     #[derive(Debug, Serialize, Deserialize)]
     pub struct Lockfile {
         pub version: u32,  // Always 1 for now
         pub packages: Vec<LockedPackage>,
     }

     #[derive(Debug, Serialize, Deserialize, PartialEq)]
     pub struct LockedPackage {
         pub name: String,
         pub source: String,  // git URL or path
         pub revision: String, // git commit SHA or "local"
     }
     ```
   - `Lockfile::write(path: &Path) -> Result<(), String>` -- serialize as TOML
   - `Lockfile::read(path: &Path) -> Result<Lockfile, String>` -- deserialize from file
   - Deterministic output: sort packages by name, always same order

5. Create `crates/snow-pkg/src/lib.rs`:
   ```rust
   pub mod manifest;
   pub mod resolver;
   pub mod lockfile;
   ```

6. Write tests:
   - Parse valid snow.toml with git and path dependencies
   - Parse snow.toml with missing optional fields (description, authors)
   - Reject invalid TOML (missing [package], missing name)
   - Lockfile round-trip: write then read produces same data
   - Lockfile determinism: same inputs produce byte-identical output
  </action>
  <verify>
`cargo test -p snow-pkg` passes. `cargo check -p snow-pkg` compiles.
  </verify>
  <done>
snow.toml manifest parsing with Package and Dependency types. snow.lock lockfile with deterministic serialization. Round-trip tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Git-based dependency resolution with conflict detection</name>
  <files>
    crates/snow-pkg/src/resolver.rs
    crates/snow-pkg/src/lib.rs
  </files>
  <action>
1. Create `crates/snow-pkg/src/resolver.rs`:
   - `ResolvedDep` struct: `name: String`, `source: DepSource`, `revision: String`, `path: PathBuf` (local checkout path)
   - `DepSource` enum: `Git { url: String, rev: String }`, `Path { path: PathBuf }`

2. Implement `resolve(manifest: &Manifest, project_dir: &Path) -> Result<Vec<ResolvedDep>, String>`:
   - DFS resolution per research recommendation:
     a. For each dependency in manifest.dependencies:
        - Git deps: clone/fetch to `project_dir/.snow/deps/<name>/` using git2
        - If `rev` specified: checkout that revision
        - If `tag` specified: resolve tag to rev, checkout
        - If `branch` specified: checkout that branch HEAD
        - If none specified: use default branch HEAD
        - Path deps: resolve relative path from project_dir
     b. After cloning, check if the dep has its own snow.toml
        - If yes: recursively resolve its dependencies
     c. Track visited deps to detect cycles
     d. Track dep versions to detect diamond conflicts (same dep name, different sources)
        - If conflict detected: return error "Dependency conflict: `X` required from two different sources"

3. Implement `fetch_git_dep(url: &str, dest: &Path, rev: Option<&str>, branch: Option<&str>, tag: Option<&str>) -> Result<String, String>`:
   - Use git2::Repository::clone if dest doesn't exist
   - Use git2::Repository::open + fetch if dest exists
   - Return the resolved commit SHA

4. Add `resolve_dependencies()` as public API in lib.rs that:
   - Reads snow.toml from project dir
   - Calls resolve()
   - Generates Lockfile from resolved deps
   - Returns (Vec<ResolvedDep>, Lockfile)

5. Write tests:
   - Path dependency resolution (create temp dirs with snow.toml files)
   - Conflict detection (two deps requiring same name from different sources)
   - Cycle detection (A depends on B, B depends on A)
   - NOTE: Git tests use tempdir with local git repos (git init + commit) to avoid network
  </action>
  <verify>
`cargo test -p snow-pkg` passes. Dependency resolution works for path dependencies. Conflict and cycle detection working.
  </verify>
  <done>
DFS dependency resolver handles git and path dependencies. Conflict detection flags diamond dependency issues. Cycle detection prevents infinite recursion. Lockfile generated from resolved deps.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-pkg` -- all tests pass
2. `cargo check --workspace` -- workspace compiles with new crate
3. Path-based dependency resolution works end-to-end
4. Conflict detection flags incompatible dependencies
</verification>

<success_criteria>
- snow.toml parsing supports package metadata and git/path dependencies
- Dependency resolution resolves path deps and produces correct lockfile
- Diamond conflicts are detected and reported
- Lockfile is deterministic
</success_criteria>

<output>
After completion, create `.planning/phases/10-developer-tooling/10-06-SUMMARY.md`
</output>
