---
phase: 25-type-system-soundness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "let f = show; f(non_display_value) produces a compile-time TraitNotSatisfied error"
    - "let f = show; let g = f; g(non_display_value) produces a compile-time TraitNotSatisfied error (chain aliases)"
    - "Constraint preservation works for user-defined traits, not just stdlib Display"
    - "Existing direct-call constraint checking (show(42)) still works (no regressions)"
    - "let f = show; f(display_value) still compiles successfully (no false positives)"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Constraint propagation through let bindings"
      contains: "fn_constraints.insert"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "End-to-end tests for constraint alias propagation"
      contains: "e2e_where_clause_alias"
  key_links:
    - from: "infer_let_binding"
      to: "fn_constraints map"
      via: "NameRef detection + constraint cloning"
      pattern: "fn_constraints\\.insert\\(name_text"
    - from: "infer_block"
      to: "infer_let_binding"
      via: "passing real fn_constraints instead of empty default"
      pattern: "infer_let_binding.*fn_constraints"
    - from: "infer_call"
      to: "fn_constraints map"
      via: "existing name-based lookup now finds propagated entries"
      pattern: "fn_constraints\\.get\\(&fn_name\\)"
---

<objective>
Fix the type system soundness bug where higher-order constrained functions lose their trait constraints when captured as values via let bindings. After this fix, `let f = show; f(non_display_value)` produces a compile-time error instead of silently allowing unsound calls.

Purpose: This is the last of five v1.3 known limitations. It closes a soundness hole where where-clause constraints are lost when functions are aliased, allowing the type system to be bypassed.

Output: Modified infer.rs with constraint propagation through let bindings, plus end-to-end tests proving the fix works for direct aliases, chain aliases, and user-defined traits.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-type-system-soundness/25-RESEARCH.md
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Propagate fn_constraints through let bindings</name>
  <files>crates/snow-typeck/src/infer.rs</files>
  <action>
Three changes to infer.rs, all focused on threading fn_constraints correctly:

**Change 1: Update infer_let_binding signature (line 2128)**
Change `fn_constraints: &FxHashMap<String, FnConstraints>` to `fn_constraints: &mut FxHashMap<String, FnConstraints>`.

**Change 2: Add constraint propagation logic in infer_let_binding (after line 2162, before env.insert)**
After `let scheme = ctx.generalize(binding_ty);` and inside the `if let Some(name) = let_.name()` block, before `env.insert(name_text, scheme)`:

```rust
// Propagate where-clause constraints if RHS is a NameRef
// to a constrained function (fixes TSND-01 soundness bug).
if let Expr::NameRef(ref name_ref) = init_expr {
    if let Some(source_name) = name_ref.text() {
        if let Some(source_constraints) = fn_constraints.get(&source_name).cloned() {
            fn_constraints.insert(name_text.clone(), source_constraints);
        }
    }
}
```

This uses `init_expr` which is already in scope (line 2132). The `.cloned()` on the get avoids borrow conflicts. The `Expr::NameRef` pattern is the same pattern used in `infer_call` (line 2666).

**Change 3: Fix infer_block to pass real fn_constraints to infer_let_binding (line 3139)**
CRITICAL: Currently `infer_block` passes `&FxHashMap::default()` to `infer_let_binding` (line 3139). Change this to pass the real `fn_constraints` parameter that `infer_block` already receives.

The `infer_block` signature already has `fn_constraints: &FxHashMap<String, FnConstraints>` (line 3063). But now that `infer_let_binding` needs `&mut`, there are two options:
- Option A: Change `infer_block`'s `fn_constraints` parameter to `&mut FxHashMap` and update all callers
- Option B: Create a `let mut local_constraints = fn_constraints.clone();` inside infer_block and pass `&mut local_constraints` to infer_let_binding

Use Option B (clone-locally) because it is less invasive -- `infer_block` is called from many places (infer_fn_def, infer_if, infer_case, infer_closure, etc.) and changing all of those to `&mut` would be a large cascade. Cloning the constraints map is cheap (it's typically small, only constrained functions).

Specifically, at the top of `infer_block` (after `let mut last_ty = Ty::Tuple(vec![]);` on line 3065), add:
```rust
let mut local_fn_constraints = fn_constraints.clone();
```

Then change line 3139 from `&FxHashMap::default()` to `&mut local_fn_constraints`.

Also change line 3152 from `&mut FxHashMap::default()` to `&mut local_fn_constraints` (for multi-clause fn defs inside blocks -- they should also see outer constraints for consistency).

Also change line 3181 from `fn_constraints` to `&local_fn_constraints` so that expression-statements (like `f(42)`) can see constraints propagated by earlier let bindings in the same block.

Do NOT modify Ty enum, Scheme struct, or the infer_call function. The existing constraint checking in infer_call (lines 2662-2703) already works correctly -- it just needs the fn_constraints map to contain the right entries.

Do NOT change infer_expr's signature or any function that calls infer_block. The clone-locally strategy keeps the change contained.
  </action>
  <verify>
Run `cargo build -p snow-typeck` to confirm the changes compile without errors.

Run `cargo test -p snow-typeck` to confirm no regressions in existing type checker tests.

Run `cargo test -p snow-codegen -- e2e_where_clause_enforcement` to confirm the existing direct-call constraint test still passes.

Run the full test suite: `cargo test --workspace` to confirm no regressions (expect 1,203+ tests passing).
  </verify>
  <done>
infer_let_binding accepts &mut fn_constraints. When a let binding's initializer is a NameRef to a constrained function, the constraints are cloned into the map under the new binding's name. infer_block passes a mutable clone of fn_constraints (not an empty default) to infer_let_binding so that block-level let bindings can both read and write constraints. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end tests for constraint alias propagation</name>
  <files>crates/snow-codegen/src/mir/lower.rs</files>
  <action>
Add three new test functions in the `#[cfg(test)]` module of lower.rs, adjacent to the existing `e2e_where_clause_enforcement` test (around line 7544). Follow the exact same test pattern: parse Snow source, run typeck, assert TraitNotSatisfied error presence/absence.

**Test 1: e2e_where_clause_alias_propagation**
Tests that `let f = show; f(42)` produces a TraitNotSatisfied error.

```rust
#[test]
fn e2e_where_clause_alias_propagation() {
    let source = r#"
interface Displayable do
  fn display(self) -> String
end

fn show<T>(x :: T) -> String where T: Displayable do
  display(x)
end

fn main() do
  let f = show
  f(42)
end
"#;
    let parse = snow_parser::parse(source);
    let typeck = snow_typeck::check(&parse);

    let has_trait_error = typeck.errors.iter().any(|e| {
        matches!(e, snow_typeck::error::TypeError::TraitNotSatisfied { .. })
    });
    assert!(
        has_trait_error,
        "Expected TraitNotSatisfied when calling aliased constrained function f(42). Errors: {:?}",
        typeck.errors
    );
}
```

**Test 2: e2e_where_clause_chain_alias**
Tests that `let f = show; let g = f; g(42)` also errors.

```rust
#[test]
fn e2e_where_clause_chain_alias() {
    let source = r#"
interface Displayable do
  fn display(self) -> String
end

fn show<T>(x :: T) -> String where T: Displayable do
  display(x)
end

fn main() do
  let f = show
  let g = f
  g(42)
end
"#;
    let parse = snow_parser::parse(source);
    let typeck = snow_typeck::check(&parse);

    let has_trait_error = typeck.errors.iter().any(|e| {
        matches!(e, snow_typeck::error::TypeError::TraitNotSatisfied { .. })
    });
    assert!(
        has_trait_error,
        "Expected TraitNotSatisfied when calling chain-aliased constrained function g(42). Errors: {:?}",
        typeck.errors
    );
}
```

**Test 3: e2e_where_clause_alias_user_trait**
Tests that constraint preservation works with a user-defined trait (not just stdlib), and also verifies no false positives -- calling the alias with a type that DOES implement the trait should succeed.

```rust
#[test]
fn e2e_where_clause_alias_user_trait() {
    // Part A: Should error -- Int does not implement Greetable
    let source_bad = r#"
interface Greetable do
  fn greet(self) -> String
end

fn say_hello<T>(x :: T) -> String where T: Greetable do
  greet(x)
end

fn main() do
  let f = say_hello
  f(42)
end
"#;
    let parse = snow_parser::parse(source_bad);
    let typeck = snow_typeck::check(&parse);

    let has_trait_error = typeck.errors.iter().any(|e| {
        matches!(e, snow_typeck::error::TypeError::TraitNotSatisfied { .. })
    });
    assert!(
        has_trait_error,
        "Expected TraitNotSatisfied for user-defined trait Greetable via alias. Errors: {:?}",
        typeck.errors
    );

    // Part B: Should NOT error -- Person implements Greetable
    let source_good = r#"
interface Greetable do
  fn greet(self) -> String
end

struct Person do
  name :: String
end

impl Greetable for Person do
  fn greet(self) -> String do
    "hello"
  end
end

fn say_hello<T>(x :: T) -> String where T: Greetable do
  greet(x)
end

fn main() do
  let f = say_hello
  let p = Person { name: "Alice" }
  f(p)
end
"#;
    let parse_good = snow_parser::parse(source_good);
    let typeck_good = snow_typeck::check(&parse_good);

    let has_trait_error_good = typeck_good.errors.iter().any(|e| {
        matches!(e, snow_typeck::error::TypeError::TraitNotSatisfied { .. })
    });
    assert!(
        !has_trait_error_good,
        "Should NOT get TraitNotSatisfied when calling aliased constrained function with conforming type. Errors: {:?}",
        typeck_good.errors
    );
}
```
  </action>
  <verify>
Run `cargo test -p snow-codegen -- e2e_where_clause_alias` to verify all three new tests pass.

Run `cargo test -p snow-codegen -- e2e_where_clause` to verify both old and new where-clause tests pass together (4 total).

Run `cargo test --workspace` to confirm full suite passes with no regressions (expect 1,206+ tests, up from 1,203).
  </verify>
  <done>
Three new e2e tests pass: (1) direct alias `let f = show; f(42)` produces TraitNotSatisfied, (2) chain alias `let f = show; let g = f; g(42)` produces TraitNotSatisfied, (3) user-defined trait alias errors for non-conforming type and succeeds for conforming type (no false positives). Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with 1,206+ tests (3 new tests added)
2. `cargo test -p snow-codegen -- e2e_where_clause` passes (4 tests: 1 existing + 3 new)
3. `cargo test -p snow-typeck` passes (no regressions from signature change)
4. The existing `e2e_where_clause_enforcement` test still passes (direct calls unaffected)
</verification>

<success_criteria>
- `let f = show; f(42)` produces a compile-time TraitNotSatisfied error (not silent unsoundness)
- `let f = show; let g = f; g(42)` also produces the error (chain aliases)
- User-defined trait constraints are preserved through aliases
- Calling an aliased constrained function with a conforming type succeeds (no false positives)
- All 1,203+ existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/25-type-system-soundness/25-01-SUMMARY.md`
</output>
