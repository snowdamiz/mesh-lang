---
phase: 98-query-builder-repo
plan: 02
type: execute
wave: 2
depends_on: ["98-01"]
files_modified:
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-rt/src/db/repo.rs
  - crates/mesh-rt/src/db/mod.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-repl/src/jit.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Repo.all(pool, query) reads the Query struct's slots and builds complete SELECT SQL with WHERE, ORDER BY, LIMIT, OFFSET, GROUP BY, HAVING, JOIN, and fragment clauses"
    - "Repo.one(pool, query) returns the first matching row or error"
    - "Repo.get(pool, table, id) fetches a single row by primary key"
    - "Repo.get_by(pool, table, field, value) fetches a single row by field condition"
    - "Repo.count(pool, query) returns an integer count of matching rows"
    - "Repo.exists(pool, query) returns a boolean existence check"
  artifacts:
    - path: "crates/mesh-rt/src/db/repo.rs"
      provides: "Repo read operations: all, one, get, get_by, count, exists as extern C functions"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Repo module type signatures in build_stdlib_modules"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Repo module in STDLIB_MODULES, known_functions, map_builtin_name"
  key_links:
    - from: "crates/mesh-rt/src/db/repo.rs"
      to: "crates/mesh-rt/src/db/query.rs"
      via: "Repo functions read Query struct slots via query_get/query_get_int helpers"
      pattern: "query_get.*query_get_int"
    - from: "crates/mesh-rt/src/db/repo.rs"
      to: "crates/mesh-rt/src/db/pool.rs"
      via: "Repo calls mesh_pool_query for SQL execution"
      pattern: "mesh_pool_query"
    - from: "crates/mesh-rt/src/db/repo.rs"
      to: "crates/mesh-rt/src/db/orm.rs"
      via: "Repo uses SQL builder helpers for parameterized query generation"
      pattern: "build_select_sql"
---

<objective>
Register the Repo module in the compiler pipeline and implement all read operations: Repo.all, Repo.one, Repo.get, Repo.get_by, Repo.count, Repo.exists. Each operation reads the Query struct's slots (built by 98-01), generates parameterized SQL including all clause types, and executes via Pool.query.

Purpose: Provides the database execution layer that turns composed Query objects into actual PostgreSQL results.
Output: Repo runtime module with 6 read functions, compiler registration, comprehensive SQL generation from Query struct, e2e tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/098-query-builder-repo/98-RESEARCH.md
@.planning/phases/098-query-builder-repo/98-01-SUMMARY.md
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-rt/src/db/query.rs
@crates/mesh-rt/src/db/pool.rs
@crates/mesh-rt/src/db/orm.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Repo module in compiler pipeline and implement comprehensive SQL generation + read operations</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-rt/src/db/repo.rs
    crates/mesh-rt/src/db/mod.rs
    crates/mesh-rt/src/lib.rs
    crates/mesh-repl/src/jit.rs
  </files>
  <action>
    **1. Type checker (infer.rs):**
    - Add `"Repo"` to `STDLIB_MODULE_NAMES` array
    - In `build_stdlib_modules()`, register Repo read functions:
      ```
      Repo.all(Ptr, Ptr) -> Ptr        // (pool, query) -> Result<List<Map<String,String>>, String>
      Repo.one(Ptr, Ptr) -> Ptr         // (pool, query) -> Result<Map<String,String>, String>
      Repo.get(Ptr, String, String) -> Ptr    // (pool, table, id) -> Result<Map<String,String>, String>
      Repo.get_by(Ptr, String, String, String) -> Ptr  // (pool, table, field, value) -> Result<Map<String,String>, String>
      Repo.count(Ptr, Ptr) -> Ptr       // (pool, query) -> Result<Int, String>
      Repo.exists(Ptr, Ptr) -> Ptr      // (pool, query) -> Result<Bool, String>
      ```
    - Return types use `Ptr` since Result is an opaque pointer at the MIR level. These match existing patterns like `Pool.query` which returns `Ptr` (a Result).

    **2. MIR lowerer (lower.rs):**
    - Add `"Repo"` to `STDLIB_MODULES` array
    - Register known_functions:
      ```
      "mesh_repo_all"     -> FnPtr([Ptr, Ptr], Ptr)
      "mesh_repo_one"     -> FnPtr([Ptr, Ptr], Ptr)
      "mesh_repo_get"     -> FnPtr([Ptr, Ptr, Ptr], Ptr)
      "mesh_repo_get_by"  -> FnPtr([Ptr, Ptr, Ptr, Ptr], Ptr)
      "mesh_repo_count"   -> FnPtr([Ptr, Ptr], Ptr)
      "mesh_repo_exists"  -> FnPtr([Ptr, Ptr], Ptr)
      ```
    - Add map_builtin_name mappings:
      ```
      "repo_all" => "mesh_repo_all"
      "repo_one" => "mesh_repo_one"
      "repo_get" => "mesh_repo_get"
      "repo_get_by" => "mesh_repo_get_by"
      "repo_count" => "mesh_repo_count"
      "repo_exists" => "mesh_repo_exists"
      ```

    **3. LLVM intrinsics (intrinsics.rs):**
    - Declare all 6 Repo read functions following existing pattern.

    **4. Runtime (repo.rs) -- Comprehensive SQL Builder:**

    Create `crates/mesh-rt/src/db/repo.rs`. This file contains:

    **(a) Internal `query_to_select_sql` function** -- reads all Query struct slots and generates a complete SELECT statement:
    ```rust
    fn query_to_select_sql(query: *mut u8) -> (String, Vec<String>) {
        // Read all slots from the Query struct
        let source = read_mesh_string(query_get(query, 0));       // table name
        let select_fields = read_list_strings(query_get(query, 1)); // columns
        let where_clauses = read_list_strings(query_get(query, 2));
        let where_params = read_list_strings(query_get(query, 3));
        let order_fields = read_list_strings(query_get(query, 4));
        let limit_val = query_get_int(query, 5);
        let offset_val = query_get_int(query, 6);
        let join_clauses = read_list_strings(query_get(query, 7));
        let group_fields = read_list_strings(query_get(query, 8));
        let having_clauses = read_list_strings(query_get(query, 9));
        let having_params = read_list_strings(query_get(query, 10));
        let fragment_parts = read_list_strings(query_get(query, 11));
        let fragment_params = read_list_strings(query_get(query, 12));

        // Build SQL string
        let mut sql = String::new();
        let mut params: Vec<String> = Vec::new();
        let mut param_idx = 1usize;

        // SELECT clause
        sql.push_str("SELECT ");
        if select_fields.is_empty() {
            sql.push('*');
        } else {
            let cols: Vec<String> = select_fields.iter()
                .map(|f| format!("\"{}\"", f))
                .collect();
            sql.push_str(&cols.join(", "));
        }

        // FROM clause
        sql.push_str(&format!(" FROM \"{}\"", source));

        // JOIN clauses (format: "TYPE:table:on_clause")
        for join in &join_clauses {
            let parts: Vec<&str> = join.splitn(3, ':').collect();
            if parts.len() == 3 {
                sql.push_str(&format!(" {} JOIN \"{}\" ON {}",
                    parts[0], parts[1], parts[2]));
            }
        }

        // WHERE clause
        if !where_clauses.is_empty() {
            sql.push_str(" WHERE ");
            let mut where_parts = Vec::new();
            let mut wp_idx = 0;
            for clause in &where_clauses {
                if clause.ends_with("IS NULL") || clause.ends_with("IS NOT NULL") {
                    where_parts.push(format!("\"{}\"",
                        clause.replace(" IS NULL", "\" IS NULL")
                              .replace(" IS NOT NULL", "\" IS NOT NULL")));
                    // Actually: parse "field IS NULL" -> "field" IS NULL
                    // Better: split on first space to get field, rest is operator
                    let space_pos = clause.find(' ').unwrap_or(clause.len());
                    let field = &clause[..space_pos];
                    let op = &clause[space_pos+1..];
                    where_parts.push(format!("\"{}\" {}", field, op));
                } else if clause.contains("IN:") {
                    // Handle IN clause: "field IN:N"
                    let space_pos = clause.find(' ').unwrap();
                    let field = &clause[..space_pos];
                    let count: usize = clause[space_pos+4..].parse().unwrap_or(0);
                    let placeholders: Vec<String> = (0..count)
                        .map(|i| { let p = format!("${}", param_idx + i); p })
                        .collect();
                    where_parts.push(format!("\"{}\" IN ({})",
                        field, placeholders.join(", ")));
                    for _ in 0..count {
                        if wp_idx < where_params.len() {
                            params.push(where_params[wp_idx].clone());
                            wp_idx += 1;
                        }
                        param_idx += 1;
                    }
                    continue; // skip the default param handling below
                } else {
                    // Regular operator: "field op" -> "field" op $N
                    let space_pos = clause.find(' ').unwrap_or(clause.len());
                    let field = &clause[..space_pos];
                    let op = &clause[space_pos+1..];
                    where_parts.push(format!("\"{}\" {} ${}", field, op, param_idx));
                    if wp_idx < where_params.len() {
                        params.push(where_params[wp_idx].clone());
                        wp_idx += 1;
                    }
                    param_idx += 1;
                }
            }
            sql.push_str(&where_parts.join(" AND "));
        }

        // GROUP BY clause
        if !group_fields.is_empty() {
            let cols: Vec<String> = group_fields.iter()
                .map(|f| format!("\"{}\"", f)).collect();
            sql.push_str(&format!(" GROUP BY {}", cols.join(", ")));
        }

        // HAVING clause
        if !having_clauses.is_empty() {
            sql.push_str(" HAVING ");
            let mut having_parts = Vec::new();
            for clause in &having_clauses {
                having_parts.push(format!("{} ${}", clause, param_idx));
                param_idx += 1;
            }
            sql.push_str(&having_parts.join(" AND "));
            for p in &having_params {
                params.push(p.clone());
            }
        }

        // Fragment injection (appended to WHERE or as standalone)
        // Fragments with ? placeholders get $N substitution
        for (i, frag) in fragment_parts.iter().enumerate() {
            sql.push_str(&format!(" {}", frag));
            // Replace ? with $N for each fragment param
        }
        for p in &fragment_params {
            params.push(p.clone());
        }

        // ORDER BY clause
        if !order_fields.is_empty() {
            sql.push_str(" ORDER BY ");
            let orders: Vec<String> = order_fields.iter().map(|o| {
                let space_pos = o.find(' ').unwrap_or(o.len());
                let field = &o[..space_pos];
                let dir = if space_pos < o.len() { &o[space_pos+1..] } else { "ASC" };
                format!("\"{}\" {}", field, dir)
            }).collect();
            sql.push_str(&orders.join(", "));
        }

        // LIMIT clause
        if limit_val >= 0 {
            sql.push_str(&format!(" LIMIT {}", limit_val));
        }

        // OFFSET clause
        if offset_val >= 0 {
            sql.push_str(&format!(" OFFSET {}", offset_val));
        }

        (sql, params)
    }
    ```

    **IMPORTANT NOTE:** The pseudocode above is illustrative. The actual implementation must:
    - Use the exact same Mesh runtime string/list helper functions used in orm.rs and pool.rs
    - Handle the WHERE clause encoding correctly per Phase 97 format ("column op" space-separated)
    - Use proper GC-safe allocation for result strings/lists
    - Match the exact `extern "C"` calling convention

    **(b) Helper to read list of strings from Mesh List<String> pointer:**
    Look at how existing functions in pool.rs or orm.rs read Mesh lists. Follow that pattern. You need:
    - `mesh_list_len(list)` -> length
    - `mesh_list_get(list, index)` -> element pointer
    - `mesh_string_to_rust(ptr)` -> Rust String

    **(c) `mesh_repo_all(pool: *mut u8, query: *mut u8) -> *mut u8`:**
    1. Call `query_to_select_sql(query)` to get (sql, params)
    2. Convert sql String to MeshString pointer
    3. Convert params Vec to Mesh List<String>
    4. Call `mesh_pool_query(pool, sql_ptr, params_ptr)` (the existing pool query function)
    5. Return the result directly (already Result<List<Map<String,String>>, String>)

    **(d) `mesh_repo_one(pool: *mut u8, query: *mut u8) -> *mut u8`:**
    1. Modify the query to add LIMIT 1 (set slot 5 = 1)
    2. Call `query_to_select_sql(modified_query)` to get (sql, params)
    3. Execute via `mesh_pool_query`
    4. Extract first row from result list. If empty, return Err("not found"). If present, return Ok(first_row).

    **(e) `mesh_repo_get(pool: *mut u8, table: *mut u8, id: *mut u8) -> *mut u8`:**
    1. Build SQL: `SELECT * FROM "table" WHERE "id" = $1`
    2. Execute via `mesh_pool_query(pool, sql, [id])`
    3. Extract first row or return Err("not found")

    **(f) `mesh_repo_get_by(pool: *mut u8, table: *mut u8, field: *mut u8, value: *mut u8) -> *mut u8`:**
    1. Build SQL: `SELECT * FROM "table" WHERE "field" = $1 LIMIT 1`
    2. Execute via `mesh_pool_query(pool, sql, [value])`
    3. Extract first row or return Err("not found")

    **(g) `mesh_repo_count(pool: *mut u8, query: *mut u8) -> *mut u8`:**
    1. Read Query slots but override select to `COUNT(*)`
    2. Build SQL with count select clause
    3. Execute via `mesh_pool_query`
    4. Parse integer from first row's first column
    5. Return Result<Int, String> (Ok with the count value as i64)

    **(h) `mesh_repo_exists(pool: *mut u8, query: *mut u8) -> *mut u8`:**
    1. Build SQL: `SELECT EXISTS(SELECT 1 FROM "table" WHERE ... LIMIT 1)`
    2. Execute via `mesh_pool_query`
    3. Parse boolean from result
    4. Return Result<Bool, String>

    **Result construction:** Use existing `mesh_result_ok(value)` and `mesh_result_err(error_string)` helpers from the runtime. Check how pool.rs constructs Result values and follow the same pattern.

    **5. Module registration (mod.rs, lib.rs):**
    - Add `pub mod repo;` to `crates/mesh-rt/src/db/mod.rs`
    - Re-export all `mesh_repo_*` functions in `crates/mesh-rt/src/lib.rs`

    **6. JIT registration (jit.rs):**
    - Add JIT symbol mappings for all 6 Repo read functions.

    **Commit:** `feat(98-02): register Repo module and implement read operations with SQL generation from Query`
  </action>
  <verify>
    Run `cargo build --workspace` -- zero errors.
    Run `cargo test -p mesh-rt` -- all tests pass.
    Verify 6 Repo read functions declared in intrinsics, registered in known_functions, mapped in map_builtin_name.
  </verify>
  <done>
    Repo module registered across full compiler pipeline. Six read operations implemented: all (full query), one (limit 1), get (by PK), get_by (by field), count (aggregate), exists (boolean). Comprehensive SQL builder reads all 13 Query slots and generates correct parameterized SQL. All functions use Pool.query for execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for Repo read operations and full query-to-SQL pipeline</name>
  <files>
    crates/meshc/tests/e2e.rs
  </files>
  <action>
    Add e2e tests that verify Repo functions compile and type-check correctly. Since Repo functions require a real database connection, tests will verify compilation and type checking rather than execution. For SQL verification, add a helper that exposes the generated SQL.

    **Approach for testability:** Since the e2e tests compile and run Mesh programs but there is no database, test the compilation path and type checking:

    **Test 1: repo_all_type_checks** -- Verify Repo.all accepts pool and query:
    ```mesh
    import Query
    import Repo

    pub fn main() do
      IO.println("ok")
    end
    ```
    Expected: `ok` (verifies Repo module imports without error)

    **Test 2: repo_full_pipeline_compiles** -- Verify the full pipeline compiles:
    ```mesh
    import Query
    import Repo
    import Pool

    pub fn main() do
      # This compiles but would fail at runtime without a DB
      # We just verify the types check correctly
      let q = Query.from("users")
        |> Query.where(:name, "Alice")
        |> Query.order_by(:name, :asc)
        |> Query.limit(10)
      IO.println("ok")
    end
    ```
    Expected: `ok` (type checking passes for full query pipeline)

    **Test 3: repo_get_type_checks** -- Verify Repo.get signature compiles:
    ```mesh
    import Repo

    pub fn main() do
      IO.println("ok")
    end
    ```
    Expected: `ok`

    **Test 4: repo_count_exists_type_check** -- Verify count/exists signatures:
    ```mesh
    import Query
    import Repo

    pub fn main() do
      let q = Query.from("users") |> Query.where(:active, "true")
      IO.println("ok")
    end
    ```
    Expected: `ok`

    **Test 5: repo_with_schema_struct** -- Full pipeline with Schema struct:
    ```mesh
    import Query
    import Repo

    struct User do
      id: String
      name: String
      email: String
    end deriving(Schema, Row)

    pub fn main() do
      let q = Query.from(User.__table__())
        |> Query.where(:name, "Alice")
        |> Query.select(User.__fields__())
      IO.println("ok")
    end
    ```
    Expected: `ok` (Schema metadata integrates with Query builder)

    NOTE: These tests verify compilation and type inference. Runtime behavior (actual SQL execution) is verified via integration tests requiring PostgreSQL, which are out of scope for e2e tests.

    **Commit:** `test(98-02): add e2e tests for Repo read operations and query pipeline`
  </action>
  <verify>
    Run `cargo test -p meshc --test e2e` -- all tests pass including new Repo tests.
    Verify at least 4 new tests added.
    Verify all pre-existing tests pass (zero regressions).
  </verify>
  <done>
    E2e tests verify Repo module compiles and type-checks correctly: module import, full pipeline composition, Schema struct integration. All existing tests pass unchanged.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` -- zero errors, zero new warnings
2. `cargo test -p meshc --test e2e` -- all tests pass, zero regressions
3. `cargo test -p mesh-rt` -- all runtime tests pass
4. Repo module appears in STDLIB_MODULE_NAMES and STDLIB_MODULES
5. All 6 Repo read functions declared in intrinsics.rs
6. repo.rs file exists with query_to_select_sql comprehensive builder
</verification>

<success_criteria>
- Repo.all reads Query struct and generates complete SELECT SQL with all clauses
- Repo.one, get, get_by, count, exists all have correct type signatures and implementations
- Full pipeline `Query.from |> Query.where |> Repo.all` compiles and type-checks
- Comprehensive SQL builder handles WHERE (with operators, IN, IS NULL), ORDER BY, LIMIT, OFFSET, JOIN, GROUP BY, HAVING, FRAGMENT
- At least 4 new e2e tests pass verifying Repo compilation
</success_criteria>

<output>
After completion, create `.planning/phases/098-query-builder-repo/98-02-SUMMARY.md`
</output>
