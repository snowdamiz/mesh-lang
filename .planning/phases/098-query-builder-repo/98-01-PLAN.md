---
phase: 98-query-builder-repo
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/mesh-typeck/src/infer.rs
  - crates/mesh-codegen/src/mir/lower.rs
  - crates/mesh-codegen/src/codegen/intrinsics.rs
  - crates/mesh-rt/src/db/query.rs
  - crates/mesh-rt/src/db/mod.rs
  - crates/mesh-rt/src/lib.rs
  - crates/mesh-repl/src/jit.rs
  - crates/meshc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Query.from('users') creates an opaque Query value representing a SELECT from the users table"
    - "Query builder functions (where, select, order_by, limit, offset, join, group_by, having, fragment) are pipe-composable: each takes a Query and returns a new Query without mutating the original"
    - "Query.where supports equality (3-arg) and operator (4-arg) overloads plus where_in/where_null/where_not_null variants"
    - "Atoms (:name, :eq, :gt, :asc, :desc, :inner, :left, :right) work as field and operator arguments in query builder calls"
    - "Composable scopes work as regular functions that take and return Query values"
  artifacts:
    - path: "crates/mesh-rt/src/db/query.rs"
      provides: "Query struct runtime: opaque 13-slot heap object, all builder functions as extern C"
    - path: "crates/mesh-typeck/src/infer.rs"
      provides: "Query module type signatures in STDLIB_MODULE_NAMES and build_stdlib_modules"
    - path: "crates/mesh-codegen/src/mir/lower.rs"
      provides: "Query module in STDLIB_MODULES, known_functions, map_builtin_name, pipe schema-to-table transform"
    - path: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM intrinsic declarations for all Query runtime functions"
  key_links:
    - from: "crates/mesh-typeck/src/infer.rs"
      to: "crates/mesh-codegen/src/mir/lower.rs"
      via: "Query module function signatures match known_functions declarations"
      pattern: "query_from.*query_where.*query_select"
    - from: "crates/mesh-codegen/src/mir/lower.rs"
      to: "crates/mesh-rt/src/db/query.rs"
      via: "map_builtin_name maps Query.fn to mesh_query_fn extern C symbols"
      pattern: "mesh_query_from.*mesh_query_where"
    - from: "crates/mesh-codegen/src/codegen/intrinsics.rs"
      to: "crates/mesh-rt/src/db/query.rs"
      via: "LLVM intrinsic declarations match extern C function signatures"
      pattern: "mesh_query"
---

<objective>
Implement the Query struct as an opaque runtime-managed Ptr and all pipe-composable builder functions (from, where, where_in, where_null, where_not_null, select, order_by, limit, offset, join, group_by, having, fragment). Register the Query module across the full compiler pipeline (typeck, MIR, intrinsics, JIT). Add pipe-chain schema-to-table transformation so `User |> Query.where(...)` works.

Purpose: Provides the composable query building foundation that Repo operations (98-02, 98-03) consume to execute SQL against PostgreSQL.
Output: Query runtime module, compiler registration, e2e tests verifying pipe-composable query construction.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/098-query-builder-repo/98-RESEARCH.md
@.planning/phases/97-schema-metadata-sql-generation/97-02-SUMMARY.md
@crates/mesh-typeck/src/infer.rs
@crates/mesh-codegen/src/mir/lower.rs
@crates/mesh-codegen/src/codegen/intrinsics.rs
@crates/mesh-rt/src/db/orm.rs
@crates/mesh-rt/src/db/mod.rs
@crates/mesh-repl/src/jit.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register Query module in compiler pipeline and implement runtime Query struct with builder functions</name>
  <files>
    crates/mesh-typeck/src/infer.rs
    crates/mesh-codegen/src/mir/lower.rs
    crates/mesh-codegen/src/codegen/intrinsics.rs
    crates/mesh-rt/src/db/query.rs
    crates/mesh-rt/src/db/mod.rs
    crates/mesh-rt/src/lib.rs
    crates/mesh-repl/src/jit.rs
  </files>
  <action>
    **1. Type checker (infer.rs):**
    - Add `"Query"` to `STDLIB_MODULE_NAMES` array (alongside Pool, Orm, etc.)
    - In `build_stdlib_modules()`, register Query module functions with these type signatures:
      ```
      Query.from(String) -> Ptr                          // creates Query from table name
      Query.where(Ptr, String, String) -> Ptr             // 3-arg: field = value equality
      Query.where(Ptr, String, String, String) -> Ptr     // 4-arg: field op value
      Query.where_in(Ptr, String, Ptr) -> Ptr             // field IN values_list
      Query.where_null(Ptr, String) -> Ptr                // field IS NULL
      Query.where_not_null(Ptr, String) -> Ptr            // field IS NOT NULL
      Query.select(Ptr, Ptr) -> Ptr                       // select fields (List<String>)
      Query.order_by(Ptr, String, String) -> Ptr          // field, direction atom
      Query.limit(Ptr, Int) -> Ptr                        // limit count
      Query.offset(Ptr, Int) -> Ptr                       // offset count
      Query.join(Ptr, String, String, String) -> Ptr      // type atom, table, on_clause
      Query.group_by(Ptr, String) -> Ptr                  // field atom
      Query.having(Ptr, String, String) -> Ptr            // clause, value
      Query.fragment(Ptr, String, Ptr) -> Ptr             // raw sql, params list
      ```
    - Note: Atoms lower to String at MIR level per 96-01 decision. The type checker uses String type for atom parameters since atoms are compile-time only. The `where` function needs TWO overloads by arity (3-arg and 4-arg). Register both in the module -- use `"where"` for the 3-arg version. For the 4-arg version, since Mesh does NOT support same-name different-arity overloading in module registration, register it as `"where_op"` in the module map. The MIR lowerer will handle the mapping from the 4-arg `Query.where` call to `mesh_query_where_op` via arity-based dispatch.

    **IMPORTANT -- Arity-based where dispatch:** Mesh multi-clause functions support different arities, but stdlib module registration maps names to single signatures. Two approaches:
    - **(A)** Register `where` as 3-arg AND separately `where_op` as 4-arg. Users write `Query.where(q, :name, "Alice")` for equality and `Query.where(q, :age, :gt, "21")` for operator form. The type checker resolves based on arity.
    - **(B)** Register only 4-arg `where` and require users always pass operator: `Query.where(q, :name, :eq, "Alice")`.

    **Choose approach (A):** Register `"where"` as 3-arg (equality shorthand), `"where_op"` as 4-arg. In user code, `Query.where(q, :name, "Alice")` uses the 3-arg version, `Query.where(q, :name, :gt, "21")` uses the... wait, that's also 3 args to the module (since q comes from pipe). Let me reconsider.

    Actually, with pipe: `q |> Query.where(:name, "Alice")` desugars to `Query.where(q, :name, "Alice")` = 3 explicit args. And `q |> Query.where(:name, :gt, "21")` desugars to `Query.where(q, :name, :gt, "21")` = 4 explicit args. So we need two arity overloads for `where` in the module.

    Check how the module system handles multi-arity: if `build_stdlib_modules` uses a HashMap<String, Scheme>, it can only store ONE signature per name. If so, use separate names: `where` (3-arg) and `where_op` (4-arg). Users call `Query.where_op(q, :name, :gt, "21")` for operator form. This is the simpler, more reliable approach.

    Register these function names in the Query module map:
    - `"from"`, `"where"`, `"where_op"`, `"where_in"`, `"where_null"`, `"where_not_null"`, `"select"`, `"order_by"`, `"limit"`, `"offset"`, `"join"`, `"group_by"`, `"having"`, `"fragment"`

    **2. MIR lowerer (lower.rs):**
    - Add `"Query"` to `STDLIB_MODULES` array
    - In `register_known_functions()`, add known_functions entries for all 14 Query functions:
      ```
      "mesh_query_from"          -> FnPtr([Ptr], Ptr)
      "mesh_query_where"         -> FnPtr([Ptr, Ptr, Ptr], Ptr)
      "mesh_query_where_op"      -> FnPtr([Ptr, Ptr, Ptr, Ptr], Ptr)
      "mesh_query_where_in"      -> FnPtr([Ptr, Ptr, Ptr], Ptr)
      "mesh_query_where_null"    -> FnPtr([Ptr, Ptr], Ptr)
      "mesh_query_where_not_null"-> FnPtr([Ptr, Ptr], Ptr)
      "mesh_query_select"        -> FnPtr([Ptr, Ptr], Ptr)
      "mesh_query_order_by"      -> FnPtr([Ptr, Ptr, Ptr], Ptr)
      "mesh_query_limit"         -> FnPtr([Ptr, Int], Ptr)
      "mesh_query_offset"        -> FnPtr([Ptr, Int], Ptr)
      "mesh_query_join"          -> FnPtr([Ptr, Ptr, Ptr, Ptr], Ptr)
      "mesh_query_group_by"      -> FnPtr([Ptr, Ptr], Ptr)
      "mesh_query_having"        -> FnPtr([Ptr, Ptr, Ptr], Ptr)
      "mesh_query_fragment"      -> FnPtr([Ptr, Ptr, Ptr], Ptr)
      ```
    - In `map_builtin_name()`, add mappings:
      ```
      "query_from" => "mesh_query_from"
      "query_where" => "mesh_query_where"
      "query_where_op" => "mesh_query_where_op"
      "query_where_in" => "mesh_query_where_in"
      "query_where_null" => "mesh_query_where_null"
      "query_where_not_null" => "mesh_query_where_not_null"
      "query_select" => "mesh_query_select"
      "query_order_by" => "mesh_query_order_by"
      "query_limit" => "mesh_query_limit"
      "query_offset" => "mesh_query_offset"
      "query_join" => "mesh_query_join"
      "query_group_by" => "mesh_query_group_by"
      "query_having" => "mesh_query_having"
      "query_fragment" => "mesh_query_fragment"
      ```
    - **Pipe schema-to-table transformation:** In the pipe lowering code (where `lower_pipe_expr` or `infer_pipe` processes `LHS |> RHS`), add special handling: when the LHS of a pipe expression resolves to a struct type name that has `deriving(Schema)`, AND the RHS is a Query module function call, transform the LHS from a type reference to a call to `StructName.__table__()`. This produces a String value that `Query.where` (or any first Query builder function) uses to create a new Query via `Query.from` implicitly.

    **Implementation detail for pipe transform:** The simplest approach is to handle this in the type checker's `infer_pipe`. When the LHS type is a type constructor (struct name) and the RHS call target is a Query module function, insert an implicit `Query.from(__table__())` call. Check how the existing pipe inference works for this. If that's too complex, an alternative: in the MIR lowerer, when lowering a pipe where the LHS is a NameRef that resolves to a Schema struct's module, emit a call to the `__table__` function. The key integration point is wherever `User` in `User |> Query.where(...)` gets lowered -- intercept it and replace with the __table__ call result.

    **3. LLVM intrinsics (intrinsics.rs):**
    - Declare all 14 Query extern C functions following the exact pattern used for Orm functions in the same file.
    - Each function takes the appropriate number of `i8*` (Ptr) and `i64` (Int) parameters and returns `i8*` (Ptr).

    **4. Runtime implementation (query.rs):**
    Create `crates/mesh-rt/src/db/query.rs` with the Query struct runtime:

    **Query object layout:** 13 slots, each 8 bytes (104 bytes total), allocated via `mesh_gc_alloc_actor`:
    ```
    slot 0  (offset  0): source          (*mut u8 -> MeshString for table name)
    slot 1  (offset  8): select_fields   (*mut u8 -> List<String>, null = SELECT *)
    slot 2  (offset 16): where_clauses   (*mut u8 -> List<String>)
    slot 3  (offset 24): where_params    (*mut u8 -> List<String>)
    slot 4  (offset 32): order_fields    (*mut u8 -> List<String>)
    slot 5  (offset 40): limit_val       (i64 tagged: -1 = no limit)
    slot 6  (offset 48): offset_val      (i64 tagged: -1 = no offset)
    slot 7  (offset 56): join_clauses    (*mut u8 -> List<String>)
    slot 8  (offset 64): group_fields    (*mut u8 -> List<String>)
    slot 9  (offset 72): having_clauses  (*mut u8 -> List<String>)
    slot 10 (offset 80): having_params   (*mut u8 -> List<String>)
    slot 11 (offset 88): fragment_parts  (*mut u8 -> List<String>)
    slot 12 (offset 96): fragment_params (*mut u8 -> List<String>)
    ```

    Helper functions for field access:
    ```rust
    const QUERY_SLOTS: usize = 13;
    const QUERY_SIZE: usize = QUERY_SLOTS * 8; // 104 bytes

    unsafe fn query_get(q: *mut u8, slot: usize) -> *mut u8 {
        *(q.add(slot * 8) as *mut *mut u8)
    }
    unsafe fn query_set(q: *mut u8, slot: usize, val: *mut u8) {
        *(q.add(slot * 8) as *mut *mut u8) = val;
    }
    unsafe fn query_get_int(q: *mut u8, slot: usize) -> i64 {
        *(q.add(slot * 8) as *mut i64)
    }
    unsafe fn query_set_int(q: *mut u8, slot: usize, val: i64) {
        *(q.add(slot * 8) as *mut i64) = val;
    }
    ```

    **`mesh_query_from(table: *mut u8) -> *mut u8`:**
    1. Allocate 104 bytes via `mesh_gc_alloc_actor(104, 8)` (8-byte alignment)
    2. Zero-fill all slots: `std::ptr::write_bytes(ptr, 0, 104)`
    3. Set slot 0 = table (source MeshString)
    4. Set slot 1 through 4, 7-12 = empty list via `mesh_list_new()` (call the existing list constructor)
    5. Set slot 5 (limit) = -1i64 (tagged: store -1 directly as i64)
    6. Set slot 6 (offset) = -1i64
    7. Return the Query pointer

    **Each builder function (e.g., `mesh_query_where`):**
    1. Allocate new 104-byte Query via `mesh_gc_alloc_actor(104, 8)`
    2. Copy all 104 bytes from input query: `std::ptr::copy_nonoverlapping(old, new, 104)`
    3. Modify relevant slot(s):
       - For `where`: Create the clause string `"field ="` (concatenate field + " ="), append to where_clauses list (slot 2), append value to where_params list (slot 3). Use `mesh_list_append` to create new list with appended element.
       - For `where_op`: Map operator atom string to SQL operator ("eq"->"=", "neq"->"!=", "gt"->">", "lt"->"<", "gte"->">=", "lte"->"<=", "like"->"LIKE"). Create clause string `"field op"`, append to where_clauses (slot 2), append value to where_params (slot 3).
       - For `where_in`: Create clause `"field IN:N"` where N = list length. Append to where_clauses (slot 2). Iterate values list and append each to where_params (slot 3).
       - For `where_null`: Create clause `"field IS NULL"`. Append to where_clauses (slot 2). Do NOT add to where_params.
       - For `where_not_null`: Create clause `"field IS NOT NULL"`. Append to where_clauses (slot 2). Do NOT add to where_params.
       - For `select`: Set slot 1 = fields list argument directly (replace, not append)
       - For `order_by`: Create order string `"field direction"` (map :asc->"ASC", :desc->"DESC"). Append to order_fields (slot 4).
       - For `limit`: Set slot 5 = n (i64)
       - For `offset`: Set slot 6 = n (i64)
       - For `join`: Create join string `"TYPE:table:on_clause"` (map :inner->"INNER", :left->"LEFT", :right->"RIGHT"). Append to join_clauses (slot 7).
       - For `group_by`: Append field to group_fields (slot 8).
       - For `having`: Append clause to having_clauses (slot 9), value to having_params (slot 10).
       - For `fragment`: Append sql to fragment_parts (slot 11), params list elements to fragment_params (slot 12).
    4. Return new Query pointer

    **String manipulation helpers:** Use existing runtime functions:
    - `mesh_string_concat(a, b)` to build clause strings
    - `mesh_string_from_rust_string` to create MeshString from Rust &str
    - `mesh_list_new()` to create empty lists
    - `mesh_list_append(list, element)` to append to lists
    - Check existing `mesh-rt/src/lib.rs` for the exact function signatures and how to call them from Rust.

    **Atom-to-operator mapping:** Implement a helper function:
    ```rust
    fn atom_to_sql_op(atom: &str) -> &str {
        match atom {
            "eq" => "=", "neq" => "!=",
            "lt" => "<", "gt" => ">",
            "lte" => "<=", "gte" => ">=",
            "like" => "LIKE",
            _ => "=",  // default to equality
        }
    }
    ```

    **5. Module registration (mod.rs, lib.rs):**
    - Add `pub mod query;` to `crates/mesh-rt/src/db/mod.rs`
    - Re-export all `mesh_query_*` functions in `crates/mesh-rt/src/lib.rs`

    **6. JIT registration (jit.rs):**
    - Add JIT symbol mappings for all 14 Query functions following the existing pattern for Orm functions.

    **Commit:** `feat(98-01): register Query module and implement runtime query builder functions`
  </action>
  <verify>
    Run `cargo build --workspace` from project root -- must compile with zero errors.
    Run `cargo test -p mesh-rt` -- any existing runtime tests must pass.
    Verify all 14 Query functions are declared in intrinsics.rs, registered in known_functions, mapped in map_builtin_name.
  </verify>
  <done>
    Query module registered across typeck (STDLIB_MODULE_NAMES + function types), MIR (STDLIB_MODULES + known_functions + map_builtin_name), intrinsics (LLVM declarations), JIT (symbol mappings), and runtime (extern C functions in query.rs). All 14 builder functions implemented with immutable copy-on-write semantics. Pipe schema-to-table transformation handles `User |> Query.where(...)` pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add e2e tests for Query builder pipe composition and composable scopes</name>
  <files>
    crates/meshc/tests/e2e.rs
  </files>
  <action>
    Add e2e tests to the existing test file that verify Query builder functions compile and execute correctly.

    **Test 1: query_builder_basic_from** -- Verify `Query.from("users")` creates a Query value that can be used:
    ```mesh
    import Query
    let q = Query.from("users")
    IO.println("ok")
    ```
    Expected output: `ok` (verifies Query.from returns a valid Ptr)

    **Test 2: query_builder_pipe_chain** -- Verify pipe-composable chain:
    ```mesh
    import Query
    let q = Query.from("users")
      |> Query.where(:name, "Alice")
      |> Query.order_by(:name, :asc)
      |> Query.limit(10)
    IO.println("ok")
    ```
    Expected output: `ok` (verifies chaining works without crash)

    **Test 3: query_builder_where_op** -- Verify operator-based where:
    ```mesh
    import Query
    let q = Query.from("posts")
      |> Query.where_op(:age, :gt, "21")
      |> Query.where_null(:deleted_at)
      |> Query.where_not_null(:name)
    IO.println("ok")
    ```
    Expected output: `ok`

    **Test 4: query_builder_all_clauses** -- Verify all clause types compile:
    ```mesh
    import Query
    let q = Query.from("events")
      |> Query.select(["id", "name"])
      |> Query.where(:status, "active")
      |> Query.order_by(:created_at, :desc)
      |> Query.limit(100)
      |> Query.offset(20)
      |> Query.group_by(:category)
      |> Query.having("count(*) >", "5")
    IO.println("ok")
    ```
    Expected output: `ok`

    **Test 5: query_builder_immutability** -- Verify original Query unchanged after pipe:
    ```mesh
    import Query
    let q1 = Query.from("users")
    let q2 = q1 |> Query.where(:name, "Alice")
    let q3 = q1 |> Query.where(:name, "Bob")
    IO.println("ok")
    ```
    Expected output: `ok` (q1 unmodified; q2 and q3 are independent)

    **Test 6: query_builder_composable_scope** -- Verify scopes as pure functions:
    ```mesh
    import Query

    pub fn active(q) do
      q |> Query.where(:status, "active")
    end

    pub fn recent(q) do
      q |> Query.order_by(:created_at, :desc) |> Query.limit(10)
    end

    pub fn main() do
      let q = Query.from("users") |> active() |> recent()
      IO.println("ok")
    end
    ```
    Expected output: `ok` (composable scopes work as regular functions)

    **Test 7: query_builder_schema_pipe** -- Verify `User |> Query.where(...)` with schema struct (if pipe transform implemented):
    ```mesh
    import Query

    struct User do
      id: String
      name: String
    end deriving(Schema)

    pub fn main() do
      let q = User |> Query.where(:name, "Alice")
      IO.println("ok")
    end
    ```
    Expected output: `ok` (Schema struct at pipe LHS transforms to table name)

    NOTE: If the pipe schema-to-table transformation proves too complex for this plan, test 7 can use `Query.from(User.__table__())` as fallback. The explicit form is always valid. Mark this test as testing the explicit form if the implicit pipe transform is deferred.

    **Commit:** `test(98-01): add e2e tests for Query builder pipe composition and composable scopes`
  </action>
  <verify>
    Run the full e2e test suite: `cargo test -p meshc --test e2e` -- all tests pass including new Query builder tests.
    Verify at least 6 new tests added.
    Verify all pre-existing tests still pass (zero regressions).
  </verify>
  <done>
    At least 6 e2e tests pass verifying: Query.from creates valid Query, pipe-chain composition works, where/where_op/where_null variants work, all clause types compile, immutability preserved, composable scopes function as regular Mesh functions. Total e2e test count increased from 180+ baseline.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` -- zero errors, zero new warnings
2. `cargo test -p meshc --test e2e` -- all tests pass, zero regressions
3. `cargo test -p mesh-rt` -- all runtime tests pass
4. Query module appears in STDLIB_MODULE_NAMES and STDLIB_MODULES
5. All 14 Query runtime functions declared in intrinsics.rs
6. query.rs file exists in mesh-rt/src/db/ with all builder functions
</verification>

<success_criteria>
- Query.from("table") creates a valid opaque Query Ptr
- All builder functions are pipe-composable and return new Query Ptrs
- Composable scopes (regular functions taking/returning Query) work in pipe chains
- At least 6 e2e tests pass demonstrating query construction
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/098-query-builder-repo/98-01-SUMMARY.md`
</output>
