---
phase: 51-http-path-parameters
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/src/http/router.rs
  - crates/snow-rt/src/http/server.rs
  - crates/snow-rt/src/http/mod.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "Router matches /users/42 against route pattern /users/:id"
    - "Request.param(req, 'id') returns Some('42') for matched path parameter"
    - "HTTP.get(router, path, handler) registers a GET-only route"
    - "HTTP.post/put/delete register method-specific routes"
    - "Exact routes /users/me match before parameterized /users/:id"
    - "Existing HTTP.route still works as method-agnostic catch-all"
    - "Existing HTTP.get(url) client function still works with 1 arg"
  artifacts:
    - path: "crates/snow-rt/src/http/router.rs"
      provides: "Segment-based path matching with param extraction, method field on RouteEntry"
      contains: "fn match_segments"
    - path: "crates/snow-rt/src/http/server.rs"
      provides: "path_params field on SnowHttpRequest, snow_http_request_param accessor"
      contains: "snow_http_request_param"
    - path: "crates/snow-rt/src/http/mod.rs"
      provides: "Re-exports for all new runtime functions"
      contains: "snow_http_route_get"
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "LLVM declarations for 5 new runtime functions"
      contains: "snow_http_route_get"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Type signatures for http_route_get/post/put/delete and request_param"
      contains: "http_route_get"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Arity-based dispatch for HTTP.get/post, known_functions, map_builtin_name entries"
      contains: "http_route_get"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/http/router.rs"
      via: "map_builtin_name arity dispatch"
      pattern: "snow_http_route_get"
    - from: "crates/snow-typeck/src/builtins.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "typeck registers http_route_get, lower maps to snow_http_route_get"
      pattern: "http_route_get"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/http/router.rs"
      via: "handle_request calls match_route which returns params"
      pattern: "path_params"
---

<objective>
Implement path parameter matching, method-specific routing, and parameter extraction across the Snow runtime and compiler pipeline.

Purpose: This is the core infrastructure for Phase 51 -- extending the HTTP router to support REST-style dynamic routes (/users/:id) with method-specific dispatch (HTTP.get, HTTP.post, HTTP.put, HTTP.delete) and parameter extraction (Request.param). Without this, Snow programs cannot build RESTful APIs.

Output: 6 modified files spanning runtime (router.rs, server.rs, mod.rs), codegen (intrinsics.rs), typeck (builtins.rs), and MIR lowering (lower.rs). All existing HTTP tests must continue to pass (backward compatibility).
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-http-path-parameters/51-RESEARCH.md
@crates/snow-rt/src/http/router.rs
@crates/snow-rt/src/http/server.rs
@crates/snow-rt/src/http/mod.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Runtime -- path parameter matching, method-specific routing, and request param accessor</name>
  <files>
    crates/snow-rt/src/http/router.rs
    crates/snow-rt/src/http/server.rs
    crates/snow-rt/src/http/mod.rs
  </files>
  <action>
**router.rs changes:**

1. Add `method: Option<String>` field to `RouteEntry` struct (after `pattern`, before `handler_fn`). Update ALL existing code that constructs `RouteEntry` to include `method: None`.

2. Add a `match_segments` function that performs segment-based matching with parameter extraction:
```
fn match_segments(pattern: &str, path: &str) -> Option<Vec<(String, String)>>
```
Split both pattern and path on `/`, filter out empty segments. If segment counts differ, return None. For each segment pair: if pattern segment starts with `:`, capture (name[1..], actual) into params vec. If pattern segment is literal and doesn't equal actual, return None. Return Some(params) on success.

3. Determine if a pattern has parameter segments (contains `:`). This is used for priority ordering.

4. Change `SnowRouter::match_route` signature to return `Option<(*mut u8, *mut u8, Vec<(String, String)>)>` (handler_fn, handler_env, params). Implement two-pass matching for exact > parameterized priority:
   - First pass: try routes that have NO `:` segments (exact and wildcard patterns). Use existing `matches_pattern` for these. Return empty params vec.
   - Second pass: try routes that have `:` segments. Use `match_segments` for these. Return captured params.
   - In both passes, also check method: if `entry.method` is `Some(m)`, only match if provided HTTP method equals `m`. If `entry.method` is `None`, match any method.
   - The `match_route` method needs to accept the HTTP method as a parameter: `pub fn match_route(&self, path: &str, method: &str) -> Option<(...)>`

5. Add a helper function `route_with_method` (not `#[no_mangle]`, internal) that creates a new router with a route entry including the method field. This is shared by the 4 method-specific extern functions.

6. Add 4 new `#[no_mangle] pub extern "C"` functions, each calling `route_with_method`:
   - `snow_http_route_get(router, pattern, handler_fn) -> *mut u8` -- method: Some("GET")
   - `snow_http_route_post(router, pattern, handler_fn) -> *mut u8` -- method: Some("POST")
   - `snow_http_route_put(router, pattern, handler_fn) -> *mut u8` -- method: Some("PUT")
   - `snow_http_route_delete(router, pattern, handler_fn) -> *mut u8` -- method: Some("DELETE")

7. Update existing `snow_http_route` to set `method: None` (backward compatible).

8. Update existing unit tests: `RouteEntry` constructions need `method: None`. `match_route` calls need a method arg (use "GET"). Add new tests:
   - `test_segment_matching`: verify `/users/:id` matches `/users/42` and captures id=42
   - `test_segment_no_match`: verify `/users/:id` does NOT match `/users/42/extra`
   - `test_exact_beats_param`: verify exact `/users/me` matches before parameterized `/users/:id`
   - `test_method_filtering`: verify GET-only route doesn't match POST request

**server.rs changes:**

1. Add `pub path_params: *mut u8` field to `SnowHttpRequest` -- APPEND at the end after `headers`. This is critical for repr(C) safety.

2. In `handle_request`, update the `match_route` call to pass the HTTP method string and destructure the 3-tuple `(handler_fn, handler_env, params)`.

3. After matching, convert the `Vec<(String, String)>` params into a `SnowMap` using `map::snow_map_new()` and `map::snow_map_put()`, then assign to `(*snow_req).path_params`.

4. For the 404 no-match case and as the default initialization, set `path_params` to `map::snow_map_new()` (empty map).

5. Add `snow_http_request_param` accessor function -- follows the EXACT pattern of `snow_http_request_query`:
```rust
#[no_mangle]
pub extern "C" fn snow_http_request_param(req: *mut u8, name: *const SnowString) -> *mut u8 {
    unsafe {
        let request = &*(req as *const SnowHttpRequest);
        let key_str = (*name).as_str();
        let key_snow = snow_string_new(key_str.as_ptr(), key_str.len() as u64);
        let val = map::snow_map_get(request.path_params, key_snow as u64);
        if val == 0 {
            alloc_option(1, std::ptr::null_mut())
        } else {
            alloc_option(0, val as *mut u8)
        }
    }
}
```

6. Update the `test_request_accessors` test to initialize `path_params` field on the manually-built SnowHttpRequest.

**mod.rs changes:**

1. Add re-exports for the new functions:
   - From router: `snow_http_route_get`, `snow_http_route_post`, `snow_http_route_put`, `snow_http_route_delete`
   - From server: `snow_http_request_param`
  </action>
  <verify>
Run `cargo test -p snow-rt` -- all existing HTTP tests pass plus new router unit tests pass. Specifically check:
- `test_segment_matching` passes
- `test_exact_beats_param` passes
- `test_method_filtering` passes
- `test_router_match_order` still passes (backward compat)
- `test_request_accessors` still passes
  </verify>
  <done>
Runtime has segment-based path matching with parameter extraction, method-specific routing via 4 new extern "C" functions, and Request.param accessor. All existing HTTP tests pass unchanged (backward compatible). New unit tests verify param extraction, priority ordering, and method filtering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compiler pipeline -- intrinsics, type checker, and MIR lowering with arity-based dispatch</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**intrinsics.rs changes:**

Add 5 new LLVM function declarations after the existing HTTP declarations (~line 448):

```rust
// snow_http_route_get(router: ptr, pattern: ptr, handler_fn: ptr) -> ptr
module.add_function("snow_http_route_get", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));

// snow_http_route_post(router: ptr, pattern: ptr, handler_fn: ptr) -> ptr
module.add_function("snow_http_route_post", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));

// snow_http_route_put(router: ptr, pattern: ptr, handler_fn: ptr) -> ptr
module.add_function("snow_http_route_put", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));

// snow_http_route_delete(router: ptr, pattern: ptr, handler_fn: ptr) -> ptr
module.add_function("snow_http_route_delete", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));

// snow_http_request_param(req: ptr, name: ptr) -> ptr (SnowOption)
module.add_function("snow_http_request_param", ptr_type.fn_type(&[ptr_type.into(), ptr_type.into()], false), Some(inkwell::module::Linkage::External));
```

Update the `test_declare_intrinsics` test to assert all 5 new functions exist.

**builtins.rs changes:**

Add type registrations in the HTTP section (after `http_post`, ~line 567):

```rust
// HTTP.get(Router, String, Fn(Request) -> Response) -> Router  (routing variant -- 3 args)
// NOTE: registered as http_route_get to avoid collision with http_get client.
// MIR lowering dispatches HTTP.get with 3 args to http_route_get.
env.insert(
    "http_route_get".into(),
    Scheme::mono(Ty::fun(
        vec![router_t.clone(), Ty::string(), Ty::fun(vec![request_t.clone()], response_t.clone())],
        router_t.clone(),
    )),
);
// HTTP.post routing variant
env.insert(
    "http_route_post".into(),
    Scheme::mono(Ty::fun(
        vec![router_t.clone(), Ty::string(), Ty::fun(vec![request_t.clone()], response_t.clone())],
        router_t.clone(),
    )),
);
// HTTP.put routing variant
env.insert(
    "http_route_put".into(),
    Scheme::mono(Ty::fun(
        vec![router_t.clone(), Ty::string(), Ty::fun(vec![request_t.clone()], response_t.clone())],
        router_t.clone(),
    )),
);
// HTTP.delete routing variant
env.insert(
    "http_route_delete".into(),
    Scheme::mono(Ty::fun(
        vec![router_t.clone(), Ty::string(), Ty::fun(vec![request_t.clone()], response_t.clone())],
        router_t.clone(),
    )),
);

// Request.param(Request, String) -> Option<String>
env.insert(
    "request_param".into(),
    Scheme::mono(Ty::fun(
        vec![request_t.clone(), Ty::string()],
        Ty::option(Ty::string()),
    )),
);
```

Update the `test_http_builtins` test to assert `http_route_get`, `http_route_post`, `http_route_put`, `http_route_delete`, and `request_param` are registered.

**lower.rs changes:**

1. Add known_functions entries (~line 666, after existing HTTP entries):
```rust
self.known_functions.insert("snow_http_route_get".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::String, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_http_route_post".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::String, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_http_route_put".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::String, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_http_route_delete".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::String, MirType::Ptr], Box::new(MirType::Ptr)));
self.known_functions.insert("snow_http_request_param".to_string(), MirType::FnPtr(vec![MirType::Ptr, MirType::String], Box::new(MirType::Ptr)));
```

2. Add map_builtin_name entries (~line 8980, after existing request_ entries):
```rust
"request_param" => "snow_http_request_param".to_string(),
"http_route_get" => "snow_http_route_get".to_string(),
"http_route_post" => "snow_http_route_post".to_string(),
"http_route_put" => "snow_http_route_put".to_string(),
"http_route_delete" => "snow_http_route_delete".to_string(),
```

3. **CRITICAL: Arity-based dispatch for HTTP.get/post name collision.** In the stdlib module lowering path (inside `lower_call_expr`, around line 5352 where `STDLIB_MODULES.contains(&base_name.as_str())` is checked and the prefixed name is constructed), add arity-aware dispatch BEFORE calling `map_builtin_name`. When the base module is "HTTP" and the field is "get" or "post":

   The key insight: at the point where we construct `let prefixed = format!("{}_{}", base_name.to_lowercase(), field)` (line ~5358), we have the call's arg_list available from the enclosing `call` parameter of `lower_call_expr`. Count the args:
   - `http_get` with 3 args (router, pattern, handler) -> change prefixed to `"http_route_get"`
   - `http_get` with 1 arg (url) -> keep as `"http_get"` (client)
   - `http_post` with 3 args -> change to `"http_route_post"`
   - `http_post` with 2 args (url, body) -> keep as `"http_post"` (client)

   However, the stdlib module lowering at line ~5352 is inside `lower_field_access`, NOT inside `lower_call_expr`. The field access lowers to `MirExpr::Var(runtime_name, ty)` and the call happens in `lower_call_expr` which then wraps it in `MirExpr::Call`. So we need the arity info at the field access level.

   **Better approach:** The arity dispatch must happen in `lower_call_expr`, where we have both the callee and the arg list. The flow is:
   1. `lower_call_expr` sees `CallExpr` with callee being `FieldAccess(HTTP, get)` and 3 args
   2. It checks `is_module_or_special` = true (HTTP is a STDLIB_MODULE)
   3. Falls through to `let callee = self.lower_expr(&callee_expr)` which calls `lower_field_access`
   4. `lower_field_access` returns `MirExpr::Var("snow_http_get", ...)` (the client version)
   5. The call is emitted with the wrong function

   **Fix location:** After `lower_field_access` returns `MirExpr::Var(runtime_name, ty)` in step 4, but before emitting the call, intercept in `lower_call_expr`. After lowering the callee and args, check: if the callee is `MirExpr::Var("snow_http_get", _)` and args.len() == 3, rewrite to `MirExpr::Var("snow_http_route_get", ...)`. Same for `snow_http_post` with 3 args -> `snow_http_route_post`.

   Find the section in `lower_call_expr` where the callee has been lowered (after the module/special check falls through to the general path). After `let callee = self.lower_expr(&callee_expr);` and the args are lowered, add:

   ```rust
   // Arity-based dispatch for HTTP.get/post collision (Phase 51).
   // HTTP.get(url) -> snow_http_get (client, 1 arg)
   // HTTP.get(router, path, handler) -> snow_http_route_get (routing, 3 args)
   let callee = if let MirExpr::Var(ref name, ref ty) = callee {
       match (name.as_str(), args.len()) {
           ("snow_http_get", 3) => {
               let route_ty = self.known_functions.get("snow_http_route_get").cloned().unwrap_or(ty.clone());
               MirExpr::Var("snow_http_route_get".to_string(), route_ty)
           }
           ("snow_http_post", 3) => {
               let route_ty = self.known_functions.get("snow_http_route_post").cloned().unwrap_or(ty.clone());
               MirExpr::Var("snow_http_route_post".to_string(), route_ty)
           }
           _ => callee,
       }
   } else {
       callee
   };
   ```

   Place this AFTER both callee and args are lowered but BEFORE the `MirExpr::Call` is constructed and returned. Look for the general call emission path in `lower_call_expr` -- it should be after the method-call interception block, in the general case where the callee is lowered and args are collected.

   For `HTTP.put` and `HTTP.delete` there is NO naming collision (no existing client functions), so `map_builtin_name("http_put")` -> `"snow_http_route_put"` and `map_builtin_name("http_delete")` -> `"snow_http_route_delete"` work directly. Add these to map_builtin_name:
   ```rust
   "http_put" => "snow_http_route_put".to_string(),
   "http_delete" => "snow_http_route_delete".to_string(),
   ```

   NOTE: For the type checker, HTTP.get with 3 args needs to typecheck. Since typeck has `http_get` registered as `(String) -> Result`, calling `HTTP.get(router, path, handler)` with 3 args would fail typeck. The solution: in the typeck builtins, we registered `http_route_get` etc. But the Snow source writes `HTTP.get(...)` which the typeck sees as `http_get(...)`. This means the typeck needs to also handle the arity.

   **Simpler approach for typeck:** Since Snow's type checker uses HM unification, calling `HTTP.get(router, path, handler)` with mismatched arity will cause a type error. To fix this cleanly, the typeck should NOT try to resolve `http_get` for 3-arg calls. Instead, modify the typeck to register a SECOND overload or make the function polymorphic by arity.

   **Practical solution:** The Snow type checker likely does NOT enforce strict arity on builtins -- it just unifies the function type with the call-site args. If `http_get` is `String -> Result<String,String>` and we call it with 3 args `(Router, String, Fn)`, unification would fail. So we need the typeck to see the right type.

   Check how this actually works: the typeck looks up `http_get` from the env, gets its type `String -> Result<String,String>`. The call has 3 args. Unification of a 1-param function with 3 args should fail. This WILL cause a type error.

   **Resolution:** Do NOT fight the type checker. Instead, handle this at the MIR level ONLY. The type checker already skips unknown builtins gracefully (it infers types). Check if the Snow typeck actually rejects mismatched arity for builtins, or if it falls through. If it rejects, we may need to register the 3-arg variant under the SAME name `http_get` with the 3-arg signature. But HM type inference with two signatures for the same name is complex.

   **Most pragmatic approach:** Check the actual typeck behavior. If calling `HTTP.get(r, path, handler)` causes a type error, we need to either:
   a) Register BOTH signatures (hard), or
   b) Skip typeck for HTTP.get/post when called with routing arity (let MIR handle it), or
   c) Use different Snow-level names: `HTTP.on_get` instead of `HTTP.get` for routing

   **Recommendation:** If typeck rejects 3-arg HTTP.get, use the fallback naming: register `http_get` as-is (client), and for routing use the MIR-level dispatch with the prefixed name `http_route_get` visible from the typeck. The Snow surface syntax `HTTP.get(r, p, h)` will lower via STDLIB_MODULES to `http_get`, then the arity dispatch in lower_call_expr rewrites to `snow_http_route_get`. But the typeck sees `http_get` and tries to unify -- this is the problem.

   **FINAL APPROACH (simplest that works):** Make the typeck accept both arities. Do this by registering `http_get` with a generic/polymorphic type that accepts any args (e.g., register it with the 3-arg routing type, which subsumes the 1-arg client type through unification failure being caught). OR, since the Snow typeck has shown in past phases (Phase 49-50) that it can handle builtins with flexible typing via the `Ptr` type: register the routing variant under a separate internal name that MIR dispatches to.

   **ACTUALLY:** Re-read the typeck code. The Snow type checker uses `env.lookup("http_get")` which returns a single `Scheme`. If we need two signatures, we need two names. The simplest solution:

   1. Keep `http_get` in typeck as-is (1-arg client)
   2. Register `http_route_get` in typeck (3-arg routing)
   3. In the STDLIB_MODULES lowering path (lower_field_access ~line 5358), when base is "HTTP" and field is "get", instead of always producing `http_get`, check if the call has 3 args and produce `http_route_get` instead

   But `lower_field_access` doesn't have call arg info! Only `lower_call_expr` does. So the dispatch MUST be in lower_call_expr.

   **DEFINITIVE SOLUTION:** The arity dispatch in `lower_call_expr` is the right place but the typeck must also accept the 3-arg call. Since the typeck processes the call BEFORE MIR lowering, we need to ensure it doesn't reject `HTTP.get(router, path, handler)`. The typeck sees `http_get: (String) -> Result<String,String>` and 3 args -- this WILL fail unification.

   To fix: register `http_get` in typeck with a SECOND entry. Since `env.insert` with the same key would overwrite, we CAN'T have two. So instead, make the typeck flexible: register `http_get` with the WIDER type (3 args) and let the 1-arg call site also work through partial application or permissive unification. But Snow's type system doesn't have partial application.

   **SIMPLEST FIX:** Override the typeck for `http_get` to accept EITHER arity. This can be done by NOT registering it in env at all (letting the typeck infer it) or by registering with a very permissive type. But this breaks type safety.

   **CLEANEST FIX (recommended):** Accept that HTTP.get/HTTP.post have a naming collision and resolve it at the typeck level by registering both names AND performing the name rewrite BEFORE typeck. This means the parser/pre-typeck phase needs to know about arity. But we don't have a pre-typeck rewrite pass.

   **PRAGMATIC FIX:** Register `http_get` with the ROUTING signature (3-arg: Router, String, Fn -> Router) in typeck. This will make the client 1-arg call `HTTP.get(url)` fail typeck. Then ALSO keep the old `http_get` signature somehow. This is circular.

   **ACTUAL SIMPLEST FIX:** Since we can't overload in typeck, the arity dispatch must work around the type checker. The best way: in builtins.rs, remove the specific type for `http_get` and `http_post` and replace with a GENERIC type that accepts any args. Use a type variable:

   Actually, just check -- does the Snow typeck ACTUALLY reject arity mismatches for builtins? Many HM systems infer call sites independently and only unify when both are constrained. If `http_get` is `(a) -> b` (generic), it would unify with both 1-arg and 3-arg. But it's registered as `(String) -> Result<String,String>` (monomorphic).

   **TEST THIS:** Compile the existing `HTTP.get(url)` code. If it works, the typeck enforces the signature. Calling with 3 args should fail. So we MUST handle this.

   **FINAL DEFINITIVE APPROACH:** Use separate internal typeck names. The Snow source `HTTP.get(r, path, handler)` will still work because:
   1. Typeck sees `HTTP.get(...)` -- it resolves the module-qualified call. The typeck needs to know which internal name to look up based on arity.
   2. OR: Make the typeck skip strict checking for HTTP module calls (treat them as untyped/permissive).
   3. OR: Register `http_get` as a polymorphic scheme with a type variable.

   Approach 3 is cleanest: `http_get: forall a b. (a) -> b` would accept any call. But this loses all type safety for the client.

   **REAL FINAL APPROACH:** Check if the Snow typeck actually enforces function arity on module-qualified calls. Read builtins.rs registration: `http_get` is `Scheme::mono(Ty::fun(vec![Ty::string()], Ty::result(...)))`. When the user writes `HTTP.get(r, "/path", handler)`, the typeck:
   1. Resolves `HTTP.get` to `http_get`
   2. Looks up `http_get` in env -> gets `(String) -> Result<String,String>`
   3. Unifies function type with call args: 3 args vs 1 param -> unification FAILS

   So this WILL be rejected. The resolution: change the approach. Instead of `HTTP.get` for routing, expose it as `HTTP.get` but handle it in the typeck by checking arity and looking up different types.

   Modify the typeck's call resolution for module-qualified names: when resolving `HTTP.get` with 3 args, look up `http_route_get` instead of `http_get`. This requires the typeck to be arity-aware for specific names.

   **WHERE in typeck:** Find where the typeck resolves module-qualified calls. It likely has a similar STDLIB_MODULES pattern as the MIR lowerer.

   IMPORTANT: After reading the typeck code more carefully, determine the exact mechanism. The key question is: does the typeck resolve `HTTP.get(r, p, h)` to `http_get` and then try to unify? If so, we need to intercept there.

   **Alternative that avoids all this complexity:** Use `HTTP.on_get`, `HTTP.on_post`, `HTTP.on_put`, `HTTP.on_delete` as the Snow-level names for routing. No collision, no arity dispatch needed. Register `http_on_get` etc. Simple and clean. The research noted this as a fallback. Given the complexity of arity-based dispatch across typeck AND MIR, this is the pragmatic choice.

   **DECISION: If arity-based dispatch proves too complex in the typeck layer, fall back to HTTP.on_get/on_post/on_put/on_delete naming.** Try the arity approach first by examining the typeck's module-qualified call resolution. If it requires surgery across typeck AND MIR, use the `on_` prefix instead.

   The executor should:
   1. First check how the typeck resolves module-qualified calls (grep for how `HTTP.` calls flow through typeck)
   2. If the typeck has a clean interception point for arity-based name remapping, implement arity dispatch
   3. If not, use `HTTP.on_get`, `HTTP.on_post`, `HTTP.on_put`, `HTTP.on_delete` naming (register as `http_on_get` etc. in builtins, `map_builtin_name("http_on_get") => "snow_http_route_get"`)
  </action>
  <verify>
Run `cargo test -p snow-codegen` and `cargo test -p snow-typeck` -- all existing tests pass plus new intrinsic/builtin assertions pass. Run `cargo build` to verify full compilation. Specifically:
- intrinsics test asserts `snow_http_route_get/post/put/delete` and `snow_http_request_param` exist
- builtins test asserts routing and param type registrations exist
- No regressions in existing HTTP client/server compilation
  </verify>
  <done>
Compiler pipeline fully wired: LLVM intrinsic declarations, type checker registrations, MIR known_functions, map_builtin_name mappings, and arity-based dispatch (or on_ prefix fallback) for HTTP.get/post name collision. Snow source code writing `HTTP.get(router, "/path", handler)` (or `HTTP.on_get(...)`) and `Request.param(req, "id")` compiles through the full pipeline to the correct runtime function calls.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-rt` -- runtime tests pass (router matching, param extraction, method filtering)
2. `cargo test -p snow-codegen` -- intrinsics + MIR lowering tests pass
3. `cargo test -p snow-typeck` -- builtin registration tests pass
4. `cargo build` -- full project compiles without errors
5. Existing E2E tests: `cargo test e2e_http_server_runtime` still passes (backward compat)
</verification>

<success_criteria>
- Router supports segment-based matching with `:param` capture
- Method-specific routing via 4 new extern functions
- Request.param accessor returns Option<String>
- Exact routes match before parameterized routes
- Existing HTTP.route (method-agnostic) still works
- Full compiler pipeline wired (intrinsics, typeck, MIR)
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/51-http-path-parameters/51-01-SUMMARY.md`
</output>
