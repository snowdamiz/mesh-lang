---
phase: 51-http-path-parameters
plan: 02
type: execute
wave: 2
depends_on: ["51-01"]
files_modified:
  - tests/e2e/stdlib_http_path_params.snow
  - crates/snowc/tests/e2e_stdlib.rs
autonomous: true

must_haves:
  truths:
    - "Snow program with /users/:id route compiles and runs as HTTP server"
    - "GET /users/42 returns response containing id=42"
    - "Request.param extracts the path parameter value"
    - "GET-only route rejects POST requests (404)"
    - "Exact route /users/me matches before parameterized /users/:id"
  artifacts:
    - path: "tests/e2e/stdlib_http_path_params.snow"
      provides: "Snow test fixture demonstrating path params, method routing, and priority"
      contains: "Request.param"
    - path: "crates/snowc/tests/e2e_stdlib.rs"
      provides: "Rust E2E test that compiles+runs the fixture and verifies HTTP responses"
      contains: "e2e_http_path_params"
  key_links:
    - from: "tests/e2e/stdlib_http_path_params.snow"
      to: "crates/snow-rt/src/http/router.rs"
      via: "compiled Snow calling runtime path matching"
      pattern: "HTTP\\.(get|on_get)"
    - from: "crates/snowc/tests/e2e_stdlib.rs"
      to: "tests/e2e/stdlib_http_path_params.snow"
      via: "read_fixture loading Snow source"
      pattern: "stdlib_http_path_params"
---

<objective>
End-to-end test proving path parameters, method-specific routing, and route priority work in a real compiled Snow program with a running HTTP server.

Purpose: Validates that the full stack (Snow source -> typeck -> MIR -> LLVM -> runtime) produces a working HTTP server with path parameter extraction and method-specific routing. This is the proof that Phase 51 requirements HTTP-01, HTTP-02, and HTTP-03 are satisfied.

Output: 1 new Snow test fixture and 1 new Rust E2E test function.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-http-path-parameters/51-RESEARCH.md
@.planning/phases/51-http-path-parameters/51-01-SUMMARY.md
@crates/snowc/tests/e2e_stdlib.rs
@tests/e2e/stdlib_http_server_runtime.snow
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Snow test fixture demonstrating path params, method routing, and priority</name>
  <files>
    tests/e2e/stdlib_http_path_params.snow
  </files>
  <action>
Create a Snow source file that starts an HTTP server on port 18081 (use a different port from existing tests to avoid conflicts) with multiple routes demonstrating all Phase 51 features.

NOTE: The exact Snow syntax for method-specific routes depends on the outcome of Plan 01's arity-vs-naming decision. If Plan 01 used arity-based dispatch, routes use `HTTP.get(r, path, handler)`. If Plan 01 fell back to `on_` prefix, routes use `HTTP.on_get(r, path, handler)`. Check the 51-01-SUMMARY.md to determine which.

The fixture should define:

1. **Exact route** `/users/me` that returns `"me"` -- tests exact-before-param priority (SC-4)
2. **Parameterized route** `/users/:id` that extracts `id` via `Request.param(req, "id")` and returns it -- tests HTTP-01 and HTTP-02
3. **POST-specific route** `/data` that returns `"posted"` -- tests HTTP-03
4. **Method-agnostic fallback** `/*` using `HTTP.route` that returns `"fallback"` -- tests backward compat

Example structure (adjust syntax based on Plan 01 outcome):
```snow
fn me_handler(request) do
  HTTP.response(200, "me")
end

fn user_handler(request) do
  case Request.param(request, "id") do
    Some(id) -> HTTP.response(200, id)
    None(_)  -> HTTP.response(400, "no-id")
  end
end

fn post_handler(request) do
  HTTP.response(200, "posted")
end

fn fallback_handler(request) do
  HTTP.response(200, "fallback")
end

fn main() do
  let r = HTTP.router()
  let r = HTTP.get(r, "/users/me", me_handler)
  let r = HTTP.get(r, "/users/:id", user_handler)
  let r = HTTP.post(r, "/data", post_handler)
  let r = HTTP.route(r, "/*", fallback_handler)
  HTTP.serve(r, 18081)
end
```

The exact route `/users/me` MUST be registered BEFORE `/users/:id` in the code, though the router's two-pass matching should handle priority regardless of registration order. Registering exact first is still good practice.
  </action>
  <verify>
The file exists at `tests/e2e/stdlib_http_path_params.snow` and contains:
- `Request.param` call
- At least one method-specific route registration (HTTP.get or HTTP.on_get)
- An exact route and a parameterized route for the same prefix
- A POST-specific route
- Port 18081
  </verify>
  <done>
Snow test fixture created with routes testing path parameter extraction, method-specific routing, exact-vs-param priority, and backward-compatible HTTP.route fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Rust E2E test that compiles, runs server, and verifies HTTP responses</name>
  <files>
    crates/snowc/tests/e2e_stdlib.rs
  </files>
  <action>
Add a new test function `e2e_http_path_params` to `e2e_stdlib.rs`. Follow the EXACT pattern of `e2e_http_server_runtime` (lines 687-764):

1. Load fixture: `let source = read_fixture("stdlib_http_path_params.snow");`
2. Compile and start server: `let mut guard = compile_and_start_server(&source);`
3. Wait for server ready signal on stderr ("HTTP server listening on")
4. Make multiple HTTP requests to port 18081 using raw `TcpStream` and verify responses:

**Test case A -- Path parameter extraction (HTTP-01 + HTTP-02):**
- Send `GET /users/42 HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n`
- Assert response contains "200"
- Assert response body contains "42"

**Test case B -- Exact route priority (SC-4):**
- Send `GET /users/me HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n`
- Assert response contains "200"
- Assert response body contains "me" (NOT a param extraction of "me" as id, but the literal "me" from the exact route handler)

**Test case C -- Method-specific routing (HTTP-03):**
- Send `POST /data HTTP/1.1\r\nHost: localhost\r\nContent-Length: 0\r\nConnection: close\r\n\r\n`
- Assert response contains "200"
- Assert response body contains "posted"

**Test case D -- Method filtering (GET route rejects POST):**
- Send `POST /users/42 HTTP/1.1\r\nHost: localhost\r\nContent-Length: 0\r\nConnection: close\r\n\r\n`
- Assert response contains "200" (fallback route catches it) and body contains "fallback"
  - OR if no fallback matches, assert 404. Depends on whether the `/*` wildcard is method-agnostic.

**Test case E -- Fallback route (backward compat):**
- Send `GET /unknown/path HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n`
- Assert response contains "200"
- Assert response body contains "fallback"

Use the retry pattern (up to 5 attempts with 200ms between) for each request. Each request needs its own TcpStream connection. Add brief sleeps between test cases (50ms) to avoid overwhelming the single-threaded test.

Helper pattern for each test case (extract into a local closure or inline):
```rust
fn send_request(port: u16, request: &str) -> String {
    let mut response = String::new();
    for attempt in 0..5 {
        if attempt > 0 {
            std::thread::sleep(std::time::Duration::from_millis(200));
        }
        match std::net::TcpStream::connect(format!("127.0.0.1:{}", port)) {
            Ok(mut stream) => {
                stream.set_read_timeout(Some(std::time::Duration::from_secs(5))).unwrap();
                stream.write_all(request.as_bytes()).expect("write");
                stream.read_to_string(&mut response).expect("read");
                return response;
            }
            Err(_) => continue,
        }
    }
    panic!("Failed to connect after 5 attempts");
}
```

Place this helper function near the top of the test or inline the pattern.
  </action>
  <verify>
Run `cargo test e2e_http_path_params -- --nocapture` and verify:
- Test compiles and runs
- All 5 test cases pass (path param, exact priority, method routing, method filtering, fallback)
- No other E2E tests regress: `cargo test e2e_http_server_runtime` still passes
  </verify>
  <done>
E2E test proves the full Phase 51 stack works: Snow source compiles through typeck/MIR/LLVM, starts a real HTTP server, and correctly handles path parameter extraction, exact-before-parameterized priority, method-specific routing, and backward-compatible fallback routes. All 4 success criteria from the roadmap are verified.
  </done>
</task>

</tasks>

<verification>
1. `cargo test e2e_http_path_params -- --nocapture` -- new E2E test passes
2. `cargo test e2e_http_server_runtime` -- existing HTTP test still passes
3. `cargo test e2e_http_crash_isolation` -- existing crash isolation test still passes
4. Snow fixture demonstrates all 4 roadmap success criteria
</verification>

<success_criteria>
- Snow program with path parameters compiles and runs as HTTP server
- Path parameter extraction returns correct values (id=42)
- Exact routes match before parameterized routes (/users/me before /users/:id)
- Method-specific routes only match their HTTP method
- Backward-compatible HTTP.route fallback works
- All existing HTTP E2E tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/51-http-path-parameters/51-02-SUMMARY.md`
</output>
