# Phase 87.2: Refactor Phase 87 Code to Use Cross-Module Services - Research

**Researched:** 2026-02-14
**Domain:** Mesh language refactoring -- cross-module services, ? operator, polymorphic type exports
**Confidence:** HIGH

## Summary

Phase 87.2 is a pure refactoring phase. Phase 87 (Foundation) built the Mesher application with all services stuffed into `main.mpl` (321 lines) due to three compiler limitations: (1) services could not be exported cross-module, (2) the `?` operator produced LLVM codegen errors, and (3) polymorphic type variables could not cross module boundaries. Phase 87.1 fixed all three limitations. This phase removes the workarounds and restructures the code to use the newly-fixed language features.

The refactoring involves three distinct operations: (A) extract services from `main.mpl` into dedicated module files under `mesher/services/`, (B) replace explicit `case result do Ok(x) -> ... | Err(_) -> ... end` patterns with the `?` operator where appropriate, and (C) move the StorageWriter batch/buffer logic into `mesher/storage/writer.mpl` now that polymorphic types cross module boundaries. The `services/` directory already exists but is currently empty (the original plan intended services there, but the compiler limitation forced everything into main.mpl).

**Primary recommendation:** Extract each service into its own module file, use `?` operator throughout, and move StorageWriter buffer logic to writer.mpl. Keep the flush_ticker actor in main.mpl since it references the StorageWriter service (or move it alongside StorageWriter if cross-module service references work for actors too).

## Standard Stack

This phase does not introduce new libraries or tools. It refactors existing Mesh application code.

### Core
| Technology | Version | Purpose | Why Standard |
|------------|---------|---------|--------------|
| Mesh language | current (meshc) | Programming language for all application code | Project's own language |
| meshc compiler | HEAD | Builds multi-module Mesh projects | `meshc build mesher/` |

### Key Language Features Now Available
| Feature | Fixed In | Replaces |
|---------|----------|----------|
| Cross-module service export/import | 87.1-02 | All services in main.mpl |
| `?` operator for Result unwrapping | 87.1-01 | Explicit case/match blocks |
| Polymorphic type variable cross-module export | 87.1-02 | Duplicated buffer logic in main.mpl |

## Architecture Patterns

### Current Structure (BEFORE refactoring)
```
mesher/
  main.mpl           # 321 lines -- ALL 4 services + buffer logic + entry point
  services/           # EMPTY directory
  storage/
    schema.mpl        # Schema DDL (71 lines)
    queries.mpl       # CRUD queries (196 lines) -- already uses ? operator
    writer.mpl        # Only insert_event function (17 lines)
  types/
    event.mpl         # Event types (77 lines)
    issue.mpl         # Issue types (25 lines)
    project.mpl       # Org/Project/ApiKey types (31 lines)
    user.mpl          # User/Session/OrgMembership types (28 lines)
    alert.mpl         # AlertRule/AlertCondition types (21 lines)
```

### Target Structure (AFTER refactoring)
```
mesher/
  main.mpl           # ~50-70 lines -- entry point only, imports services
  services/
    org.mpl           # OrgService (module: Services.Org)
    project.mpl       # ProjectService (module: Services.Project)
    user.mpl          # UserService + login_user helper (module: Services.User)
    writer.mpl        # StorageWriter + WriterState + buffer logic + flush_ticker (module: Services.Writer)
  storage/
    schema.mpl        # Unchanged (already uses ?)
    queries.mpl       # Unchanged (already uses ?)
    writer.mpl        # insert_event only (unchanged)
  types/              # All unchanged
    ...
```

### Pattern 1: Cross-Module Service Import
**What:** Define a service in one module, import and use it from main.mpl
**When to use:** All services in this refactoring
**Proven syntax (from E2E test e2e_cross_module_service):**

```mesh
# In services/org.mpl (module: Services.Org)
from Storage.Queries import insert_org, get_org, list_orgs
from Types.Project import Organization

service OrgService do
  fn init(pool :: PoolHandle) -> PoolHandle do
    pool
  end

  call CreateOrg(name :: String, slug :: String) do |pool|
    let result = insert_org(pool, name, slug)
    (pool, result)
  end
  ...
end
```

```mesh
# In main.mpl
from Services.Org import OrgService

fn main() do
  ...
  let org_svc = OrgService.start(pool)
  ...
end
```

**Import syntax:** `from Services.Org import OrgService` -- the service name is imported like any other symbol. File `services/org.mpl` maps to module `Services.Org` via PascalCase conversion.

### Pattern 2: ? Operator for Result Unwrapping
**What:** Replace explicit case/match on Result with the `?` operator
**When to use:** Any function that returns `Result<T, String>` (syntax: `T!String`) and calls another function that also returns a Result
**Proven syntax (from E2E test e2e_cross_module_try_operator):**

```mesh
# BEFORE (current workaround in main.mpl)
fn flush_loop(pool :: PoolHandle, project_id :: String, events, i :: Int, total :: Int) -> Int!String do
  if i < total do
    let event_json = List.get(events, i)
    let r = insert_event(pool, project_id, event_json)
    case r do
      Ok(_) -> flush_loop(pool, project_id, events, i + 1, total)
      Err(_) -> Err("flush failed")
    end
  else
    Ok(0)
  end
end

# AFTER (using ? operator)
fn flush_loop(pool :: PoolHandle, project_id :: String, events, i :: Int, total :: Int) -> Int!String do
  if i < total do
    let event_json = List.get(events, i)
    insert_event(pool, project_id, event_json)?
    flush_loop(pool, project_id, events, i + 1, total)
  else
    Ok(0)
  end
end
```

### Pattern 3: Service File Naming Convention
**What:** Map file paths to module names using the Mesh convention
**Convention:** `dir/file_name.mpl` -> `Dir.FileName` (snake_case to PascalCase, dots for directories)
**Examples:**
- `services/org.mpl` -> `Services.Org` -> `from Services.Org import OrgService`
- `services/project.mpl` -> `Services.Project` -> `from Services.Project import ProjectService`
- `services/user.mpl` -> `Services.User` -> `from Services.User import UserService`
- `services/writer.mpl` -> `Services.Writer` -> `from Services.Writer import StorageWriter`

### Anti-Patterns to Avoid
- **Moving too much into service modules:** Service modules should NOT import other services. The service hierarchy is flat -- each service only depends on the query/storage layer, not on other services.
- **Changing the call handler tuple order:** The `call` handler returns `(new_state, reply_value)` -- this is NOT `(reply, state)`. The current code uses `(pool, result)` which is correct because pool IS the state. Do not change this.
- **Adding pub prefix to services:** The Mesh grammar lacks `pub service` syntax. Services are exported by default (decision from 87.1-02). Do NOT add `pub` before `service`.
- **Importing PoolHandle:** `PoolHandle` is a builtin type, available globally. Do NOT add `import` statements for it.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Module naming | Manual module declarations | File path convention | meshc auto-derives module names from file paths via PascalCase conversion |
| Service export | Custom export annotations | Default export behavior | Services are always exported (87.1-02 decision) |
| Result error propagation | Explicit case/match blocks | `?` operator | Now fixed in 87.1-01 |

**Key insight:** This is a mechanical refactoring. The code logic does not change -- only its location and syntax. Every line of the existing main.mpl has been tested and verified. The refactoring should preserve exact behavior.

## Common Pitfalls

### Pitfall 1: Wrong Module Path in Import
**What goes wrong:** File placed at `services/org_service.mpl` but imported as `from Services.Org import OrgService` (mismatch)
**Why it happens:** File name determines module name. `org_service.mpl` -> `Services.OrgService`, not `Services.Org`
**How to avoid:** Choose file names carefully. Use `org.mpl` for `Services.Org` or `org_service.mpl` for `Services.OrgService`. Be consistent.
**Warning signs:** Compilation error: unresolved import

### Pitfall 2: Circular Dependencies Between Service Modules
**What goes wrong:** If service A imports service B and service B imports service A, meshc reports a cycle error
**Why it happens:** meshc enforces acyclic module graphs via topological sort
**How to avoid:** Services should ONLY depend on types/ and storage/, NEVER on each other. main.mpl imports all services and wires them together.
**Warning signs:** "Circular dependency" error from meshc

### Pitfall 3: Missing Type Imports in Service Modules
**What goes wrong:** Service module references Organization, Project, User etc. but forgets to import them
**Why it happens:** In main.mpl, all imports were co-located. When splitting into separate files, each file needs its own imports.
**How to avoid:** Each service module must import the types it uses from Types.* modules
**Warning signs:** "Unresolved type" error

### Pitfall 4: Forgetting the WriterState Struct
**What goes wrong:** StorageWriter service uses WriterState struct, which was defined in main.mpl. If the struct definition is not moved alongside the service, it won't be in scope.
**Why it happens:** WriterState is tightly coupled to StorageWriter but was defined outside the service block
**How to avoid:** Move WriterState struct definition into the same module as StorageWriter (services/writer.mpl or storage/writer.mpl)
**Warning signs:** "Unresolved type" error for WriterState

### Pitfall 5: The ? Operator Requires the Function to Return Result
**What goes wrong:** Using `?` in a function that doesn't have a `T!String` return type
**Why it happens:** `?` unwraps Ok or early-returns Err. The enclosing function must return a compatible Result type.
**How to avoid:** Only use `?` in functions declared with `-> T!String` return types
**Warning signs:** Type error or codegen error

### Pitfall 6: flush_ticker Actor References StorageWriter
**What goes wrong:** The flush_ticker actor calls `StorageWriter.flush(writer_pid)`. If StorageWriter moves to a different module, flush_ticker needs to import it.
**Why it happens:** Actor functions are module-level, just like regular functions
**How to avoid:** Either keep flush_ticker in the same module as StorageWriter, or import StorageWriter in the module where flush_ticker lives
**Warning signs:** "Unresolved function" or service method error

### Pitfall 7: Case Expression Scrutinee Must Be Variable
**What goes wrong:** `case some_function() do ... end` fails to parse
**Why it happens:** Mesh's case expression requires a variable/name reference as scrutinee, not inline function calls (discovered in 87.1-02)
**How to avoid:** Always bind to a let first: `let r = some_function()` then `case r do ... end`
**Warning signs:** Parse error

## Code Examples

Verified patterns from E2E tests and existing codebase:

### Cross-Module Service Definition and Import
```mesh
# Source: E2E test e2e_cross_module_service (crates/meshc/tests/e2e.rs:2859)

# services.mpl
service Store do
  fn init(start_val :: Int) -> Int do
    start_val
  end

  call Get() :: Int do |state|
    (state, state)
  end

  call Set(value :: Int) :: Int do |_state|
    (value, value)
  end

  cast Clear() do |_state|
    0
  end
end

# main.mpl
from Services import Store

fn main() do
  let pid = Store.start(100)
  let v1 = Store.get(pid)
  Store.clear(pid)
end
```

### ? Operator with Cross-Module Result Functions
```mesh
# Source: E2E test e2e_cross_module_try_operator (crates/meshc/tests/e2e.rs:2903)

# validation.mpl
pub fn validate_positive(n :: Int) -> Int!String do
  if n > 0 do
    Ok(n)
  else
    Err("must be positive")
  end
end

# main.mpl
from Validation import validate_positive, validate_small

fn process(n :: Int) -> Int!String do
  let a = validate_positive(n)?
  let b = validate_small(a)?
  Ok(b * 2)
end
```

### Service with PoolHandle State (Current Working Pattern)
```mesh
# Source: mesher/main.mpl (current, verified compiling)

service OrgService do
  fn init(pool :: PoolHandle) -> PoolHandle do
    pool
  end

  call CreateOrg(name :: String, slug :: String) do |pool|
    let result = insert_org(pool, name, slug)
    (pool, result)
  end
end
```

### queries.mpl Already Uses ? Operator Successfully
```mesh
# Source: mesher/storage/queries.mpl (lines 16-23, verified compiling)

pub fn insert_org(pool :: PoolHandle, name :: String, slug :: String) -> String!String do
  let rows = Pool.query(pool, "INSERT INTO organizations (name, slug) VALUES ($1, $2) RETURNING id::text", [name, slug])?
  if List.length(rows) > 0 do
    Ok(Map.get(List.head(rows), "id"))
  else
    Err("insert_org: no id returned")
  end
end
```

## State of the Art

| Old Approach (Phase 87) | Current Approach (Post 87.1) | When Changed | Impact |
|--------------------------|------------------------------|--------------|--------|
| All services in main.mpl | Services in separate modules | Phase 87.1-02 | Modular codebase |
| Explicit case/match on Result | `?` operator | Phase 87.1-01 | ~15 case blocks removable |
| Buffer logic duplicated in main.mpl | Polymorphic types cross-module | Phase 87.1-02 | StorageWriter self-contained |

**Workarounds being removed:**
- [87-02] All services in main.mpl -> Move to services/*.mpl
- [87-02] Explicit case matching instead of ? -> Use ? operator
- [87-02] JSON string buffer in main.mpl -> Move to writer module

**Workarounds being KEPT (not fixed yet):**
- [87-02] Timer actor pattern (recursive sleep + cast) for periodic flush -- Timer.send_after still incompatible with service dispatch (Issue 6 from 87.1 research, deferred)
- [87-01] Recursive helper functions for iteration (language design, not a bug)
- [87-01] Row structs use all-String fields (language limitation, not a bug)

## Refactoring Inventory

Detailed inventory of what moves where and what changes:

### From main.mpl -> services/org.mpl
- OrgService service definition (lines 131-150)
- Needed imports: `from Storage.Queries import insert_org, get_org, list_orgs`
- Needed imports: `from Types.Project import Organization`

### From main.mpl -> services/project.mpl
- ProjectService service definition (lines 155-189)
- Needed imports: `from Storage.Queries import insert_project, get_project, list_projects_by_org, create_api_key, get_project_by_api_key, revoke_api_key`
- Needed imports: `from Types.Project import Project`

### From main.mpl -> services/user.mpl
- UserService service definition (lines 195-234)
- login_user helper function (lines 38-44)
- Needed imports: `from Storage.Queries import create_user, authenticate_user, get_user, create_session, validate_session, delete_session, add_member, get_members`
- Needed imports: `from Types.User import User, Session, OrgMembership`

### From main.mpl -> services/writer.mpl
- WriterState struct (lines 25-32)
- StorageWriter service definition (lines 244-267)
- flush_ticker actor (lines 273-277)
- Buffer management helpers: writer_store, writer_flush (lines 104-126)
- Batch flush logic: flush_loop, flush_batch, flush_drop, flush_retry3, flush_retry2, flush_with_retry (lines 50-98)
- Needed imports: `from Storage.Writer import insert_event`

### Remaining in main.mpl
- Import statements for all services
- start_services function (lines 281-311)
- main function (lines 313-320)
- Schema/partition setup

### ? Operator Replacements in main.mpl (before extraction)
The following explicit case/match blocks can be replaced with `?`:

1. **flush_loop** (line 54): `case r do Ok(_) -> ... | Err(_) -> Err("flush failed") end` -> `insert_event(pool, project_id, event_json)?`
2. **flush_with_retry** (line 94): `case r1 do Ok(n) -> Ok(n) | Err(_) -> flush_retry2(...) end` -- This one should KEEP explicit case because the Err branch does NOT propagate the error; it calls retry logic instead.
3. **flush_retry2** (line 86): Same pattern as flush_with_retry -- KEEP explicit case
4. **flush_retry3** (line 76): Same pattern -- KEEP explicit case
5. **login_user** (line 40): `case auth_result do Ok(user) -> create_session(pool, user.id) | Err(_) -> Err("authentication failed") end` -- Can use `?` only if we want the original error message. Current code replaces with "authentication failed". KEEP explicit case for custom error message.
6. **start_services schema_result** (line 284): `case schema_result do Ok(_) -> println(...) | Err(_) -> println(...) end` -- Cannot use `?` because start_services does not return Result. KEEP explicit case.
7. **start_services partition_result** (line 291): Same -- KEEP explicit case.
8. **main pool_result** (line 316): Same -- KEEP explicit case.

**Conclusion:** Only flush_loop benefits from `?` replacement. The other case blocks either have custom error handling logic (retries, custom messages) or are in functions that don't return Result.

## Open Questions

1. **Service call handler return type annotations**
   - What we know: The current main.mpl services use `call CreateOrg(name :: String, slug :: String) do |pool|` WITHOUT `:: ReturnType` annotation. The E2E cross-module test uses `call Get() :: Int do |state|`. Both work.
   - What's unclear: Whether the cross-module import pipeline requires explicit return type annotations on call handlers, or if type inference works for both cases.
   - Recommendation: Keep the current style (no explicit return type annotation) since it already compiles. If cross-module import fails, add annotations. The working cross-module E2E test with `:: Int` confirms that style works, but the current mesher services may work without it.

2. **Actor functions and cross-module service references**
   - What we know: `flush_ticker` actor calls `StorageWriter.flush(writer_pid)`. If both are in the same module, this works.
   - What's unclear: Whether an `actor` function can reference a service imported from another module (no E2E test for this pattern).
   - Recommendation: Keep flush_ticker in the same module as StorageWriter to avoid this question. This is the simplest approach.

## Sources

### Primary (HIGH confidence)
- Mesher source code: `mesher/main.mpl` (321 lines, current state of services)
- Mesher source code: `mesher/storage/queries.mpl` (196 lines, ? operator already working)
- Mesher source code: `mesher/storage/writer.mpl` (17 lines, insert_event only)
- E2E test: `e2e_cross_module_service` (crates/meshc/tests/e2e.rs:2859) -- proves cross-module service works
- E2E test: `e2e_cross_module_try_operator` (crates/meshc/tests/e2e.rs:2903) -- proves cross-module ? works
- Module naming: `crates/meshc/src/discovery.rs` -- path_to_module_name convention
- Phase 87.1-01 SUMMARY: Codegen fixes (alloca, ? operator, List.find)
- Phase 87.1-02 SUMMARY: Module system fixes (service export, TyVar normalization)
- Phase 87.1 VERIFICATION: All 9/9 truths verified

### Secondary (MEDIUM confidence)
- Compilation test: `meshc build mesher/` compiles successfully as of 2026-02-14

## Metadata

**Confidence breakdown:**
- Refactoring scope: HIGH -- Exact lines to move are identified, source/target locations clear
- Cross-module service syntax: HIGH -- E2E tests prove the pattern works
- ? operator applicability: HIGH -- Only 1 of 8 case blocks is actually replaceable; analysis is thorough
- Module naming convention: HIGH -- Verified via discovery.rs source code

**Research date:** 2026-02-14
**Valid until:** Indefinite (refactoring of existing code with proven patterns)
