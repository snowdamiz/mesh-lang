---
phase: 18-trait-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - crates/snow-typeck/src/lib.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "TraitRegistry is available in TypeckResult after type checking"
    - "MIR Lowerer receives TraitRegistry and can query it during lowering"
    - "impl Add for MyStruct uses the same dispatch path as built-in Int + Int (both go through TraitRegistry)"
  artifacts:
    - path: "crates/snow-typeck/src/lib.rs"
      provides: "TypeckResult with trait_registry field"
      contains: "trait_registry.*TraitRegistry"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "infer() returns trait_registry in TypeckResult"
      contains: "trait_registry"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Lowerer struct with trait_registry field, dispatch prep"
      contains: "trait_registry"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/lib.rs"
      via: "TypeckResult construction includes trait_registry"
      pattern: "trait_registry"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-typeck/src/lib.rs"
      via: "Lowerer reads typeck.trait_registry"
      pattern: "typeck\\.trait_registry"
---

<objective>
Expose TraitRegistry through TypeckResult so the MIR lowerer can access trait information during code generation, and add the trait_registry field to the Lowerer struct -- preparing the dispatch unification path where user-defined trait impls and compiler-known trait impls go through the same resolution mechanism.

Purpose: Currently TraitRegistry is created locally in infer() and discarded. It never reaches the codegen layer, which means MIR lowering cannot resolve user-defined trait method calls. This plan threads TraitRegistry through to the Lowerer, which is a prerequisite for Phase 19 (trait method codegen) and unifies the dispatch model so that `impl Add for MyStruct` will use the same lookup path as built-in `Int + Int`.

Output: TraitRegistry flows from typeck through TypeckResult to Lowerer. The Lowerer has access to trait information but does not yet change dispatch behavior (that is Phase 19's job). This is pure plumbing.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-trait-infrastructure/18-RESEARCH.md
@.planning/phases/18-trait-infrastructure/18-01-SUMMARY.md
@crates/snow-typeck/src/lib.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread TraitRegistry through TypeckResult to Lowerer</name>
  <files>crates/snow-typeck/src/lib.rs, crates/snow-typeck/src/infer.rs, crates/snow-codegen/src/mir/lower.rs</files>
  <action>
1. **lib.rs** -- Add TraitRegistry to TypeckResult:
   - Add `pub use crate::traits::TraitRegistry;` to the re-exports at the top of the file (near the existing `pub use crate::infer::{...}` block).
   - Add a new field to the `TypeckResult` struct: `pub trait_registry: TraitRegistry`
   - Update the doc comment on TypeckResult to mention the trait registry.

2. **infer.rs** -- Return trait_registry in TypeckResult:
   - In the `infer()` function (around line 629), add `trait_registry` to the TypeckResult construction. Currently it returns:
     ```rust
     TypeckResult {
         types: resolved_types,
         errors: ctx.errors,
         warnings: ctx.warnings,
         result_type: resolved_result,
         type_registry,
     }
     ```
     Change to:
     ```rust
     TypeckResult {
         types: resolved_types,
         errors: ctx.errors,
         warnings: ctx.warnings,
         result_type: resolved_result,
         type_registry,
         trait_registry,
     }
     ```
     The `trait_registry` variable is already in scope (created at line 494 as `let mut trait_registry = TraitRegistry::new()`). It just needs to be moved into the result.

3. **lower.rs** -- Add trait_registry to Lowerer struct and constructor:
   - Add import: In the existing `use snow_typeck::{...}` import, add `TraitRegistry`.
   - Add field to `Lowerer<'a>` struct (around line 35): `trait_registry: &'a TraitRegistry,`
   - Update the `Lowerer::new(typeck: &TypeckResult)` constructor to populate the field: `trait_registry: &typeck.trait_registry,`
   - That's it for this plan. The Lowerer now HAS the trait_registry but does not USE it yet for dispatch. Phase 19 will add the actual dispatch logic.

4. **Verify no other files need changes**: The `lower_to_mir` public function already takes `&TypeckResult`, so no signature changes are needed at the call site. The `check()` function in `lib.rs` calls `infer::infer()` which now returns the updated TypeckResult, so it propagates automatically.
  </action>
  <verify>
Run `cargo check --workspace` to verify compilation. Run `cargo test --workspace` to verify all tests pass. The key check: `cargo check -p snow-codegen` must succeed, confirming the Lowerer correctly receives TraitRegistry through TypeckResult.
  </verify>
  <done>
- TypeckResult has a `trait_registry: TraitRegistry` field
- infer() populates trait_registry in its return value
- Lowerer struct has a `trait_registry: &'a TraitRegistry` field populated from typeck
- All existing tests pass with zero regressions
- cargo check --workspace succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TraitRegistry query test and verify dispatch path equivalence</name>
  <files>crates/snow-typeck/src/traits.rs</files>
  <action>
1. Add an integration-style unit test in `traits.rs` that verifies the end-to-end flow works for both built-in and user-defined types going through the same TraitRegistry:

```rust
#[test]
fn unified_dispatch_builtin_and_user_types() {
    // Simulate what builtins.rs does for Add trait
    let mut registry = TraitRegistry::new();
    registry.register_trait(TraitDef {
        name: "Add".to_string(),
        methods: vec![TraitMethodSig {
            name: "add".to_string(),
            has_self: true,
            param_count: 1,
            return_type: None,
        }],
    });

    // Built-in impl: Add for Int
    let mut int_methods = FxHashMap::default();
    int_methods.insert("add".to_string(), ImplMethodSig {
        has_self: true,
        param_count: 1,
        return_type: Some(Ty::int()),
    });
    let errors = registry.register_impl(ImplDef {
        trait_name: "Add".to_string(),
        impl_type: Ty::int(),
        impl_type_name: "Int".to_string(),
        methods: int_methods,
    });
    assert!(errors.is_empty());

    // User-defined impl: Add for MyStruct (simulated as Ty::Con("MyStruct"))
    let my_struct = Ty::Con(TyCon::new("MyStruct"));
    let mut struct_methods = FxHashMap::default();
    struct_methods.insert("add".to_string(), ImplMethodSig {
        has_self: true,
        param_count: 1,
        return_type: Some(my_struct.clone()),
    });
    let errors = registry.register_impl(ImplDef {
        trait_name: "Add".to_string(),
        impl_type: my_struct.clone(),
        impl_type_name: "MyStruct".to_string(),
        methods: struct_methods,
    });
    assert!(errors.is_empty());

    // Both resolve through the same path
    assert!(registry.has_impl("Add", &Ty::int()));
    assert!(registry.has_impl("Add", &my_struct));

    // Method resolution works for both
    let int_ret = registry.resolve_trait_method("add", &Ty::int());
    assert_eq!(int_ret, Some(Ty::int()));

    let struct_ret = registry.resolve_trait_method("add", &my_struct);
    assert_eq!(struct_ret, Some(my_struct));
}
```

This test proves that `impl Add for MyStruct` goes through the exact same `TraitRegistry` path as `impl Add for Int`, which is the phase success criterion: "no special-case dispatch path for built-in types vs. user types."

2. Also add the `TyCon` import to the test module if not already present (it's needed for `TyCon::new`).
  </action>
  <verify>
Run `cargo test -p snow-typeck -- traits::tests::unified_dispatch` to verify the new test passes. Then `cargo test --workspace` for full regression check.
  </verify>
  <done>
- Test proves built-in Int and user-defined MyStruct both resolve through the same TraitRegistry API
- No special-case dispatch paths exist for built-in vs. user types
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` -- everything compiles
2. `cargo test --workspace` -- all tests pass
3. Grep for `trait_registry` in lib.rs confirms the field exists in TypeckResult
4. Grep for `trait_registry` in lower.rs confirms the Lowerer has the field
5. The unified_dispatch test passes, proving single dispatch path for all types
</verification>

<success_criteria>
- TraitRegistry flows: infer() -> TypeckResult -> Lowerer
- impl Add for MyStruct and impl Add for Int both resolve through the same TraitRegistry.has_impl / find_impl / resolve_trait_method path
- No hardcoded type-specific dispatch logic in TraitRegistry
- All 1,018+ existing tests pass
- Lowerer is ready to receive trait dispatch logic in Phase 19
</success_criteria>

<output>
After completion, create `.planning/phases/18-trait-infrastructure/18-03-SUMMARY.md`
</output>
