---
phase: 18-trait-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - crates/snow-typeck/src/traits.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "Two impl Display for Int blocks produce a compile-time error naming both locations"
    - "Two traits defining to_string at the same call site produce an ambiguity error"
    - "Single-trait method resolution still works without ambiguity errors"
  artifacts:
    - path: "crates/snow-typeck/src/error.rs"
      provides: "DuplicateImpl and AmbiguousMethod error variants"
      contains: "DuplicateImpl"
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Rendered diagnostics for duplicate impl and ambiguous method errors"
      contains: "DuplicateImpl"
    - path: "crates/snow-typeck/src/traits.rs"
      provides: "Check-before-insert in register_impl, ambiguity detection in resolve_trait_method"
      contains: "DuplicateImpl\\|ambig"
  key_links:
    - from: "crates/snow-typeck/src/traits.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "TraitRegistry returns DuplicateImpl/AmbiguousMethod errors"
      pattern: "TypeError::DuplicateImpl"
    - from: "crates/snow-typeck/src/diagnostics.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "render_diagnostic handles new error variants"
      pattern: "DuplicateImpl"
---

<objective>
Add duplicate impl detection (check-before-insert with structural matching) and method name collision handling (ambiguity errors when multiple traits provide the same method name for the same type) to TraitRegistry.

Purpose: Currently `register_impl` silently overwrites duplicate impls via HashMap insert (now Vec push after 18-01), and `resolve_trait_method` returns the first match nondeterministically when multiple traits define methods with the same name. Both must produce clear compile-time errors.

Output: Two new TypeError variants (DuplicateImpl, AmbiguousMethod) with full diagnostic rendering, integrated into TraitRegistry's registration and lookup paths.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-trait-infrastructure/18-RESEARCH.md
@.planning/phases/18-trait-infrastructure/18-01-SUMMARY.md
@crates/snow-typeck/src/traits.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DuplicateImpl and AmbiguousMethod error variants</name>
  <files>crates/snow-typeck/src/error.rs, crates/snow-typeck/src/diagnostics.rs</files>
  <action>
1. Add two new variants to `TypeError` in `error.rs`:

```rust
/// Two impl blocks implement the same trait for the same type (or structurally overlapping types).
DuplicateImpl {
    trait_name: String,
    impl_type: String,
    /// Description of the first impl location (e.g. "previously defined here").
    first_impl: String,
},

/// Multiple traits provide a method with the same name for a given type, causing ambiguity.
AmbiguousMethod {
    method_name: String,
    /// The trait names that all provide this method.
    candidate_traits: Vec<String>,
    ty: Ty,
},
```

2. Add `Display` implementations for both new variants in the `impl fmt::Display for TypeError` block:
   - DuplicateImpl: `"duplicate impl: \`{trait_name}\` is already implemented for \`{impl_type}\` ({first_impl})"`
   - AmbiguousMethod: `"ambiguous method \`{method_name}\` for type \`{ty}\`: candidates from traits [{candidate_traits joined by ', '}]"`

3. Add diagnostic rendering for both new variants in `diagnostics.rs`, in the `render_diagnostic` function's match. Follow the existing pattern used by other error variants (create a Report with appropriate labels and a suggestion message):
   - DuplicateImpl: Report with error code "E-DUPLICATE-IMPL", message showing trait and type, suggestion "Remove one of the conflicting impl blocks"
   - AmbiguousMethod: Report with error code "E-AMBIGUOUS-METHOD", message listing candidate traits, suggestion "Use qualified syntax: TraitName.method_name(value)"

Look at how existing variants like `MissingTraitMethod` are rendered in diagnostics.rs and follow the same pattern. Since these new errors don't have TextRange spans (they come from trait registry, not source positions), use a simple format without source labels -- just the report header and message. Check if there's a pattern for span-less errors already in the diagnostics file and follow it.
  </action>
  <verify>
Run `cargo check -p snow-typeck` to verify the new variants compile. Run `cargo test -p snow-typeck` to ensure no regressions.
  </verify>
  <done>
- TypeError has DuplicateImpl and AmbiguousMethod variants
- Both variants have Display implementations
- Both variants have diagnostic rendering in diagnostics.rs
- All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate duplicate detection and ambiguity handling into TraitRegistry</name>
  <files>crates/snow-typeck/src/traits.rs</files>
  <action>
1. Modify `register_impl` to check for duplicates before pushing. Before adding a new impl to the Vec for a trait, iterate over existing impls for that trait and use structural matching (same temporary InferCtx pattern from plan 18-01) to check if any existing impl overlaps with the new one. If a match is found, return a `TypeError::DuplicateImpl` error with the trait name, type name, and a description of the existing impl (use `impl_type_name` from the existing ImplDef as `first_impl`). Still push the new impl even if duplicate (so later lookups work), but return the error.

2. Modify `resolve_trait_method` to detect ambiguity. Instead of returning on the first match, collect ALL matches (from ALL traits). If exactly one match is found, return it. If more than one match is found from DIFFERENT traits, return `None` and -- since resolve_trait_method returns `Option<Ty>` and cannot return errors directly -- add a new method `resolve_trait_method_or_ambiguity` that returns `Result<Option<Ty>, TypeError>` where the Err case is `TypeError::AmbiguousMethod`. Update the existing `resolve_trait_method` to call the new method and discard the error (returning None on ambiguity), preserving backward compatibility. The caller in `infer.rs` can be updated in a future phase to use the richer API.

   Actually, simpler approach: Add a separate method `find_method_traits(&self, method_name: &str, ty: &Ty) -> Vec<String>` that returns the list of trait names providing this method for the given type. This is useful for diagnostics. Keep `resolve_trait_method` as-is (returns first match). The ambiguity check can happen at the call site in `infer.rs` where the context exists to emit errors. For now, just add the `find_method_traits` helper.

3. Add unit tests:
   - `duplicate_impl_detected`: Register two `impl Printable for Int` and verify `register_impl` returns a `DuplicateImpl` error.
   - `no_false_duplicate_for_different_types`: Register `impl Printable for Int` and `impl Printable for String`, verify no duplicate error.
   - `find_method_traits_single`: Register `impl Printable for Int` with method `to_string`, call `find_method_traits("to_string", &Ty::int())`, verify returns `["Printable"]`.
   - `find_method_traits_multiple`: Register `impl Printable for Int` with `to_string` and `impl Displayable for Int` with `to_string`, call `find_method_traits("to_string", &Ty::int())`, verify returns both trait names.
  </action>
  <verify>
Run `cargo test -p snow-typeck -- traits` to verify all trait tests pass. Then `cargo test --workspace` for full regression check.
  </verify>
  <done>
- register_impl detects structurally overlapping impls and returns DuplicateImpl error
- find_method_traits returns all trait names providing a given method for a type
- All new and existing tests pass
- No regressions in workspace test suite
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck -- traits` -- all trait unit tests pass including new duplicate/ambiguity tests
2. `cargo test -p snow-typeck` -- full typeck tests pass
3. `cargo test --workspace` -- full workspace passes
4. Grep for `DuplicateImpl` in error.rs, diagnostics.rs, and traits.rs confirms all three files have the variant
</verification>

<success_criteria>
- Two `impl Display for Int` blocks produce a DuplicateImpl compile-time error
- Two traits defining `to_string` for the same type are detectable via find_method_traits
- Single-trait method resolution continues to work without false ambiguity
- Error messages include trait name, type name, and existing impl reference
- All 1,018+ existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-trait-infrastructure/18-02-SUMMARY.md`
</output>
