---
phase: 18-trait-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/traits.rs
autonomous: true

must_haves:
  truths:
    - "impl Display for List<T> resolves when queried with List<Int> or List<String>"
    - "impl Add for Int still resolves correctly after storage refactor (no regression)"
    - "has_impl, find_impl, resolve_trait_method all use structural matching instead of string keys"
  artifacts:
    - path: "crates/snow-typeck/src/traits.rs"
      provides: "TraitRegistry with structural type matching via temporary unification"
      contains: "find_impl_structural\\|fresh"
  key_links:
    - from: "crates/snow-typeck/src/traits.rs"
      to: "crates/snow-typeck/src/unify.rs"
      via: "InferCtx temporary unification for type matching"
      pattern: "InferCtx::new\\(\\)"
---

<objective>
Replace string-based type_to_key lookup in TraitRegistry with structural type matching via temporary unification, and refactor impl storage from FxHashMap<(String, String), ImplDef> to FxHashMap<String, Vec<ImplDef>> keyed by trait name.

Purpose: The current type_to_key produces literal strings like "List<T>" which never match "List<Int>", making generic impls (impl Display for List<T>) impossible to resolve. Structural matching via the existing InferCtx unification engine fixes this.

Output: A TraitRegistry that correctly resolves impls for parameterized types while maintaining backward compatibility with all existing simple-type impls.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-trait-infrastructure/18-RESEARCH.md
@crates/snow-typeck/src/traits.rs
@crates/snow-typeck/src/unify.rs
@crates/snow-typeck/src/ty.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor impl storage and add structural type matching</name>
  <files>crates/snow-typeck/src/traits.rs</files>
  <action>
1. Change the `impls` field in `TraitRegistry` from `FxHashMap<(String, String), ImplDef>` to `FxHashMap<String, Vec<ImplDef>>`, keyed by trait name only. This allows multiple impls per trait (needed for generic matching).

2. Add a `use crate::unify::InferCtx;` import at the top of the file.

3. Create a helper function `freshen_type_params(ty: &Ty, ctx: &mut InferCtx) -> Ty` that recursively walks a `Ty` and replaces any `Ty::Con` whose name is a single uppercase letter (A-Z) or a conventional type parameter name (T, U, V, K, V, E, etc.) with a fresh `Ty::Var` from the InferCtx. Use a local `FxHashMap<String, Ty>` to ensure the same type param name maps to the same fresh var within one freshening pass. The heuristic: if the TyCon name is a single uppercase ASCII letter, or is one of the common type parameter names, treat it as a type parameter. More precisely: check if the name is a single character A-Z, or matches common multi-char params like "Key", "Value", etc. The simplest correct approach: any TyCon name that is a single uppercase ASCII character (len == 1 && is_ascii_uppercase) should be freshened. This covers T, U, V, K, E, etc.

4. Rewrite `register_impl` to push onto the Vec for the trait name instead of inserting into a (trait_name, type_key) map. Remove the `type_to_key` call from `register_impl`.

5. Rewrite `has_impl` to use structural matching: iterate over the Vec of impls for the given trait_name, create a temporary `InferCtx`, freshen the impl's stored `impl_type`, and attempt `ctx.unify(freshened_impl_type, query_ty.clone(), ConstraintOrigin::Builtin)`. Return true if any impl unifies successfully.

6. Rewrite `find_impl` with the same structural matching logic, returning `Some(&ImplDef)` for the first matching impl.

7. Rewrite `resolve_trait_method` to iterate over ALL impls (all trait names), structurally match the type, and return the method's return type if found. After finding a match via unification, if the method's return_type contains freshened vars that were unified, resolve them through the temp InferCtx before returning.

8. Update `check_where_constraints` to use the new `has_impl` (no changes needed since it delegates to has_impl).

9. Remove the `type_to_key` function entirely -- it is no longer needed.

10. Update ALL existing tests to work with the new storage. Add new tests:
    - `structural_match_generic_impl`: Register `impl Display for List<T>` (where List<T> is `Ty::App(Box::new(Ty::Con("List")), vec![Ty::Con("T")])`), then verify `has_impl("Display", &Ty::App(Box::new(Ty::Con("List")), vec![Ty::int()]))` returns true.
    - `structural_match_no_false_positive`: Verify `has_impl("Display", &Ty::int())` returns false when only `impl Display for List<T>` is registered.
    - `simple_type_still_works`: Verify Int/Float impls still resolve correctly (regression check).

IMPORTANT: When freshening, only `Ty::Con` with single-uppercase-letter names need freshening. Do NOT freshen "Int", "Float", "String", "Bool", "List", "Option", "Result", etc. -- these are concrete type constructors, not type parameters. The `Ty::App` node itself is NOT freshened; only the leaf `Ty::Con` nodes inside it that look like type parameters.

IMPORTANT: The `unify` method on `InferCtx` returns `Result<Ty, TypeError>`. Check `.is_ok()` for matching. The temporary InferCtx is thrown away after each match attempt -- do not reuse it across different impl candidates.
  </action>
  <verify>
Run `cargo test -p snow-typeck -- traits` to verify all trait registry tests pass. Then run the full test suite: `cargo test --workspace` to ensure no regressions.
  </verify>
  <done>
- TraitRegistry uses Vec-based storage keyed by trait name
- type_to_key function is removed
- Structural matching via temporary InferCtx correctly resolves generic impls (List<T> matches List<Int>)
- All existing tests pass (no regressions for simple type impls)
- New tests for generic matching pass
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck -- traits` -- all trait registry unit tests pass
2. `cargo test --workspace` -- full test suite passes with zero regressions
3. Grep for `type_to_key` in traits.rs returns zero results (function removed)
</verification>

<success_criteria>
- `impl Display for List<T>` correctly resolves when queried with `List<Int>` or `List<String>`
- Existing compiler-known trait impls (Add for Int, Eq for String, etc.) still resolve correctly
- No string-based type matching remains in TraitRegistry
- All 1,018+ existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-trait-infrastructure/18-01-SUMMARY.md`
</output>
