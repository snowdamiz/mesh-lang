---
phase: 04-pattern-matching-adts
plan: 03
type: tdd
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/snow-typeck/src/exhaustiveness.rs
  - crates/snow-typeck/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "is_useful correctly identifies when a pattern adds coverage to a matrix"
    - "Exhaustiveness check detects missing variants in a sum type match"
    - "Redundancy check detects unreachable pattern arms"
    - "Wildcard and variable patterns are treated as catch-all"
    - "Nested patterns (Some(Circle(r))) are handled via recursive specialization"
  artifacts:
    - path: "crates/snow-typeck/src/exhaustiveness.rs"
      provides: "Maranget's Algorithm U implementation"
      contains: "is_useful"
      min_lines: 150
    - path: "crates/snow-typeck/src/exhaustiveness.rs"
      provides: "Pattern matrix representation"
      contains: "PatternMatrix"
  key_links:
    - from: "crates/snow-typeck/src/exhaustiveness.rs"
      to: "crates/snow-typeck/src/infer.rs"
      via: "Uses TypeRegistry to look up sum type variants for constructor enumeration"
      pattern: "TypeRegistry"
---

<objective>
Implement Maranget's usefulness algorithm for exhaustiveness and redundancy checking of pattern matching.

Purpose: This is the core algorithmic heart of Phase 4. The algorithm operates on a pattern matrix representation and recursively decomposes via constructor specialization. Both exhaustiveness (is wildcard useful?) and redundancy (is each arm useful?) use the same `is_useful` predicate. TDD approach because this has clearly defined inputs and outputs.

Output: A working `exhaustiveness.rs` module with `is_useful`, `check_exhaustiveness`, and `check_redundancy` functions, thoroughly tested.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-pattern-matching-adts/04-CONTEXT.md
@.planning/phases/04-pattern-matching-adts/04-RESEARCH.md
@.planning/phases/04-pattern-matching-adts/04-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/ty.rs
</context>

<feature>
  <name>Maranget's Usefulness Algorithm (Algorithm U)</name>
  <files>crates/snow-typeck/src/exhaustiveness.rs, crates/snow-typeck/src/lib.rs</files>
  <behavior>
  The algorithm operates on an abstract pattern representation (not AST nodes directly).

  Core data types:
  - `Pat` enum: `Wildcard`, `Constructor { name: String, type_name: String, args: Vec<Pat> }`, `Literal { value: String, ty: LitKind }`, `Or { alternatives: Vec<Pat> }`
  - `LitKind` enum: `Int`, `Float`, `Bool`, `String`
  - `PatternMatrix`: Vec of pattern rows (Vec<Pat>), each row is one match arm
  - `PatternRow`: Vec<Pat> (one pattern per column)
  - `TypeInfo`: information about a type's constructors for exhaustiveness (enum of `SumType { variants: Vec<ConstructorSig> }`, `Bool`, `Literal`, `Infinite`)
  - `ConstructorSig`: `{ name: String, arity: usize }`

  Core algorithm: `is_useful(matrix: &PatternMatrix, row: &[Pat], type_info: &[TypeInfo]) -> bool`

  Cases:
  1. Empty matrix (0 rows): return true (any pattern is useful against nothing)
  2. Empty row (0 columns): return false (no more columns to match)
  3. First column analysis:
     a. If row[0] is Constructor(c, args):
        - Specialize matrix and row by c
        - Recurse: is_useful(specialize(matrix, c), specialize_row(row, c, args), type_info_expanded)
     b. If row[0] is Wildcard:
        - If the type is a sum type with known constructors:
          - For each constructor c of the type: check if is_useful(specialize(matrix, c), default_row_expanded(row, c), ...)
          - Return true if ANY constructor returns true
        - If the type has infinite inhabitants (Int, String, Float):
          - Use default matrix: is_useful(default(matrix), row[1..], type_info[1..])
     c. If row[0] is Or(alts):
        - Return true if ANY alternative is useful: any alt -> is_useful(matrix, [alt] + row[1..], ...)
     d. If row[0] is Literal(v):
        - Specialize by the literal value
        - Similar to constructor with arity 0

  Specialization:
  - `specialize(matrix, constructor)`: For each row in matrix:
    - If row[0] is the same constructor: replace row[0] with its args, keep rest
    - If row[0] is Wildcard: replace row[0] with N wildcards (N = constructor arity), keep rest
    - If row[0] is a different constructor: drop the row
    - If row[0] is Or: expand each alternative
  - `default(matrix)`: For each row in matrix:
    - If row[0] is Wildcard: keep row[1..]
    - Otherwise: drop the row

  Public API:
  - `check_exhaustiveness(arms: &[Pat], scrutinee_type_info: &TypeInfo, registry: &TypeRegistry) -> Option<Vec<Pat>>`:
    Build matrix from arms. Check if wildcard row is useful. If yes, return witness patterns (missing cases).
  - `check_redundancy(arms: &[Pat], scrutinee_type_info: &TypeInfo, registry: &TypeRegistry) -> Vec<usize>`:
    For each arm index i, check if arm[i] is useful against arms[0..i]. If not useful, arm is redundant. Return list of redundant arm indices.

  Test cases (input -> expected output):
  - Bool exhaustive: [true, false] -> exhaustive (wildcard NOT useful)
  - Bool non-exhaustive: [true] -> NOT exhaustive (wildcard IS useful), witness: [false]
  - Sum type exhaustive: Shape with [Circle(_), Point] -> exhaustive
  - Sum type non-exhaustive: Shape with [Circle(_)] -> NOT exhaustive, witness: [Point]
  - Redundant arm: [_, Circle(_)] -> arm 1 is redundant
  - Nested: Option<Shape> with [Some(Circle(_)), Some(Point), None] -> exhaustive
  - Nested non-exhaustive: Option<Shape> with [Some(Circle(_)), None] -> NOT exhaustive, witness: [Some(Point)]
  - Or-pattern: [Circle(_) | Point] for Shape -> exhaustive
  - Wildcard: [_] -> always exhaustive
  - Literal: [1, 2, _] -> exhaustive; [1, 2] for Int -> NOT exhaustive (Int is infinite)
  </behavior>
  <implementation>
  Create `crates/snow-typeck/src/exhaustiveness.rs` as a new module.

  1. Define the abstract pattern types (Pat, PatternMatrix, TypeInfo, ConstructorSig).
  2. Implement `specialize` and `default` matrix operations.
  3. Implement `is_useful` recursively.
  4. Implement `check_exhaustiveness` and `check_redundancy` as public API.
  5. Add `witness_patterns` generation: when a wildcard IS useful, construct a concrete pattern showing what's missing. Walk the recursion collecting constructor choices that made the wildcard useful.
  6. Add `pub mod exhaustiveness;` to `crates/snow-typeck/src/lib.rs`.

  TypeInfo lookup: The algorithm needs to know the constructors of a type. This requires access to the TypeRegistry. Pass a trait or closure for looking up type info:
  ```rust
  pub trait TypeContext {
      fn type_info(&self, type_name: &str) -> TypeInfo;
  }
  ```
  Or simpler: pass &TypeRegistry and have exhaustiveness.rs depend on the registry types. Since both are in snow-typeck, direct dependency is fine.

  For Bool: hardcode two constructors (true, false) with arity 0.
  For Int/Float/String: mark as Infinite (default matrix path).
  For sum types: look up in TypeRegistry to get variant list.
  For tuples: treat as a single constructor with arity = tuple length.

  IMPORTANT: This module operates on ABSTRACT patterns (Pat enum), not AST patterns. The translation from AST Pattern to abstract Pat happens at the call site (in infer.rs, Plan 04). This plan only builds and tests the algorithm itself.
  </implementation>
</feature>

<verification>
- `cargo test -p snow-typeck` passes
- All TDD test cases pass for is_useful, check_exhaustiveness, check_redundancy
- Bool, sum type, nested, or-pattern, literal, and wildcard cases all handled correctly
- Witness pattern generation produces correct missing patterns
</verification>

<success_criteria>
- is_useful correctly handles all pattern forms (wildcard, constructor, literal, or)
- Specialization and default matrix operations are correct
- check_exhaustiveness returns None for exhaustive matches, Some(witnesses) for non-exhaustive
- check_redundancy returns indices of unreachable arms
- Nested patterns handled via recursive specialization
- Algorithm is purely functional (no mutation of input data)
</success_criteria>

<output>
After completion, create `.planning/phases/04-pattern-matching-adts/04-03-SUMMARY.md`
</output>
