---
phase: 04-pattern-matching-adts
plan: 05
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/builtins.rs
autonomous: true

must_haves:
  truths:
    - "Non-exhaustive match errors render with ariadne showing missing variants"
    - "Redundant arm warnings render distinctly from errors"
    - "Option and Result are defined as user-definable ADTs (sum types) rather than compiler builtins"
    - "Existing Option/Result usage (Some, None, Ok, Err) still type-checks correctly"
  artifacts:
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Rendering for NonExhaustiveMatch, RedundantArm, and other new error types"
      contains: "NonExhaustiveMatch"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Option/Result registered via sum type mechanism"
      contains: "register_builtin_sum_types"
  key_links:
    - from: "crates/snow-typeck/src/diagnostics.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "Renders new TypeError variants"
      pattern: "NonExhaustiveMatch"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/exhaustiveness.rs"
      via: "Option/Result as sum types enables exhaustiveness checking on them"
      pattern: "register_builtin_sum_types"
---

<objective>
Add ariadne diagnostic rendering for new error types and migrate Option/Result to user-definable ADTs registered through the sum type mechanism.

Purpose: This plan delivers the user-facing quality of error messages and completes the ADT story by making Option/Result proper sum types. After this, `case opt do Some(x) -> x end` triggers a non-exhaustive error because None is missing -- the system is fully integrated.

Output: Pretty-printed error diagnostics for all new error types. Option/Result as sum types with exhaustiveness checking. End-to-end integration verified.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-pattern-matching-adts/04-CONTEXT.md
@.planning/phases/04-pattern-matching-adts/04-RESEARCH.md
@.planning/phases/04-pattern-matching-adts/04-02-SUMMARY.md
@.planning/phases/04-pattern-matching-adts/04-03-SUMMARY.md
@.planning/phases/04-pattern-matching-adts/04-04-SUMMARY.md
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ariadne diagnostic rendering for new error types</name>
  <files>
    crates/snow-typeck/src/diagnostics.rs
  </files>
  <action>
1. Add rendering for `NonExhaustiveMatch` error (E0010):
   - Use ReportKind::Error (hard error, per CONTEXT.md)
   - Message: "non-exhaustive match: missing {missing_patterns_joined}"
   - Label on the case/match expression span: "this match is not exhaustive"
   - Help suggestion: Show BOTH explicit missing arms AND wildcard fallback option (per Claude's Discretion in CONTEXT.md -- Rust approach):
     - "add missing arms: {list}" AND "or add a wildcard `_ -> ...` arm"
   - Example output:
     ```
     Error[E0010]: non-exhaustive match: missing Green, Blue
       |
     3 | case c do
       | ^^^^^^^^^ this match is not exhaustive
       |
       = help: add missing arms: Green -> ..., Blue -> ...
       = help: or add a wildcard `_ -> ...` arm
     ```

2. Add rendering for `RedundantArm` warning (E0011):
   - Use ReportKind::Warning (not error, per CONTEXT.md)
   - Message: "unreachable pattern: arm {arm_index} will never match"
   - Label on the redundant arm's span: "this arm is unreachable"
   - Help: "consider removing this arm"

3. Add rendering for `InvalidGuardExpression` error (E0012):
   - Message: "invalid guard expression: {reason}"
   - Label on the guard span
   - Help: "guards may only use comparisons, boolean ops, and builtin functions"

4. Add rendering for `OrPatternBindingMismatch` (if added in Plan 02):
   - Message: "or-pattern alternatives bind different variables"
   - Label showing which alternative has the mismatch

5. Add rendering for `UnknownVariant` (if added in Plan 02):
   - Message: "unknown variant `{variant_name}` for type `{type_name}`"
   - Label on the pattern span

6. Update the `error_code` function to handle all new variants.

7. Write snapshot tests for diagnostic output:
   - Non-exhaustive match error with ariadne formatting
   - Redundant arm warning
   - Verify colorless output matches expected format
  </action>
  <verify>
    `cargo test -p snow-typeck` passes. Snapshot tests confirm diagnostic output format for all new error types.
  </verify>
  <done>
    All new error types render with ariadne. Non-exhaustive match shows missing patterns with explicit arm and wildcard suggestions. Redundant arm renders as warning. Diagnostic snapshot tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Option/Result migration to sum types and end-to-end verification</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/builtins.rs
  </files>
  <action>
1. Migrate Option/Result from hardcoded constructors to sum type definitions:
   - Add `register_builtin_sum_types` function (replaces `register_option_result_constructors`):
     ```rust
     fn register_builtin_sum_types(ctx: &mut InferCtx, env: &mut TypeEnv, type_registry: &mut TypeRegistry) {
         // Register Option<T> as a sum type
         let option_info = SumTypeDefInfo {
             name: "Option".into(),
             generic_params: vec!["T".into()],
             variants: vec![
                 VariantInfo { name: "Some".into(), fields: vec![VariantFieldInfo::Positional(Ty::Con(TyCon::new("T")))] },
                 VariantInfo { name: "None".into(), fields: vec![] },
             ],
         };
         type_registry.register_sum_type(option_info);

         // Register Result<T, E> as a sum type
         let result_info = SumTypeDefInfo {
             name: "Result".into(),
             generic_params: vec!["T".into(), "E".into()],
             variants: vec![
                 VariantInfo { name: "Ok".into(), fields: vec![VariantFieldInfo::Positional(Ty::Con(TyCon::new("T")))] },
                 VariantInfo { name: "Err".into(), fields: vec![VariantFieldInfo::Positional(Ty::Con(TyCon::new("E")))] },
             ],
         };
         type_registry.register_sum_type(result_info);

         // Register variant constructors (same as before but through the sum type mechanism)
         // Some :: forall T. T -> Option<T>
         // None :: forall T. Option<T>
         // Ok :: forall T E. T -> Result<T, E>
         // Err :: forall T E. E -> Result<T, E>
         // Use the same enter_level/leave_level/generalize pattern
     }
     ```
   - Replace the call to `register_option_result_constructors` in `infer()` with `register_builtin_sum_types`
   - Keep backward compatibility: `Some(42)` still works (unqualified). `Option.Some(42)` also works (qualified). Same for None, Ok, Err.
   - CRITICAL: Don't break existing Phase 3 tests. All 258 tests must still pass. Option/Result behavior must be identical.

2. Verify exhaustiveness now works on Option/Result:
   - `case opt do Some(x) -> x end` -> NonExhaustiveMatch error: missing None
   - `case opt do Some(x) -> x None -> default end` -> exhaustive, no error
   - `case res do Ok(v) -> v Err(e) -> handle(e) end` -> exhaustive

3. Write end-to-end integration tests combining all Phase 4 features:
   - Define sum type, construct, match with exhaustiveness:
     ```
     type Shape do
       Circle(Float)
       Rectangle(Float, Float)
       Point
     end

     fn area(shape :: Shape) -> Float do
       case shape do
         Circle(r) -> r * r * 3.14
         Rectangle(w, h) -> w * h
         Point -> 0.0
       end
     end
     ```
   - Generic sum type with nested pattern matching:
     ```
     type Option<T> do Some(T) None end
     case opt do
       Some(Circle(r)) -> r
       Some(_) -> 0.0
       None -> 0.0
     end
     ```
   - Or-patterns:
     ```
     case shape do
       Circle(_) | Point -> "no area"
       Rectangle(_, _) -> "has area"
     end
     ```
   - Guards:
     ```
     case shape do
       Circle(r) when r > 0.0 -> "valid circle"
       Circle(_) -> "invalid circle"
       _ -> "other"
     end
     ```

4. Run full workspace tests and fix any regressions:
   - `cargo test --workspace` must pass
   - All 258+ existing tests must still pass
   - New tests for Phase 4 features must pass
  </action>
  <verify>
    `cargo test --workspace` passes. All existing tests pass (no regressions). Option/Result works as sum types with exhaustiveness checking. End-to-end integration tests pass.
  </verify>
  <done>
    Option/Result are proper sum types in TypeRegistry. Exhaustiveness checking works on them. All Phase 4 features work end-to-end: sum type definition, construction, pattern matching with exhaustiveness/redundancy, guards, or-patterns, as-patterns, nested patterns. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes with zero failures
- Non-exhaustive match errors render correctly with missing patterns listed
- Redundant arm warnings render distinctly from errors
- Option/Result registered as sum types with exhaustiveness checking
- End-to-end: define sum type -> construct -> match -> exhaustiveness enforced
- All 258+ existing Phase 1-3 tests still pass
</verification>

<success_criteria>
- Diagnostic rendering covers all new TypeError variants with ariadne
- Option<T> and Result<T, E> are user-definable sum types (not hardcoded)
- `case opt do Some(x) -> x end` is a hard error (missing None)
- End-to-end integration tests prove the full Phase 4 feature set works
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-pattern-matching-adts/04-05-SUMMARY.md`
</output>
