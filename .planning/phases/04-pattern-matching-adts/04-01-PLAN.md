---
phase: 04-pattern-matching-adts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-common/src/token.rs
  - crates/snow-lexer/src/lib.rs
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/items.rs
  - crates/snow-parser/src/parser/patterns.rs
  - crates/snow-parser/src/ast/pat.rs
  - crates/snow-parser/src/ast/item.rs
autonomous: true

must_haves:
  truths:
    - "Sum type definitions parse into SUM_TYPE_DEF nodes with VARIANT_DEF children"
    - "Constructor patterns (Shape.Circle(r)) parse into CONSTRUCTOR_PAT nodes"
    - "Or-patterns (A | B) parse into OR_PAT nodes using the BAR token"
    - "As-patterns (p as x) parse into AS_PAT nodes"
    - "The lexer emits a BAR token for bare | instead of Error"
  artifacts:
    - path: "crates/snow-common/src/token.rs"
      provides: "Bar token kind"
      contains: "Bar"
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "SUM_TYPE_DEF, VARIANT_DEF, VARIANT_FIELD, CONSTRUCTOR_PAT, OR_PAT, AS_PAT, BAR SyntaxKind variants"
      contains: "SUM_TYPE_DEF"
    - path: "crates/snow-parser/src/parser/items.rs"
      provides: "parse_sum_type_def function"
      contains: "parse_sum_type_def"
    - path: "crates/snow-parser/src/parser/patterns.rs"
      provides: "Constructor, or, and as pattern parsing"
      contains: "CONSTRUCTOR_PAT"
    - path: "crates/snow-parser/src/ast/pat.rs"
      provides: "ConstructorPat, OrPat, AsPat AST node types"
      contains: "ConstructorPat"
    - path: "crates/snow-parser/src/ast/item.rs"
      provides: "SumTypeDef, VariantDef AST node types"
      contains: "SumTypeDef"
  key_links:
    - from: "crates/snow-common/src/token.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "TokenKind::Bar maps to SyntaxKind::BAR"
      pattern: "Bar.*BAR"
    - from: "crates/snow-parser/src/parser/patterns.rs"
      to: "crates/snow-parser/src/ast/pat.rs"
      via: "Parser emits CONSTRUCTOR_PAT/OR_PAT/AS_PAT nodes that AST casts"
      pattern: "CONSTRUCTOR_PAT"
---

<objective>
Add lexer, parser, and AST support for sum type definitions and extended pattern syntax (constructor patterns, or-patterns, as-patterns).

Purpose: This is the foundational layer for Phase 4. Sum types need to be parseable before the type checker can register them, and the new pattern forms must exist in the CST/AST before exhaustiveness checking can analyze them.

Output: Lexer emits BAR token for `|`, parser produces SUM_TYPE_DEF/VARIANT_DEF/CONSTRUCTOR_PAT/OR_PAT/AS_PAT nodes, typed AST wrappers expose these to downstream phases.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pattern-matching-adts/04-CONTEXT.md
@.planning/phases/04-pattern-matching-adts/04-RESEARCH.md
@crates/snow-common/src/token.rs
@crates/snow-lexer/src/lib.rs
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/items.rs
@crates/snow-parser/src/parser/patterns.rs
@crates/snow-parser/src/ast/pat.rs
@crates/snow-parser/src/ast/item.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lexer BAR token and SyntaxKind extensions</name>
  <files>
    crates/snow-common/src/token.rs
    crates/snow-lexer/src/lib.rs
    crates/snow-parser/src/syntax_kind.rs
  </files>
  <action>
1. In `crates/snow-common/src/token.rs`:
   - Add `Bar` variant to `TokenKind` enum (in the Operators section, after `Pipe`). Doc comment: `/// \`|\` bare pipe for or-patterns`
   - This changes operator count from 23 to 24. Update the `token_kind_variant_count` test: operators = 24, total = 88.
   - Update `keyword_from_str` tests if needed (they test keyword count, not operator count -- should be fine).

2. In `crates/snow-lexer/src/lib.rs`:
   - In the `lex_pipe` method: change the fallback arm for bare `|` from emitting `TokenKind::Error` to emitting `TokenKind::Bar`.
   - The `||` -> PipePipe and `|>` -> Pipe cases remain unchanged.

3. In `crates/snow-parser/src/syntax_kind.rs`:
   - Add `BAR` variant in the Operators section (after PIPE). Doc comment: `/// \`|\` bare pipe for or-patterns`
   - Add composite node kinds:
     - `SUM_TYPE_DEF` -- `type Shape do ... end`
     - `VARIANT_DEF` -- `Circle(Float)` or `Rectangle(width: Float, height: Float)`
     - `VARIANT_FIELD` -- `width: Float` (named field inside a variant)
     - `CONSTRUCTOR_PAT` -- `Shape.Circle(r)` or `Some(x)` in patterns
     - `OR_PAT` -- `Circle(_) | Point`
     - `AS_PAT` -- `Circle(_) as c`
     - `GUARD_CLAUSE` -- `when r > 0.0` (for future use in Plan 04)
   - Add `TokenKind::Bar => SyntaxKind::BAR` mapping in the `From<TokenKind>` impl.
   - Update the `all_token_kinds_convert_to_syntax_kind` test: add `TokenKind::Bar` to the list, update count from 87 to 88.
   - Update `syntax_kind_has_enough_variants` test: add new node kinds to the list, update the minimum count assertion.
   - Mark `BAR` as NOT trivia (it already won't be since is_trivia is an explicit match).
  </action>
  <verify>
    `cargo test -p snow-common` passes (token count test updated).
    `cargo test -p snow-lexer` passes (bare `|` now emits Bar, not Error).
    `cargo test -p snow-parser --lib` passes (SyntaxKind conversion test updated).
  </verify>
  <done>
    Bare `|` lexes as `TokenKind::Bar` / `SyntaxKind::BAR`. All new SyntaxKind variants exist. All existing tests pass with updated counts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Parser support for sum type definitions and extended patterns</name>
  <files>
    crates/snow-parser/src/parser/items.rs
    crates/snow-parser/src/parser/patterns.rs
    crates/snow-parser/src/parser/expressions.rs
  </files>
  <action>
1. In `crates/snow-parser/src/parser/items.rs`:
   - Add `parse_sum_type_def` function. Syntax: `type Name [<T, U>] do Variant1(Type) Variant2(name: Type) ... end`
     - Open SUM_TYPE_DEF marker
     - Advance past TYPE_KW
     - Expect NAME (IDENT)
     - Optional GENERIC_PARAM_LIST: if `<` follows, parse `<T, U, ...>` using existing generic param parsing pattern (see how struct def does it in items.rs)
     - Expect DO_KW
     - Loop parsing VARIANT_DEF entries until END_KW or EOF:
       - eat_newlines
       - If at END_KW or EOF, break
       - Open VARIANT_DEF marker
       - Expect IDENT (variant name)
       - If L_PAREN follows, parse variant fields:
         - Each field is either: `IDENT :: TYPE` (named field -> VARIANT_FIELD node) or just a type reference (positional -> emit TYPE_ANNOTATION child)
         - To distinguish: peek ahead -- if IDENT followed by COLON_COLON, it's a named field; otherwise it's a positional type
         - For named fields: open VARIANT_FIELD, advance IDENT, expect COLON_COLON, parse type annotation tokens (IDENT, LT, GT, COMMA etc), close VARIANT_FIELD
         - For positional fields: just emit a TYPE_ANNOTATION node with the type tokens
         - Handle comma-separated fields, trailing comma OK
         - Expect R_PAREN
       - Close VARIANT_DEF
     - Expect END_KW
     - Close SUM_TYPE_DEF
   - Hook `parse_sum_type_def` into the item dispatch: when current token is TYPE_KW AND the next token is IDENT AND the token after name (possibly after generic params) is DO_KW, call parse_sum_type_def. Be careful not to conflict with TYPE_ALIAS_DEF (which has `type Name = ...`). The distinguisher: `type Name do` vs `type Name =` vs `type Name<T> do` vs `type Name<T> =`.
   - Add `SumTypeDef` to the `Item` enum dispatch in `parse_item` or wherever items are dispatched.

2. In `crates/snow-parser/src/parser/patterns.rs`:
   - Extend `parse_pattern` to handle:
     a. **Constructor patterns**: When IDENT is followed by DOT then IDENT (qualified: `Shape.Circle(r)`), or when IDENT is followed by L_PAREN and the ident looks like a constructor (starts with uppercase -- but since the parser doesn't distinguish case, just check IDENT followed by L_PAREN where IDENT text starts with uppercase letter). Actually, simpler approach: parse IDENT, then check for DOT (qualified) or L_PAREN (unqualified constructor). If neither, it's a plain IDENT_PAT.
        - For qualified: open CONSTRUCTOR_PAT, parse IDENT (type name), advance DOT, parse IDENT (variant name), optional L_PAREN with sub-patterns (recursive parse_pattern calls comma-separated), R_PAREN, close CONSTRUCTOR_PAT
        - For unqualified constructor (e.g. `Some(x)`, `None`): open CONSTRUCTOR_PAT, advance past IDENT, parse L_PAREN + sub-patterns + R_PAREN, close CONSTRUCTOR_PAT. But we need a heuristic: if IDENT starts with uppercase and L_PAREN follows, treat as constructor. If just uppercase IDENT with no parens, it could be a nullary constructor OR a variable -- resolve in type checker. For now in parser: if IDENT is followed by L_PAREN and text starts with uppercase, parse as CONSTRUCTOR_PAT. Otherwise emit IDENT_PAT. Nullary constructors like `None` will parse as IDENT_PAT and be resolved during type checking.
     b. **Or-patterns**: After parsing a base pattern, check if BAR follows. If so, wrap in OR_PAT: open_before the already-parsed pattern, loop consuming BAR + parse_pattern, close OR_PAT. This is a postfix operation on any pattern.
     c. **As-patterns**: After parsing a base pattern (or or-pattern), check if IDENT with text "as" follows (since "as" is not a keyword, it's a contextual identifier). If so, wrap: open_before, advance past "as" IDENT, parse IDENT (binding name) into an IDENT_PAT child, close AS_PAT.

   - Restructure parse_pattern into a layered approach:
     ```
     parse_pattern -> parse_as_pattern -> parse_or_pattern -> parse_primary_pattern
     ```
     Where parse_primary_pattern is the current match-based dispatch (wildcard, literal, tuple, ident/constructor).

3. In `crates/snow-parser/src/parser/expressions.rs`:
   - In `parse_match_arm`, the guard parsing already exists (checks WHEN_KW). No changes needed for basic guard parsing -- that's already there. But ensure the new pattern types flow through correctly since parse_pattern is called from parse_match_arm.

4. Write parser snapshot tests:
   - `type Shape do Circle(Float) Rectangle(width: Float, height: Float) Point end` -> verify SUM_TYPE_DEF structure
   - `type Option<T> do Some(T) None end` -> verify generic sum type
   - `case x do Shape.Circle(r) -> r end` -> verify CONSTRUCTOR_PAT
   - `case x do Circle(_) | Point -> 1 end` -> verify OR_PAT
   - `case x do Circle(_) as c -> c end` -> verify AS_PAT
   - `case x do Some(Circle(r)) -> r end` -> verify nested constructor patterns
  </action>
  <verify>
    `cargo test -p snow-parser` passes. Snapshot tests show correct CST node structure for sum type definitions, constructor patterns, or-patterns, and as-patterns.
  </verify>
  <done>
    Sum type definitions parse into SUM_TYPE_DEF with VARIANT_DEF children. Constructor patterns (qualified and unqualified), or-patterns, and as-patterns all parse into their respective CST node types. Existing parser tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Typed AST wrappers for new node types</name>
  <files>
    crates/snow-parser/src/ast/pat.rs
    crates/snow-parser/src/ast/item.rs
    crates/snow-parser/src/ast/mod.rs
  </files>
  <action>
1. In `crates/snow-parser/src/ast/pat.rs`:
   - Add `ConstructorPat` AST node (CONSTRUCTOR_PAT):
     - `type_name() -> Option<SyntaxToken>`: the type qualifier IDENT (e.g., "Shape" in Shape.Circle)
     - `variant_name() -> Option<SyntaxToken>`: the variant IDENT (e.g., "Circle"). For unqualified constructors, this is the first IDENT.
     - `fields() -> impl Iterator<Item = Pattern>`: sub-patterns inside parens
     - `is_qualified() -> bool`: whether it has a DOT (Shape.Circle vs Some)
   - Add `OrPat` AST node (OR_PAT):
     - `alternatives() -> impl Iterator<Item = Pattern>`: the alternative patterns
   - Add `AsPat` AST node (AS_PAT):
     - `pattern() -> Option<Pattern>`: the inner pattern
     - `binding_name() -> Option<SyntaxToken>`: the "as" binding IDENT
   - Extend the `Pattern` enum with new variants: `Constructor(ConstructorPat)`, `Or(OrPat)`, `As(AsPat)`
   - Update `Pattern::cast()` to handle CONSTRUCTOR_PAT, OR_PAT, AS_PAT
   - Update `Pattern::syntax()` to handle new variants

2. In `crates/snow-parser/src/ast/item.rs`:
   - Add `SumTypeDef` AST node (SUM_TYPE_DEF):
     - `name() -> Option<Name>`: the type name
     - `variants() -> impl Iterator<Item = VariantDef>`: the variant definitions
     - `visibility() -> Option<Visibility>`: pub modifier if present
   - Add `VariantDef` AST node (VARIANT_DEF):
     - `name() -> Option<SyntaxToken>`: variant name IDENT
     - `fields() -> impl Iterator<Item = VariantField>`: named fields (VARIANT_FIELD children)
     - `positional_types() -> impl Iterator<Item = TypeAnnotation>`: positional type params
   - Add `VariantField` AST node (VARIANT_FIELD):
     - `name() -> Option<Name>`: field name
     - `type_annotation() -> Option<TypeAnnotation>`: field type
   - Extend `Item` enum with `SumTypeDef(SumTypeDef)` variant
   - Update `Item::cast()` to handle SUM_TYPE_DEF

3. In `crates/snow-parser/src/ast/mod.rs`:
   - Ensure the new types are re-exported if the module exports pattern/item types.
  </action>
  <verify>
    `cargo test -p snow-parser` passes. Can write a test that parses a sum type definition and calls `.name()`, `.variants()` on the AST node.
  </verify>
  <done>
    All new AST wrapper types (SumTypeDef, VariantDef, VariantField, ConstructorPat, OrPat, AsPat) exist with accessor methods. Pattern and Item enums updated with new variants. Downstream code (type checker) can now import and use these types.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes with no failures
- Parsing `type Shape do Circle(Float) Rectangle(width: Float, height: Float) Point end` produces valid SUM_TYPE_DEF CST
- Parsing `case x do Shape.Circle(r) -> r _ -> 0 end` produces valid CONSTRUCTOR_PAT inside MATCH_ARM
- Parsing `case x do A | B -> 1 end` produces valid OR_PAT
- Parsing `case x do Circle(r) as c -> c end` produces valid AS_PAT
- Bare `|` lexes as BAR token, not Error
</verification>

<success_criteria>
- All new SyntaxKind variants exist and are tested
- Sum type definitions parse correctly with positional and named fields, generics
- Constructor patterns parse in both qualified (Shape.Circle(r)) and unqualified (Some(x)) forms
- Or-patterns and as-patterns parse with correct nesting
- Typed AST wrappers provide accessor methods for all new node types
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-pattern-matching-adts/04-01-SUMMARY.md`
</output>
