---
phase: 04-pattern-matching-adts
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/ty.rs
  - crates/snow-typeck/src/error.rs
autonomous: true

must_haves:
  truths:
    - "Sum type definitions register in the type checker with variant constructors as polymorphic functions"
    - "Variant construction via qualified access (Shape.Circle(5.0)) type-checks and infers correctly"
    - "Constructor patterns in match arms infer the correct types for bindings"
    - "Or-patterns validate that all alternatives bind the same variables with compatible types"
    - "As-patterns bind the whole matched value to a name"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Sum type registration, variant constructor inference, constructor pattern inference"
      contains: "register_sum_type"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "SumTypeDefInfo struct in TypeRegistry"
      contains: "SumTypeDefInfo"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/item.rs"
      via: "SumTypeDef AST node drives registration"
      pattern: "SumTypeDef"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/pat.rs"
      via: "ConstructorPat/OrPat/AsPat drive pattern inference"
      pattern: "ConstructorPat"
---

<objective>
Add type checking for sum type definitions, variant constructors, and extended pattern types (constructor, or, as patterns).

Purpose: After Plan 01 established parsing, this plan wires sum types into the type checker so they can be defined, constructed, and destructured with full type inference. This is the semantic backbone that exhaustiveness checking (Plan 03) will operate on.

Output: Sum types register in TypeRegistry. Variant constructors are polymorphic functions. Constructor/or/as patterns infer correct types and bind variables.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pattern-matching-adts/04-CONTEXT.md
@.planning/phases/04-pattern-matching-adts/04-RESEARCH.md
@.planning/phases/04-pattern-matching-adts/04-01-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/ty.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/env.rs
@crates/snow-typeck/src/unify.rs
@crates/snow-parser/src/ast/pat.rs
@crates/snow-parser/src/ast/item.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sum type registration and variant constructor inference</name>
  <files>
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
1. Add `SumTypeDefInfo` struct to TypeRegistry (analogous to StructDefInfo):
   ```rust
   struct SumTypeDefInfo {
       name: String,
       generic_params: Vec<String>,
       variants: Vec<VariantInfo>,
   }
   struct VariantInfo {
       name: String,
       fields: Vec<VariantFieldInfo>,  // positional or named
   }
   enum VariantFieldInfo {
       Positional(Ty),
       Named(String, Ty),
   }
   ```

2. Extend `TypeRegistry` with:
   - `sum_type_defs: FxHashMap<String, SumTypeDefInfo>`
   - `register_sum_type(&mut self, info: SumTypeDefInfo)`
   - `lookup_sum_type(&self, name: &str) -> Option<&SumTypeDefInfo>`
   - `lookup_variant(&self, variant_name: &str) -> Option<(&SumTypeDefInfo, &VariantInfo)>` -- for unqualified variant lookup
   - `lookup_qualified_variant(&self, type_name: &str, variant_name: &str) -> Option<(&SumTypeDefInfo, &VariantInfo)>` -- for Shape.Circle lookup

3. Add `register_sum_type_def` function (mirrors `register_struct_def`):
   - Extract sum type name from SumTypeDef AST node
   - Extract generic type parameters from GENERIC_PARAM_LIST child
   - For each VariantDef child:
     - Extract variant name
     - Extract fields (positional types or named fields with types)
     - Parse types using existing resolve_type_annotation or token-based approach
   - Register in type_registry.sum_type_defs
   - Register each variant constructor as a polymorphic function in the environment:
     - For variant with fields: `Shape.Circle :: forall T... (field_types) -> Shape<T...>` -- use enter_level/leave_level/generalize pattern (same as register_option_result_constructors)
     - For nullary variant: `Shape.Point :: forall T... Shape<T...>` -- register as a constant, not a function
     - Register under BOTH qualified name "Shape.Circle" and unqualified name "Circle" in env. The qualified name ensures disambiguation; unqualified enables ergonomic use when unambiguous.
   - Register the sum type name itself in env as a type (Scheme::mono for non-generic, Scheme with vars for generic)

4. Hook `register_sum_type_def` into `infer_item`:
   - Add `Item::SumTypeDef(sum_def) => { register_sum_type_def(ctx, env, sum_def, &mut type_registry); None }`
   - This requires the Item enum in the parser AST to include SumTypeDef (done in Plan 01)

5. Extend `infer_field_access` to handle variant construction via qualified access:
   - When base is a NAME_REF that resolves to a sum type name (not a struct instance), and field is a variant name:
   - Look up in type_registry.sum_type_defs
   - If found, return the variant constructor's type (instantiated from its scheme)
   - This makes `Shape.Circle(5.0)` work: `Shape` resolves to the type, `.Circle` resolves to the constructor function, `(5.0)` is a call
   - Key insight: Shape is registered in env as a type. When infer_field_access sees a NAME_REF "Shape" that matches a sum type name, look up the variant "Circle" and return its constructor type.
   - Handle both: the env lookup for "Shape" may return a type, and field access on it resolves to a constructor.

6. Write typeck tests:
   - `type Shape do Circle(Float) Point end let c = Shape.Circle(5.0)` -> c infers as Shape
   - `type Option<T> do Some(T) None end let x = Option.Some(42)` -> x infers as Option<Int>
   - `type Pair<A, B> do MkPair(A, B) end let p = Pair.MkPair(1, "hi")` -> p infers as Pair<Int, String>
  </action>
  <verify>
    `cargo test -p snow-typeck` passes. Sum type constructors type-check correctly with inference.
  </verify>
  <done>
    Sum types register in TypeRegistry. Variant constructors are polymorphic functions accessible via qualified syntax. `Shape.Circle(5.0)` infers as `Shape`. Generic sum types (`Option<T>`) infer type parameters from arguments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Constructor, or-pattern, and as-pattern type inference</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/error.rs
  </files>
  <action>
1. Extend `infer_pattern` to handle new Pattern variants:

   a. **Pattern::Constructor(ctor_pat)**:
      - Extract type name and variant name from the AST node
      - Look up the variant in type_registry (qualified or unqualified)
      - The variant constructor has type `(field_types) -> SumType<T...>`
      - Instantiate the constructor's scheme (fresh type vars for generics)
      - For each sub-pattern in the constructor: recursively infer_pattern, unify with the corresponding field type
      - Return the sum type (e.g., Shape, Option<T>) -- this is what the scrutinee should unify with
      - Bind sub-pattern variables into the environment (already happens via recursive infer_pattern)
      - For qualified patterns (Shape.Circle(r)): look up via type_name + variant_name
      - For unqualified patterns (Some(x)): look up via variant_name only, using lookup_variant

   b. **Pattern::Or(or_pat)**:
      - Infer each alternative pattern
      - All alternatives must unify to the same type (unify pairwise)
      - Validate that all alternatives bind the SAME set of variable names with compatible types. This is critical for soundness. For each alternative, collect the set of bound names. All sets must be identical. For each shared name, the types must unify.
      - If binding sets differ, emit a new TypeError variant (add `OrPatternBindingMismatch` to error.rs)
      - Return the unified type of the alternatives

   c. **Pattern::As(as_pat)**:
      - Infer the inner pattern's type
      - Bind the "as" name to the same type in the environment
      - Return the inner pattern's type

2. Add new TypeError variant in `crates/snow-typeck/src/error.rs`:
   - `OrPatternBindingMismatch { left_bindings: Vec<String>, right_bindings: Vec<String>, span: TextRange }` -- for or-patterns with inconsistent bindings
   - `UnknownVariant { type_name: String, variant_name: String, span: TextRange }` -- for constructor patterns referencing non-existent variants
   - Update `fmt::Display` impl for both new variants

3. Update `infer_case` to work with new pattern types:
   - The existing infer_case already calls infer_pattern for each arm's pattern and unifies with scrutinee_ty. This should work as-is with the new pattern types, since infer_pattern now handles constructors/or/as.
   - No changes needed in infer_case itself -- the extension is fully in infer_pattern.

4. Write typeck tests:
   - Constructor pattern: `type Shape do Circle(Float) Point end case Shape.Circle(3.0) do Circle(r) -> r Point -> 0.0 end` -> r infers as Float
   - Or-pattern: `case x do Circle(_) | Point -> 1 end` -> both alternatives unify with same scrutinee type
   - As-pattern: `case x do Circle(r) as c -> (r, c) end` -> r is Float, c is Shape
   - Nested: `type Option<T> do Some(T) None end case opt do Some(Circle(r)) -> r None -> 0.0 end` -> r is Float
   - Or-pattern binding mismatch error: `case x do Circle(r) | Point -> r end` -> error (Point doesn't bind r)
   - Named field destructuring: `type Rect do MkRect(width: Float, height: Float) end case r do MkRect(w: w, h: _) -> w end` -> w is Float. NOTE: For named field patterns, the parser should handle `name: pattern` syntax inside constructor patterns. If Plan 01 didn't add this, handle it here by treating `IDENT COLON_COLON pattern` inside a CONSTRUCTOR_PAT as named field destructuring. Actually per CONTEXT.md syntax is `Rectangle(w: w, h: _)` using `:` not `::`. Check what the parser emits and adapt.
  </action>
  <verify>
    `cargo test -p snow-typeck` passes. Constructor patterns extract correct types. Or-pattern binding validation works. As-patterns bind correctly.
  </verify>
  <done>
    All pattern types (constructor, or, as) infer correctly. Constructor patterns unify sub-patterns with variant field types. Or-patterns validate consistent bindings. As-patterns bind the matched value. Nested patterns work to arbitrary depth.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes
- Sum type definitions register with correct variant info
- `Shape.Circle(5.0)` type-checks to `Shape`
- `Option.Some(42)` type-checks to `Option<Int>`
- Constructor patterns in case/match extract correct binding types
- Or-patterns enforce same bindings across alternatives
- As-patterns bind the whole matched value
- Nested constructor patterns (Some(Circle(r))) work
</verification>

<success_criteria>
- TypeRegistry has sum_type_defs alongside struct_defs
- Variant constructors registered as polymorphic functions using enter_level/generalize
- Qualified variant access (Shape.Circle) resolves through field_access inference
- All new Pattern variants handled in infer_pattern
- Type errors for unknown variants and or-pattern binding mismatches
- All existing typeck tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-pattern-matching-adts/04-02-SUMMARY.md`
</output>
