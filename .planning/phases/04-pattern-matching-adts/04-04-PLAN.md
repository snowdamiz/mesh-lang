---
phase: 04-pattern-matching-adts
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/error.rs
autonomous: true

must_haves:
  truths:
    - "Guards in match arms restrict to comparisons, boolean ops, and builtins only"
    - "Guards can reference bindings from their pattern"
    - "Guarded arms do NOT count toward exhaustiveness (treated as potentially non-matching)"
    - "Non-exhaustive match produces a hard error listing missing variants"
    - "Redundant pattern arm produces a warning"
    - "Exhaustiveness and redundancy checks are wired into case/match inference"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Exhaustiveness/redundancy integration in infer_case"
      contains: "check_exhaustiveness"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Guard expression validation"
      contains: "validate_guard"
    - path: "crates/snow-typeck/src/error.rs"
      provides: "NonExhaustiveMatch and RedundantArm error variants"
      contains: "NonExhaustiveMatch"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/exhaustiveness.rs"
      via: "infer_case calls check_exhaustiveness and check_redundancy"
      pattern: "check_exhaustiveness"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "Emits NonExhaustiveMatch errors and RedundantArm warnings"
      pattern: "NonExhaustiveMatch"
---

<objective>
Wire exhaustiveness/redundancy checking into case/match inference, implement guard expression validation, and add multi-clause function support.

Purpose: This connects the exhaustiveness algorithm (Plan 03) to the actual type checker (Plan 02). Guards are validated to be restricted expressions. Non-exhaustive matches become hard errors. Redundant arms become warnings.

Output: Full pattern matching semantics integrated into the type checker. Guards work with restricted expressions. Exhaustiveness and redundancy are enforced.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-pattern-matching-adts/04-CONTEXT.md
@.planning/phases/04-pattern-matching-adts/04-RESEARCH.md
@.planning/phases/04-pattern-matching-adts/04-01-SUMMARY.md
@.planning/phases/04-pattern-matching-adts/04-02-SUMMARY.md
@.planning/phases/04-pattern-matching-adts/04-03-SUMMARY.md
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/exhaustiveness.rs
@crates/snow-typeck/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Exhaustiveness/redundancy wiring and guard validation</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/error.rs
  </files>
  <action>
1. Add new TypeError variants in `error.rs`:
   - `NonExhaustiveMatch { scrutinee_type: Ty, missing_patterns: Vec<String>, span: TextRange }` -- hard error
   - `RedundantArm { arm_index: usize, span: TextRange }` -- warning (still stored as TypeError but rendered as warning)
   - `InvalidGuardExpression { reason: String, span: TextRange }` -- for non-restricted guard expressions
   - Update `fmt::Display` for all new variants
   - Assign error codes: E0010 for NonExhaustiveMatch, E0011 for RedundantArm, E0012 for InvalidGuardExpression

2. Add AST-to-abstract-pattern conversion function in `infer.rs`:
   ```rust
   fn ast_pattern_to_abstract(
       pat: &Pattern,
       ctx: &InferCtx,
       type_registry: &TypeRegistry,
   ) -> exhaustiveness::Pat
   ```
   - Pattern::Wildcard -> Pat::Wildcard
   - Pattern::Ident -> Pat::Wildcard (variable bindings are wildcards for exhaustiveness)
   - Pattern::Literal -> Pat::Literal { value, kind }
   - Pattern::Tuple -> Pat::Constructor { name: "Tuple", args: [recursive...] }
   - Pattern::Constructor -> Pat::Constructor { name: variant_name, type_name, args: [recursive...] }
   - Pattern::Or -> Pat::Or { alternatives: [recursive...] }
   - Pattern::As -> recurse into inner pattern (as-binding doesn't affect exhaustiveness)

3. Add scrutinee type to TypeInfo conversion:
   ```rust
   fn type_to_type_info(ty: &Ty, type_registry: &TypeRegistry) -> exhaustiveness::TypeInfo
   ```
   - Ty::Con("Bool") -> TypeInfo::Bool
   - Ty::Con("Int") / Ty::Con("Float") / Ty::Con("String") -> TypeInfo::Infinite
   - Ty::App(Con(name), _) where name is in sum_type_defs -> TypeInfo::SumType { variants }
   - Ty::Tuple(elems) -> TypeInfo::Tuple { arity: elems.len() }
   - Otherwise -> TypeInfo::Infinite (unknown types are treated as potentially infinite)

4. Modify `infer_case` to call exhaustiveness/redundancy checking after type-checking all arms:
   - After the existing arm-inference loop, collect the patterns (AST) from each arm
   - Convert each arm's pattern to abstract Pat via ast_pattern_to_abstract
   - For arms with guards: exclude from exhaustiveness matrix (per CONTEXT.md: "Guards do NOT count toward exhaustiveness -- a guarded arm is treated as potentially non-matching, so a fallback is required"). Specifically: when building the pattern matrix for exhaustiveness, replace guarded arm patterns with nothing (skip them). For redundancy: guarded arms are never flagged as redundant (they're conditional).
   - Resolve the scrutinee type and convert to TypeInfo
   - Call check_exhaustiveness. If non-exhaustive, emit NonExhaustiveMatch error (hard error) with the missing patterns formatted as strings
   - Call check_redundancy. For each redundant arm index, emit RedundantArm warning (push to ctx.errors but mark as warning -- or use a separate warnings vec)
   - NOTE: For the warnings vs errors distinction, add a `warnings: Vec<TypeError>` field to TypeckResult (alongside errors). RedundantArm goes to warnings, NonExhaustiveMatch goes to errors. Update TypeckResult in lib.rs.

5. Add guard expression validation:
   - Add `validate_guard_expr` function that walks the guard expression AST and checks it only contains:
     - Comparisons: `>`, `<`, `==`, `!=`, `>=`, `<=`
     - Boolean ops: `and`, `or`, `not`, `&&`, `||`
     - Literals (Int, Float, String, Bool)
     - Name references (variables from pattern bindings)
     - Specific builtin function calls (allow a whitelist: `is_nil`, `is_int`, `is_float`, `is_string`, `is_bool`, `length`, `abs` -- or just allow any function call for now and restrict later)
     - Per CONTEXT.md: "no user-defined functions in guards" -- but detecting which functions are user-defined vs builtin at this stage may be complex. Pragmatic approach: allow comparisons, boolean ops, literals, name refs, and calls to known builtins. For now, be permissive and warn on unknown calls rather than hard-error.
   - In `infer_case`, after inferring guard expressions, call validate_guard_expr. If invalid, emit InvalidGuardExpression.
   - Guard type must be Bool -- this is already handled by the existing guard parsing in infer_case (the WHEN_KW branch already parses the expression; add unification with Bool type).

6. Write integration tests:
   - Non-exhaustive sum type: `type Color do Red Green Blue end case c do Red -> 1 end` -> error: "missing Green, Blue"
   - Exhaustive sum type: `type Color do Red Green Blue end case c do Red -> 1 Green -> 2 Blue -> 3 end` -> no error
   - Redundant arm: `type Color do Red Green Blue end case c do _ -> 0 Red -> 1 end` -> warning on arm 1 (Red is redundant)
   - Guard excluded from exhaustiveness: `type Bool2 do T F end case b do T when x > 0 -> 1 F -> 2 end` -> error: non-exhaustive (guarded T doesn't count, so T is missing)
   - Guard with correct fallback: `case b do T when x > 0 -> 1 _ -> 2 end` -> exhaustive
  </action>
  <verify>
    `cargo test -p snow-typeck` passes. Non-exhaustive matches produce errors. Redundant arms produce warnings. Guards are validated and excluded from exhaustiveness.
  </verify>
  <done>
    Exhaustiveness checking is wired into infer_case. Non-exhaustive match is a hard error listing missing patterns. Redundant arms are warnings. Guards are restricted to comparisons/boolean ops and excluded from exhaustiveness matrix.
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-clause function definitions with pattern matching</name>
  <files>
    crates/snow-parser/src/parser/items.rs
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
1. Multi-clause function definitions: Per CONTEXT.md, pattern matching works in function heads with exhaustiveness checking across clauses. Elixir-style:
   ```
   fn factorial(0) -> 1
   fn factorial(n) -> n * factorial(n - 1)
   ```
   These are multiple FN_DEF items with the same name, each with a pattern in the parameter position.

   Parser changes in `items.rs`:
   - Currently parse_fn_def parses parameters as PARAM nodes with IDENT + optional type annotation. Extend to support patterns in parameter position: when parsing a function parameter, if the token is a literal (INT_LITERAL, TRUE_KW, FALSE_KW, etc.), `_` (wildcard), or a tuple `(...)`, parse it as a pattern node instead of a plain IDENT param.
   - For function heads with patterns: `fn name(pattern1, pattern2) -> body end`
   - The simplest approach: in parse_param, check if the current token could be a pattern (literal, `_`, `(`, constructor). If so, parse a pattern inside the PARAM node. The AST Param node already has a way to access children -- add `pattern() -> Option<Pattern>` to Param.
   - Actually, a cleaner approach aligned with Elixir: each clause is a separate fn def. Adjacent fn defs with the same name are grouped into a multi-clause function. This grouping happens at the type checker level, not the parser.

2. Type checker changes in `infer.rs`:
   - Add multi-clause function grouping: After walking all items, group adjacent FnDef items with the same name.
   - For each group of same-name FnDef items:
     a. All clauses must have the same arity (number of params). If not, emit error.
     b. Infer each clause independently (the body may reference different bound variables).
     c. All clauses must have the same return type (unify).
     d. Collect patterns from parameter positions across all clauses.
     e. Run exhaustiveness checking across the collected patterns (treat it like a case/match where the scrutinee is the parameter tuple).
     f. Register the function once in the environment with the unified type.
   - For the parameter pattern inference: when a PARAM has a pattern child (not an IDENT), infer the pattern type and unify with the parameter type. Bind any variables from the pattern.
   - This is complex. Simplify: for v1, support multi-clause functions where:
     - Each clause is `fn name(pat) -> body end` (single parameter for simplicity, extend to multi later)
     - Adjacent fn defs with same name are grouped
     - Exhaustiveness checked across all clauses
     - All clauses have same arity and return type

3. Add `Param::pattern()` method to the AST:
   - In `crates/snow-parser/src/ast/item.rs`, add to Param: `pub fn pattern(&self) -> Option<super::pat::Pattern>` that tries to find a Pattern child node.

4. Write tests:
   - Multi-clause: `fn fact(0) -> 1 fn fact(n) -> n * fact(n - 1)` -> both clauses type-check, fact is (Int) -> Int
   - Exhaustiveness across clauses: `type Dir do North South East West end fn go(North) -> 1 fn go(South) -> 2` -> non-exhaustive (missing East, West)
   - Full coverage: `fn go(North) -> 1 fn go(South) -> 2 fn go(East) -> 3 fn go(West) -> 4` -> exhaustive, no error

  NOTE: If multi-clause functions prove too complex for this plan's context budget, focus on the guard wiring (Task 1) and leave multi-clause as a gap to close in a follow-up plan. Multi-clause is desirable but the core phase success criteria (success criteria 1-3) can be met without it. Signal in the summary if deferred.
  </action>
  <verify>
    `cargo test --workspace` passes. Multi-clause functions (or at minimum, guard integration) works correctly.
  </verify>
  <done>
    Guards validated in match arms (restricted expressions, excluded from exhaustiveness). Multi-clause function definitions with pattern matching work with exhaustiveness across clauses. If multi-clause was deferred, this is documented in the summary.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes
- Non-exhaustive match produces hard error with missing pattern list
- Redundant arm produces warning
- Guards excluded from exhaustiveness (guarded arm alone doesn't satisfy coverage)
- Guard expressions restricted to comparisons, boolean ops, builtins
- Multi-clause functions group by name and check exhaustiveness across clauses
</verification>

<success_criteria>
- Exhaustiveness checking integrated into infer_case
- NonExhaustiveMatch is a hard error (won't compile)
- RedundantArm is a warning (compiles, dead code flagged)
- Guards work with restricted expressions and are excluded from exhaustiveness
- Missing pattern errors list missing variants explicitly
- Multi-clause functions check exhaustiveness across clauses (or documented as deferred)
</success_criteria>

<output>
After completion, create `.planning/phases/04-pattern-matching-adts/04-04-SUMMARY.md`
</output>
