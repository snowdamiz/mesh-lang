---
phase: 22-auto-derive-stretch
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-typeck/src/infer.rs
  - tests/e2e/
autonomous: true

must_haves:
  truths:
    - "`struct Point do x :: Int, y :: Int end deriving(Eq, Display, Debug, Hash)` compiles and all four protocols work correctly"
    - "Derived Display produces `Point(1, 2)` style output (positional, no field names)"
    - "Derived Debug produces `Point { x: 1, y: 2 }` style output (named fields, braces)"
    - "Derived Eq performs field-by-field comparison on structs"
    - "Derived Ord performs lexicographic comparison on structs"
    - "Sum type `deriving(Eq, Ord, Display, Debug, Hash)` generates correct variant-aware implementations"
    - "Sum type Display produces `Circle(3.14)` for variants with fields and `None` for nullary variants"
    - "Sum type Hash combines variant tag with field hashes"
    - "`deriving()` with empty parens produces a type with no protocol impls"
    - "Unsupported trait in deriving clause produces a clear compiler error"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "generate_display_struct, generate_display_sum_type, generate_hash_sum_type functions"
      contains: "generate_display_struct"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Validation of derivable trait names + error on unsupported traits"
      contains: "cannot derive"
    - path: "tests/e2e/"
      provides: "End-to-end tests for deriving on structs and sum types"
      contains: "deriving"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "Typeck registers Display/Hash impls for types with deriving clause; MIR generates matching functions"
      pattern: "Display__to_string|Hash__hash"
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "generate_display_struct uses wrap_to_string and snow_string_concat (same as Debug pattern)"
      pattern: "wrap_to_string|snow_string_concat"
---

<objective>
Implement the three new derive generation functions (Display for structs, Display for sum types, Hash for sum types), add validation for unsupported derive traits, and create comprehensive e2e tests proving all five derivable protocols work correctly on both structs and sum types.

Purpose: Completes Phase 22's success criteria -- users can write `deriving(Eq, Display, Debug, Hash)` and get correct, working implementations without any manual `impl` blocks.
Output: Working Display and Hash-sum generation, derive validation, and e2e tests covering all combinations.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-auto-derive-stretch/22-RESEARCH.md
@.planning/phases/22-auto-derive-stretch/22-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Display generation for structs/sum types + Hash generation for sum types</name>
  <files>
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
    1. Add `generate_display_struct(name, fields)` method to the Lowerer impl, modeled closely on the existing `generate_debug_inspect_struct` (line 1366). Key differences from Debug:
       - Mangled name: `Display__to_string__{name}` (not `Debug__inspect__`)
       - Format: `"Point(1, 2)"` -- positional values in parentheses, NO field names
       - Empty struct: `"Point()"` (not `"Point {}"`)
       - Opening: `format!("{}(", name)` (not `format!("{} {{ ", name)`)
       - Fields: just the value via `wrap_to_string(field_access, None)` -- NO `"field_name: "` label prefix
       - Separator: `", "` between fields (same as Debug)
       - Closing: `")"` (not `" }"`)
       - Register in `self.functions` and `self.known_functions` with same pattern as Debug

    2. Add `generate_display_sum_type(name, variants)` method, modeled on `generate_debug_inspect_sum_type` (line 1448) but with field value rendering:
       - Mangled name: `Display__to_string__{name}`
       - Uses Match on self with Constructor patterns (same pattern as `generate_eq_sum` uses for field binding)
       - For each variant, build a match arm that:
         a. For nullary variants (no fields): return `StringLit(variant_name)`
         b. For variants with fields: bind fields as `field_0, field_1, ...` using `MirPattern::Constructor` with `MirPattern::Var` bindings, then build `"VariantName(val0, val1)"` by:
            - Start with `StringLit(format!("{}(", variant_name))`
            - For each bound field: `wrap_to_string(Var("field_i", field_ty), None)` then concat
            - Separate with `", "`
            - Close with `")"`
       - The Constructor pattern usage follows the EXACT same structure as `generate_eq_sum` lines 1736-1846: create self_fields as `Vec<MirPattern>` with `MirPattern::Var(format!("field_{}", i), ft.clone())`, create bindings as `Vec<(String, MirType)>`, then use `MirPattern::Constructor { type_name, variant, fields: self_fields, bindings }`.
       - Register in `self.functions` and `self.known_functions`

    3. Add `generate_hash_sum_type(name, variants)` method, modeled on `generate_hash_struct` (line 2041) but using Match with Constructor patterns:
       - Mangled name: `Hash__hash__{name}`
       - Uses Match on self with Constructor patterns (same as Display sum type)
       - For each variant, build a match arm that:
         a. Start by hashing the tag: `snow_hash_int(tag as i64)` -- this gives variant discrimination
         b. For each field in the variant: `emit_hash_for_type(Var("field_i", field_ty), &field_ty)` then `snow_hash_combine` with previous hash
         c. Return the combined hash
       - For nullary variants: just `snow_hash_int(tag as i64)`
       - Register in `self.functions` and `self.known_functions`

    4. In `lower_struct_def`, add the Display generation call after the existing conditional gates (from Plan 01):
       ```rust
       if derive_list.iter().any(|t| t == "Display") {
           self.generate_display_struct(&name, &fields);
       }
       ```

    5. In `lower_sum_type_def`, add the Display and Hash generation calls after the existing conditional gates (from Plan 01):
       ```rust
       if derive_list.iter().any(|t| t == "Display") {
           self.generate_display_sum_type(&name, &variants);
       }
       if has_deriving && derive_list.iter().any(|t| t == "Hash") {
           self.generate_hash_sum_type(&name, &variants);
       }
       ```
       Note: Hash for sum types requires explicit `deriving(Hash)` -- it was never in the implicit derive_all set.

    IMPORTANT distinctions between Display and Debug:
    - Display: `"Point(1, 2)"` -- constructor-style, positional
    - Debug: `"Point { x: 1, y: 2 }"` -- record-style, named fields
    These MUST produce different output. Do NOT copy-paste Debug and forget to remove field names.
  </action>
  <verify>
    `cargo build --workspace` compiles cleanly.
    `cargo test -p snow-codegen` passes.
    Grep for `generate_display_struct`, `generate_display_sum_type`, `generate_hash_sum_type` in lower.rs confirms all three functions exist.
  </verify>
  <done>
    Three new MIR generation functions exist: Display for structs (positional format), Display for sum types (variant-aware), Hash for sum types (tag + field hashing). All correctly registered in known_functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Derive validation + e2e tests for all protocols on structs and sum types</name>
  <files>
    crates/snow-typeck/src/infer.rs
    tests/e2e/
  </files>
  <action>
    1. In `crates/snow-typeck/src/infer.rs`, add validation for unsupported derive trait names. In both `register_struct_def` and `register_sum_type_def`, after extracting the derive list, validate each trait name:
       ```rust
       let valid_derives = ["Eq", "Ord", "Display", "Debug", "Hash"];
       for trait_name in &derive_list {
           if !valid_derives.contains(&trait_name.as_str()) {
               ctx.error(format!(
                   "cannot derive `{}` -- only Eq, Ord, Display, Debug, and Hash are derivable",
                   trait_name
               ));
           }
       }
       ```
       Place this validation right after the `let derive_list = ...` extraction, before the `if generic_params.is_empty()` guard. This way even generic types get a clear error message about what's derivable vs the separate "not supported for generic types" message.

    2. Also add a check for generic types with deriving clause -- emit a clear error:
       ```rust
       if has_deriving && !generic_params.is_empty() {
           ctx.error("deriving is not supported for generic types".to_string());
       }
       ```

    3. Create e2e test(s) that exercise the full `deriving(...)` pipeline. Place in the existing e2e test directory (follow the project's pattern -- check `tests/e2e/` or similar for how e2e tests are structured). The tests must cover:

       **Test A: Struct with all five protocols**
       ```snow
       struct Point do
         x :: Int
         y :: Int
       end deriving(Eq, Ord, Display, Debug, Hash)

       fn main() do
         let p = Point { x: 1, y: 2 }
         let q = Point { x: 1, y: 2 }
         let r = Point { x: 3, y: 4 }
         println("${p}")              # Display: "Point(1, 2)"
         println("${p == q}")         # Eq: "true"
         println("${p == r}")         # Eq: "false"
       end
       ```
       Expected output:
       ```
       Point(1, 2)
       true
       false
       ```

       **Test B: Sum type with deriving**
       ```snow
       type Shape do
         Circle(Float)
         Rectangle(Float, Float)
         Dot
       end deriving(Eq, Ord, Display, Debug, Hash)

       fn main() do
         let c = Circle(3.14)
         let d = Dot
         println("${c}")              # Display: "Circle(3.14)"
         println("${d}")              # Display: "Dot"
         println("${c == c}")         # Eq: "true"
         println("${d == d}")         # Eq: "true"
       end
       ```
       Expected output:
       ```
       Circle(3.14)
       Dot
       true
       true
       ```

       **Test C: Backward compatibility (no deriving clause)**
       ```snow
       struct Pair do
         a :: Int
         b :: Int
       end

       fn main() do
         let p = Pair { a: 10, b: 20 }
         let q = Pair { a: 10, b: 20 }
         println("${p == q}")         # Eq still works (backward compat)
       end
       ```
       Expected output: `true`

       **Test D: Selective deriving (only some protocols)**
       ```snow
       struct Tag do
         id :: Int
       end deriving(Eq)

       fn main() do
         let a = Tag { id: 1 }
         let b = Tag { id: 1 }
         println("${a == b}")         # Eq: "true"
       end
       ```
       Expected output: `true`
       Note: This type does NOT derive Debug, Display, Ord, or Hash -- only Eq.

       **Test E: Empty deriving (opt-out)**
       Verify that `deriving()` produces a struct with no auto-derived protocols. This can be tested by ensuring the struct compiles but attempting to use `==` on it would fail (if there's a way to test for compile errors in the e2e framework). If the e2e framework only tests successful compilation + output, skip this test or make it a simple "compiles and prints a value" test:
       ```snow
       struct Empty do
         val :: Int
       end deriving()

       fn main() do
         let e = Empty { val: 42 }
         println("42")
       end
       ```
       Expected output: `42`

    4. Run the full test suite to confirm:
       - All new e2e tests pass
       - All existing e2e tests pass (backward compatibility)
       - No regressions in any crate's unit tests

    IMPORTANT: The e2e test format must match the project's existing e2e test conventions. Check the existing test files in `tests/` to determine:
    - File naming convention (e.g., `test_deriving.snow` or `deriving.snow`)
    - How expected output is specified (inline comments, separate `.expected` file, or Rust test harness)
    - How to run them (`cargo test` or a separate script)
    Adapt the tests above to match whatever convention exists.
  </action>
  <verify>
    `cargo test --workspace` passes with zero regressions.
    E2e tests for deriving on structs produce correct Display/Debug/Eq output.
    E2e tests for deriving on sum types produce correct variant-aware output.
    Backward-compatibility test (no deriving clause) still auto-derives all protocols.
  </verify>
  <done>
    Unsupported derive traits produce clear error messages. Generic types with deriving produce clear error. E2e tests prove: struct deriving(Eq, Display, Debug, Hash) works, sum type deriving works with variant-aware implementations, backward compatibility preserved, selective deriving works.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` -- all tests pass including new e2e deriving tests
- `cargo build --workspace` -- clean compilation
- Display__to_string__StructName produces `"StructName(val1, val2)"` format (NOT Debug format)
- Debug__inspect__StructName still produces `"StructName { field: val }"` format
- Hash__hash__SumTypeName hashes tag + fields
- Unsupported trait in deriving clause produces error
- Struct without deriving clause still gets Debug, Eq, Ord, Hash automatically
- `deriving()` empty clause produces no auto-derived protocols
</verification>

<success_criteria>
- `struct Point do x :: Int, y :: Int end deriving(Eq, Display, Debug, Hash)` compiles and runs correctly
- Display output is `"Point(1, 2)"` (NOT the Debug format)
- Sum type Display produces variant name + positional fields
- Sum type Hash combines tag with field hashes
- All five derivable protocols (Eq, Ord, Display, Debug, Hash) work on both structs and sum types
- Backward compatibility: no deriving clause = derive all (existing behavior preserved)
- `deriving(Invalid)` produces a clear compiler error
- All tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/22-auto-derive-stretch/22-02-SUMMARY.md`
</output>
