---
phase: 22-auto-derive-stretch
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/items.rs
  - crates/snow-parser/src/ast/item.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-fmt/src/walker.rs
autonomous: true

must_haves:
  truths:
    - "`end deriving(Eq, Display)` parses into a DERIVING_CLAUSE CST node with correct trait name children"
    - "A struct/sum type WITHOUT a deriving clause still auto-derives Debug, Eq, Ord, Hash (backward compatible)"
    - "A struct/sum type WITH `deriving(Eq)` derives ONLY Eq (no Debug, Ord, Hash unless listed)"
    - "`deriving()` with empty parens derives nothing"
    - "Typeck conditional gating matches MIR conditional gating (no registration/generation mismatch)"
    - "Formatter preserves `deriving(...)` clause when formatting struct and sum type definitions"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "DERIVING_CLAUSE SyntaxKind"
      contains: "DERIVING_CLAUSE"
    - path: "crates/snow-parser/src/parser/items.rs"
      provides: "Parser logic for deriving clause after end in struct/sum defs"
      contains: "deriving"
    - path: "crates/snow-parser/src/ast/item.rs"
      provides: "deriving_traits() accessor on StructDef and SumTypeDef"
      contains: "deriving_traits"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Conditional trait registration gated by derive list"
      contains: "deriving_traits"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "Conditional MIR generation gated by derive list"
      contains: "deriving_traits"
    - path: "crates/snow-fmt/src/walker.rs"
      provides: "DERIVING_CLAUSE formatting in walk_struct_def and walk_block_def"
      contains: "DERIVING_CLAUSE"
  key_links:
    - from: "crates/snow-parser/src/parser/items.rs"
      to: "crates/snow-parser/src/ast/item.rs"
      via: "Parser produces DERIVING_CLAUSE node, AST accessor reads trait names from it"
      pattern: "DERIVING_CLAUSE"
    - from: "crates/snow-parser/src/ast/item.rs"
      to: "crates/snow-typeck/src/infer.rs"
      via: "typeck calls deriving_traits() to decide which impls to register"
      pattern: "deriving_traits"
    - from: "crates/snow-parser/src/ast/item.rs"
      to: "crates/snow-codegen/src/mir/lower.rs"
      via: "lowerer calls deriving_traits() to decide which generate_* functions to invoke"
      pattern: "deriving_traits"
---

<objective>
Add `deriving(Trait1, Trait2, ...)` syntax to Snow and wire it through the full compiler pipeline: parser, AST, typeck conditional registration, MIR conditional generation, and formatter.

Purpose: Transitions from implicit unconditional auto-derive to explicit opt-in, giving users control over which protocols are derived. This is the infrastructure that Plan 02 builds on for new Display/Hash-sum generation.
Output: Parsing, conditional gating, and formatting for `deriving(...)` clause on struct and sum type definitions. All existing tests still pass (backward compatibility via "no clause = derive all").
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-auto-derive-stretch/22-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parser syntax for deriving clause + AST accessors</name>
  <files>
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/parser/items.rs
    crates/snow-parser/src/ast/item.rs
  </files>
  <action>
    1. In `crates/snow-parser/src/syntax_kind.rs`, add a new composite node kind `DERIVING_CLAUSE` in the "Sum type / ADT node kinds" section (after `GUARD_CLAUSE` around line 262). This is a node wrapping `deriving(Trait1, Trait2, ...)`.

    2. In `crates/snow-parser/src/parser/items.rs`, modify `parse_struct_def` (line ~246):
       - BEFORE the `p.close(m, SyntaxKind::STRUCT_DEF)` call on line 302, insert the deriving clause check:
       ```rust
       // Optional deriving clause: end deriving(Trait1, Trait2, ...)
       if p.at(SyntaxKind::IDENT) && p.current_text() == "deriving" {
           let dc = p.open();
           p.advance(); // "deriving" IDENT
           p.expect(SyntaxKind::L_PAREN);
           loop {
               if p.at(SyntaxKind::R_PAREN) || p.at(SyntaxKind::EOF) {
                   break;
               }
               if p.at(SyntaxKind::IDENT) {
                   p.advance(); // trait name
               } else {
                   p.error("expected trait name in deriving clause");
                   break;
               }
               if !p.eat(SyntaxKind::COMMA) {
                   break;
               }
           }
           p.expect(SyntaxKind::R_PAREN);
           p.close(dc, SyntaxKind::DERIVING_CLAUSE);
       }
       ```
       - The check must happen AFTER consuming END_KW but BEFORE closing STRUCT_DEF. Move the `p.close(m, SyntaxKind::STRUCT_DEF)` after the deriving check. The existing code has the close on line 302 -- the deriving parsing goes between the `p.advance(); // END_KW` (line 299) and the close. Handle the error path too: the close on line 261 (early return on missing name) stays as is.

    3. In the same file, apply the identical deriving clause parsing to `parse_sum_type_def` (line ~654):
       - BEFORE the `p.close(m, SyntaxKind::SUM_TYPE_DEF)` call on line 710, insert the same deriving clause check (copy-paste from above). Again, this goes between the `p.advance(); // END_KW` (line 707) and the close.

    4. In `crates/snow-parser/src/ast/item.rs`, add a `deriving_traits()` method to `impl StructDef` (after the `fields()` method, around line 275):
       ```rust
       /// Returns the list of trait names from `deriving(Eq, Display, ...)`.
       /// Returns an empty Vec if no DERIVING_CLAUSE is present (meaning "derive all" for backward compat).
       /// A present but empty `deriving()` returns an empty Vec with has_deriving_clause() == true.
       pub fn has_deriving_clause(&self) -> bool {
           self.syntax.children().any(|n| n.kind() == SyntaxKind::DERIVING_CLAUSE)
       }

       pub fn deriving_traits(&self) -> Vec<String> {
           self.syntax
               .children()
               .find(|n| n.kind() == SyntaxKind::DERIVING_CLAUSE)
               .map(|dc| {
                   dc.children_with_tokens()
                       .filter_map(|it| it.into_token())
                       .filter(|t| t.kind() == SyntaxKind::IDENT && t.text() != "deriving")
                       .map(|t| t.text().to_string())
                       .collect()
               })
               .unwrap_or_default()
       }
       ```

    5. Add the same two methods (`has_deriving_clause()` and `deriving_traits()`) to `impl SumTypeDef` (after the `variants()` method, around line 488). Identical implementation -- both AST nodes use the same DERIVING_CLAUSE child pattern.

    6. Add a parser test in the existing test infrastructure (or inline in items.rs if that's the pattern) that verifies:
       - `struct Point do x :: Int end deriving(Eq, Display)` produces a STRUCT_DEF with a DERIVING_CLAUSE child containing IDENT tokens "Eq" and "Display"
       - `struct Point do x :: Int end` (no clause) produces a STRUCT_DEF WITHOUT a DERIVING_CLAUSE child
       - `type Shape do Circle end deriving(Eq)` produces a SUM_TYPE_DEF with DERIVING_CLAUSE

    IMPORTANT: `deriving` is NOT a keyword -- it's parsed as a regular IDENT whose text happens to be "deriving". Do NOT add it to TokenKind or keyword_from_str. The `p.current_text() == "deriving"` check is a contextual parse.
  </action>
  <verify>
    `cargo test -p snow-parser` passes with zero regressions.
    `cargo build --workspace` compiles cleanly.
    New parser tests for deriving clause pass.
  </verify>
  <done>
    DERIVING_CLAUSE SyntaxKind exists. Parser produces it for `end deriving(...)` on both structs and sum types. AST accessors `has_deriving_clause()` and `deriving_traits()` work on both StructDef and SumTypeDef.
  </done>
</task>

<task type="auto">
  <name>Task 2: Conditional gating in typeck + MIR lowering + formatter</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
    1. In `crates/snow-typeck/src/infer.rs`, modify `register_struct_def` (starts line 1408):
       - After extracting `name` and `generic_params`, extract the derive list:
       ```rust
       let has_deriving = struct_def.has_deriving_clause();
       let derive_list = struct_def.deriving_traits();
       let derive_all = !has_deriving; // no clause = backward compat: derive all
       ```
       - Replace the existing unconditional auto-registration block (lines 1461-1531) with conditional gating:
       ```rust
       if generic_params.is_empty() {
           let impl_ty = Ty::Con(TyCon::new(&name));

           if derive_all || derive_list.iter().any(|t| t == "Debug") {
               // Debug impl (existing code, unchanged)
           }
           if derive_all || derive_list.iter().any(|t| t == "Eq") {
               // Eq impl (existing code, unchanged)
           }
           if derive_all || derive_list.iter().any(|t| t == "Ord") {
               // Ord impl (existing code, unchanged)
           }
           if derive_all || derive_list.iter().any(|t| t == "Hash") {
               // Hash impl (existing code, unchanged)
           }
           if derive_list.iter().any(|t| t == "Display") {
               // Display impl -- NEW registration (same pattern as Debug but trait_name="Display", method="to_string")
               let mut display_methods = FxHashMap::default();
               display_methods.insert("to_string".to_string(), ImplMethodSig {
                   has_self: true, param_count: 0, return_type: Some(Ty::string()),
               });
               let _ = trait_registry.register_impl(TraitImplDef {
                   trait_name: "Display".to_string(),
                   impl_type: impl_ty.clone(),
                   impl_type_name: name.clone(),
                   methods: display_methods,
               });
           }
       }
       ```
       - Note: Display is NOT in `derive_all` because it was never auto-derived before. Only explicit `deriving(Display)` triggers it.

    2. Apply the same conditional gating to `register_sum_type_def` (starts line 1616):
       - Extract derive list from `sum_def.has_deriving_clause()` / `sum_def.deriving_traits()`
       - Gate the existing Debug, Eq, Ord registration (lines 1692-1747) with the same `derive_all || derive_list.contains(...)` pattern
       - Add Hash registration for sum types when `derive_list.iter().any(|t| t == "Hash")` -- Hash was never auto-derived for sum types, so it needs explicit opt-in via deriving clause only (NOT in derive_all). Use same ImplMethodSig pattern as struct Hash.
       - Add Display registration for sum types when `derive_list.iter().any(|t| t == "Display")` -- same as struct Display above.

    3. In `crates/snow-codegen/src/mir/lower.rs`, modify `lower_struct_def` (starts line 1278):
       - Extract derive list from the `struct_def` parameter (it's `&StructDef` so call `struct_def.has_deriving_clause()` / `struct_def.deriving_traits()`)
       - Gate the four existing generate calls (lines 1299-1309):
       ```rust
       let has_deriving = struct_def.has_deriving_clause();
       let derive_list = struct_def.deriving_traits();
       let derive_all = !has_deriving;

       if derive_all || derive_list.iter().any(|t| t == "Debug") {
           self.generate_debug_inspect_struct(&name, &fields);
       }
       if derive_all || derive_list.iter().any(|t| t == "Eq") {
           self.generate_eq_struct(&name, &fields);
       }
       if derive_all || derive_list.iter().any(|t| t == "Ord") {
           self.generate_ord_struct(&name, &fields);
       }
       if derive_all || derive_list.iter().any(|t| t == "Hash") {
           self.generate_hash_struct(&name, &fields);
       }
       // Display generation is added in Plan 02 (generate_display_struct does not exist yet)
       ```

    4. Apply the same conditional gating to `lower_sum_type_def` (starts line 1316):
       - Extract derive list from `sum_def` parameter
       - Gate the three existing generate calls (lines 1350-1357):
       ```rust
       let has_deriving = sum_def.has_deriving_clause();
       let derive_list = sum_def.deriving_traits();
       let derive_all = !has_deriving;

       if derive_all || derive_list.iter().any(|t| t == "Debug") {
           self.generate_debug_inspect_sum_type(&name, &variants);
       }
       if derive_all || derive_list.iter().any(|t| t == "Eq") {
           self.generate_eq_sum(&name, &variants);
       }
       if derive_all || derive_list.iter().any(|t| t == "Ord") {
           self.generate_ord_sum(&name, &variants);
       }
       // Hash-sum and Display-sum generation are added in Plan 02
       ```

    5. In `crates/snow-fmt/src/walker.rs`, update `walk_struct_def` (starts line 792):
       - After `parts.push(ir::text("end"));` (line 854), add handling for DERIVING_CLAUSE:
       - In the main `for child` loop, add a match arm for `SyntaxKind::DERIVING_CLAUSE` nodes that appear as children of STRUCT_DEF. When encountered (after end):
       ```rust
       // In the Node match branch, handle DERIVING_CLAUSE:
       SyntaxKind::DERIVING_CLAUSE => {
           // Will be handled after "end" is emitted
       }
       ```
       - Actually, the cleaner approach: after emitting "end" text, check if there's a DERIVING_CLAUSE child node and format it inline:
       ```rust
       // After parts.push(ir::text("end"));
       // Check for deriving clause
       if let Some(dc) = node.children().find(|n| n.kind() == SyntaxKind::DERIVING_CLAUSE) {
           parts.push(sp());
           parts.push(ir::text("deriving("));
           let traits: Vec<String> = dc.children_with_tokens()
               .filter_map(|it| it.into_token())
               .filter(|t| t.kind() == SyntaxKind::IDENT && t.text() != "deriving")
               .map(|t| t.text().to_string())
               .collect();
           parts.push(ir::text(&traits.join(", ")));
           parts.push(ir::text(")"));
       }
       ```

    6. Apply the same formatter logic to `walk_block_def` (starts line 697) for sum types. After `parts.push(ir::text("end"));` (line 785), add the same DERIVING_CLAUSE handling.

    7. Run full test suite to verify backward compatibility: ALL existing tests must pass unchanged because no existing struct/sum type has a deriving clause, so `derive_all = true` preserves current behavior.

    CRITICAL: The typeck and MIR lowering MUST agree on what gets derived. Both read from the same CST node via the same `has_deriving_clause()` / `deriving_traits()` methods. A mismatch (typeck registers Display impl but MIR doesn't generate the function) causes link errors.
  </action>
  <verify>
    `cargo test --workspace` passes with zero regressions (backward compatibility).
    `cargo build --workspace` compiles cleanly.
    Manually verify: a struct without deriving still gets Debug, Eq, Ord, Hash in both typeck and MIR.
  </verify>
  <done>
    Typeck conditionally registers trait impls based on deriving clause. MIR lowering conditionally generates protocol functions based on deriving clause. Formatter preserves deriving clause. All existing tests pass (backward compatible).
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` -- all existing tests pass (backward compat: no deriving clause = derive all)
- `cargo build --workspace` -- clean compilation
- DERIVING_CLAUSE SyntaxKind added to syntax_kind.rs
- Parser produces DERIVING_CLAUSE for `end deriving(Trait1, Trait2)` on struct and sum type
- AST accessors `has_deriving_clause()` and `deriving_traits()` work on StructDef and SumTypeDef
- Typeck gates Debug/Eq/Ord/Hash registration on derive list (derive_all when no clause)
- MIR lowering gates generate_* calls on derive list (derive_all when no clause)
- Formatter handles DERIVING_CLAUSE node in both walk_struct_def and walk_block_def
</verification>

<success_criteria>
- DERIVING_CLAUSE is a valid SyntaxKind
- `struct Point do x :: Int end deriving(Eq, Display)` parses without error
- `type Shape do Circle end deriving(Eq)` parses without error
- StructDef.deriving_traits() returns ["Eq", "Display"] for the first example
- All existing tests pass without modification (backward compatibility confirmed)
- Formatter round-trips `deriving(...)` clause correctly
</success_criteria>

<output>
After completion, create `.planning/phases/22-auto-derive-stretch/22-01-SUMMARY.md`
</output>
