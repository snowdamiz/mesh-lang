---
phase: 91.1-refactor-mesher-to-use-pipe-operators-and-idiomatic-mesh-features
plan: 02
type: execute
wave: 2
depends_on: ["91.1-01"]
files_modified:
  - mesher/main.mpl
  - mesher/api/search.mpl
  - mesher/api/dashboard.mpl
  - mesher/api/team.mpl
  - mesher/api/detail.mpl
  - mesher/ingestion/routes.mpl
autonomous: true

must_haves:
  truths:
    - "main.mpl HTTP router uses a single pipe chain instead of 27 sequential let r = HTTP.on_* bindings"
    - "API handler serialize functions use pipe chains (rows |> List.map(...) |> to_json_array)"
    - "meshc build mesher/ compiles successfully with zero errors"
    - "No behavioral changes: all API responses, status codes, and JSON field names are identical"
  artifacts:
    - path: "mesher/main.mpl"
      provides: "Entry point with pipe-chained HTTP router"
      contains: "|>"
    - path: "mesher/api/search.mpl"
      provides: "Search handlers with pipe-chain data transforms"
      contains: "|>"
    - path: "mesher/api/dashboard.mpl"
      provides: "Dashboard handlers with pipe-chain data transforms"
      contains: "|>"
    - path: "mesher/api/team.mpl"
      provides: "Team handlers with pipe-chain data transforms"
      contains: "|>"
  key_links:
    - from: "mesher/main.mpl"
      to: "HTTP.on_get / HTTP.on_post"
      via: "pipe operator desugaring"
      pattern: "\\|> HTTP\\.on_"
---

<objective>
Pipe-chain the HTTP router in main.mpl and data transform pipelines in API handlers.

Purpose: Transform the most visible code patterns from verbose sequential `let` bindings to fluent pipe chains, making the Mesher codebase a showcase of idiomatic Mesh style. The HTTP router is the single most impactful visual improvement.

Output: Updated main.mpl, search.mpl, dashboard.mpl, team.mpl, detail.mpl, routes.mpl with pipe operator usage.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/91.1-refactor-mesher-to-use-pipe-operators-and-idiomatic-mesh-features/91.1-RESEARCH.md
@.planning/phases/91.1-refactor-mesher-to-use-pipe-operators-and-idiomatic-mesh-features/91.1-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pipe-chain HTTP router in main.mpl</name>
  <files>mesher/main.mpl</files>
  <action>
Rewrite the HTTP router setup in `start_services` (lines 62-101) from 27 sequential `let r = HTTP.on_*(r, ...)` bindings to a single pipe chain.

**Before** (current pattern):
```mesh
let r = HTTP.router()
let r = HTTP.on_post(r, "/api/v1/events", handle_event)
let r = HTTP.on_post(r, "/api/v1/events/bulk", handle_bulk)
let r = HTTP.on_get(r, "/api/v1/projects/:project_id/issues", handle_search_issues)
# ... 23 more lines like this ...
```

**After** (pipe chain):
```mesh
let r = HTTP.router()
  |> HTTP.on_post("/api/v1/events", handle_event)
  |> HTTP.on_post("/api/v1/events/bulk", handle_bulk)
  |> HTTP.on_get("/api/v1/projects/:project_id/issues", handle_search_issues)
  |> HTTP.on_get("/api/v1/projects/:project_id/events/search", handle_search_events)
  |> HTTP.on_get("/api/v1/projects/:project_id/events/tags", handle_filter_by_tag)
  |> HTTP.on_get("/api/v1/issues/:issue_id/events", handle_list_issue_events)
  |> HTTP.on_get("/api/v1/projects/:project_id/dashboard/volume", handle_event_volume)
  |> HTTP.on_get("/api/v1/projects/:project_id/dashboard/levels", handle_error_breakdown)
  |> HTTP.on_get("/api/v1/projects/:project_id/dashboard/top-issues", handle_top_issues)
  |> HTTP.on_get("/api/v1/projects/:project_id/dashboard/tags", handle_tag_breakdown)
  |> HTTP.on_get("/api/v1/issues/:issue_id/timeline", handle_issue_timeline)
  |> HTTP.on_get("/api/v1/projects/:project_id/dashboard/health", handle_project_health)
  |> HTTP.on_get("/api/v1/events/:event_id", handle_event_detail)
  |> HTTP.on_post("/api/v1/issues/:id/resolve", handle_resolve_issue)
  |> HTTP.on_post("/api/v1/issues/:id/archive", handle_archive_issue)
  |> HTTP.on_post("/api/v1/issues/:id/unresolve", handle_unresolve_issue)
  |> HTTP.on_post("/api/v1/issues/:id/assign", handle_assign_issue)
  |> HTTP.on_post("/api/v1/issues/:id/discard", handle_discard_issue)
  |> HTTP.on_post("/api/v1/issues/:id/delete", handle_delete_issue)
  |> HTTP.on_get("/api/v1/orgs/:org_id/members", handle_list_members)
  |> HTTP.on_post("/api/v1/orgs/:org_id/members", handle_add_member)
  |> HTTP.on_post("/api/v1/orgs/:org_id/members/:membership_id/role", handle_update_member_role)
  |> HTTP.on_post("/api/v1/orgs/:org_id/members/:membership_id/remove", handle_remove_member)
  |> HTTP.on_get("/api/v1/projects/:project_id/api-keys", handle_list_api_keys)
  |> HTTP.on_post("/api/v1/projects/:project_id/api-keys", handle_create_api_key)
  |> HTTP.on_post("/api/v1/api-keys/:key_id/revoke", handle_revoke_api_key)
```

This works because `x |> HTTP.on_post("/path", handler)` desugars to `HTTP.on_post(x, "/path", handler)`, which is exactly the current calling convention.

Keep the section comments (# Ingestion, # Issue listing, # Dashboard, etc.) as inline comments above the relevant pipe segments for readability.

CRITICAL: Preserve the EXACT same route paths and handler references. Do NOT reorder routes. Do NOT change any handler function names. Keep the comments about Ws.serve and HTTP.serve below the router chain unchanged.

Do NOT change `start_services` before the router (schema creation, service starts) or after (Ws.serve, HTTP.serve). Only the router binding block changes.
  </action>
  <verify>
Run `meshc build mesher/` from the project root. Must compile with zero errors. Visually inspect main.mpl to confirm pipe chain syntax and that all 26 routes are present.
  </verify>
  <done>
main.mpl HTTP router uses a single pipe chain with |> operators. All 26 routes preserved with identical paths and handlers. meshc build mesher/ succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pipe-chain data transform pipelines in API handlers</name>
  <files>
    mesher/api/search.mpl
    mesher/api/dashboard.mpl
    mesher/api/team.mpl
    mesher/api/detail.mpl
    mesher/ingestion/routes.mpl
  </files>
  <action>
Add pipe chains to data serialization patterns across API handlers. The transform is: wherever there is a `let json_items = List.map(rows, fn(...) do ... end)` followed by `to_json_array(json_items)` or similar, combine into a pipe chain.

**search.mpl changes:**

1. `serialize_issue_rows` (currently lines ~155-159): Replace sequential lets with pipe:
```mesh
fn serialize_issue_rows(rows, limit_str :: String) -> String do
  let json_array = rows
    |> List.map(fn(row) do row_to_issue_json(row) end)
    |> to_json_array
  let limit = limit_to_int(limit_str)
  build_paginated_response(json_array, rows, limit)
end
```

2. `serialize_event_search` (currently lines ~193-196): Replace with pipe:
```mesh
fn serialize_event_search(rows) -> String do
  rows |> List.map(fn(row) do row_to_event_json(row) end) |> to_json_array
end
```

3. `serialize_tag_events` (currently lines ~233-236): Replace with pipe:
```mesh
fn serialize_tag_events(rows) -> String do
  rows |> List.map(fn(row) do row_to_tag_event_json(row) end) |> to_json_array
end
```

4. `serialize_issue_event_rows` (currently lines ~281-286): Replace with pipe:
```mesh
fn serialize_issue_event_rows(rows, limit_str :: String) -> String do
  let json_array = rows
    |> List.map(fn(row) do row_to_issue_event_json(row) end)
    |> to_json_array
  let limit = limit_to_int(limit_str)
  build_event_paginated_response(json_array, rows, limit)
end
```

**dashboard.mpl changes:**

1. `respond_volume` (currently lines ~82-85): Replace with pipe:
```mesh
fn respond_volume(rows) do
  let body = rows |> List.map(fn(row) do bucket_to_json(row) end) |> to_json_array
  HTTP.response(200, body)
end
```

2. `respond_levels` (currently lines ~102-105): Same pattern with level_to_json.

3. `respond_top_issues` (currently lines ~121-124): Same pattern with top_issue_to_json.

4. `respond_tag_breakdown` (currently lines ~141-144): Same pattern with tag_entry_to_json.

5. `respond_timeline` (currently lines ~170-173): Same pattern with timeline_event_to_json.

**team.mpl changes:**

1. `handle_list_members` (line ~192): The inline `to_json_array(List.map(rows, ...))` can become a pipe:
```mesh
Ok(rows) -> HTTP.response(200, rows |> List.map(fn(row) do member_to_json(row) end) |> to_json_array)
```

2. `handle_list_api_keys` (line ~239): Same pattern:
```mesh
Ok(rows) -> HTTP.response(200, rows |> List.map(fn(row) do api_key_to_json(row) end) |> to_json_array)
```

**detail.mpl changes:**
Minimal -- no `to_json_array` usage. No changes needed. Skip this file.

**routes.mpl changes:**
The `issues_to_json` function was already updated in Plan 01 to use String.join. If it currently reads:
```mesh
fn issues_to_json(issues :: List<Issue>) -> String do
  let json_items = List.map(issues, fn(issue) do issue_to_json_str(issue) end)
  "[" <> String.join(json_items, ",") <> "]"
end
```
Convert to pipe:
```mesh
fn issues_to_json(issues :: List<Issue>) -> String do
  let items = issues |> List.map(fn(issue) do issue_to_json_str(issue) end)
  "[" <> String.join(items, ",") <> "]"
end
```
Note: We cannot pipe the full chain because String.join returns a String which then needs string concatenation with "[" and "]", which is not a function call suitable for piping.

CRITICAL: Do NOT change any handler logic, SQL queries, response formats, error messages, or HTTP status codes. Only change the internal variable binding patterns to use pipe operators.

IMPORTANT: If `|> to_json_array` (bare module-qualified reference without parens) does not compile, use `|> to_json_array()` (empty parens) instead. The pipe desugaring handles both forms, but the parser may require call syntax for imported functions.
  </action>
  <verify>
Run `meshc build mesher/` from the project root. Must compile with zero errors. Grep for `|>` in the modified files to confirm pipe operators are present. Verify no pub function signatures changed.
  </verify>
  <done>
All API data transform functions use pipe chains (|> List.map |> to_json_array). main.mpl router is a single pipe chain. meshc build mesher/ succeeds. All API responses identical to pre-refactor.
  </done>
</task>

</tasks>

<verification>
1. `meshc build mesher/` compiles successfully with zero errors
2. `grep -r "|>" mesher/main.mpl` shows pipe operators in the router chain
3. `grep -r "|>" mesher/api/` shows pipe operators in data transform functions
4. No pub function signatures changed (all handler names and param types identical)
5. Visual inspection confirms readable, idiomatic pipe chain style
</verification>

<success_criteria>
- meshc build mesher/ produces a valid binary
- main.mpl router is a single pipe chain (1 `let r` binding, 26 `|>` lines)
- At least 8 data transform functions in api/ use pipe chains
- No behavioral changes to any API endpoint
</success_criteria>

<output>
After completion, create `.planning/phases/91.1-refactor-mesher-to-use-pipe-operators-and-idiomatic-mesh-features/91.1-02-SUMMARY.md`
</output>
