# Phase 91.1: Refactor Mesher to Use Pipe Operators and Idiomatic Mesh Features - Research

**Researched:** 2026-02-14
**Domain:** Mesh language idioms, pipe operators, stdlib features for application refactoring
**Confidence:** HIGH

## Summary

The Mesher application (~3275 lines of Mesh across 26 files) was written incrementally across Phases 87-91, during which the Mesh language itself was evolving. Many workarounds for bugs that have since been fixed remain in the code. Several language features that now exist (pipe operators, `?` operator, `String.join`, `for..in` comprehensions, `List.map`/`filter`/`reduce` with closures) were either unavailable or unreliable when the Mesher code was written, so the code uses verbose patterns: recursive `json_array_loop` functions instead of `String.join`, duplicated `query_or_default` helpers across modules, explicit `case` matching on every `Result` instead of `?`, sequential `let r = HTTP.on_get(r, ...)` chains instead of pipe chains, and manual recursive iteration instead of `for..in` or `List.map |> reduce`.

This refactoring phase is purely cosmetic/idiomatic -- no new features, no behavioral changes, no API changes. The goal is to make the Mesher codebase a showcase of idiomatic Mesh, demonstrating that Mesh is a pleasant language for real applications. The refactoring can be verified by confirming the compiler still produces a valid binary (`meshc build mesher/`) and that no public API signatures change.

**Primary recommendation:** Refactor file-by-file with three main transforms: (1) replace `json_array_loop`/`to_json_array` with `String.join`, (2) pipe-chain HTTP router setup and data transformation pipelines, (3) use `?` operator for Result propagation where explicit `case` was the workaround. Do NOT change behavior, SQL queries, or service architecture.

## Available Language Features for Refactoring

### Pipe Operator (`|>`)
**Confidence:** HIGH -- verified via MIR lowering source code and E2E tests

**Semantics (from `lower_pipe_expr` in `crates/mesh-codegen/src/mir/lower.rs:5856`):**
- `x |> f` desugars to `f(x)` (bare function ref)
- `x |> f(a, b)` desugars to `f(x, a, b)` (prepend LHS to existing args)
- Pipe chains: `x |> f |> g(a)` desugars to `g(f(x), a)`

**Verified patterns:**
```mesh
# Bare function pipe
5 |> double |> add_one    # -> add_one(double(5))

# Pipe with args
5 |> add(10)              # -> add(5, 10)

# Pipe with closures (from pipe_chain_closures.mpl)
list |> map(fn x -> x + 1 end) |> filter(fn x -> x > 3 end) |> reduce(0, fn acc, x -> acc + x end)
```

**Applicable in Mesher:**
- HTTP router chain: `HTTP.router() |> HTTP.on_get("/path", handler) |> HTTP.on_post("/path", handler2)`
- Data transform chains: `rows |> List.map(fn(row) do row_to_json(row) end) |> String.join(",")`
- Query parameter extraction chains

### `?` Operator for Result Handling
**Confidence:** HIGH -- fixed in Phase 87.1-01, verified working

The `?` operator was broken due to LLVM codegen type mismatch (returning `ptr` instead of `{ i8, ptr }`). Fixed in 87.1-01 with defensive ptr-to-struct load in `codegen_return`. The Mesher code already uses `?` in some newer files (e.g., `storage/writer.mpl:34`, `storage/queries.mpl` extensively), but many handler files still use explicit `case` matching as a holdover from pre-fix code.

**Pattern to replace:**
```mesh
# Before (workaround)
let result = some_query(pool, args)
case result do
  Ok(rows) -> process(rows)
  Err(e) -> HTTP.response(500, "{\"error\":\"" <> e <> "\"}")
end

# After (idiomatic) -- only where the Err branch is simple error propagation
let rows = some_query(pool, args)?
process(rows)
```

**IMPORTANT CAVEAT:** The `?` operator only works in functions that return `Result<T, E>`. HTTP handlers return HTTP responses, NOT Result types. So `?` cannot be used directly in pub handler functions. It CAN be used in helper functions that return Result.

### `String.join(list, separator)`
**Confidence:** HIGH -- verified in builtins (infer.rs:260) and E2E test (stdlib_string_split_join.mpl)

**Signature:** `String.join(List<String>, String) -> String`

This is the single highest-impact refactoring target. The Mesher codebase has **three separate copies** of `json_array_loop`/`to_json_array` (in `api/search.mpl`, `api/dashboard.mpl`, `api/team.mpl`) plus one in `ingestion/routes.mpl` (`issues_to_json_loop`). Each is a 10-line recursive function that can be replaced with a one-liner:

```mesh
# Before (14 lines across 2 functions)
fn json_array_loop(items, i :: Int, total :: Int, acc :: String) -> String do
  if i < total do
    let item = List.get(items, i)
    let new_acc = if i > 0 do acc <> "," <> item else item end
    json_array_loop(items, i + 1, total, new_acc)
  else
    "[" <> acc <> "]"
  end
end
fn to_json_array(items) -> String do
  json_array_loop(items, 0, List.length(items), "")
end

# After (1 line)
fn to_json_array(items) -> String do
  "[" <> String.join(items, ",") <> "]"
end
```

### `for..in` Comprehensions
**Confidence:** HIGH -- verified in E2E tests (for_in_filter.mpl, for_in_map.mpl, for_in_range.mpl)

Available syntax:
- `for x in list do ... end` -- iterate and collect
- `for x in list when condition do ... end` -- filter during iteration
- `for {k, v} in map do ... end` -- map destructuring
- `for i in 0..n do ... end` -- range iteration

**Applicable in Mesher:** Could replace some `List.map` calls, but `List.map` with closures is already idiomatic. The `for..in` comprehension is most useful where the existing code uses manual recursive loops for iteration (e.g., `fingerprint_frames_loop`, `flush_loop`, `drain_connections_loop`).

**CAVEAT:** `for..in` produces a `List`. Some loops in Mesher have side effects (sending WS messages, inserting DB rows) or accumulate non-list results. These cannot use `for..in`. The recursive patterns for these should stay.

### Top-Level `map`, `filter`, `reduce`
**Confidence:** HIGH -- verified in builtins (builtins.rs:289-293) and pipe_chain_closures.mpl test

These are available both as `List.map(list, fn)` (module-qualified) and as bare `map(list, fn)` (top-level builtin). Both work identically. The module-qualified form is more explicit and preferred for readability.

## Architecture Patterns

### Pattern 1: Pipe-Chained HTTP Router
**What:** Replace sequential `let r = HTTP.on_*(r, ...)` with a single pipe chain
**When to use:** main.mpl router setup
**Example:**
```mesh
# Before (40 lines)
let r = HTTP.router()
let r = HTTP.on_post(r, "/api/v1/events", handle_event)
let r = HTTP.on_post(r, "/api/v1/events/bulk", handle_bulk)
let r = HTTP.on_get(r, "/api/v1/projects/:project_id/issues", handle_search_issues)
# ... 15 more routes ...

# After (pipe chain)
let r = HTTP.router()
  |> HTTP.on_post("/api/v1/events", handle_event)
  |> HTTP.on_post("/api/v1/events/bulk", handle_bulk)
  |> HTTP.on_get("/api/v1/projects/:project_id/issues", handle_search_issues)
  # ... 15 more routes ...
```

This works because `x |> HTTP.on_post("/path", handler)` desugars to `HTTP.on_post(x, "/path", handler)`, which is exactly the current pattern.

### Pattern 2: Data Transform Pipeline
**What:** Replace let-chain data transforms with pipe chains
**When to use:** Serializing query results to JSON in API handlers
**Example:**
```mesh
# Before
let json_items = List.map(rows, fn(row) do row_to_json(row) end)
let json_array = to_json_array(json_items)

# After
let json_array = rows
  |> List.map(fn(row) do row_to_json(row) end)
  |> to_json_array
```

### Pattern 3: Shared Helper Module (DRY)
**What:** Extract duplicated helpers into a shared module
**When to use:** `query_or_default`, `to_json_array` -- currently duplicated across 3-4 files
**Example:**
```mesh
# New file: mesher/api/helpers.mpl
pub fn query_or_default(request, param :: String, default :: String) -> String do
  let opt = Request.query(request, param)
  case opt do
    Some(v) -> v
    None -> default
  end
end

pub fn to_json_array(items) -> String do
  "[" <> String.join(items, ",") <> "]"
end
```

Then each API module imports: `from Api.Helpers import query_or_default, to_json_array`

**CAVEAT:** Cross-module function import with inferred (polymorphic) type parameters was fixed in 87.1-02. `to_json_array` takes `List<String>` which is concrete, so it should work. `query_or_default` takes `request` with inferred type -- this needs testing.

### Pattern 4: Simplified Schema Creation with Pipe + `?`
**What:** Chain schema DDL statements with `?` operator
**When to use:** `storage/schema.mpl` already uses `?` for chaining Pool.execute calls
**Note:** The schema file already uses `?` idiomatically. No changes needed there.

### Anti-Patterns to Avoid

- **Forcing pipe chains where they reduce readability.** Multi-step processes with intermediate variables that are referenced later should NOT be piped. For example, the event processor's `route_event` chain passes `state` through multiple functions and branches -- piping would obscure the control flow.

- **Using `?` in HTTP handler functions.** HTTP handlers return `HTTP.response(...)`, not `Result`. The `?` operator requires a `Result`-returning function. Keep explicit `case` matching in handler functions for the final Result dispatch.

- **Breaking the define-before-use ordering.** Mesh requires functions to be defined before they are used. When consolidating helpers into a shared module, the import must come before any usage. This is already the convention.

- **Removing `both_match` helper.** The `&&` operator still has LLVM PHI node codegen issues in nested if blocks (decision [90-01]). Keep using `both_match(a, b)` where `&&` would be used inside nested if statements.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| JSON array from list of strings | Recursive `json_array_loop` | `"[" <> String.join(items, ",") <> "]"` | `String.join` handles empty lists, separators correctly |
| Iterating list with index | Recursive loop with `i`, `total`, `List.get(items, i)` | `List.map(items, fn(item) do ... end)` or `for item in items do ... end` | Built-in, no off-by-one risk |
| Converting Option to default | `case opt do Some(v) -> v \| None -> default end` | Keep explicit `case` -- Mesh has no `Option.unwrap_or` | No stdlib alternative exists yet |

## Common Pitfalls

### Pitfall 1: Pipe Operator with Module-Qualified Functions
**What goes wrong:** Writing `x |> Module.function` -- need to verify the parser handles module-qualified names in pipe RHS
**Why it happens:** The pipe operator's RHS can be a bare function ref or a call expression. Module-qualified access (`HTTP.on_get`) is a field access expression, which may or may not be handled as a valid pipe RHS.
**How to avoid:** Tested: `x |> HTTP.on_post("/path", handler)` should work because `HTTP.on_post(...)` is a `CallExpr` with callee being a field access -- the pipe prepends `x` to the args. For bare module refs (`x |> List.length`), this would be a field access without a call, which the MIR lowering handles via the `Some(rhs_expr)` branch (bare function ref). However, this needs verification with actual compilation.
**Warning signs:** Compiler error mentioning "expected function, found ..." on pipe RHS

### Pitfall 2: Removing Explicit Case Where `?` Cannot Apply
**What goes wrong:** Trying to use `?` in a function that doesn't return `Result`
**Why it happens:** HTTP handler functions return HTTP responses, not Result types
**How to avoid:** Only use `?` in helper functions with `Result` return types. Keep explicit `case` in pub handler functions where Ok/Err map to different HTTP status codes.
**Warning signs:** Type error: "expected Result, found ..."

### Pitfall 3: Breaking Define-Before-Use Order When Extracting Shared Module
**What goes wrong:** Importing a shared helper module but the import is processed after the helper is used
**Why it happens:** Mesh requires define-before-use; imports are processed in order
**How to avoid:** Place all `from` imports at the top of each file (already the convention)
**Warning signs:** Compiler error: "undefined function ..."

### Pitfall 4: Changing Behavior During "Cosmetic" Refactoring
**What goes wrong:** Accidentally changing logic while reformatting code
**Why it happens:** Temptation to "improve" logic alongside formatting changes
**How to avoid:** Strictly transform syntax only. Keep all SQL queries, error messages, status codes, and JSON field names identical. Diff each file to verify no logic changes.
**Warning signs:** Different JSON output, different HTTP status codes, different error messages

### Pitfall 5: Cross-Module Import of Inferred-Type Functions
**What goes wrong:** Exporting a function with untyped parameters from a shared module
**Why it happens:** `query_or_default(request, ...)` has an inferred type for `request`; cross-module polymorphic type export was fixed in 87.1-02 but may still have edge cases
**How to avoid:** Add explicit type annotations to any shared helper's parameters, or test compilation early
**Warning signs:** Panic or type error during compilation of importing module

## Refactoring Inventory

### Files and Specific Changes

| File | Lines | Changes | Impact |
|------|-------|---------|--------|
| `main.mpl` | 117 | Pipe-chain HTTP router (lines 62-100) | HIGH -- most visible improvement |
| `api/search.mpl` | 307 | Remove json_array_loop/to_json_array (replace with String.join); pipe-chain data transforms | HIGH -- removes ~30 lines |
| `api/dashboard.mpl` | 213 | Remove json_array_loop/to_json_array; pipe-chain data transforms | HIGH -- removes ~30 lines |
| `api/team.mpl` | 266 | Remove json_array_loop/to_json_array; pipe-chain data transforms | HIGH -- removes ~30 lines |
| `api/detail.mpl` | 108 | Minor pipe-chain opportunities | LOW |
| `ingestion/routes.mpl` | 322 | Remove issues_to_json_loop; some pipe-chain transforms | MEDIUM |
| `ingestion/auth.mpl` | 35 | Minimal -- already clean | LOW |
| `ingestion/validation.mpl` | 46 | Minimal -- already clean | LOW |
| `ingestion/fingerprint.mpl` | 87 | Replace fingerprint_frames_loop with for..in + String.join | MEDIUM |
| `ingestion/pipeline.mpl` | 164 | Minor cleanup | LOW |
| `ingestion/ws_handler.mpl` | 150 | Minor pipe opportunities | LOW |
| `services/*.mpl` | ~450 | Minimal -- services are already concise | LOW |
| `storage/queries.mpl` | 457 | Already uses `?` idiomatically -- no changes needed | NONE |
| `storage/writer.mpl` | 21 | No changes needed | NONE |
| `storage/schema.mpl` | 71 | Already uses `?` idiomatically -- no changes needed | NONE |
| `types/*.mpl` | ~120 | No changes needed (struct definitions) | NONE |

### Shared Helper Extraction Candidates

| Helper | Currently In | Copies | Extract To |
|--------|-------------|--------|------------|
| `query_or_default` | search.mpl, dashboard.mpl, team.mpl | 3 | `api/helpers.mpl` (new) |
| `to_json_array` (with String.join) | search.mpl, dashboard.mpl, team.mpl | 3 | `api/helpers.mpl` (new) |
| `json_array_loop` | search.mpl, dashboard.mpl, team.mpl | 3 | DELETE (replaced by String.join) |

### Estimated Line Count Reduction

| Category | Lines Removed | Lines Added | Net |
|----------|--------------|-------------|-----|
| json_array_loop removal (3 copies x ~14 lines) | ~42 | 0 | -42 |
| to_json_array replacement (3 copies -> 1 shared) | ~6 | 3 (shared) | -3 |
| query_or_default dedup (3 copies -> 1 shared) | ~14 | 7 (shared) | -7 |
| HTTP router pipe chain | ~40 | ~40 | 0 (same lines, different style) |
| fingerprint_frames_loop -> for..in | ~10 | 3 | -7 |
| Data transform pipe chains | ~20 | ~10 | -10 |
| **Total** | **~132** | **~63** | **~-69** |

## Known Limitations (Do NOT Try to Fix)

These are known Mesh language limitations that remain after 87.1 fixes. Do NOT attempt to work around them differently during refactoring:

1. **`&&` operator in nested if blocks** -- LLVM PHI node codegen issue. Keep using `both_match` helper (decision [90-01]).

2. **No mutable variable assignment** -- Language design choice. Keep using recursive helper functions or `let` rebinding where needed.

3. **Timer.send_after service dispatch incompatibility** -- Keep using `Timer.sleep` + recursive actor pattern (decision [87-02]).

4. **Cast handler if/else must be in helper functions** -- Parser limitation with branching in cast bodies (decision [90-03]). Keep extracted helpers.

5. **Single-expression case arms** -- Parser limitation. Keep multi-line logic in extracted helper functions (decision [88-02]).

6. **Row structs all-String fields** -- DB text protocol limitation. Keep `::text` casts in SQL.

7. **No closures in HTTP routing** -- Keep PipelineRegistry service pattern (decision [88-03]).

## State of the Art

| Old Approach (Pre-87.1) | Current Idiomatic Approach | When Changed | Impact on Mesher |
|--------------------------|---------------------------|--------------|-----------------|
| Explicit case for every Result | `?` operator for Result propagation | 87.1-01 | ~10 helper functions can use `?` |
| All services in main.mpl | Cross-module service import | 87.1-02 | Already applied in 87.2 |
| Manual recursive loops for JSON arrays | `String.join(list, ",")` | Phase 46 (always available, but not used) | Eliminates ~42 lines of recursive code |
| Sequential let bindings for router | Pipe-chain `\|>` for fluent API calls | Phase 30 (always available, but not used) | Makes router setup readable |
| Nested function calls for transforms | Pipe-chain for data transforms | Phase 30 | Cleaner data serialization |

## Plan Structure Recommendation

### Recommended Plan Breakdown

**Plan 91.1-01: Extract shared helpers and replace json_array_loop with String.join**
- Create `api/helpers.mpl` with shared `query_or_default` and `to_json_array`
- Replace all `json_array_loop`/`to_json_array` copies with `String.join` one-liner
- Update imports in search.mpl, dashboard.mpl, team.mpl
- Remove the `issues_to_json_loop` from routes.mpl
- Verify: `meshc build mesher/` succeeds

**Plan 91.1-02: Pipe-chain HTTP router and data transform pipelines**
- Rewrite main.mpl router setup as pipe chain
- Add pipe chains for List.map -> to_json_array transforms in API handlers
- Replace fingerprint_frames_loop with idiomatic alternative (for..in + String.join)
- Verify: `meshc build mesher/` succeeds

Why two plans instead of one: the first plan changes imports and module structure (higher risk of compilation errors), while the second is purely syntactic transformations within existing files. Separating them allows independent verification.

## Open Questions

1. **Pipe operator with module-qualified bare function refs**
   - What we know: `x |> f` works for bare functions; `x |> f(a, b)` works for calls including module-qualified ones like `x |> HTTP.on_get("/path", handler)`
   - What's unclear: Does `x |> List.length` (bare module-qualified ref, no call parens) work? The MIR lowering's `Some(rhs_expr)` branch treats any non-CallExpr as a bare function ref, and field access IS a valid expression, so it should work.
   - Recommendation: Test early in Plan 02. If it doesn't work, use `x |> List.length()` (empty parens) as a workaround since `x |> f()` -> `f(x)` via the CallExpr branch.

2. **Cross-module export of inferred-type functions**
   - What we know: Polymorphic type export was fixed in 87.1-02 (TyVar normalization)
   - What's unclear: Whether `query_or_default(request, ...)` where `request` is inferred can be exported cleanly
   - Recommendation: If cross-module export fails for inferred types, add explicit type annotations or keep the function duplicated. The String.join refactoring is the main win; deduplication is secondary.

## Sources

### Primary (HIGH confidence)
- `crates/mesh-codegen/src/mir/lower.rs:5856-5899` -- Pipe operator MIR lowering (desugaring rules)
- `crates/mesh-typeck/tests/integration.rs:288-330` -- Pipe operator type checking tests
- `crates/mesh-typeck/src/infer.rs:215-284` -- String module stdlib (String.join at line 260)
- `crates/mesh-typeck/src/infer.rs:341-385` -- List module stdlib (map, filter, reduce)
- `crates/mesh-typeck/src/builtins.rs:289-293` -- Top-level map, filter, reduce builtins
- `tests/e2e/pipe.mpl`, `tests/e2e/pipe_chain_closures.mpl` -- Pipe operator E2E tests
- `tests/e2e/stdlib_string_split_join.mpl` -- String.join E2E test
- `.planning/phases/87.1-issues-encountered/87.1-VERIFICATION.md` -- Verification of ? operator and cross-module fixes
- All 26 Mesher source files -- direct code analysis

### Secondary (MEDIUM confidence)
- `.planning/STATE.md` -- Accumulated decisions about workarounds and language limitations
- `.planning/phases/90-real-time-streaming/90-01-SUMMARY.md` -- `both_match` workaround context

## Metadata

**Confidence breakdown:**
- Pipe operator semantics: HIGH -- verified from compiler source code and E2E tests
- String.join availability: HIGH -- verified from builtins and E2E test
- `?` operator status: HIGH -- fixed in 87.1, verification report confirms
- Cross-module helpers: MEDIUM -- polymorphic export fixed but edge cases possible with inferred types
- Line count estimates: MEDIUM -- based on manual code analysis, actual counts may vary

**Research date:** 2026-02-14
**Valid until:** Indefinite (Mesh language features are stable; this is a Mesh application refactoring)
