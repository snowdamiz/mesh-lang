---
phase: 26-polymorphic-list-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/infer.rs
autonomous: true

must_haves:
  truths:
    - "Parser produces LIST_LITERAL node for `[1, 2, 3]` syntax"
    - "Parser distinguishes list literals (prefix `[`) from index access (postfix `[`)"
    - "Type checker infers `List<Int>` for `[1, 2, 3]` and `List<String>` for `[\"a\", \"b\"]`"
    - "List.append, List.get, List.head accept any element type (polymorphic schemes)"
    - "Existing code using List.new() + List.append() continues to type-check"
  artifacts:
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "LIST_LITERAL SyntaxKind variant"
      contains: "LIST_LITERAL"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "ListLiteral AST node with elements() iterator"
      contains: "ListLiteral"
    - path: "crates/snow-typeck/src/builtins.rs"
      provides: "Polymorphic list function schemes using TyVar(91000)"
      contains: "TyVar(91000)"
  key_links:
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "L_BRACKET prefix match produces LIST_LITERAL"
      pattern: "LIST_LITERAL"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "Expr::ListLiteral variant handled in infer_expr"
      pattern: "ListLiteral"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "List module functions use same polymorphic TyVar range"
      pattern: "TyVar(91000)"
---

<objective>
Add list literal syntax `[expr, ...]` to the parser and make all List type signatures polymorphic in the type checker.

Purpose: This is the foundation for polymorphic List<T>. Without parser support for list literals, users must build lists via List.new() + List.append(). Without polymorphic type signatures, list functions are locked to Int elements.

Output: LIST_LITERAL parsed and type-inferred for any element type; all List module functions accept polymorphic elements. Compiler builds and all existing tests pass.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-polymorphic-list-foundation/26-RESEARCH.md
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/parser/expressions.rs
@crates/snow-parser/src/ast/expr.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LIST_LITERAL to parser (syntax kind, parser, AST node)</name>
  <files>
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/parser/expressions.rs
    crates/snow-parser/src/ast/expr.rs
  </files>
  <action>
**syntax_kind.rs:**
Add `LIST_LITERAL` as a new composite node kind in the `SyntaxKind` enum, placed near `MAP_LITERAL` (after `MAP_ENTRY`). Also add it to the `syntax_kind_has_enough_variants` test array.

**expressions.rs:**
Replace the comment at line 235 (`// L_BRACKET for list literals could go here in the future.`) with the list literal parsing code. This goes in the atom/prefix match (NUD position), so there is NO ambiguity with index access (which is postfix/LED):

```rust
SyntaxKind::L_BRACKET => {
    let m = p.open();
    p.advance(); // consume [
    if p.current() != SyntaxKind::R_BRACKET {
        expr_bp(p, 0);
        while p.current() == SyntaxKind::COMMA {
            p.advance(); // consume ,
            if p.current() == SyntaxKind::R_BRACKET {
                break; // trailing comma
            }
            expr_bp(p, 0);
        }
    }
    p.expect(SyntaxKind::R_BRACKET);
    Some(p.close(m, SyntaxKind::LIST_LITERAL))
}
```

**ast/expr.rs:**
1. Add `ListLiteral(ListLiteral)` variant to the `Expr` enum (near MapLiteral).
2. Add `SyntaxKind::LIST_LITERAL => Some(Expr::ListLiteral(ListLiteral { syntax: node }))` to `Expr::cast()`.
3. Add `Expr::ListLiteral(n) => &n.syntax` to `Expr::syntax()`.
4. Add the AST node definition after MapLiteral:

```rust
ast_node!(ListLiteral, LIST_LITERAL);

impl ListLiteral {
    /// The element expressions in the list literal.
    pub fn elements(&self) -> impl Iterator<Item = Expr> + '_ {
        self.syntax.children().filter_map(Expr::cast)
    }
}
```
  </action>
  <verify>
Run `cargo build -p snow-parser` to confirm the parser crate compiles. Run `cargo test -p snow-parser` to confirm all existing parser tests pass and the new LIST_LITERAL kind is recognized.
  </verify>
  <done>
`[1, 2, 3]` parses as a LIST_LITERAL node with three LITERAL children. `[]` parses as empty LIST_LITERAL. `list[0]` still parses as INDEX_EXPR (no regression). All existing parser tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make list functions polymorphic in type checker</name>
  <files>
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/infer.rs
  </files>
  <action>
**builtins.rs -- Polymorphic list function registration:**

Replace the monomorphic list function registrations (lines ~250-343) with polymorphic versions using type variables. Use `TyVar(91000)` for T and `TyVar(91001)` for U (avoids collision with Map's 90000/90001 and Default's 99000).

Change `list_t` from `Ty::list_untyped()` to `Ty::list(t.clone())` where `t = Ty::Var(TyVar(91000))`.

The key changes:
- `list_new`: `() -> List<T>` (polymorphic, Scheme with vars: [t_var])
- `list_append`: `(List<T>, T) -> List<T>` (was `(List, Int) -> List`)
- `list_get`: `(List<T>, Int) -> T` (was `(List, Int) -> Int`)
- `list_head`: `(List<T>) -> T` (was `(List) -> Int`)
- `list_tail`: `(List<T>) -> List<T>` (was `(List) -> List`)
- `list_length`: `(List<T>) -> Int` (was `(List) -> Int`)
- `list_concat`: `(List<T>, List<T>) -> List<T>` (was `(List, List) -> List`)
- `list_reverse`: `(List<T>) -> List<T>` (was `(List) -> List`)
- `list_map`: `(List<T>, (T) -> U) -> List<U>` (was `(List, (Int) -> Int) -> List`)
- `list_filter`: `(List<T>, (T) -> Bool) -> List<T>` (was `(List, (Int) -> Bool) -> List`)
- `list_reduce`: `(List<T>, U, (U, T) -> U) -> U` (was `(List, Int, (Int,Int) -> Int) -> Int`)

Also update bare prelude names (`map`, `filter`, `reduce`, `head`, `tail`) to use the same polymorphic schemes.

Keep `list_t` used in `map_keys` and `map_values` return types as `Ty::list_untyped()` to avoid breaking Map -- or better, use `Ty::list(k.clone())` for keys and `Ty::list(v.clone())` for values since those are inside the Map block that already has k_var/v_var.

**infer.rs -- List module polymorphic signatures:**

Find the List module section (lines ~311-328) and replace monomorphic Scheme::mono entries with polymorphic schemes. Introduce the same type variables:

```rust
let t_var = TyVar(91000);
let u_var = TyVar(91001);
let t = Ty::Var(t_var);
let u = Ty::Var(u_var);
let list_t = Ty::list(t.clone());
let list_u = Ty::list(u.clone());
```

Then replace each `list_mod.insert(...)` with the polymorphic version matching builtins.rs.

**infer.rs -- ListLiteral type inference:**

Add `Expr::ListLiteral(lit)` handling in the main `infer_expr` match. Follow the pattern of `infer_map_literal`:

1. Import `ListLiteral` in the use statement at the top (add to the `snow_parser::ast::expr` import).
2. In the main match in `infer_expr`, add before `Expr::IndexExpr`:

```rust
Expr::ListLiteral(lit) => {
    infer_list_literal(ctx, env, &lit, types, type_registry, trait_registry, fn_constraints)?
}
```

3. Add `infer_list_literal` function near `infer_map_literal`:

```rust
fn infer_list_literal(
    ctx: &mut InferCtx,
    env: &mut TypeEnv,
    lit: &ListLiteral,
    types: &mut FxHashMap<TextRange, Ty>,
    type_registry: &TypeRegistry,
    trait_registry: &TraitRegistry,
    fn_constraints: &FxHashMap<String, FnConstraints>,
) -> Result<Ty, TypeError> {
    let elem_ty = ctx.fresh_var();
    for elem in lit.elements() {
        let t = infer_expr(ctx, env, &elem, types, type_registry, trait_registry, fn_constraints)?;
        ctx.unify(t, elem_ty.clone(), UnifyOrigin::ListLiteral)?;
    }
    let resolved = ctx.resolve(elem_ty);
    let result_ty = Ty::list(resolved);
    types.insert(lit.syntax().text_range(), result_ty.clone());
    Ok(result_ty)
}
```

If `UnifyOrigin` doesn't have a `ListLiteral` variant, use `UnifyOrigin::Expr` or whatever the general-purpose variant is. Check the `UnifyOrigin` enum to find the appropriate variant.
  </action>
  <verify>
Run `cargo build -p snow-typeck` to confirm the typeck crate compiles. Run `cargo test -p snow-typeck` to confirm all existing typeck tests pass. Run `cargo build` (full workspace) to confirm nothing breaks downstream.
  </verify>
  <done>
List functions are registered with polymorphic type schemes. `List.append(my_list, "hello")` type-checks as `List<String>`. `[1, 2, 3]` infers as `List<Int>`. `["a", "b"]` infers as `List<String>`. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-parser` -- all parser tests pass, LIST_LITERAL kind exists
2. `cargo test -p snow-typeck` -- all typeck tests pass, polymorphic list schemes work
3. `cargo build` -- full workspace builds without errors
4. `cargo test` -- all 1,206+ tests pass (backward compatibility)
</verification>

<success_criteria>
- LIST_LITERAL is a recognized SyntaxKind and AST node
- `[expr, expr, ...]` parses correctly in prefix position
- `list[i]` (index access) still parses correctly in postfix position
- All list function types are polymorphic (not hardcoded to Int)
- List literal type inference produces Ty::list(elem_type)
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/26-polymorphic-list-foundation/26-01-SUMMARY.md`
</output>
