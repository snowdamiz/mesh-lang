---
phase: 26-polymorphic-list-foundation
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/codegen/expr.rs
autonomous: true

must_haves:
  truths:
    - "`[1, 2, 3]` compiles and runs, producing a List<Int> with elements 1, 2, 3"
    - "`[\"hello\", \"world\"]` compiles and runs, producing a List<String>"
    - "`[true, false]` compiles and runs, producing a List<Bool>"
    - "List.get on a List<String> returns a String (not garbage/segfault)"
    - "List.append on a List<Bool> accepts a Bool value"
    - "`[1, 2] ++ [3, 4]` produces `[1, 2, 3, 4]` (list concatenation, not string concat)"
    - "`[[1, 2], [3, 4]]` compiles as List<List<Int>> and nested access works"
    - "Existing programs using List<Int> with List.new()/List.append() continue to work"
  artifacts:
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "List literal lowering to snow_list_from_array calls"
      contains: "lower_list_literal"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "ListLit codegen with type-aware value conversion"
      contains: "ListLit"
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "ListLit MirExpr variant"
      contains: "ListLit"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/codegen/expr.rs"
      via: "MirExpr::ListLit variant lowered in MIR, codegen-ed in LLVM"
      pattern: "ListLit"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "snow-rt snow_list_from_array"
      via: "Codegen emits call to snow_list_from_array for list literals"
      pattern: "snow_list_from_array"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "snow-rt snow_list_concat"
      via: "BinOp::Concat dispatches to snow_list_concat for list operands"
      pattern: "snow_list_concat"
---

<objective>
Lower list literals to MIR and LLVM, handle polymorphic list operations in codegen, and support list concatenation via `++`.

Purpose: Plan 01 added parsing and type checking. This plan makes list literals and polymorphic list operations actually compile to working native code. This completes all five LIST requirements (LIST-01 through LIST-05).

Output: End-to-end list literal compilation for Int, String, Bool, struct, and nested list element types. `++` operator works for list concatenation. All tests pass.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-polymorphic-list-foundation/26-RESEARCH.md
@.planning/phases/26-polymorphic-list-foundation/26-01-SUMMARY.md
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/mir/mod.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ListLit to MIR and lower list literals</name>
  <files>
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**mir/mod.rs -- Add ListLit variant:**

Add a new MirExpr variant for list literals:

```rust
/// List literal: [e1, e2, ...]
ListLit {
    elements: Vec<MirExpr>,
    ty: MirType,
},
```

Add it near the existing expression variants. Also add the `.ty()` match arm:
```rust
MirExpr::ListLit { ty, .. } => ty,
```

**mir/lower.rs -- Import ListLiteral and lower it:**

1. Add `ListLiteral` to the import from `snow_parser::ast::expr` (line ~12).

2. Add `Expr::ListLiteral(lit) => self.lower_list_literal(&lit)` to the main `lower_expr` match (line ~3054, near MapLiteral).

3. Add the `lower_list_literal` method (near `lower_map_literal`):

```rust
/// Lower a list literal `[e1, e2, ...]` to MIR.
///
/// For empty lists: calls snow_list_new().
/// For non-empty lists: creates a MirExpr::ListLit with lowered elements.
/// The codegen will stack-allocate an array, store elements, and call
/// snow_list_from_array(arr_ptr, count).
fn lower_list_literal(&mut self, lit: &ListLiteral) -> MirExpr {
    let elements: Vec<MirExpr> = lit.elements()
        .map(|e| self.lower_expr(&e))
        .collect();

    if elements.is_empty() {
        // Empty list: call snow_list_new()
        let fn_ty = MirType::FnPtr(vec![], Box::new(MirType::Ptr));
        return MirExpr::Call {
            func: Box::new(MirExpr::Var("snow_list_new".to_string(), fn_ty)),
            args: vec![],
            ty: MirType::Ptr,
        };
    }

    MirExpr::ListLit {
        elements,
        ty: MirType::Ptr,
    }
}
```

4. **Update known_functions for polymorphic return types:**

Change the known_functions entries for list operations that return element values. The key changes:
- `snow_list_append`: Change second param from `MirType::Int` to `MirType::Int` (keep as-is -- the runtime accepts u64 for all types, and at MIR level we pass Int/Ptr which are both 8 bytes)
- `snow_list_head`: Change return type from `Box::new(MirType::Int)` to `Box::new(MirType::Ptr)` -- the actual type is determined by typeck, and Ptr is safe for all types at LLVM level
- `snow_list_get`: Change return type from `Box::new(MirType::Int)` to `Box::new(MirType::Ptr)` -- same reasoning
- `snow_list_reduce`: Change init param from `MirType::Int` to `MirType::Int` and return from `Box::new(MirType::Int)` to `Box::new(MirType::Ptr)` -- to support non-Int accumulators

IMPORTANT: The `snow_list_append` input element type stays as `MirType::Int` because at the LLVM level, all values are passed as i64 (Int is i64, Ptr is also i64-sized, Bool is zero-extended to i64, Float is bitcast to i64). The runtime's `snow_list_append(list: *mut u8, element: u64)` accepts all types as u64. However, for the codegen to know the call is "known" (direct call, not closure call), it just needs the right arity.

Actually, it is safer to leave the MIR signatures mostly unchanged except for return types. The critical change is: when codegen resolves the result of `snow_list_get` or `snow_list_head`, it must use the typeck-resolved type (not the known_functions return type) to determine the LLVM type for the result. This is handled in Task 2.
  </action>
  <verify>
Run `cargo build -p snow-codegen` to confirm the codegen crate compiles with the new ListLit variant and lower_list_literal method. Run `cargo test -p snow-codegen` to confirm all existing codegen tests pass.
  </verify>
  <done>
ListLit is a valid MirExpr variant. List literals lower to ListLit (non-empty) or snow_list_new call (empty). MIR known_functions return types updated for polymorphic list operations. Codegen crate builds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Codegen for list literals, polymorphic value conversion, and list ++</name>
  <files>
    crates/snow-codegen/src/codegen/expr.rs
  </files>
  <action>
**codegen/expr.rs -- Handle MirExpr::ListLit:**

Add a match arm for `MirExpr::ListLit { elements, .. }` in the main `codegen_expr` function. The codegen should:

1. Stack-allocate an array of i64 values with size = elements.len()
2. For each element, codegen the element expression and store it to the array slot. Apply type conversion:
   - Bool (i8): zero-extend to i64 before storing
   - Float (f64): bitcast to i64 before storing
   - Ptr: ptr-to-int cast to i64 before storing
   - Int: store directly (already i64)
3. Call `snow_list_from_array(array_ptr, count)` which takes a `*const u64` and length.

Implementation pattern:
```
let i64_type = self.context.i64_type();
let array_type = i64_type.array_type(elements.len() as u32);
let array_alloca = self.builder.build_alloca(array_type, "list_arr");

for (i, elem) in elements.iter().enumerate() {
    let val = self.codegen_expr(elem)?;
    let val_as_i64 = convert_to_i64(val, elem.ty());  // handle Bool/Float/Ptr
    let gep = self.builder.build_struct_gep(array_type, array_alloca, i as u32, "elem_ptr");
    // OR use GEP with indices [0, i]
    self.builder.build_store(gep, val_as_i64);
}

let array_ptr = self.builder.build_pointer_cast(array_alloca, ptr_type, "arr_ptr");
let count = i64_type.const_int(elements.len() as u64, false);
let from_array_fn = get_intrinsic(&self.module, "snow_list_from_array");
let result = self.builder.build_call(from_array_fn, &[array_ptr.into(), count.into()], "list");
```

For the element-to-i64 conversion, create a helper or inline:
- Check `elem.ty()` (MirType): if Bool, `build_int_z_extend` to i64; if Float, `build_bitcast` to i64; if Ptr, `build_ptr_to_int` to i64; if Int, use directly.

**codegen/expr.rs -- Polymorphic list_get/list_head result conversion:**

When codegen encounters a call to `snow_list_get` or `snow_list_head`, the runtime returns `u64` (i64 at LLVM level). But the actual result type may be String (Ptr), Bool (i8), Float (f64), or a struct (Ptr). The codegen must convert the i64 result back to the correct LLVM type.

Find where `snow_list_get` and `snow_list_head` call results are handled. After the call, check the expected MirType of the expression (from the `ty` field of the MirExpr::Call). If the ty is:
- `MirType::Ptr` or `MirType::String`: `build_int_to_ptr` from i64 to ptr
- `MirType::Bool`: `build_int_truncate` from i64 to i8
- `MirType::Float`: `build_bitcast` from i64 to f64
- `MirType::Int`: no conversion needed

The best place to handle this is after any call to a `snow_list_get` or `snow_list_head` function. Check the function name and if the call ty suggests a non-Int result, apply the conversion.

**codegen/expr.rs -- `++` operator for list concatenation:**

Currently, `BinOp::Concat` unconditionally calls `codegen_string_concat`. Modify this to check the operand type first.

In the binop handler (around line 235):
```rust
if matches!(op, BinOp::Concat) {
    // Check if operands are lists (MirType::Ptr from List type)
    // vs strings (MirType::String)
    if matches!(lhs_ty, MirType::Ptr) {
        return self.codegen_list_concat(lhs_val, rhs_val);
    }
    return self.codegen_string_concat(lhs_val, rhs_val);
}
```

Add `codegen_list_concat` method:
```rust
fn codegen_list_concat(
    &mut self,
    lhs: BasicValueEnum<'ctx>,
    rhs: BasicValueEnum<'ctx>,
) -> Result<BasicValueEnum<'ctx>, String> {
    let concat_fn = get_intrinsic(&self.module, "snow_list_concat");
    let result = self.builder
        .build_call(concat_fn, &[lhs.into(), rhs.into()], "list_concat")
        .map_err(|e| e.to_string())?;
    result.try_as_basic_value().basic()
        .ok_or_else(|| "snow_list_concat returned void".to_string())
}
```

Note: MirType::Ptr covers all collection types (List, Map, Set). Since `++` is only defined for String and List in Snow, and Map/Set are MirType::Ptr too, we need to be careful. The type checker enforces that `++` only applies to String or List, so at codegen level if the type is `Ptr`, it must be a List (the only Ptr type that supports `++`). This is safe.

**codegen/expr.rs -- Bool/Float storage in list_append:**

When `snow_list_append` is called with a Bool or Float element, the element must be converted to i64 first. Find where list_append calls are generated and ensure:
- Bool args are zero-extended from i8 to i64
- Float args are bitcast from f64 to i64

This may already be handled if the MIR lowering coerces types, but verify. If the codegen passes values through to runtime calls without conversion, add conversion logic in the call site for `snow_list_append`.

**End-to-end test files:**

After all codegen changes, create integration tests as Snow source files. Write a test Snow program that exercises:
1. `let xs = [1, 2, 3]` -- List<Int> literal
2. `let ss = ["hello", "world"]` -- List<String> literal
3. `let bs = [true, false, true]` -- List<Bool> literal
4. `let nested = [[1, 2], [3, 4]]` -- List<List<Int>>
5. `List.get(xs, 0)` returning Int
6. `List.get(ss, 0)` returning String
7. `List.append(ss, "new")` returning List<String>
8. `xs ++ [4, 5]` producing `[1, 2, 3, 4, 5]`
9. Existing `List.new() |> List.append(1)` still works

Place test as `tests/integration/list_polymorphic.snow` or in the appropriate test directory following existing patterns.
  </action>
  <verify>
1. `cargo build` -- full workspace builds
2. `cargo test` -- all existing 1,206+ tests pass
3. Create and compile a test Snow program with `[1, 2, 3]`, `["a", "b"]`, `[true, false]`, `[[1, 2], [3, 4]]` -- all compile and run correctly
4. Verify `[1, 2] ++ [3, 4]` produces correct list concatenation
5. Verify `List.get(["hello", "world"], 0)` returns "hello" (not garbage)
  </verify>
  <done>
List literals compile to native code for all element types (Int, String, Bool, structs, nested lists). `++` operator works for list concatenation. List.get/List.head return correctly-typed values for non-Int element types. All existing tests pass. New integration test validates polymorphic list behavior end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` -- all 1,206+ existing tests pass (backward compatibility verified)
2. Compile and run: `let xs = [1, 2, 3]; println(to_string(xs))` prints `[1, 2, 3]`
3. Compile and run: `let ss = ["hello", "world"]; println(to_string(List.get(ss, 0)))` prints `hello`
4. Compile and run: `let bs = [true, false]; println(to_string(List.get(bs, 0)))` prints `true`
5. Compile and run: `let nested = [[1, 2], [3, 4]]; println(to_string(List.get(nested, 0)))` prints `[1, 2]`
6. Compile and run: `let combined = [1, 2] ++ [3, 4]; println(to_string(combined))` prints `[1, 2, 3, 4]`
7. Existing programs using `List.new() |> List.append(42)` compile and run unchanged
</verification>

<success_criteria>
- [1, 2, 3] compiles as List<Int> and runs correctly (LIST-01)
- ["hello", "world"] compiles as List<String> with working access/append (LIST-02)
- [true, false] compiles as List<Bool> (LIST-03)
- [[1, 2], [3, 4]] compiles as List<List<Int>> with nested access (LIST-05)
- ++ operator works for list concatenation
- Bool/Float values stored/retrieved correctly (zero-extend/truncate/bitcast)
- All 1,206+ existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/26-polymorphic-list-foundation/26-02-SUMMARY.md`
</output>
