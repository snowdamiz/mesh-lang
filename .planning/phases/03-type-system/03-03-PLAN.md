---
phase: 03-type-system
plan: 03
type: tdd
wave: 3
depends_on: ["03-02"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/ty.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/src/env.rs
  - crates/snow-typeck/tests/structs.rs
autonomous: true

must_haves:
  truths:
    - "Struct types with annotated fields can be defined and their fields accessed with full inference"
    - "Struct literals type-check against their definition, inferring generic type parameters"
    - "Option<T> is built-in with Int? sugar working in type annotations"
    - "Result<T, E> is built-in with T!E sugar working in type annotations"
    - "Type aliases resolve transparently during inference"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Struct, Option, Result inference + field access + type alias resolution"
      contains: "fn infer_struct_literal"
    - path: "crates/snow-typeck/tests/structs.rs"
      provides: "Integration tests for struct, Option, Result, and type alias inference"
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "Option and Result constructors registered as built-in generic types"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/item.rs"
      via: "Reads StructDef fields and TypeAliasDef for type resolution"
---

<objective>
Struct types, Option<T>, Result<T, E>, and type aliases integrated into the inference engine.

Purpose: Struct types are needed for any real program. Option and Result are THE error-handling story for Snow -- they must be built-in with deep compiler awareness (Int? sugar, T!E sugar, specialized error messages). Type aliases provide convenience and readability.

Output: Working struct inference with field access, built-in Option/Result with sugar syntax, type alias resolution.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-system/03-CONTEXT.md
@.planning/phases/03-type-system/03-RESEARCH.md
@.planning/phases/03-type-system/03-01-SUMMARY.md
@.planning/phases/03-type-system/03-02-SUMMARY.md
@crates/snow-typeck/src/ty.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-typeck/src/env.rs
@crates/snow-parser/src/ast/item.rs
@crates/snow-parser/src/ast/expr.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for structs, Option, Result, and type aliases</name>
  <files>
    crates/snow-typeck/tests/structs.rs
  </files>
  <action>
    Create integration test file `crates/snow-typeck/tests/structs.rs` with test cases (RED phase):

    **Struct tests:**
    1. `test_struct_definition_and_literal`: Parse `struct Point do x: Int, y: Int end\nlet p = Point { x: 1, y: 2 }`, check `p` is `Point`.
    2. `test_struct_field_access`: Parse `struct Point do x: Int, y: Int end\nlet p = Point { x: 1, y: 2 }\np.x`, check result is `Int`.
    3. `test_generic_struct`: Parse `struct Pair<A, B> do first: A, second: B end\nlet p = Pair { first: 1, second: "hello" }`, check `p` is `Pair<Int, String>`.
    4. `test_generic_struct_field_access`: Using `Pair` from above, check `p.first` is `Int` and `p.second` is `String`.
    5. `test_struct_wrong_field_type`: Parse `struct Point do x: Int, y: Int end\nPoint { x: "bad", y: 2 }`, check for type mismatch error.
    6. `test_struct_missing_field`: Parse `struct Point do x: Int, y: Int end\nPoint { x: 1 }`, check for missing field error.

    **Option tests:**
    7. `test_option_some_inference`: Parse `let x: Option<Int> = Some(42)`, check `x` is `Option<Int>`. (Note: Some/None need to be recognized as constructors -- register in builtins.)
    8. `test_option_none_inference`: Parse `let x: Option<Int> = None`, check `x` is `Option<Int>`.
    9. `test_option_sugar_annotation`: Parse `let x: Int? = Some(42)`, check `x` is `Option<Int>` (Int? desugars to Option<Int>).
    10. `test_option_generic_propagation`: Parse `fn wrap<T>(x: T) -> Option<T> do Some(x) end\nwrap(42)`, check result is `Option<Int>`.

    **Result tests:**
    11. `test_result_ok_inference`: Parse `let x: Result<Int, String> = Ok(42)`, check `x` is `Result<Int, String>`.
    12. `test_result_err_inference`: Parse `let x: Result<Int, String> = Err("bad")`, check `x` is `Result<Int, String>`.
    13. `test_result_sugar_annotation`: Parse `let x: Int!String = Ok(42)`, check `x` is `Result<Int, String>` (T!E desugars to Result<T, E>).

    **Type alias tests:**
    14. `test_type_alias_simple`: Parse `type Name = String\nlet x: Name = "hello"`, check `x` is `String`.
    15. `test_type_alias_generic`: Parse `type Pair<A, B> = (A, B)\nlet x: Pair<Int, String> = (1, "hello")`, check it type-checks.

    Run tests -- all MUST fail (RED).
  </action>
  <verify>
    `cargo test -p snow-typeck` compiles but all 15 struct/option/result/alias tests fail (RED).
  </verify>
  <done>
    15 test cases exist for struct definitions, field access, generic structs, Option with sugar, Result with sugar, and type aliases. All fail.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement struct, Option/Result, and type alias inference</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/ty.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/env.rs
  </files>
  <action>
    Implement the inference support to pass all 15 tests (GREEN phase).

    **Type registry (new concept, add to env.rs or a new registry.rs):**
    1. Create a `TypeRegistry` that stores struct definitions, type constructors, and type aliases. Fields: `struct_defs: HashMap<String, StructDef>`, `type_aliases: HashMap<String, TypeAlias>`, `constructors: HashMap<String, ConstructorInfo>`.
    2. `StructDef` stores: name, generic params, field names with types. Example: `Point { generics: [], fields: { "x": Int, "y": Int } }`.
    3. `TypeAlias` stores: name, generic params, aliased type.
    4. `ConstructorInfo` stores: which type it constructs, and its function signature. For `Some(x)`: constructs `Option<T>`, signature `(T) -> Option<T>`. For `None`: constructs `Option<T>`, signature `() -> Option<T>` (or a value, not a function). For `Ok(x)`: `(T) -> Result<T, E>`. For `Err(e)`: `(E) -> Result<T, E>`.

    **Built-in Option/Result registration (builtins.rs):**
    1. Register `Option` as a generic type constructor with arity 1.
    2. Register `Result` as a generic type constructor with arity 2.
    3. Register `Some` as a constructor: `forall T. T -> Option<T>` (a polymorphic function in the type environment).
    4. Register `None` as a constructor: `forall T. Option<T>` (a polymorphic value -- scheme with one free var).
    5. Register `Ok` as a constructor: `forall T E. T -> Result<T, E>`.
    6. Register `Err` as a constructor: `forall T E. E -> Result<T, E>`.

    **Struct inference (infer.rs):**
    1. When encountering a `StructDef` item during AST walk: register the struct in the TypeRegistry. For generic structs, store the generic param names.
    2. When encountering a `StructLiteral` expression: look up the struct name in the registry. For generic structs, create fresh type vars for each generic param. For each field in the literal, infer the field value's type and unify with the struct field's declared type (with generic vars substituted). Return `Ty::App(struct_tycon, [instantiated_generic_args])` for generic structs, or `Ty::Con(struct_tycon)` for non-generic.
    3. When encountering a `FieldAccess` expression: infer the base expression's type. Look up the resolved type in the struct registry. Find the field's type in the struct definition. For generic structs, substitute the generic args. Return the field's type.
    4. Add error variants: `UnknownStruct { name, span }`, `UnknownField { struct_name, field_name, span }`, `MissingField { struct_name, field_name, span }`.

    **Type annotation resolution (infer.rs):**
    1. When a type annotation is present (e.g., `let x: Int = ...`), resolve the annotation to a `Ty`. Handle:
       - Simple names: look up in type registry (`Int` -> `Ty::Con(Int)`)
       - Generic application: `Option<Int>` -> `Ty::App(Option, [Int])`
       - Option sugar: `Int?` -> `Ty::App(Option, [Int])`
       - Result sugar: `Int!String` -> `Ty::App(Result, [Int, String])`
       - Qualified paths: `Module.Type` -> look up (defer full module resolution, just handle simple cases)
       - Type alias: look up in alias registry, substitute generic args if any
    2. The parser already produces the CST structure for these (from plan 03-01). The inference engine reads the CST nodes and resolves them to `Ty` values.

    **Type alias resolution:**
    1. When encountering a `TypeAliasDef` item: register in the TypeRegistry as `name -> (generic_params, aliased_type)`.
    2. When resolving a type name that matches an alias: substitute the alias body with provided generic args.
    3. Aliases are transparent -- `type Name = String` means `Name` and `String` are the same type for unification purposes.

    Run `cargo test -p snow-typeck` -- all 15 struct tests pass, plus all 16 prior inference tests still pass (GREEN).
  </action>
  <verify>
    `cargo test -p snow-typeck` passes all tests (15 struct/option/result + 16 inference = 31 total).
    `cargo test --workspace` passes.
  </verify>
  <done>
    Struct types with generic params can be defined and instantiated. Field access type-checks with generic substitution. Option and Result are built-in with Some/None/Ok/Err constructors and Int?/T!E sugar. Type aliases resolve transparently. All 31 tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` passes all tests.
2. `struct Point do x: Int, y: Int end` followed by `Point { x: 1, y: 2 }.x` infers as `Int`.
3. Generic structs correctly propagate type parameters.
4. `Some(42)` infers as `Option<Int>`, `None` requires annotation context.
5. `Ok(42)` and `Err("bad")` infer correctly with Result.
6. `Int?` resolves to `Option<Int>`, `Int!String` resolves to `Result<Int, String>`.
7. Type aliases are transparent.
</verification>

<success_criteria>
- Struct definitions, literals, and field access work with full inference.
- Generic structs propagate type parameters correctly.
- Option<T> and Result<T, E> are built-in with constructor inference.
- Sugar syntax (Int?, T!E) works in type annotations.
- Type aliases resolve transparently.
- All tests pass (struct + prior inference tests).
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-system/03-03-SUMMARY.md`
</output>
