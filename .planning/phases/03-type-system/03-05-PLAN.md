---
phase: 03-type-system
plan: 05
type: execute
wave: 4
depends_on: ["03-03", "03-04"]
files_modified:
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/lib.rs
  - crates/snow-typeck/tests/diagnostics.rs
  - crates/snow-typeck/tests/integration.rs
autonomous: true

must_haves:
  truths:
    - "Type errors include the source location of the conflict and the inferred types involved"
    - "Error messages show expected vs found types with labeled source spans"
    - "Fix suggestions are provided when a plausible fix exists"
    - "All 5 success criteria from the phase roadmap pass in end-to-end tests"
  artifacts:
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "ariadne-based error rendering with multi-span labels and fix suggestions"
      contains: "fn render_diagnostic"
    - path: "crates/snow-typeck/tests/diagnostics.rs"
      provides: "Snapshot tests for error message formatting"
    - path: "crates/snow-typeck/tests/integration.rs"
      provides: "End-to-end tests covering all 5 phase success criteria"
  key_links:
    - from: "crates/snow-typeck/src/diagnostics.rs"
      to: "crates/snow-typeck/src/error.rs"
      via: "Renders TypeError variants into ariadne Reports"
    - from: "crates/snow-typeck/src/diagnostics.rs"
      to: "ariadne"
      via: "Uses Report::build, Label, Source for diagnostic output"
---

<objective>
Type error reporting with ariadne diagnostics and comprehensive end-to-end phase verification.

Purpose: Error messages are how users experience the type system. The locked decision requires Elm-level thoroughness with Go-minimal tone -- concise messages showing both sides of conflicts with fix suggestions. This plan also runs the definitive end-to-end tests for all 5 phase success criteria.

Output: ariadne-based diagnostic renderer, snapshot-tested error messages, and passing end-to-end tests for the entire type system phase.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-system/03-CONTEXT.md
@.planning/phases/03-type-system/03-RESEARCH.md
@.planning/phases/03-type-system/03-01-SUMMARY.md
@.planning/phases/03-type-system/03-02-SUMMARY.md
@.planning/phases/03-type-system/03-03-SUMMARY.md
@.planning/phases/03-type-system/03-04-SUMMARY.md
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/ty.rs
@crates/snow-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ariadne diagnostic renderer with fix suggestions</name>
  <files>
    crates/snow-typeck/Cargo.toml
    crates/snow-typeck/src/diagnostics.rs
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/lib.rs
  </files>
  <action>
    **Add ariadne dependency:**
    1. Add `ariadne = "0.6"` to `crates/snow-typeck/Cargo.toml` dependencies.

    **diagnostics.rs -- Error rendering:**
    1. Define `pub fn render_diagnostic(error: &TypeError, source: &str, filename: &str) -> String`: renders a `TypeError` into a formatted string using ariadne. Returns the rendered string (not printed directly) so it can be captured in tests.

    2. For each `TypeError` variant, produce a targeted diagnostic:

       **Mismatch { expected, found, origin }:**
       - Message: `"expected {expected}, found {found}"` (terse one-liner)
       - Label on expected span: `"expected {expected}"` (Color::Red)
       - Label on found span: `"found {found}"` (Color::Blue)
       - Help/fix suggestion based on types:
         - If expected is `Option<T>` and found is `T`: suggest "wrap in Some(...)"
         - If expected is `Result<T, E>` and found is `T`: suggest "wrap in Ok(...)"
         - If expected is `Int` and found is `Float`: suggest "use Int conversion"
         - If expected is `String` and found is `Int`: suggest "use to_string()"

       **InfiniteType { var, ty, origin }:**
       - Message: `"infinite type: {var} occurs in {ty}"`
       - Label on the expression span
       - Help: "a value cannot have a type that refers to itself"

       **ArityMismatch { expected, found, origin }:**
       - Message: `"expected {expected} argument(s), found {found}"`
       - Label on call site
       - Help: if expected > found, "missing {diff} argument(s)"

       **UnboundVariable { name, span }:**
       - Message: `"undefined variable: {name}"`
       - Label on the span
       - Help: attempt fuzzy match against known names in scope (Levenshtein distance <= 2). If match found: "did you mean `{suggestion}`?"

       **NotAFunction { ty, span }:**
       - Message: `"type {ty} is not callable"`
       - Label on the expression being called

       **TraitNotSatisfied { trait_name, ty, span }:**
       - Message: `"{ty} does not implement {trait_name}"`
       - Label on span
       - Help: "add `impl {trait_name} for {ty} do ... end`"

       **MissingTraitMethod { trait_name, method_name, span }:**
       - Message: `"missing method {method_name} in impl {trait_name}"`
       - Help: "add `fn {method_name}(...) do ... end` to the impl block"

       **MissingField { struct_name, field_name, span }:**
       - Message: `"missing field {field_name} in {struct_name}"`
       - Help: "add `{field_name}: <value>` to the struct literal"

       **UnknownField { struct_name, field_name, span }:**
       - Message: `"{struct_name} has no field {field_name}"`
       - Help: fuzzy match against known fields

    3. Use ariadne `ReportKind::Error` for all type errors. Use error codes: E0001 (Mismatch), E0002 (InfiniteType), E0003 (ArityMismatch), E0004 (UnboundVariable), E0005 (NotAFunction), E0006 (TraitNotSatisfied), E0007 (MissingTraitMethod), E0008 (MissingField), E0009 (UnknownField).

    4. The rendering writes to a `Vec<u8>` buffer (using `ariadne::Report::write` instead of `print`), then converts to String. This enables testing.

    **Update lib.rs:**
    1. Add `pub mod diagnostics;`
    2. Add a convenience method `TypeckResult::render_errors(&self, source: &str, filename: &str) -> Vec<String>` that renders all errors.

    **Error message tone (per locked decision):**
    - Terse. No conversational framing ("I found that..." or "It seems like...").
    - Show the conflict: "expected Int, found String".
    - Show both locations with labeled spans.
    - Suggest fix when plausible: "wrap in Some(...)" not "you might want to wrap...".
    - One-liner message, multi-span labels, optional help line. That's it.
  </action>
  <verify>
    `cargo build -p snow-typeck` compiles with ariadne integration.
    Diagnostic renderer produces output for all TypeError variants.
  </verify>
  <done>
    ariadne-based diagnostic renderer produces terse, labeled error messages for all TypeError variants with fix suggestions. Error codes assigned. Rendering captured as strings for testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Snapshot tests for error messages and end-to-end phase verification</name>
  <files>
    crates/snow-typeck/tests/diagnostics.rs
    crates/snow-typeck/tests/integration.rs
  </files>
  <action>
    **Diagnostic snapshot tests (tests/diagnostics.rs):**
    Create snapshot tests using insta for every error type. Each test parses a Snow program that produces a specific error, renders the diagnostic, and snapshots the output.

    1. `test_diag_type_mismatch`: `let x: Int = "hello"` -> snapshot the "expected Int, found String" diagnostic.
    2. `test_diag_infinite_type`: `fn (x) -> x(x) end` -> snapshot the "infinite type" diagnostic.
    3. `test_diag_arity_mismatch`: `let f = fn (x, y) -> x end\nf(1)` -> snapshot the arity error.
    4. `test_diag_unbound_variable`: `x + 1` -> snapshot with "undefined variable: x".
    5. `test_diag_not_a_function`: `let x = 42\nx(1)` -> snapshot "type Int is not callable".
    6. `test_diag_if_branch_mismatch`: `if true do 1 else "hello" end` -> snapshot.
    7. `test_diag_trait_not_satisfied`: Where clause violation -> snapshot.
    8. `test_diag_missing_field`: Struct literal missing field -> snapshot.
    9. `test_diag_option_suggestion`: Expected `Option<Int>`, found `Int` -> snapshot should include "wrap in Some(...)".
    10. `test_diag_result_suggestion`: Expected `Result<Int, String>`, found `Int` -> snapshot should include "wrap in Ok(...)".

    Use `insta::assert_snapshot!()` for each. Strip ANSI color codes from the rendered output for stable snapshots (ariadne supports `Config::with_color(false)` or write to a buffer without colors).

    **End-to-end phase success criteria tests (tests/integration.rs):**
    Create definitive tests that map to the 5 success criteria:

    1. `test_success_criterion_1_let_polymorphism`:
       ```
       let id = fn (x) -> x end
       let a = id(1)
       let b = id("hello")
       (a, b)
       ```
       Assert: no errors, `a` is `Int`, `b` is `String`, result is `(Int, String)`.

    2. `test_success_criterion_2_occurs_check`:
       ```
       fn (x) -> x(x) end
       ```
       Assert: exactly one error, it is `InfiniteType`, error message references "occurs" or "infinite type".

    3. `test_success_criterion_3_structs_option_result`:
       ```
       struct User do
         name: String
         age: Int
       end

       let u = User { name: "Alice", age: 30 }
       let name = u.name

       let maybe: Int? = Some(42)
       let result: Int!String = Ok(1)
       ```
       Assert: no errors, `name` is `String`, `maybe` is `Option<Int>`, `result` is `Result<Int, String>`.

    4. `test_success_criterion_4_traits`:
       ```
       interface Printable do
         fn to_string(self) -> String
       end

       impl Printable for Int do
         fn to_string(self) -> String
           "int"
         end
       end

       fn show<T>(x: T) -> String where T: Printable do
         to_string(x)
       end

       show(42)
       ```
       Assert: no errors, result is `String`.

    5. `test_success_criterion_5_error_locations`:
       ```
       let x: Int = "hello"
       ```
       Assert: error is `Mismatch`, the diagnostic output contains a span pointing to the string literal, shows "expected Int, found String", and includes the source line.

    Run `cargo test -p snow-typeck` -- all tests pass.
    Run `cargo insta review` if needed to accept new snapshots.
  </action>
  <verify>
    `cargo test -p snow-typeck` passes all tests (diagnostics + integration + prior tests).
    `cargo test --workspace` passes.
    All 5 success criteria tests pass.
    Diagnostic snapshots match expected format (terse, labeled spans, fix suggestions).
  </verify>
  <done>
    10 diagnostic snapshot tests verify error message formatting for all error types. 5 end-to-end tests verify all phase success criteria. Error messages are terse with labeled spans and fix suggestions per the locked Elm-quality/Go-tone decision. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` passes all tests.
2. `cargo test --workspace` passes.
3. All 5 phase success criteria verified by dedicated end-to-end tests.
4. Error diagnostics render with ariadne labels, error codes, and fix suggestions.
5. Diagnostic snapshots are stable and match expected tone/format.
6. Error for `let x: Int = "hello"` shows source location and "expected Int, found String".
7. Error for infinite type references the occurs check.
8. Fix suggestions appear for Option/Result wrapping, arity mismatches, and undefined variables.
</verification>

<success_criteria>
- Type errors include source location and inferred types (success criterion #5).
- Error messages are terse (Go-tone) with dual-span labels (Elm-thoroughness).
- Fix suggestions provided for common mistakes.
- All 5 phase success criteria pass in end-to-end tests.
- Full snapshot coverage of error diagnostic rendering.
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-system/03-05-SUMMARY.md`
</output>
