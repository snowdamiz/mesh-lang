---
phase: 03-type-system
plan: 04
type: tdd
wave: 3
depends_on: ["03-02"]
files_modified:
  - crates/snow-typeck/src/traits.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/ty.rs
  - crates/snow-typeck/src/error.rs
  - crates/snow-typeck/src/builtins.rs
  - crates/snow-typeck/tests/traits.rs
autonomous: true

must_haves:
  truths:
    - "Interface definitions create trait constraints with method signatures"
    - "Impl blocks register implementations that satisfy interface constraints"
    - "Where clauses constrain generic type parameters and are enforced at call sites"
    - "Calling a trait method on a concrete type with a registered impl succeeds"
    - "Calling a trait method on a type without an impl produces a clear error"
    - "Arithmetic operators dispatch via compiler-known numeric traits"
  artifacts:
    - path: "crates/snow-typeck/src/traits.rs"
      provides: "Trait registry, impl lookup, constraint resolution"
      contains: "struct TraitRegistry"
    - path: "crates/snow-typeck/tests/traits.rs"
      provides: "Integration tests for interface, impl, where clause, and trait resolution"
  key_links:
    - from: "crates/snow-typeck/src/traits.rs"
      to: "crates/snow-typeck/src/infer.rs"
      via: "resolve_trait_method() called during method dispatch and where-clause checking"
    - from: "crates/snow-typeck/src/traits.rs"
      to: "crates/snow-typeck/src/builtins.rs"
      via: "Compiler-known traits (Add, Eq, Ord) registered in builtins"
---

<objective>
Trait system with interface definitions, impl blocks, where-clause constraints, and trait method resolution.

Purpose: Traits enable polymorphic dispatch -- the `interface` keyword defines method contracts, `impl` blocks satisfy them, and `where` clauses constrain generics. This also provides the foundation for operator overloading via compiler-known traits (Add, Eq, etc.), making arithmetic work properly with the type system.

Output: Working trait definitions, implementations, where-clause enforcement, and compiler-known operator traits.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-system/03-CONTEXT.md
@.planning/phases/03-type-system/03-RESEARCH.md
@.planning/phases/03-type-system/03-01-SUMMARY.md
@.planning/phases/03-type-system/03-02-SUMMARY.md
@crates/snow-typeck/src/ty.rs
@crates/snow-typeck/src/infer.rs
@crates/snow-typeck/src/unify.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-parser/src/ast/item.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for traits, impls, and where clauses</name>
  <files>
    crates/snow-typeck/tests/traits.rs
  </files>
  <action>
    Create integration test file `crates/snow-typeck/tests/traits.rs` with test cases (RED phase):

    **Interface definition and impl:**
    1. `test_interface_definition`: Parse `interface Printable do fn to_string(self) -> String end`. Check it registers without errors.
    2. `test_impl_block`: Parse `interface Printable do fn to_string(self) -> String end\nimpl Printable for Int do fn to_string(self) -> String do "int" end end`. Check it type-checks without errors.
    3. `test_impl_missing_method`: Parse an impl block missing a required method. Check for a `MissingTraitMethod` error.
    4. `test_impl_wrong_method_signature`: Parse an impl block where a method has wrong return type. Check for type mismatch.

    **Where clauses:**
    5. `test_where_clause_satisfied`: Parse `interface Printable do fn to_string(self) -> String end\nimpl Printable for Int do fn to_string(self) -> String do "int" end end\nfn show<T>(x: T) -> String where T: Printable do to_string(x) end\nshow(42)`. Check result is `String`.
    6. `test_where_clause_unsatisfied`: Same setup but call `show("hello")` without a Printable impl for String. Check for `TraitNotSatisfied` error.
    7. `test_multiple_where_constraints`: Parse `fn both<T>(x: T) where T: Printable, T: Eq do ... end`. Check it accepts types satisfying both.

    **Compiler-known traits for operators:**
    8. `test_add_trait_int`: Parse `1 + 2`, verify it type-checks as `Int` (Add impl for Int is built-in).
    9. `test_add_trait_float`: Parse `1.0 + 2.0`, verify it type-checks as `Float`.
    10. `test_add_trait_string_fails`: Parse `"a" + "b"`, verify it fails (no Add impl for String -- use `++` for string concat instead, or register it if desired). Decision: String does NOT have Add. String concat is `++`.
    11. `test_eq_trait`: Parse `1 == 2`, verify it type-checks as `Bool` (Eq impl for Int is built-in).
    12. `test_ord_trait`: Parse `1 < 2`, verify it type-checks as `Bool` (Ord impl for Int is built-in).

    **Trait method dispatch:**
    13. `test_trait_method_call`: Parse interface + impl, then call `to_string(42)` (where `to_string` is the trait method). Check it returns `String`. Note: trait methods may need to be called as `x.to_string()` (method syntax) or `Printable.to_string(x)` (qualified). Decide: for now, trait methods are called as regular functions with the `self` type used for dispatch. `to_string(42)` dispatches to the Int impl.

    Run tests -- all MUST fail (RED).
  </action>
  <verify>
    `cargo test -p snow-typeck` compiles but all 13 trait tests fail (RED).
  </verify>
  <done>
    13 trait test cases covering interface definitions, impl blocks, where clauses, compiler-known operator traits, and trait method dispatch. All fail.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement trait registry, resolution, and compiler-known traits</name>
  <files>
    crates/snow-typeck/src/traits.rs
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/ty.rs
    crates/snow-typeck/src/error.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/lib.rs
  </files>
  <action>
    Implement the trait system to pass all 13 tests (GREEN phase).

    **traits.rs -- Trait registry and resolution:**
    1. Define `TraitDef` struct: `{ name: String, generic_params: Vec<String>, methods: Vec<TraitMethodDef> }`. `TraitMethodDef`: `{ name: String, self_param: bool, param_types: Vec<Ty>, return_type: Ty }`.
    2. Define `ImplDef` struct: `{ trait_name: String, implementing_type: Ty, methods: Vec<ImplMethodDef> }`.
    3. Define `TraitRegistry` struct: `{ traits: HashMap<String, TraitDef>, impls: Vec<ImplDef> }`.
    4. Implement `register_trait(&mut self, def: TraitDef)`: store in registry.
    5. Implement `register_impl(&mut self, impl_def: ImplDef)`: validate all required methods are present with correct signatures, then store.
    6. Implement `find_impl(&self, trait_name: &str, ty: &Ty) -> Option<&ImplDef>`: search impls for a matching trait+type combo. For now, exact match on concrete types. Generic impl resolution (e.g., `impl<T> Trait for Vec<T>`) is deferred to later phases.
    7. Implement `check_where_clause(&self, constraints: &[(TyVar, String)], substitution: &HashMap<TyVar, Ty>) -> Result<(), TypeError>`: for each constraint `(var, trait_name)`, look up the concrete type the var resolved to, then check `find_impl`. If not found, produce `TraitNotSatisfied` error.

    **Compiler-known traits (builtins.rs):**
    1. Register compiler-known traits: `Add`, `Sub`, `Mul`, `Div`, `Mod` (arithmetic), `Eq`, `Ord` (comparison), `Not` (logical negation).
    2. Register built-in impls: `Add for Int`, `Add for Float`, `Sub for Int`, `Sub for Float`, `Mul for Int`, `Mul for Float`, `Div for Int`, `Div for Float`, `Mod for Int`, `Eq for Int`, `Eq for Float`, `Eq for String`, `Eq for Bool`, `Ord for Int`, `Ord for Float`.
    3. These are registered in the `TraitRegistry` before user code is processed.

    **Integration with inference engine (infer.rs):**
    1. Update `BinaryExpr` inference to use trait dispatch:
       - For `+`: look up `Add` impl for the operand type. If found, the return type is the `Add::Output` type (for simplicity, same as the operand type for built-in numerics).
       - For `==`, `!=`: look up `Eq` impl. Return type is `Bool`.
       - For `<`, `>`, `<=`, `>=`: look up `Ord` impl. Return type is `Bool`.
       - For `and`, `or`: both sides must be `Bool`, return `Bool` (no trait needed).
       - For `++`: string concat, both sides must be `String`, return `String`.
    2. Update `InterfaceDef` item handling: when the AST walker encounters an `InterfaceDef`, extract method signatures and register a `TraitDef` in the `TraitRegistry`.
    3. Update `ImplDef` item handling: when the AST walker encounters an `ImplDef`, extract methods, type-check each method body, and register an `ImplDef` in the `TraitRegistry`. Validate that the impl's methods match the trait's signatures.
    4. For function definitions with where clauses: parse the where clause AST (from plan 03-01's parser additions), store constraints as `(param_name, trait_name)` pairs. When the function is called, after inferring all argument types, check that each constrained type parameter's resolved type has the required impl.

    **New error variants (error.rs):**
    1. `TraitNotSatisfied { trait_name: String, ty: Ty, span: TextRange }` -- "type Int does not implement Display"
    2. `MissingTraitMethod { trait_name: String, method_name: String, span: TextRange }` -- "impl Printable for Int is missing method to_string"
    3. `TraitMethodSignatureMismatch { ... }` -- method signature in impl does not match trait definition

    **ty.rs updates:**
    1. Add `WhereClause` to function type representation if needed: `Ty::Fun` may need to carry constraints. Alternatively, constraints are stored separately in the inference context and checked at call sites. Simpler approach: store constraints in the `Scheme` alongside the quantified vars. `Scheme { vars, constraints: Vec<(TyVar, String)>, ty }`.

    Run `cargo test -p snow-typeck` -- all 13 trait tests pass, plus all prior tests still pass (GREEN).
  </action>
  <verify>
    `cargo test -p snow-typeck` passes all tests (13 trait + 16 inference + 15 struct = 44 total).
    `cargo test --workspace` passes.
  </verify>
  <done>
    Interface definitions, impl blocks, and where clauses work. Trait registry stores definitions and implementations. Where clauses are enforced at call sites. Compiler-known traits handle arithmetic and comparison operators. Trait method dispatch resolves to the correct impl. All 44 tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` passes all tests.
2. Interface definitions register correctly.
3. Impl blocks validate method signatures against trait definitions.
4. Where clauses are enforced -- calling with a type that lacks the impl produces an error.
5. Arithmetic and comparison operators dispatch through built-in traits.
6. Prior inference and struct tests remain passing.
</verification>

<success_criteria>
- Trait definitions and implementations type-check correctly (success criterion #4).
- Where clauses constrain generics and are enforced at call sites.
- Compiler-known traits handle arithmetic/comparison operators.
- Missing impl and wrong method signatures produce clear errors.
- All tests pass (trait + struct + inference).
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-system/03-04-SUMMARY.md`
</output>
