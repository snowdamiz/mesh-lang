---
phase: 03-type-system
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/unify.rs
  - crates/snow-typeck/src/lib.rs
  - crates/snow-typeck/src/builtins.rs
autonomous: true

must_haves:
  truths:
    - "let id = fn x -> x end followed by (id(1), id(\"hello\")) type-checks successfully"
    - "fn x -> x(x) end is rejected with a type error referencing the occurs check"
    - "Integer literal 42 always infers as Int, float literal 3.14 always infers as Float"
    - "let x = 1 followed by let y = x + 2 infers both as Int"
    - "if true do 1 else \"hello\" end produces a type mismatch error"
  artifacts:
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "AST-walking inference engine with constraint generation"
      contains: "fn infer_expr"
    - path: "crates/snow-typeck/src/lib.rs"
      provides: "Public check() API returning TypeckResult with type table and errors"
      exports: ["check", "TypeckResult"]
  key_links:
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast"
      via: "Walks typed AST wrappers (Expr, Item, LetBinding, FnDef, etc.)"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/unify.rs"
      via: "Calls unify() to generate and solve type constraints"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/env.rs"
      via: "Uses TypeEnv for variable binding lookup and scope management"
---

<objective>
Algorithm J inference engine that walks the Snow AST, generates type constraints, and solves them via unification -- the core of Hindley-Milner type inference with let-polymorphism.

Purpose: This is THE plan that makes type inference work. Let-polymorphism (the identity function used at multiple types) and the occurs check (rejecting infinite types) are the two hardest correctness properties. Getting this right is the foundation for everything else.

Output: Working `check()` function that type-checks Snow programs with let-polymorphism, literal typing, function inference, and basic arithmetic.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-system/03-CONTEXT.md
@.planning/phases/03-type-system/03-RESEARCH.md
@.planning/phases/03-type-system/03-01-SUMMARY.md
@crates/snow-typeck/src/ty.rs
@crates/snow-typeck/src/unify.rs
@crates/snow-typeck/src/env.rs
@crates/snow-typeck/src/error.rs
@crates/snow-typeck/src/builtins.rs
@crates/snow-parser/src/ast/expr.rs
@crates/snow-parser/src/ast/item.rs
@crates/snow-parser/src/ast/pat.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for core inference behaviors</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/tests/inference.rs
  </files>
  <action>
    Create an integration test file `crates/snow-typeck/tests/inference.rs` with test cases that call `snow_typeck::check()` on parsed Snow source and assert on results. These tests MUST fail initially (RED phase).

    **Test cases to write:**

    1. `test_integer_literal_is_int`: Parse `42`, check that the expression's inferred type is `Int`.
    2. `test_float_literal_is_float`: Parse `3.14`, check that the expression's inferred type is `Float`.
    3. `test_string_literal_is_string`: Parse `"hello"`, check type is `String`.
    4. `test_bool_literal_is_bool`: Parse `true`, check type is `Bool`.
    5. `test_let_binding_inference`: Parse `let x = 42`, check `x` is `Int`.
    6. `test_let_binding_with_usage`: Parse `let x = 1\nx + 2`, check result is `Int`.
    7. `test_function_identity`: Parse `let id = fn (x) -> x end\nid(1)`, check result is `Int`.
    8. `test_let_polymorphism`: Parse `let id = fn (x) -> x end\nlet a = id(1)\nlet b = id("hello")`, check `a` is `Int` and `b` is `String`. This is **success criterion #1**.
    9. `test_occurs_check_rejection`: Parse `fn (x) -> x(x) end`, check that `check()` returns an `InfiniteType` error. This is **success criterion #2**.
    10. `test_if_branch_mismatch`: Parse `if true do 1 else "hello" end`, check that a `Mismatch` error is returned.
    11. `test_if_branches_same_type`: Parse `if true do 1 else 2 end`, check type is `Int`.
    12. `test_function_application_wrong_arity`: Parse `let f = fn (x, y) -> x end\nf(1)`, check `ArityMismatch` error.
    13. `test_unbound_variable`: Parse `x + 1`, check `UnboundVariable` error for `x`.
    14. `test_arithmetic_int`: Parse `1 + 2 * 3`, check type is `Int`.
    15. `test_comparison_returns_bool`: Parse `1 < 2`, check type is `Bool`.
    16. `test_nested_function_inference`: Parse `let apply = fn (f, x) -> f(x) end\napply(fn (n) -> n + 1 end, 42)`, check result is `Int`.

    Use a helper function `check_source(src: &str) -> TypeckResult` that calls `snow_parser::parse(src)` then `snow_typeck::check(&parse)`.

    For assertions, create helpers:
    - `assert_type_is(result, expected_type_str)` -- checks the final expression's type
    - `assert_has_error(result, error_kind)` -- checks for specific error type

    Run `cargo test -p snow-typeck` -- all tests MUST fail (RED). The check() function from 03-01 returns empty results, so inference tests will fail.
  </action>
  <verify>
    `cargo test -p snow-typeck` compiles but all 16 inference tests fail (RED phase confirmed).
  </verify>
  <done>
    16 inference test cases exist covering: literals, let bindings, identity function, let-polymorphism, occurs check, if-branch type checking, arity errors, unbound variables, arithmetic, and nested function inference. All fail because the inference engine is not yet implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Algorithm J inference engine to pass all tests</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/lib.rs
    crates/snow-typeck/src/builtins.rs
    crates/snow-typeck/src/unify.rs
  </files>
  <action>
    Implement the inference engine in `crates/snow-typeck/src/infer.rs` to make all 16 tests pass (GREEN phase).

    **infer.rs -- Core inference functions:**

    1. `pub fn infer(parse: &Parse) -> TypeckResult`: Entry point. Creates `InferCtx`, `TypeEnv`, calls `register_builtins()`, then walks the AST's root `SourceFile` node inferring each item/statement. Returns `TypeckResult` with the type table and errors.

    2. `fn infer_expr(ctx: &mut InferCtx, env: &mut TypeEnv, expr: &Expr) -> Result<Ty, TypeError>`: The main expression inference dispatcher. Match on the `Expr` enum variants:
       - `Expr::Literal(lit)` -> infer_literal: IntLiteral -> Int, FloatLiteral -> Float, StringExpr -> String, true/false -> Bool, nil -> Option<a> (fresh var)
       - `Expr::NameRef(name)` -> look up in env, instantiate the scheme. If not found, return `UnboundVariable` error.
       - `Expr::BinaryExpr(bin)` -> infer both sides; for arithmetic ops (+, -, *, /, %), unify both sides, return same type; for comparison ops (<, >, <=, >=, ==, !=), unify both sides, return Bool; for logical ops (and, or), unify both sides with Bool, return Bool
       - `Expr::UnaryExpr(un)` -> for `-`, infer operand, return same type; for `!`/`not`, return Bool
       - `Expr::IfExpr(if_)` -> infer condition, unify with Bool; infer then-branch; if else branch exists, infer it and unify with then-branch type; if no else, then-branch type is unit/tuple(). Return branch type.
       - `Expr::CallExpr(call)` -> infer callee type; for each arg, infer type; create fresh return var; unify callee with `Fun(arg_types, ret_var)`; return ret_var
       - `Expr::ClosureExpr(closure)` -> for each param, create fresh type var; push scope with params bound to their vars; infer body; pop scope; return `Fun(param_types, body_type)`
       - `Expr::PipeExpr(pipe)` -> infer LHS; infer RHS (must be function); create fresh return var; unify RHS with `Fun([lhs_type], ret_var)`; return ret_var
       - `Expr::TupleExpr(tuple)` -> infer each element; return `Tuple(element_types)`
       - `Expr::Block(block)` -> infer each statement; return last expression's type (or unit if empty)
       - `Expr::CaseExpr(case)` -> infer scrutinee; for each arm, infer pattern type and unify with scrutinee, infer body; unify all arm bodies; return arm body type
       - `Expr::ReturnExpr(ret)` -> infer the value; store as function return constraint; return Never
       - `Expr::FieldAccess(fa)` -> defer to struct inference (return fresh var for now, will be completed in 03-03)
       - `Expr::IndexExpr(idx)` -> defer (return fresh var)

    3. `fn infer_item(ctx: &mut InferCtx, env: &mut TypeEnv, item: &Item)`: Dispatch on Item variants:
       - `Item::LetBinding(let_)` -> enter_level; infer initializer; if annotation, unify; leave_level; generalize; bind name in env
       - `Item::FnDef(fn_)` -> Similar to LetBinding but create function type from params + body. Support recursion by pre-binding the function name to a fresh var before inferring the body. Generalize at the end.
       - `Item::ModuleDef`, `Item::ImportDecl`, `Item::StructDef`, `Item::InterfaceDef`, `Item::ImplDef` -> defer to later plans (skip or return Ok for now)

    4. `fn infer_pattern(ctx: &mut InferCtx, env: &mut TypeEnv, pat: &Pattern) -> Result<Ty, TypeError>`: Pattern type inference:
       - `Pattern::IdentPat` -> create fresh var, bind in env, return the var
       - `Pattern::LiteralPat` -> return the literal's type
       - `Pattern::WildcardPat` -> return fresh var
       - `Pattern::TuplePat` -> infer each sub-pattern, return Tuple

    **Update lib.rs:**
    1. Add `pub mod infer;`
    2. Update `check()` to call `infer::infer(parse)` and return the real `TypeckResult`.

    **Update builtins.rs:**
    1. Register arithmetic operators. Since Snow uses operators as syntax (not function calls), the inference engine handles them directly in `infer_expr` for `BinaryExpr`. The builtins module should register type constructors for `Int`, `Float`, `String`, `Bool` as `TyCon`s accessible via the environment or a dedicated type registry.
    2. Provide helper: `builtin_type(name: &str) -> Ty` that returns `Ty::Con(TyCon { name: name.to_string() })`.

    **Error handling:**
    - When inference fails at any point, record the error (with provenance via ConstraintOrigin) but try to continue inferring other parts of the program. Use the `errors` field on `InferCtx`.
    - For the initial implementation, it is acceptable to stop at the first error per expression. Multi-error recovery is improved in plan 03-05.

    **Key correctness requirements:**
    - Let-polymorphism: `enter_level` before inferring let-binding initializer, `leave_level` + `generalize` after. Each use of a let-bound name calls `instantiate`.
    - Occurs check: in `unify()` when binding a variable, always call `occurs_in()` first.
    - Function recursion: pre-bind function name before inferring body (using a fresh var, then unify with the inferred function type).

    Run `cargo test -p snow-typeck` -- all 16 tests should pass (GREEN).
  </action>
  <verify>
    `cargo test -p snow-typeck` passes all 16 inference tests.
    Specifically verify:
    - `test_let_polymorphism` passes (success criterion #1)
    - `test_occurs_check_rejection` passes (success criterion #2)
    `cargo test --workspace` passes.
  </verify>
  <done>
    Algorithm J inference engine walks the AST, generates constraints, and solves via unification. Let-polymorphism works (id at Int and String). Occurs check rejects infinite types. Literals correctly typed. Arithmetic, comparison, if-branches, closures, function application all infer correctly. All 16 tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` passes all tests.
2. Success criterion #1: `let id = fn (x) -> x end` then `(id(1), id("hello"))` type-checks.
3. Success criterion #2: `fn (x) -> x(x) end` produces InfiniteType error.
4. The type table maps AST node ranges to resolved types.
5. Errors carry ConstraintOrigin with source locations.
</verification>

<success_criteria>
- The `check()` function returns correct types for all expression forms.
- Let-polymorphism works: identity function usable at multiple types.
- Occurs check rejects self-application.
- Type errors carry provenance (source locations).
- 16 inference tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-system/03-02-SUMMARY.md`
</output>
