---
phase: 56-https-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-rt/Cargo.toml
  - crates/snow-rt/src/http/server.rs
  - crates/snow-rt/src/http/mod.rs
autonomous: true

must_haves:
  truths:
    - "Existing Http.serve(router, port) works for plaintext HTTP without modification"
    - "All existing HTTP features (path parameters, method routing, middleware) work identically after tiny_http removal"
    - "E2E tests for HTTP server, crash isolation, path params, and middleware all pass"
  artifacts:
    - path: "crates/snow-rt/src/http/server.rs"
      provides: "Hand-rolled HTTP/1.1 request parser and response writer replacing tiny_http"
      contains: "parse_request"
    - path: "crates/snow-rt/Cargo.toml"
      provides: "Dependency manifest without tiny_http"
  key_links:
    - from: "crates/snow-rt/src/http/server.rs"
      to: "std::net::TcpListener"
      via: "TcpListener::bind in snow_http_serve"
      pattern: "TcpListener::bind"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "crates/snow-rt/src/http/router.rs"
      via: "SnowRouter::match_route for request dispatch"
      pattern: "router.match_route"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "actor::global_scheduler"
      via: "Actor spawn for per-connection handling"
      pattern: "sched.spawn"
---

<objective>
Replace tiny_http with a hand-rolled HTTP/1.1 request parser and response writer, keeping Http.serve working identically on plaintext TCP.

Purpose: Eliminate tiny_http and its transitive rustls 0.20 dependency, which conflicts with rustls 0.23 already used by Phase 55's PostgreSQL TLS and ureq's HTTP client. The hand-rolled parser provides the foundation for Plan 02's TLS layer.
Output: Rewritten server.rs with parse_request/write_response, updated Cargo.toml without tiny_http, all existing HTTP E2E tests passing.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-https-server/56-RESEARCH.md
@.planning/phases/55-postgresql-tls/55-01-SUMMARY.md
@crates/snow-rt/src/http/server.rs
@crates/snow-rt/src/http/mod.rs
@crates/snow-rt/src/http/router.rs
@crates/snow-rt/Cargo.toml
@crates/snowc/tests/e2e_stdlib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove tiny_http dependency and rewrite server.rs with hand-rolled HTTP/1.1 parser</name>
  <files>
    crates/snow-rt/Cargo.toml
    crates/snow-rt/src/http/server.rs
    crates/snow-rt/src/http/mod.rs
  </files>
  <action>
**Step 1: Remove tiny_http from Cargo.toml.**
Delete the `tiny_http = "0.12"` line from `crates/snow-rt/Cargo.toml`. All other dependencies stay.

**Step 2: Rewrite server.rs to replace tiny_http.**

Keep ALL existing code that does NOT depend on tiny_http (SnowHttpRequest, SnowHttpResponse, snow_http_response_new, all request accessors, alloc_option, ChainState, chain_next, build_snow_closure, call_handler, call_middleware, and all tests). These are unchanged.

Replace the tiny_http-dependent parts:

A. **ConnectionArgs struct**: Change `request_ptr: usize` from holding a `Box<tiny_http::Request>` to holding a `Box<TcpStream>` (the accepted TCP socket). The router_addr field stays the same.

B. **connection_handler_entry function**: Instead of unboxing a `tiny_http::Request`, unbox a `TcpStream`. Set a 30-second read timeout on the stream via `tcp_stream.set_read_timeout(Some(Duration::from_secs(30)))`. Call `parse_request(&mut stream)` to get a `ParsedRequest`. If parsing fails, log to stderr and return. Otherwise, call a new `process_request(router_ptr, parsed)` function that does the routing/middleware/response logic. After getting the SnowHttpResponse, call `write_response(&mut stream, status, body_bytes)`.

C. **Add parse_request function**: Create a `ParsedRequest` struct with fields: `method: String`, `path: String`, `headers: Vec<(String, String)>`, `body: Vec<u8>`. The function takes `&mut TcpStream` and:
  1. Wraps it in `BufReader::new(stream)` -- keep the BufReader alive for the entire parse.
  2. Reads request line via `read_line()`. Use `splitn(3, ' ')` to extract method and path. Require at least 2 parts.
  3. Reads headers line-by-line via `read_line()` until encountering an empty line (`\r\n` alone). For each header, split on first `:` via `split_once(':')`. Trim name and value. Track Content-Length (case-insensitive name comparison via `eq_ignore_ascii_case`). Limit: max 100 headers, max 8KB total header data.
  4. Reads body via `read_exact()` using Content-Length value (0 if no Content-Length header).
  5. Returns `Result<ParsedRequest, String>`.

D. **Add write_response function**: Takes `&mut TcpStream`, `status: u16`, `body: &[u8]`. Writes:
  - `HTTP/1.1 {status} {status_text}\r\n`
  - `Content-Type: application/json; charset=utf-8\r\n`
  - `Content-Length: {body.len()}\r\n`
  - `Connection: close\r\n`
  - `\r\n`
  - body bytes
  - Calls `flush()`.
  - Status text mapping: 200=OK, 201=Created, 204=No Content, 301=Moved Permanently, 302=Found, 400=Bad Request, 401=Unauthorized, 403=Forbidden, 404=Not Found, 405=Method Not Allowed, 500=Internal Server Error, _=OK.

E. **Rewrite snow_http_serve**: Replace `tiny_http::Server::http(&addr)` with `std::net::TcpListener::bind(&addr)`. Replace the `for request in server.incoming_requests()` loop with `for tcp_stream in listener.incoming()`. For each accepted stream, handle the accept error (log and continue). Box the `TcpStream` and transfer as `usize` in ConnectionArgs. Spawn the actor the same way via `sched.spawn()`.

F. **Rewrite handle_request into process_request**: Extract the routing/middleware/response logic from the existing `handle_request` function into `process_request(router_ptr: *mut u8, parsed: ParsedRequest) -> (u16, Vec<u8>)`. This function:
  - Builds SnowHttpRequest from ParsedRequest fields (method, path, body, headers, query params, path params) using the EXACT same logic as the current handle_request.
  - Splits URL into path and query string at `?`.
  - Parses query params into SnowMap.
  - Parses headers into SnowMap.
  - Calls `router.match_route(path_str, &method_str)`.
  - Runs middleware chain or direct handler call (same logic as current code).
  - For the 404-without-middleware case, return `(404, b"Not Found".to_vec())` instead of using `tiny_http::Response`.
  - Returns `(status_code as u16, body_bytes)` extracted from SnowHttpResponse.

G. **Update connection_handler_entry** to call process_request and write_response:
  ```
  let (status, body) = process_request(router_ptr, parsed);
  let _ = write_response(&mut tcp_stream, status, &body);
  ```

**Step 3: Update mod.rs** -- no changes needed to the pub use exports since the function signatures for all public functions (snow_http_serve, snow_http_response_new, accessors) are unchanged. Just update the module doc comment to remove "tiny_http" references.

**Important implementation notes:**
- The BufReader wrapping in parse_request requires `&mut TcpStream` to be borrowed. The BufReader borrows the stream for parsing, but we need the stream back for write_response. Solution: pass `&mut TcpStream` to parse_request, which creates a `BufReader<&mut TcpStream>` (borrowing the mutable reference). After parse_request returns, the borrow ends, and we can write to the stream again.
- Do NOT use `BufReader::new(stream)` that takes ownership -- use `BufReader::new(&mut *stream)` or similar reference-based approach so the stream can be written to afterward.
- Wrap connection_handler_entry in catch_unwind just like the existing code for crash isolation.
- The E2E tests send `Connection: close\r\n` in their requests and use `read_to_string` to read the full response. Our `Connection: close` response header plus closing the TCP connection after write ensures compatibility.
  </action>
  <verify>
Run `cargo build -p snow-rt` to confirm compilation without tiny_http. Then run the full test suite:
```
cargo test -p snow-rt
cargo test -p snowc --test e2e_stdlib -- e2e_http
```
All HTTP E2E tests must pass: e2e_http_server_compiles, e2e_http_server_runtime, e2e_http_crash_isolation, e2e_http_path_params, e2e_http_middleware, e2e_http_full_server_compile_only.
  </verify>
  <done>
tiny_http removed from Cargo.toml. server.rs rewritten with hand-rolled HTTP/1.1 parser. All existing HTTP E2E tests pass. `cargo build -p snow-rt` succeeds. Http.serve works identically to before for plaintext HTTP.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p snow-rt` succeeds without tiny_http dependency
2. `cargo test -p snow-rt` passes (unit tests for response creation, request accessors)
3. `cargo test -p snowc --test e2e_stdlib -- e2e_http_server_runtime` passes (real HTTP request/response)
4. `cargo test -p snowc --test e2e_stdlib -- e2e_http_crash_isolation` passes (panic recovery)
5. `cargo test -p snowc --test e2e_stdlib -- e2e_http_path_params` passes (route params, method routing)
6. `cargo test -p snowc --test e2e_stdlib -- e2e_http_middleware` passes (middleware chain)
7. `cargo build` full workspace succeeds with no new warnings from server.rs
</verification>

<success_criteria>
- tiny_http is completely removed from the dependency tree
- Http.serve(router, port) works identically for plaintext HTTP
- All 6+ HTTP E2E tests pass without modification
- Hand-rolled parser handles: GET, POST, PUT, DELETE methods; path with query strings; Content-Length body reading; header parsing into SnowMap
- Response format is compatible with raw TcpStream test assertions (HTTP/1.1 status line, Content-Type, Content-Length headers)
</success_criteria>

<output>
After completion, create `.planning/phases/56-https-server/56-01-SUMMARY.md`
</output>
