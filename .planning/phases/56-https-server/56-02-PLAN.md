---
phase: 56-https-server
plan: 02
type: execute
wave: 2
depends_on: ["56-01"]
files_modified:
  - crates/snow-rt/src/http/server.rs
  - crates/snow-rt/src/http/mod.rs
  - crates/snow-codegen/src/codegen/intrinsics.rs
  - crates/snow-codegen/src/mir/lower.rs
autonomous: true

must_haves:
  truths:
    - "User can call Http.serve_tls(router, port, cert_path, key_path) and the server accepts HTTPS connections"
    - "TLS handshakes happen inside per-connection actors, not in the accept loop"
    - "Existing Http.serve(router, port) still works for plaintext HTTP"
    - "All existing HTTP features work identically over HTTPS"
  artifacts:
    - path: "crates/snow-rt/src/http/server.rs"
      provides: "HttpStream enum, build_server_config, snow_http_serve_tls, TLS accept"
      contains: "HttpStream"
      exports: ["snow_http_serve_tls"]
    - path: "crates/snow-codegen/src/codegen/intrinsics.rs"
      provides: "snow_http_serve_tls intrinsic declaration"
      contains: "snow_http_serve_tls"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "http_serve_tls -> snow_http_serve_tls mapping"
      contains: "http_serve_tls"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-rt/src/http/server.rs"
      via: "map_builtin_name maps http_serve_tls to snow_http_serve_tls"
      pattern: "http_serve_tls.*snow_http_serve_tls"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "rustls::ServerConfig"
      via: "build_server_config creates Arc<ServerConfig> from cert/key PEM files"
      pattern: "ServerConfig::builder"
    - from: "crates/snow-rt/src/http/server.rs"
      to: "rustls::StreamOwned"
      via: "HttpStream::Tls wraps ServerConnection+TcpStream"
      pattern: "StreamOwned::new"
---

<objective>
Add Http.serve_tls(router, port, cert_path, key_path) for HTTPS serving using rustls ServerConfig + ServerConnection + StreamOwned, with an HttpStream enum for zero-cost dispatch between plain and TLS connections.

Purpose: Enable Snow programs to serve production HTTPS traffic with TLS encryption, sharing the rustls 0.23 infrastructure already used by Phase 55's PostgreSQL TLS.
Output: HttpStream enum in server.rs, snow_http_serve_tls runtime function, codegen intrinsic and MIR mapping, compile-only verification.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-https-server/56-RESEARCH.md
@.planning/phases/56-https-server/56-01-SUMMARY.md
@crates/snow-rt/src/http/server.rs
@crates/snow-rt/src/http/mod.rs
@crates/snow-rt/src/db/pg.rs
@crates/snow-codegen/src/codegen/intrinsics.rs
@crates/snow-codegen/src/mir/lower.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HttpStream enum and refactor server.rs for TLS support</name>
  <files>
    crates/snow-rt/src/http/server.rs
    crates/snow-rt/src/http/mod.rs
  </files>
  <action>
**Step 1: Add HttpStream enum to server.rs** (mirrors Phase 55's PgStream pattern from `crates/snow-rt/src/db/pg.rs`).

```rust
use rustls::{ServerConfig, ServerConnection, StreamOwned};
use std::sync::Arc;

enum HttpStream {
    Plain(TcpStream),
    Tls(StreamOwned<ServerConnection, TcpStream>),
}

impl Read for HttpStream {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        match self {
            HttpStream::Plain(s) => s.read(buf),
            HttpStream::Tls(s) => s.read(buf),
        }
    }
}

impl Write for HttpStream {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        match self {
            HttpStream::Plain(s) => s.write(buf),
            HttpStream::Tls(s) => s.write(buf),
        }
    }
    fn flush(&mut self) -> std::io::Result<()> {
        match self {
            HttpStream::Plain(s) => s.flush(),
            HttpStream::Tls(s) => s.flush(),
        }
    }
}
```

**Step 2: Add build_server_config function.**
```rust
fn build_server_config(cert_path: &str, key_path: &str) -> Result<Arc<ServerConfig>, String> {
    use rustls_pki_types::{CertificateDer, PrivateKeyDer, pem::PemObject};

    let certs: Vec<CertificateDer<'static>> = CertificateDer::pem_file_iter(cert_path)
        .map_err(|e| format!("open cert file: {}", e))?
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| format!("parse certs: {}", e))?;

    let key = PrivateKeyDer::from_pem_file(key_path)
        .map_err(|e| format!("load key: {}", e))?;

    let config = ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)
        .map_err(|e| format!("TLS config: {}", e))?;

    Ok(Arc::new(config))
}
```

**Step 3: Refactor ConnectionArgs to carry HttpStream instead of TcpStream.**
Change `request_ptr: usize` to hold a `Box<HttpStream>` transferred as usize. This allows both plain and TLS connections to flow through the same actor infrastructure.

**Step 4: Refactor connection_handler_entry** to unbox `HttpStream` instead of `TcpStream`. Update parse_request and write_response to accept `&mut HttpStream` (since HttpStream implements Read+Write, the BufReader and write_all calls work identically).

CRITICAL: For TLS connections, the read timeout must be set on the raw TcpStream BEFORE wrapping in StreamOwned. The ConnectionArgs for TLS connections will carry an HttpStream::Tls that already has the timeout set.

**Step 5: Refactor snow_http_serve** to wrap accepted TcpStreams in `HttpStream::Plain(tcp_stream)` before boxing into ConnectionArgs. The 30-second read timeout is set on the TcpStream before wrapping. Behavior is identical to Plan 01's implementation -- just wrapped in the enum.

**Step 6: Add snow_http_serve_tls function.**
```rust
#[no_mangle]
pub extern "C" fn snow_http_serve_tls(
    router: *mut u8,
    port: i64,
    cert_path: *const SnowString,
    key_path: *const SnowString,
) {
    crate::actor::snow_rt_init_actor(0);

    let cert_str = unsafe { (*cert_path).as_str() };
    let key_str = unsafe { (*key_path).as_str() };

    let tls_config = match build_server_config(cert_str, key_str) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("[snow-rt] Failed to load TLS certificates: {}", e);
            return;
        }
    };

    let addr = format!("0.0.0.0:{}", port);
    let listener = match std::net::TcpListener::bind(&addr) {
        Ok(l) => l,
        Err(e) => {
            eprintln!("[snow-rt] Failed to bind {}: {}", addr, e);
            return;
        }
    };

    eprintln!("[snow-rt] HTTPS server listening on {}", addr);

    let router_addr = router as usize;
    // Leak the Arc<ServerConfig> as a raw pointer for transfer into actors.
    // The server runs forever, so this is intentional (no cleanup needed).
    let config_ptr = Arc::into_raw(tls_config) as usize;

    for tcp_stream in listener.incoming() {
        let tcp_stream = match tcp_stream {
            Ok(s) => s,
            Err(e) => {
                eprintln!("[snow-rt] accept error: {}", e);
                continue;
            }
        };

        // Set read timeout BEFORE wrapping in TLS (Pitfall 7 from research).
        tcp_stream.set_read_timeout(Some(std::time::Duration::from_secs(30))).ok();

        // TLS handshake happens INSIDE the actor (Pitfall 1 from research).
        // We pass the raw TcpStream + config pointer to the actor.
        // The actor creates ServerConnection + StreamOwned, triggering the
        // handshake on first read. This avoids blocking the accept loop.
        let tls_config = unsafe { Arc::from_raw(config_ptr as *const ServerConfig) };
        let conn = match ServerConnection::new(Arc::clone(&tls_config)) {
            Ok(c) => c,
            Err(e) => {
                eprintln!("[snow-rt] TLS connection setup failed: {}", e);
                // Don't drop the Arc (we leaked it intentionally).
                std::mem::forget(tls_config);
                continue;
            }
        };
        // Re-leak the Arc so it's available for the next connection.
        std::mem::forget(tls_config);

        // StreamOwned::new does NO I/O -- handshake is lazy on first read/write.
        let tls_stream = StreamOwned::new(conn, tcp_stream);
        let http_stream = HttpStream::Tls(tls_stream);

        let stream_ptr = Box::into_raw(Box::new(http_stream)) as usize;
        let args = ConnectionArgs {
            router_addr,
            request_ptr: stream_ptr,
        };
        let args_ptr = Box::into_raw(Box::new(args)) as *const u8;
        let args_size = std::mem::size_of::<ConnectionArgs>() as u64;

        let sched = actor::global_scheduler();
        sched.spawn(
            connection_handler_entry as *const u8,
            args_ptr,
            args_size,
            1,
        );
    }
}
```

Note on TLS handshake location: The research says the handshake must happen inside the actor to avoid blocking the accept loop. With StreamOwned, the handshake happens lazily on first read/write. Since StreamOwned::new() does NO I/O, creating it in the accept loop is safe. The actual handshake I/O occurs when the actor calls parse_request -> BufReader::read_line -> StreamOwned::read, which runs inside the actor's coroutine on a scheduler worker thread. This satisfies success criterion 4.

ALTERNATIVE APPROACH if ServerConnection::new proves problematic in the accept loop: Pass the raw TcpStream + Arc<ServerConfig> as usize to the actor and do the StreamOwned wrapping inside connection_handler_entry. This is more complex but guarantees zero TLS work in the accept loop. Choose whichever is simpler and correct.

**Step 7: Update mod.rs** to export snow_http_serve_tls:
Add `snow_http_serve_tls` to the `pub use server::{...}` line.
  </action>
  <verify>
Run `cargo build -p snow-rt` to confirm compilation. Run `cargo test -p snow-rt` for unit tests. Run `cargo test -p snowc --test e2e_stdlib -- e2e_http` to confirm all existing HTTP E2E tests still pass after the HttpStream refactor.
  </verify>
  <done>
HttpStream enum added with Read+Write delegation. snow_http_serve uses HttpStream::Plain. snow_http_serve_tls loads certs, builds ServerConfig, accepts TLS connections. TLS handshake is lazy (inside actor). All existing HTTP tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add serve_tls codegen intrinsic and MIR mapping</name>
  <files>
    crates/snow-codegen/src/codegen/intrinsics.rs
    crates/snow-codegen/src/mir/lower.rs
  </files>
  <action>
**Step 1: Add intrinsic declaration in intrinsics.rs.**

Find the existing `snow_http_serve` declaration (around line 423-424). Add immediately after it:

```rust
// snow_http_serve_tls(router: ptr, port: i64, cert_path: ptr, key_path: ptr) -> void
module.add_function("snow_http_serve_tls",
    void_type.fn_type(&[ptr_type.into(), i64_type.into(), ptr_type.into(), ptr_type.into()], false),
    Some(inkwell::module::Linkage::External));
```

Also add to the intrinsics test (around line 770) after the `snow_http_serve` assertion:
```rust
assert!(module.get_function("snow_http_serve_tls").is_some());
```

**Step 2: Add known_functions entry in lower.rs.**

Find the existing `snow_http_serve` entry (around line 658). Add immediately after it:

```rust
self.known_functions.insert("snow_http_serve_tls".to_string(),
    MirType::FnPtr(vec![MirType::Ptr, MirType::Int, MirType::String, MirType::String],
    Box::new(MirType::Unit)));
```

The signature is: router (Ptr), port (Int), cert_path (String), key_path (String) -> Unit.

**Step 3: Add map_builtin_name entry in lower.rs.**

Find the existing `"http_serve"` entry (around line 8993). Add immediately after it:

```rust
"http_serve_tls" => "snow_http_serve_tls".to_string(),
```

This ensures `HTTP.serve_tls(router, port, cert, key)` in Snow source code is lowered to `snow_http_serve_tls` via: HTTP module detected in STDLIB_MODULES -> field access `serve_tls` prefixed as `http_serve_tls` -> map_builtin_name maps to `snow_http_serve_tls`.

**Step 4: Verify the compile-only E2E test.**

Add a compile-only test to verify Snow source using Http.serve_tls compiles. Create the test near the existing `e2e_http_full_server_compile_only` test or just verify compilation succeeds for a simple Snow program like:

```snow
let router = HTTP.router()
HTTP.serve_tls(router, 8443, "cert.pem", "key.pem")
```

This can be verified by adding a brief compile-only assertion in the test suite, or simply by running `cargo test -p snow-codegen` to verify the intrinsic is properly declared.
  </action>
  <verify>
Run `cargo test -p snow-codegen` to verify intrinsic declaration and test assertion. Run `cargo test -p snowc --test e2e_stdlib -- e2e_http` to confirm all existing HTTP tests still pass (no regressions from codegen changes). Run `cargo build` for full workspace verification.
  </verify>
  <done>
snow_http_serve_tls intrinsic declared in intrinsics.rs with correct 4-parameter signature. known_functions entry in lower.rs with (Ptr, Int, String, String) -> Unit. map_builtin_name maps http_serve_tls to snow_http_serve_tls. HTTP.serve_tls(router, port, cert, key) compiles successfully from Snow source. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` full workspace succeeds
2. `cargo test -p snow-rt` passes (unit tests including response creation, request accessors)
3. `cargo test -p snow-codegen` passes (intrinsic declaration tests)
4. `cargo test -p snowc --test e2e_stdlib -- e2e_http` passes (all HTTP E2E tests)
5. Snow source `HTTP.serve_tls(router, 8443, "cert.pem", "key.pem")` compiles without errors
6. HttpStream enum has Plain and Tls variants with Read+Write delegation
7. TLS handshake is lazy (StreamOwned::new does no I/O) -- happens inside actor on first read
</verification>

<success_criteria>
- Http.serve_tls(router, port, cert_path, key_path) is callable from Snow source code
- snow_http_serve_tls runtime function loads PEM cert/key, builds ServerConfig, accepts TLS connections
- HttpStream enum dispatches between Plain and Tls streams with zero overhead
- TLS handshake runs inside per-connection actors, not in the accept loop
- All existing HTTP E2E tests pass without modification
- Codegen pipeline: Snow source -> MIR lower -> LLVM intrinsic -> runtime function is complete
</success_criteria>

<output>
After completion, create `.planning/phases/56-https-server/56-02-SUMMARY.md`
</output>
