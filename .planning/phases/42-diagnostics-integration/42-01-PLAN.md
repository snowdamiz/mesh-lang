---
phase: 42-diagnostics-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-typeck/src/diagnostics.rs
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_missing_field.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_unknown_field.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_unbound_variable.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_type_mismatch.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_arity_mismatch.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_if_branch_mismatch.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_trait_not_satisfied.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_invalid_guard_expression.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_non_exhaustive_match.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_redundant_arm.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_receive_outside_actor.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_self_outside_actor.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_send_type_mismatch.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_spawn_non_function.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_not_a_function.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_ambiguous_method_deterministic_order.snap
  - crates/snow-typeck/tests/snapshots/diagnostics__diag_ambiguous_method_help_text.snap
autonomous: true

must_haves:
  truths:
    - "Compile errors show the actual file path instead of <unknown> in diagnostic output"
    - "Single-file compilation diagnostics show the passed filename (e.g., test.snow)"
    - "Multi-module compilation diagnostics show the module file path (e.g., math/vector.snow)"
    - "All existing diagnostic tests pass after snapshot updates"
  artifacts:
    - path: "crates/snow-typeck/src/diagnostics.rs"
      provides: "Named-source ariadne diagnostic rendering"
      contains: "ariadne::sources"
    - path: "crates/snow-typeck/tests/snapshots/diagnostics__diag_type_mismatch.snap"
      provides: "Updated snapshot showing filename instead of <unknown>"
      contains: "test.snow"
  key_links:
    - from: "crates/snow-typeck/src/diagnostics.rs"
      to: "ariadne::sources"
      via: "Named span type (String, Range<usize>)"
      pattern: "sources.*filename"
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-typeck/src/diagnostics.rs"
      via: "render_diagnostic(error, source, file_name, ...)"
      pattern: "render_diagnostic"
---

<objective>
Wire up ariadne named-source spans in diagnostic rendering so error messages display actual file paths instead of `<unknown>`.

Purpose: DIAG-01 requires compile errors to include the source module name and file path. The `render_diagnostic` function already receives `filename: &str` but passes it to ariadne as an anonymous `Source::from(source)`, resulting in `<unknown>` in output. Switching to named-source ariadne API (`ariadne::sources()` + `(String, Range<usize>)` spans) fixes this with zero caller changes.

Output: Updated `diagnostics.rs` with named-source spans, 17 updated snapshot files showing `test.snow` instead of `<unknown>`.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-diagnostics-integration/42-RESEARCH.md
@crates/snow-typeck/src/diagnostics.rs
@crates/snow-typeck/tests/diagnostics.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor render_diagnostic to use ariadne named-source spans</name>
  <files>crates/snow-typeck/src/diagnostics.rs</files>
  <action>
Refactor the `render_diagnostic` function in `crates/snow-typeck/src/diagnostics.rs` to use ariadne's named-source API:

1. **Change the import**: Keep `Source` import but add usage of `ariadne::sources`. The `sources()` function creates a named-source cache from an iterator of `(id, source_text)` pairs.

2. **Change ALL span types from `Range<usize>` to `(String, Range<usize>)`**: The `filename` parameter is already available. Every place that constructs a span for `Report::build()` or `Label::new()` must wrap the range in a tuple with the filename. There are approximately 39 `Report::build()` calls and 48 `Label::new()` calls.

   Pattern for each occurrence:
   - BEFORE: `Report::build(ReportKind::Error, span.clone())`
   - AFTER: `Report::build(ReportKind::Error, (filename.to_string(), span.clone()))`

   - BEFORE: `Label::new(range)`
   - AFTER: `Label::new((filename.to_string(), range))`

   - BEFORE: `Label::new(span.clone())`
   - AFTER: `Label::new((filename.to_string(), span.clone()))`

   Where `span` or `range` is a `Range<usize>`, wrap it as `(filename.to_string(), the_range)`.

3. **Change the cache at the bottom of the function** (line ~1502):
   - BEFORE: `let cache = Source::from(source);`
   - AFTER: `let cache = ariadne::sources([(filename.to_string(), source.to_string())]);`

   Note: `ariadne::sources()` takes owned strings for both the ID and source text. The span IDs must match the cache key exactly (both use `filename.to_string()`).

4. **Handle the `clamp` helper**: The existing `clamp()` function returns `Range<usize>`. It can stay as-is -- just wrap its return value in the tuple at each call site. Do NOT change `clamp` to return a tuple.

5. **Keep JSON mode unchanged**: The JSON rendering path (early return when `options.json`) does not use ariadne and needs no changes.

IMPORTANT: Be thorough -- every single `Report::build`, `Label::new`, and any other span-bearing ariadne call must use the `(String, Range<usize>)` type consistently. Mixing `Range<usize>` and `(String, Range<usize>)` will cause Rust compile errors because the generic `S: Span` parameter must be uniform within a report.

The `Source` import can be removed if no longer used (JSON mode does not use it either). Check if anything else in the file uses `Source::from`.
  </action>
  <verify>
Run `cargo build -p snow-typeck` to verify the refactor compiles. Then run `cargo test -p snow-typeck -- diagnostics --nocapture 2>&1 | head -50` to see that tests run (they will fail due to snapshot mismatches, which is expected and handled in Task 2).
  </verify>
  <done>
`cargo build -p snow-typeck` succeeds. The render_diagnostic function uses `(String, Range<usize>)` spans and `ariadne::sources()` cache. No `Source::from` remains for the human-readable path. No mixed span types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all diagnostic snapshot tests</name>
  <files>
    crates/snow-typeck/tests/snapshots/diagnostics__diag_missing_field.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_unknown_field.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_unbound_variable.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_type_mismatch.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_arity_mismatch.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_if_branch_mismatch.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_trait_not_satisfied.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_invalid_guard_expression.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_non_exhaustive_match.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_redundant_arm.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_receive_outside_actor.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_self_outside_actor.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_send_type_mismatch.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_spawn_non_function.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_not_a_function.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_ambiguous_method_deterministic_order.snap
    crates/snow-typeck/tests/snapshots/diagnostics__diag_ambiguous_method_help_text.snap
  </files>
  <action>
After Task 1's ariadne refactor, all 17 snapshot tests will fail because diagnostic output now shows `test.snow` instead of `<unknown>` in the file location header.

1. Run `cargo insta test -p snow-typeck -- diagnostics` to generate pending snapshot updates.
2. Run `cargo insta review` to accept all pending snapshots (or use `cargo insta accept` to batch-accept all).
3. If `cargo insta` is not available as a CLI tool, manually run `cargo test -p snow-typeck -- diagnostics` which will create `.snap.new` files, then rename each `.snap.new` to `.snap` to accept.

The expected change in every snapshot is:
- BEFORE: `+--[ <unknown>:N:M ]` (or similar ariadne header format)
- AFTER: `+--[ test.snow:N:M ]`

The test helper `render_first_error` in `tests/diagnostics.rs` passes `"test.snow"` as the filename. All snapshots should now show `test.snow` in the file location.

4. Also verify that the non-snapshot tests in `tests/diagnostics.rs` still pass (they use `assert!` checks, not snapshots, so they should be unaffected by the filename change).

5. Run the FULL test suite: `cargo test -p snow-typeck` to ensure nothing else broke.
6. Run `cargo test -p snowc` to ensure the E2E tests still pass (the build pipeline already passes correct filenames).
  </action>
  <verify>
`cargo test -p snow-typeck` -- all tests pass (0 failures). `cargo test -p snowc` -- all E2E tests pass. Every `.snap` file contains `test.snow` instead of `<unknown>`.
  </verify>
  <done>
All 17 snapshot files updated to show `test.snow` in file location headers. All snow-typeck tests pass. All snowc E2E tests pass. DIAG-01 is complete.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` passes all tests (diagnostic snapshots + unit tests)
2. `cargo test -p snowc` passes all E2E tests
3. Grep for `<unknown>` in snapshot files returns zero matches: `grep -r "<unknown>" crates/snow-typeck/tests/snapshots/`
4. Grep for `Source::from` in diagnostics.rs returns zero matches (replaced by `ariadne::sources`)
5. Build the full project: `cargo build` succeeds
</verification>

<success_criteria>
- Diagnostic output shows actual file paths instead of `<unknown>`
- All 17 snapshot tests updated and passing
- All existing E2E tests pass with zero regressions
- No mixed span types in diagnostics.rs (all use `(String, Range<usize>)`)
</success_criteria>

<output>
After completion, create `.planning/phases/42-diagnostics-integration/42-01-SUMMARY.md`
</output>
