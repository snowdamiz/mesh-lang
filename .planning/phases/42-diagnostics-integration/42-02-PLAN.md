---
phase: 42-diagnostics-integration
plan: 02
type: execute
wave: 2
depends_on: ["42-01"]
files_modified:
  - crates/snow-typeck/src/ty.rs
  - crates/snow-typeck/src/lib.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snowc/src/main.rs
  - crates/snowc/tests/e2e.rs
autonomous: true

must_haves:
  truths:
    - "Type errors involving imported types display the module origin (e.g., 'expected Geometry.Point, got Main.Point')"
    - "Builtin types (Int, String, Bool, Float, Option, Result) never show a module prefix"
    - "Local types in multi-module mode show the current module prefix in error messages"
    - "Single-file programs display types without any module prefix (backward compatible)"
    - "A realistic multi-module project (3+ modules with structs, traits, generics, imports) compiles and runs correctly"
  artifacts:
    - path: "crates/snow-typeck/src/ty.rs"
      provides: "TyCon with display_prefix field, manual PartialEq/Hash excluding display_prefix"
      contains: "display_prefix"
    - path: "crates/snow-typeck/src/lib.rs"
      provides: "ImportContext with current_module field"
      contains: "current_module"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "Display prefix set on imported and local user-defined types"
      contains: "display_prefix"
    - path: "crates/snowc/src/main.rs"
      provides: "current_module threaded into ImportContext for each module"
      contains: "current_module"
    - path: "crates/snowc/tests/e2e.rs"
      provides: "Comprehensive multi-module E2E test + module-qualified type error test"
      contains: "comprehensive_multi_module"
  key_links:
    - from: "crates/snowc/src/main.rs"
      to: "crates/snow-typeck/src/lib.rs"
      via: "ImportContext.current_module set per module"
      pattern: "current_module.*module_name"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-typeck/src/ty.rs"
      via: "TyCon::with_module() for imported types, display_prefix for local types"
      pattern: "with_module|display_prefix"
    - from: "crates/snow-typeck/src/ty.rs"
      to: "error Display output"
      via: "TyCon::Display shows prefix.name for qualified types"
      pattern: "write.*prefix.*name"
---

<objective>
Add module-qualified type display in error messages and validate the complete module system end-to-end.

Purpose: DIAG-02 requires type errors to show module origin (e.g., "expected Geometry.Point, got Main.Point"). The third success criterion requires a realistic multi-module project to compile and run correctly. TyCon needs a display-only `display_prefix` field that is excluded from PartialEq/Hash to avoid breaking type identity.

Output: Updated `TyCon` with display prefix, import resolution that sets prefixes, comprehensive E2E tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-diagnostics-integration/42-RESEARCH.md
@.planning/phases/42-diagnostics-integration/42-01-SUMMARY.md
@crates/snow-typeck/src/ty.rs
@crates/snow-typeck/src/lib.rs
@crates/snow-typeck/src/infer.rs
@crates/snowc/src/main.rs
@crates/snowc/tests/e2e.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add display_prefix to TyCon and thread current_module through type checking</name>
  <files>
    crates/snow-typeck/src/ty.rs
    crates/snow-typeck/src/lib.rs
    crates/snow-typeck/src/infer.rs
    crates/snowc/src/main.rs
  </files>
  <action>
**Step 1: Modify TyCon in `crates/snow-typeck/src/ty.rs`**

Add a `display_prefix: Option<String>` field to `TyCon`. This field is display-only -- it MUST be excluded from `PartialEq` and `Hash` to preserve type identity semantics.

```rust
// Remove #[derive(PartialEq, Eq, Hash)] -- implement manually
#[derive(Clone, Debug)]
pub struct TyCon {
    pub name: String,
    /// Module origin for display in error messages (e.g., "Geometry").
    /// NOT used for type identity or codegen. Only affects Display output.
    pub display_prefix: Option<String>,
}

impl PartialEq for TyCon {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name  // display_prefix intentionally excluded
    }
}

impl Eq for TyCon {}

impl std::hash::Hash for TyCon {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.name.hash(state);  // display_prefix intentionally excluded
    }
}
```

Add a constructor method:
```rust
impl TyCon {
    pub fn new(name: impl Into<String>) -> Self {
        TyCon { name: name.into(), display_prefix: None }
    }

    pub fn with_module(name: impl Into<String>, module: impl Into<String>) -> Self {
        TyCon { name: name.into(), display_prefix: Some(module.into()) }
    }
}
```

Update `Display` impl:
```rust
impl fmt::Display for TyCon {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(prefix) = &self.display_prefix {
            write!(f, "{}.{}", prefix, self.name)
        } else {
            write!(f, "{}", self.name)
        }
    }
}
```

IMPORTANT: The existing `TyCon::new()` must set `display_prefix: None` so all existing code continues to work without changes. Only the import resolution path sets display_prefix.

**Step 2: Add `current_module` to `ImportContext` in `crates/snow-typeck/src/lib.rs`**

Add a field to `ImportContext`:
```rust
pub struct ImportContext {
    pub module_exports: FxHashMap<String, ModuleExports>,
    pub all_trait_defs: Vec<TraitDef>,
    pub all_trait_impls: Vec<TraitImplDef>,
    /// The name of the current module being type-checked (e.g., "Geometry").
    /// None for single-file mode (backward compat). Used to set display_prefix
    /// on locally-defined types.
    pub current_module: Option<String>,
}
```

Update `ImportContext::empty()` to set `current_module: None`. The Default derive should handle this automatically if Option<String> defaults to None.

**Step 3: Thread `current_module` in `crates/snow-typeck/src/infer.rs`**

In the `infer_with_imports` function (or wherever `ImportContext` is consumed to pre-seed the type checker):

a) Store `import_ctx.current_module` on `InferCtx` (or access it from the threaded `import_ctx`). The `InferCtx` already has fields like `qualified_modules` stored as context -- add `current_module: Option<String>` similarly.

b) When registering **imported** struct/sum types from another module, set the `display_prefix` on the `TyCon`:
   - Find where imported struct types are registered (approximately lines 1509-1515 of infer.rs where `Ty::struct_ty(&name, ...)` is called for imported structs).
   - When creating the `Ty::Con(TyCon::new(...))` for an imported type, use `TyCon::with_module(name, source_module_name)` instead of `TyCon::new(name)`.
   - The source module name is available from `ModuleExports.module_name`.

c) When registering **local** struct/sum types (during normal inference of struct/sum type definitions), if `current_module` is Some, set the `display_prefix` to the current module name:
   - Find where struct type constructors are created during `infer_item` for struct definitions.
   - If `self.current_module.is_some()`, wrap the TyCon with `display_prefix`.
   - Do NOT set display_prefix for builtin types (Int, String, Bool, Float, List, Map, Set, Option, Result, Ordering, Pid, Unit). These are registered in `builtins.rs` and should never have a prefix. Since builtins use `TyCon::new()` (which sets display_prefix: None), they are safe by default.

d) For **sum types**: Same pattern as structs. When registering imported sum type constructors and their variants, set `display_prefix` to the source module name.

e) For **local sum types**: If `current_module` is Some, set `display_prefix` on the TyCon.

IMPORTANT: Do NOT change how types are looked up in the TypeRegistry or how unification works. The `TyCon.name` field (used for equality/hashing) stays unqualified. Only `Display` is affected.

**Step 4: Thread `current_module` from build pipeline in `crates/snowc/src/main.rs`**

In the `build()` function where `ImportContext` is constructed for each module before calling `check_with_imports`:
- Set `import_ctx.current_module = Some(module_name.clone())` for multi-module builds.
- For single-file builds (backward compat path), `ImportContext::empty()` already has `current_module: None`.

The module name is already available in the build loop (it comes from `project.graph.modules[id].name`).
  </action>
  <verify>
Run `cargo build -p snow-typeck` and `cargo build -p snowc` to verify compilation. Run `cargo test -p snow-typeck` to verify all type checker tests pass (the display_prefix is None for all existing single-file tests, so output should be identical). Run `cargo test -p snowc` to verify all existing E2E tests pass.
  </verify>
  <done>
TyCon has display_prefix field with manual PartialEq/Hash excluding it. ImportContext has current_module field. Imported types get display_prefix set to source module name. Local types get display_prefix set to current module name (multi-module mode only). Builtins never have display_prefix. All existing tests pass with zero regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive multi-module E2E tests and module-qualified error tests</name>
  <files>crates/snowc/tests/e2e.rs</files>
  <action>
Add E2E tests to `crates/snowc/tests/e2e.rs` that validate the complete module system end-to-end and verify module-qualified type display in errors.

**Test 1: Comprehensive multi-module integration (Success Criterion 3)**

A realistic project with 3+ modules covering structs, traits, generics, and imports:

```
project/
  main.snow       -- imports Geometry, Utils, Math.Vector; calls functions, uses types
  geometry.snow   -- pub struct Point, pub fn make_point, pub fn point_sum
  math/vector.snow -- from Geometry import Point, make_point, point_sum; pub fn scaled_sum
  utils.snow      -- pub fn double
```

Use `compile_multifile_and_run` with these 4 files. Main calls `make_point(3, 4)`, then `Vector.scaled_sum(p, 2)` which computes `point_sum(p) * 2 = (3+4)*2 = 14`, then `double(14) = 28`. Assert output is `"28\n"`.

**Test 2: Cross-module type error shows module-qualified names (DIAG-02)**

Use `compile_multifile_expect_error` with a project where:
- `geometry.snow` defines `pub struct Point do x :: Int y :: Int end`
- `main.snow` imports Point from Geometry and tries to use it as a String (type mismatch)

Assert the error output contains `Geometry.Point` (the module-qualified type name). This validates DIAG-02.

**Test 3: File path appears in error output (DIAG-01 validation)**

Use `compile_multifile_expect_error` with a type error in a non-main module. Assert the error output contains the actual file path (e.g., `geometry.snow`) instead of `<unknown>`. This validates DIAG-01 in the multi-module context.

**Test 4: Single-file backward compatibility (DIAG-03)**

If not already covered by existing tests, add a test confirming a simple single-file program compiles and runs identically. Use `compile_and_run` with a basic program. This is likely already covered by the 103+ existing E2E tests, so only add if no existing test covers this exact scenario.

IMPORTANT: Use existing test helpers (`compile_multifile_and_run`, `compile_multifile_expect_error`). Do NOT create new test infrastructure. Follow the patterns established in Phase 39-41 E2E tests.

NOTE on Snow syntax: Closures use `fn x -> expr end` (NOT `|x| expr`). String interpolation uses `"${expr}"`. Functions are defined with `fn name(params) -> ReturnType do body end` or `fn name(params) do body end` (return type inferred). `println` takes a String argument.
  </action>
  <verify>
Run `cargo test -p snowc -- e2e` to verify all E2E tests pass. Specifically check:
- The comprehensive multi-module test produces expected output
- The module-qualified error test contains the module prefix in type names
- The file path error test contains the filename (not `<unknown>`)
- All 103+ existing E2E tests still pass
  </verify>
  <done>
Comprehensive multi-module E2E test passes with correct output. Module-qualified type names appear in cross-module error messages. File paths appear in diagnostics instead of `<unknown>`. All existing E2E tests pass with zero regressions. DIAG-01, DIAG-02, DIAG-03, and Success Criterion 3 are all validated.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p snow-typeck` -- all tests pass
2. `cargo test -p snowc` -- all tests pass (including new E2E tests)
3. `cargo build` -- full project builds successfully
4. Grep for `display_prefix` in ty.rs confirms the field exists
5. Grep for `current_module` in lib.rs confirms the field exists
6. The comprehensive multi-module test covers structs, cross-module function calls, nested module paths, and qualified access
7. Error message test confirms module-qualified type names appear
</verification>

<success_criteria>
- Type errors display module-qualified names (e.g., "Geometry.Point") for imported types
- Local types show module prefix in multi-module mode (e.g., "Main.Point")
- Builtins never show module prefix
- Single-file mode has no module prefix (backward compatible)
- Comprehensive 3+ module project compiles and runs correctly
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/42-diagnostics-integration/42-02-SUMMARY.md`
</output>
