---
phase: 33-while-loop-loop-control-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/snow-common/src/token.rs
  - crates/snow-parser/src/syntax_kind.rs
  - crates/snow-parser/src/ast/expr.rs
  - crates/snow-parser/src/parser/expressions.rs
  - crates/snow-typeck/src/infer.rs
  - crates/snow-typeck/src/ty.rs
autonomous: true

must_haves:
  truths:
    - "while, break, and continue are recognized as keywords by the lexer"
    - "Parser produces WHILE_EXPR, BREAK_EXPR, CONTINUE_EXPR CST nodes from source"
    - "Type checker infers while loops as Unit type, break/continue as Never type"
    - "break/continue outside a loop produces a compile-time error"
    - "break/continue inside a closure within a loop produces a compile-time error"
  artifacts:
    - path: "crates/snow-common/src/token.rs"
      provides: "While, Break, Continue TokenKind variants"
      contains: "While"
    - path: "crates/snow-parser/src/syntax_kind.rs"
      provides: "WHILE_KW, BREAK_KW, CONTINUE_KW, WHILE_EXPR, BREAK_EXPR, CONTINUE_EXPR"
      contains: "WHILE_EXPR"
    - path: "crates/snow-parser/src/ast/expr.rs"
      provides: "WhileExpr, BreakExpr, ContinueExpr AST wrappers and Expr enum variants"
      contains: "WhileExpr"
    - path: "crates/snow-parser/src/parser/expressions.rs"
      provides: "parse_while_expr, parse_break_expr, parse_continue_expr"
      contains: "parse_while_expr"
    - path: "crates/snow-typeck/src/infer.rs"
      provides: "infer_while, infer_break, infer_continue with loop_depth tracking"
      contains: "infer_while"
  key_links:
    - from: "crates/snow-common/src/token.rs"
      to: "crates/snow-parser/src/syntax_kind.rs"
      via: "From<TokenKind> impl mapping While->WHILE_KW etc."
      pattern: "TokenKind::While => SyntaxKind::WHILE_KW"
    - from: "crates/snow-parser/src/parser/expressions.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "WHILE_EXPR node kind produced by parser, cast by Expr::cast"
      pattern: "SyntaxKind::WHILE_EXPR"
    - from: "crates/snow-typeck/src/infer.rs"
      to: "crates/snow-parser/src/ast/expr.rs"
      via: "Expr::WhileExpr match arm dispatches to infer_while"
      pattern: "Expr::WhileExpr"
---

<objective>
Add while/break/continue keywords through the front half of the compiler pipeline: lexer, parser, AST, and type checker.

Purpose: Establish the language-level syntax and semantic validation for while loops and loop control flow. After this plan, Snow recognizes while/break/continue as valid syntax, produces typed AST nodes, and rejects break/continue outside loops or across closure boundaries.

Output: Keywords in lexer, CST node kinds, AST wrappers with accessor methods, parser functions, typeck inference with loop_depth tracking and BreakOutsideLoop/ContinueOutsideLoop error variants.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-while-loop-loop-control-flow/33-RESEARCH.md
@crates/snow-common/src/token.rs
@crates/snow-parser/src/syntax_kind.rs
@crates/snow-parser/src/ast/expr.rs
@crates/snow-parser/src/parser/expressions.rs
@crates/snow-typeck/src/infer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add while/break/continue keywords, CST nodes, AST wrappers, and parser</name>
  <files>
    crates/snow-common/src/token.rs
    crates/snow-parser/src/syntax_kind.rs
    crates/snow-parser/src/ast/expr.rs
    crates/snow-parser/src/parser/expressions.rs
  </files>
  <action>
**token.rs** -- Add 3 new keywords to TokenKind enum:
- Add `While`, `Break`, `Continue` variants in the Keywords section (after `With`). Update comment from "Keywords (45)" to "Keywords (48)".
- Add `"while" => Some(TokenKind::While)`, `"break" => Some(TokenKind::Break)`, `"continue" => Some(TokenKind::Continue)` to `keyword_from_str` match.
- Update tests: add the 3 new keyword entries to `keyword_from_str_recognizes_all_keywords` test array. Update keyword count assertion from 45 to 48. Update `token_kind_variant_count` test: keywords from 45 to 48, total from 93 to 96.

**syntax_kind.rs** -- Add keyword and node kind variants:
- Add `WHILE_KW`, `BREAK_KW`, `CONTINUE_KW` in the Keywords section (after `WITH_KW`). Update comment from "Keywords (45)" to "Keywords (48)".
- Add `WHILE_EXPR`, `BREAK_EXPR`, `CONTINUE_EXPR` in the Composite node kinds section (after `LIST_LITERAL`, before the Actor node kinds section).
- Add mapping in `From<TokenKind>` impl: `TokenKind::While => SyntaxKind::WHILE_KW`, `TokenKind::Break => SyntaxKind::BREAK_KW`, `TokenKind::Continue => SyntaxKind::CONTINUE_KW`.
- Update tests: add the 3 new TokenKind variants to `all_token_kinds_convert_to_syntax_kind` test. Update count assertion from 93 to 96. Add the 3 new node kinds to `syntax_kind_has_enough_variants` test. Update node kind count assertion from 76 to 79.

**expr.rs** -- Add AST wrapper types and Expr variants:
- Add `WhileExpr(WhileExpr)`, `BreakExpr(BreakExpr)`, `ContinueExpr(ContinueExpr)` variants to the `Expr` enum.
- Add `SyntaxKind::WHILE_EXPR => Some(Expr::WhileExpr(WhileExpr { syntax: node }))` and corresponding arms for BREAK_EXPR and CONTINUE_EXPR in `Expr::cast()`.
- Add `Expr::WhileExpr(n) => &n.syntax`, `Expr::BreakExpr(n) => &n.syntax`, `Expr::ContinueExpr(n) => &n.syntax` in `Expr::syntax()`.
- Add `ast_node!(WhileExpr, WHILE_EXPR)` with accessors: `condition() -> Option<Expr>` (first child Expr) and `body() -> Option<Block>` (child_node Block). Follow the IfExpr pattern exactly.
- Add `ast_node!(BreakExpr, BREAK_EXPR)` -- no accessors needed (just a keyword node).
- Add `ast_node!(ContinueExpr, CONTINUE_EXPR)` -- no accessors needed.

**expressions.rs** -- Add parser functions:
- Add `parse_while_expr` function modeled on `parse_if_expr`: open marker, advance past WHILE_KW, call `expr(p)` for condition, expect DO_KW (save span for error), call `parse_block_body(p)` for body, expect END_KW with error_with_related pointing back to `do` if missing, close with `SyntaxKind::WHILE_EXPR`.
- Add `parse_break_expr`: open marker, advance past BREAK_KW, close with `SyntaxKind::BREAK_EXPR`. No arguments.
- Add `parse_continue_expr`: open marker, advance past CONTINUE_KW, close with `SyntaxKind::CONTINUE_EXPR`. No arguments.
- In the `lhs()` function's match on `p.current()`, add: `SyntaxKind::WHILE_KW => Some(parse_while_expr(p))`, `SyntaxKind::BREAK_KW => Some(parse_break_expr(p))`, `SyntaxKind::CONTINUE_KW => Some(parse_continue_expr(p))`.
  </action>
  <verify>
Run `cargo test -p snow-common` -- all token tests pass with updated counts (48 keywords, 96 variants).
Run `cargo test -p snow-parser` -- all parser tests pass, no regressions.
  </verify>
  <done>
while/break/continue are lexed as keywords (not identifiers), parsed into WHILE_EXPR/BREAK_EXPR/CONTINUE_EXPR CST nodes, and have typed AST wrappers with condition()/body() accessors for WhileExpr.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add type checker inference for while/break/continue with loop-depth tracking</name>
  <files>
    crates/snow-typeck/src/infer.rs
    crates/snow-typeck/src/ty.rs
  </files>
  <action>
**ty.rs** -- Check if TypeError needs new variants. Add `BreakOutsideLoop` and `ContinueOutsideLoop` error variants to the `TypeError` enum if not already present:
```
BreakOutsideLoop { span: TextRange },
ContinueOutsideLoop { span: TextRange },
```
Add Display/diagnostic formatting for these in the existing impl (follow pattern of other error variants -- use ariadne to produce error like "E0030: `break` outside of loop" with span pointing to the break keyword, and similarly "E0031: `continue` outside of loop"). If the TypeError variants and error code numbering live elsewhere (check existing pattern), follow that.

Also add `BreakInClosure { span: TextRange }` and `ContinueInClosure { span: TextRange }` for the BRKC-05 case (break/continue inside a closure within a loop). Error messages: "E0032: `break` cannot cross closure boundary" and "E0033: `continue` cannot cross closure boundary".

**infer.rs** -- Use the wrapper approach to minimize signature churn:
1. Rename the existing `infer_expr` to `infer_expr_inner`, adding a `loop_depth: u32` parameter at the end of its signature.
2. Create a new `infer_expr` with the exact same signature as the old one (no loop_depth). Its body: `infer_expr_inner(ctx, env, expr, types, type_registry, trait_registry, fn_constraints, 0)`.
3. Similarly rename `infer_block` to `infer_block_inner` with `loop_depth: u32`, and create wrapper `infer_block` that calls `infer_block_inner(..., 0)`.
4. Inside `infer_expr_inner`, update all internal recursive calls to use `infer_expr_inner(..., loop_depth)` instead of `infer_expr(...)`. Similarly for `infer_block_inner`. The key rule: pass `loop_depth` unchanged for normal recursion, pass `loop_depth + 1` when entering a while body, and pass `0` when entering a closure body.
5. In the `infer_expr_inner` match, add:
   - `Expr::WhileExpr(w) => infer_while(ctx, env, w, types, type_registry, trait_registry, fn_constraints, loop_depth)?`
   - `Expr::BreakExpr(b) => infer_break(ctx, b, loop_depth)?`
   - `Expr::ContinueExpr(c) => infer_continue(ctx, c, loop_depth)?`

6. Implement `infer_while`:
   - If condition exists, infer it with `infer_expr_inner(..., loop_depth)`, unify with `Ty::bool()`.
   - If body exists, infer it with `infer_block_inner(..., loop_depth + 1)` (increment loop_depth!).
   - Return `Ok(Ty::Tuple(vec![]))` (Unit) regardless of body type. This is WHILE-03.

7. Implement `infer_break`:
   - If `loop_depth == 0`, push `TypeError::BreakOutsideLoop { span }` to ctx.errors. This is BRKC-04.
   - Return `Ok(Ty::Never)`. Break is a control flow transfer, type is Never (already unifies with anything).

8. Implement `infer_continue`:
   - If `loop_depth == 0`, push `TypeError::ContinueOutsideLoop { span }` to ctx.errors. This is BRKC-04.
   - Return `Ok(Ty::Never)`.

9. For BRKC-05 (closure boundary): In the code path that infers closure bodies (look for where `ClosureExpr` is handled -- it calls `infer_block` or `infer_expr` for the closure body), change those calls to use `infer_block_inner(..., 0)` or `infer_expr_inner(..., 0)`. This resets loop_depth to 0 inside closures, so break/continue inside a closure will hit the `loop_depth == 0` check and produce the appropriate error. For better error messages, instead of resetting to 0, you could use a sentinel value (e.g., a separate `in_closure_in_loop: bool` flag), but the simpler reset-to-0 approach produces the correct behavior (BreakOutsideLoop error) which is acceptable. If you want the more specific `BreakInClosure` error, track both `loop_depth` and `closure_depth_at_loop_entry` -- but the simpler approach is fine for v1.7.

IMPORTANT: The `infer_if` function and all other expression inference functions that recursively call `infer_expr` or `infer_block` must be updated to take `loop_depth` and pass it through. Since there are ~41 call sites for `infer_expr` and ~14 for `infer_block`, the recommended approach is:
- Helper functions like `infer_if`, `infer_binary`, `infer_call`, etc. should be updated to accept `loop_depth` and pass it to `infer_expr_inner`/`infer_block_inner`.
- Alternatively, keep using the wrapper `infer_expr`/`infer_block` (which pass 0) in functions that do NOT appear inside loop bodies. Only the paths reachable from within a while body need the `_inner` versions. In practice, any expression can appear inside a while body, so ALL recursive calls within `infer_expr_inner` should use `_inner` with `loop_depth`. This means updating all helper functions (infer_if, infer_binary, infer_call, infer_case, infer_return, infer_pipe, etc.) to accept and forward `loop_depth`.
  </action>
  <verify>
Run `cargo test -p snow-typeck` -- all existing tests pass (no regressions from the wrapper rename).
Run `cargo check` -- the entire workspace compiles without errors.
Write and run a quick typeck-level test (if the test infrastructure supports it) that verifies:
- `while true do 1 end` infers as Unit
- `break` at top level produces BreakOutsideLoop error
- `continue` at top level produces ContinueOutsideLoop error
  </verify>
  <done>
Type checker recognizes while/break/continue. While expressions infer as Unit (WHILE-03). Break/continue outside loops produce compile errors (BRKC-04). Closure bodies reset loop_depth to 0, so break/continue inside closures within loops produce errors (BRKC-05). All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p snow-common` passes (keyword counts updated)
- `cargo test -p snow-parser` passes (new node kinds, no regressions)
- `cargo test -p snow-typeck` passes (loop_depth threading, no regressions)
- `cargo check` on full workspace succeeds
</verification>

<success_criteria>
1. `while`, `break`, `continue` are recognized as keywords (not identifiers)
2. Parser produces WHILE_EXPR, BREAK_EXPR, CONTINUE_EXPR CST nodes
3. AST has WhileExpr with condition()/body() accessors
4. Typeck infers while as Unit, break/continue as Never
5. break/continue outside loops produce errors
6. break/continue inside closures within loops produce errors
7. All 1,255+ existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/33-while-loop-loop-control-flow/33-01-SUMMARY.md`
</output>
