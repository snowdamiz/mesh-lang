---
phase: 33-while-loop-loop-control-flow
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - crates/snow-codegen/src/mir/mod.rs
  - crates/snow-codegen/src/mir/lower.rs
  - crates/snow-codegen/src/codegen/mod.rs
  - crates/snow-codegen/src/codegen/expr.rs
  - crates/snow-fmt/src/walker.rs
  - tests/e2e/while_loop.snow
  - tests/e2e/break_continue.snow
  - tests/e2e/break_continue_errors.snow
autonomous: true

must_haves:
  truths:
    - "User can write `while condition do body end` and the body executes repeatedly while condition is true"
    - "A while loop whose condition is initially false executes zero times"
    - "User can write `break` inside a while loop to exit early"
    - "User can write `continue` inside a while loop to skip to the next iteration"
    - "A tight while loop does not starve other actors in the runtime"
    - "The formatter correctly formats while/break/continue expressions"
  artifacts:
    - path: "crates/snow-codegen/src/mir/mod.rs"
      provides: "MirExpr::While, MirExpr::Break, MirExpr::Continue variants"
      contains: "MirExpr::While"
    - path: "crates/snow-codegen/src/mir/lower.rs"
      provides: "lower_while_expr, lower_break, lower_continue MIR lowering"
      contains: "lower_while_expr"
    - path: "crates/snow-codegen/src/codegen/expr.rs"
      provides: "codegen_while, codegen_break, codegen_continue LLVM emission"
      contains: "codegen_while"
    - path: "crates/snow-codegen/src/codegen/mod.rs"
      provides: "loop_stack field on CodeGen struct"
      contains: "loop_stack"
    - path: "crates/snow-fmt/src/walker.rs"
      provides: "walk_while_expr, walk_break_expr, walk_continue_expr formatter support"
      contains: "walk_while_expr"
    - path: "tests/e2e/while_loop.snow"
      provides: "E2E tests for while loop execution"
    - path: "tests/e2e/break_continue.snow"
      provides: "E2E tests for break and continue"
  key_links:
    - from: "crates/snow-codegen/src/mir/lower.rs"
      to: "crates/snow-codegen/src/mir/mod.rs"
      via: "Lowerer produces MirExpr::While/Break/Continue from AST"
      pattern: "MirExpr::While"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "crates/snow-codegen/src/codegen/mod.rs"
      via: "codegen_while uses self.loop_stack for break/continue targets"
      pattern: "self\\.loop_stack"
    - from: "crates/snow-codegen/src/codegen/expr.rs"
      to: "snow_reduction_check"
      via: "emit_reduction_check at loop back-edge"
      pattern: "emit_reduction_check"
---

<objective>
Complete the while/break/continue implementation through MIR lowering, LLVM codegen, and formatter, then validate with end-to-end tests.

Purpose: After plan 01 established parsing and type checking, this plan wires the backend: MIR representation, LLVM IR emission with proper basic block structure (cond_check/body/merge), loop_stack for break/continue targets, reduction checks at back-edges for scheduler fairness, and formatter support. E2E tests validate all 8 requirements.

Output: Working while loops with break/continue, reduction checks, formatter support, and comprehensive e2e tests covering WHILE-01, WHILE-02, WHILE-03, BRKC-01, BRKC-02, BRKC-04, BRKC-05, RTIM-01.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/33-while-loop-loop-control-flow/33-RESEARCH.md
@.planning/phases/33-while-loop-loop-control-flow/33-01-SUMMARY.md
@crates/snow-codegen/src/mir/mod.rs
@crates/snow-codegen/src/mir/lower.rs
@crates/snow-codegen/src/codegen/mod.rs
@crates/snow-codegen/src/codegen/expr.rs
@crates/snow-fmt/src/walker.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MIR variants, lowering, LLVM codegen with loop_stack, and formatter</name>
  <files>
    crates/snow-codegen/src/mir/mod.rs
    crates/snow-codegen/src/mir/lower.rs
    crates/snow-codegen/src/codegen/mod.rs
    crates/snow-codegen/src/codegen/expr.rs
    crates/snow-fmt/src/walker.rs
  </files>
  <action>
**mir/mod.rs** -- Add MIR expression variants:
1. Add to the `MirExpr` enum (after `SupervisorStart` or in a new "Loop primitives" section):
   ```
   /// While loop: evaluates condition, if true executes body and repeats. Returns Unit.
   While {
       cond: Box<MirExpr>,
       body: Box<MirExpr>,
       ty: MirType,  // Always MirType::Unit
   },
   /// Break: exit the innermost enclosing loop.
   Break,
   /// Continue: skip to the next iteration of the innermost enclosing loop.
   Continue,
   ```
2. Add arms to `MirExpr::ty()`:
   - `MirExpr::While { ty, .. } => ty`
   - `MirExpr::Break => &MirType::Never`
   - `MirExpr::Continue => &MirType::Never`

**mir/lower.rs** -- Add MIR lowering:
1. In the `lower_expr` method's match on `Expr` variants, add:
   - `Expr::WhileExpr(w) => self.lower_while_expr(w)`
   - `Expr::BreakExpr(_) => MirExpr::Break`
   - `Expr::ContinueExpr(_) => MirExpr::Continue`
2. Implement `lower_while_expr(&mut self, w: &WhileExpr) -> MirExpr`:
   - Lower condition: `w.condition().map(|e| self.lower_expr(&e)).unwrap_or(MirExpr::BoolLit(true, MirType::Bool))`
   - Lower body: `w.body().map(|b| self.lower_block(&b)).unwrap_or(MirExpr::Unit)`
   - Return `MirExpr::While { cond: Box::new(cond), body: Box::new(body), ty: MirType::Unit }`
3. Add a `lower_while_expr` unit test following the `lower_if_expr` test pattern: parse `fn test() do while true do 1 end end`, verify the function body is `MirExpr::While { .. }`.

**codegen/mod.rs** -- Add loop_stack field:
1. Add to the `CodeGen` struct: `pub(crate) loop_stack: Vec<(inkwell::basic_block::BasicBlock<'ctx>, inkwell::basic_block::BasicBlock<'ctx>)>` (each entry is `(cond_bb, merge_bb)`). Add the import for `BasicBlock` if not already present.
2. Initialize `loop_stack: Vec::new()` in the `CodeGen::new()` constructor.

**codegen/expr.rs** -- Add codegen for while/break/continue:
1. In `codegen_expr` match, add:
   - `MirExpr::While { cond, body, ty } => self.codegen_while(cond, body, ty)`
   - `MirExpr::Break => self.codegen_break()`
   - `MirExpr::Continue => self.codegen_continue()`
2. Implement `codegen_while(&mut self, cond: &MirExpr, body: &MirExpr, ty: &MirType) -> Result<BasicValueEnum<'ctx>, String>`:
   - Get current function: `self.current_fn.unwrap()`
   - Create 3 basic blocks: `while_cond`, `while_body`, `while_merge`
   - Push `(while_cond, while_merge)` onto `self.loop_stack`
   - Build unconditional branch from current block to `while_cond`
   - Position at `while_cond`, codegen the condition, build conditional branch: if true -> `while_body`, if false -> `while_merge`
   - Position at `while_body`, codegen the body expression
   - After body codegen, check if block is NOT terminated (break/continue may have terminated it): if `self.builder.get_insert_block().unwrap().get_terminator().is_none()`, emit `self.emit_reduction_check()` then build unconditional branch to `while_cond` (the back-edge)
   - Pop from `self.loop_stack`
   - Position at `while_merge`
   - Return Unit value: `self.context.struct_type(&[], false).const_zero().into()`
3. Implement `codegen_break(&mut self) -> Result<BasicValueEnum<'ctx>, String>`:
   - Get `(_, merge_bb)` from `self.loop_stack.last()`. If empty, return `Err("break outside loop")` (defensive -- typeck should have caught this).
   - Build unconditional branch to `merge_bb`
   - Return Unit dummy value (unreachable code)
4. Implement `codegen_continue(&mut self) -> Result<BasicValueEnum<'ctx>, String>`:
   - Get `(cond_bb, _)` from `self.loop_stack.last()`. If empty, return `Err("continue outside loop")`.
   - Emit `self.emit_reduction_check()` (continue is also a back-edge -- it jumps to condition check)
   - Build unconditional branch to `cond_bb`
   - Return Unit dummy value

CRITICAL: After break or continue in a block of expressions, subsequent expressions in the same block will try to emit code into a terminated block. The existing `codegen_block` must handle this. Check if `codegen_block` already skips expressions after a terminator. If not, add a check: in the loop over block expressions, after codegen-ing each expression, check if the current block has a terminator -- if so, skip remaining expressions. The existing pattern for `MirExpr::Return` already deals with this (Return emits a ret instruction which terminates the block), so verify the block codegen handles it correctly.

**walker.rs** -- Add formatter support:
1. In the `walk_node` match, add:
   - `SyntaxKind::WHILE_EXPR => walk_while_expr(node)`
   - `SyntaxKind::BREAK_EXPR => walk_break_expr(node)`
   - `SyntaxKind::CONTINUE_EXPR => walk_continue_expr(node)`
2. Implement `walk_while_expr(node: &SyntaxNode) -> FormatIR`:
   - Model on `walk_if_expr` but simpler (no else branch).
   - Iterate `node.children_with_tokens()`. For `WHILE_KW` emit `text("while")`, for condition expr (non-trivia child node before DO_KW) emit `sp()` + `walk_node(n)`, for `DO_KW` emit `sp()` + `text("do")`, for `BLOCK` emit `indent(walk_node(...))`, for `END_KW` emit `nl()` + `text("end")`. Skip trivia.
   - Wrap in `group(parts)`.
3. Implement `walk_break_expr(node: &SyntaxNode) -> FormatIR`:
   - Just emit `text("break")`. It's a single keyword with no children.
4. Implement `walk_continue_expr(node: &SyntaxNode) -> FormatIR`:
   - Just emit `text("continue")`.
  </action>
  <verify>
Run `cargo test -p snow-codegen` -- all MIR lowering tests and codegen tests pass.
Run `cargo test -p snow-fmt` -- formatter tests pass.
Run `cargo check` -- full workspace compiles.
  </verify>
  <done>
MIR has While/Break/Continue variants. Lowerer converts AST to MIR. Codegen emits correct LLVM basic block structure (cond_check/body/merge) with reduction checks at back-edges. CodeGen has loop_stack for nested loop support. Formatter handles while/break/continue syntax.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end tests for all phase requirements</name>
  <files>
    tests/e2e/while_loop.snow
    tests/e2e/break_continue.snow
    tests/e2e/break_continue_errors.snow
  </files>
  <action>
Create e2e test files that compile and run Snow programs. Follow the existing e2e test pattern (check a few existing .snow files in tests/e2e/ to see how they are structured -- likely they are Snow source files that get compiled and run, with output assertions).

**tests/e2e/while_loop.snow** -- Tests WHILE-01, WHILE-02, WHILE-03:
```snow
# WHILE-01: Basic while loop -- body executes while condition is true
let x = 0
let count = 0
# Use a mutable approach: Snow likely uses let rebinding or some mutation pattern
# Check how existing tests handle state mutation -- if Snow has no mutation,
# use a recursive approach or check if while loops support variable reassignment.
# Based on the research showing `while x > 0 do x = x - 1 end`, assignment exists.

# Test 1: While loop counts down
let i = 5
let sum = 0
while i > 0 do
  sum = sum + i
  i = i - 1
end
IO.println(sum)  # Expected: 15 (5+4+3+2+1)

# WHILE-02: Condition initially false -- body executes zero times
let ran = false
while false do
  ran = true
end
IO.println(ran)  # Expected: false

# WHILE-03: While returns Unit
let result = while false do 42 end
IO.println("done")  # Expected: "done" (no type error from while-as-expression)
```

Adjust syntax to match actual Snow conventions (check existing e2e tests for IO.println vs puts vs print patterns, assignment syntax, boolean literals, etc.).

**tests/e2e/break_continue.snow** -- Tests BRKC-01, BRKC-02:
```snow
# BRKC-01: Break exits the loop early
let i = 0
while true do
  if i == 5 do
    break
  end
  i = i + 1
end
IO.println(i)  # Expected: 5

# BRKC-02: Continue skips to next iteration
let i = 0
let sum = 0
while i < 10 do
  i = i + 1
  if i % 2 == 0 do
    continue
  end
  sum = sum + i
end
IO.println(sum)  # Expected: 25 (1+3+5+7+9)

# Nested while loops with break
let outer = 0
while outer < 3 do
  let inner = 0
  while true do
    if inner == 2 do
      break
    end
    inner = inner + 1
  end
  outer = outer + 1
end
IO.println(outer)  # Expected: 3 (break only exits inner loop)
```

**tests/e2e/break_continue_errors.snow** -- Tests BRKC-04, BRKC-05:
This file tests compile-time error cases. Check how the existing test harness handles expected-error tests. If the test runner checks for compile failures, create negative test cases:
- `break` at top level (outside any loop) -- should produce compile error
- `continue` at top level -- should produce compile error
- `break` inside a closure inside a loop -- should produce compile error:
  ```snow
  while true do
    let f = fn -> break end
  end
  ```
- `continue` inside a closure inside a loop -- should produce compile error

If the test harness does not support expected-error tests natively, add these as unit tests in the typeck crate instead (e.g., in `infer.rs` test module), parsing the source, running typeck, and asserting the error variant. Follow existing patterns for typeck error tests.

**RTIM-01 validation:** The reduction check is structural (emitted at every back-edge in codegen). Verify by:
1. Checking the LLVM IR output (if possible) for `snow_reduction_check` calls inside while loop bodies.
2. Or running the actors_preemption.snow test to confirm no regression -- it already validates that the scheduler remains responsive.
3. Optionally create a test with two actors where one runs a tight while loop and the other sends a message -- the receiving actor should still get the message.

Run the full test suite: `cargo test` across all crates.
  </action>
  <verify>
Run `cargo test` across entire workspace -- all 1,255+ existing tests pass.
Run the new e2e tests:
- `while_loop.snow` outputs 15, false, "done"
- `break_continue.snow` outputs 5, 25, 3
- `break_continue_errors.snow` produces compile errors for break/continue misuse
  </verify>
  <done>
All 8 requirements validated:
- WHILE-01: while loop body executes while condition is true (while_loop.snow test 1)
- WHILE-02: body executes zero times if condition initially false (while_loop.snow test 2)
- WHILE-03: while returns Unit (while_loop.snow test 3)
- BRKC-01: break exits innermost loop (break_continue.snow test 1)
- BRKC-02: continue skips to next iteration (break_continue.snow test 2)
- BRKC-04: break/continue outside loop = compile error (break_continue_errors.snow)
- BRKC-05: break/continue inside closure within loop = compile error (break_continue_errors.snow)
- RTIM-01: reduction check at back-edges (structural -- emitted in codegen_while and codegen_continue)
  </done>
</task>

</tasks>

<verification>
- `cargo test` -- full workspace passes (1,255+ existing tests + new tests)
- E2E: `while_loop.snow` compiles and runs correctly
- E2E: `break_continue.snow` compiles and runs correctly
- E2E: `break_continue_errors.snow` produces expected compile errors
- No actor scheduler starvation in tight loops (reduction check at back-edges)
</verification>

<success_criteria>
1. `while condition do body end` executes body repeatedly while condition is true
2. While loop with initially-false condition executes zero times
3. While expression has type Unit
4. `break` exits innermost loop; `continue` skips to next iteration
5. Nested loops: break/continue target innermost loop only
6. break/continue outside loop = compile error
7. break/continue inside closure within loop = compile error
8. Tight while loops emit reduction checks at back-edges
9. Formatter correctly formats while/break/continue syntax
10. All 1,255+ existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/33-while-loop-loop-control-flow/33-02-SUMMARY.md`
</output>
