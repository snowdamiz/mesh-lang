---
phase: 92-alerting-system
plan: 03
type: execute
wave: 2
depends_on: ["92-01"]
files_modified:
  - mesher/api/alerts.mpl
  - mesher/main.mpl
autonomous: true

must_haves:
  truths:
    - "User can create alert rules via POST /api/v1/projects/:project_id/alert-rules with JSON body containing name, condition, cooldown_minutes"
    - "User can list alert rules via GET /api/v1/projects/:project_id/alert-rules"
    - "User can toggle, delete alert rules via POST endpoints"
    - "User can list alerts via GET /api/v1/projects/:project_id/alerts"
    - "User can acknowledge alerts via POST /api/v1/alerts/:id/acknowledge"
    - "User can resolve alerts via POST /api/v1/alerts/:id/resolve"
  artifacts:
    - path: "mesher/api/alerts.mpl"
      provides: "All alert HTTP route handlers"
      contains: "handle_create_alert_rule"
      min_lines: 80
    - path: "mesher/main.mpl"
      provides: "Alert routes registered in HTTP router pipe chain"
      contains: "handle_create_alert_rule"
  key_links:
    - from: "mesher/api/alerts.mpl"
      to: "mesher/storage/queries.mpl"
      via: "import create_alert_rule, list_alert_rules, toggle_alert_rule, delete_alert_rule, list_alerts, acknowledge_alert, resolve_fired_alert"
      pattern: "from Storage.Queries import"
    - from: "mesher/api/alerts.mpl"
      to: "mesher/api/helpers.mpl"
      via: "import require_param, query_or_default, to_json_array"
      pattern: "from Api.Helpers import"
    - from: "mesher/main.mpl"
      to: "mesher/api/alerts.mpl"
      via: "import and pipe chain registration of all alert route handlers"
      pattern: "from Api.Alerts import"
---

<objective>
Create HTTP API routes for alert rule CRUD and alert state management.

Purpose: Users need API endpoints to create/list/toggle/delete alert rules (ALERT-01) and manage fired alert states (ALERT-06). This plan creates a new api/alerts.mpl module with route handlers and registers all routes in main.mpl.
Output: New mesher/api/alerts.mpl with 7 route handlers, updated main.mpl with 7 new routes in the pipe chain.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/92-alerting-system/92-RESEARCH.md
@.planning/phases/92-alerting-system/92-01-SUMMARY.md
@mesher/api/helpers.mpl
@mesher/api/team.mpl
@mesher/main.mpl
@mesher/storage/queries.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create api/alerts.mpl with alert route handlers</name>
  <files>mesher/api/alerts.mpl</files>
  <action>
  Create a NEW file mesher/api/alerts.mpl with HTTP route handlers for alert rule CRUD and alert state management.

  Follow the established patterns from api/team.mpl and ingestion/routes.mpl:
  - PipelineRegistry.get_pool via Process.whereis("mesher_registry") for pool access
  - require_param for path parameters, query_or_default for optional query params
  - Single-expression case arms with extracted helper functions (decision [88-02])
  - POST routes for all mutations (decision [89-02])
  - Bottom-up function ordering (decision [90-03])
  - Raw Map rows serialized to JSON via to_json_array helper (decision [91-01])

  File structure (define-before-use order):

  ```mesh
  # HTTP route handlers for alert rule management and alert state management.
  # Alert rules define conditions for automated notifications (ALERT-01).
  # Fired alerts have a lifecycle: active -> acknowledged -> resolved (ALERT-06).

  from Ingestion.Pipeline import PipelineRegistry
  from Storage.Queries import create_alert_rule, list_alert_rules, toggle_alert_rule, delete_alert_rule, list_alerts, acknowledge_alert, resolve_fired_alert
  from Api.Helpers import require_param, query_or_default, to_json_array

  # --- Helper functions (defined before handlers) ---

  # Serialize a single alert rule Map row to JSON string.
  fn rule_row_to_json(row) -> String do
    "{\"id\":\"" <> Map.get(row, "id") <> "\",\"project_id\":\"" <> Map.get(row, "project_id") <> "\",\"name\":\"" <> Map.get(row, "name") <> "\",\"condition\":" <> Map.get(row, "condition_json") <> ",\"action\":" <> Map.get(row, "action_json") <> ",\"enabled\":" <> Map.get(row, "enabled") <> ",\"cooldown_minutes\":" <> Map.get(row, "cooldown_minutes") <> ",\"last_fired_at\":" <> format_nullable_ts(Map.get(row, "last_fired_at")) <> ",\"created_at\":\"" <> Map.get(row, "created_at") <> "\"}"
  end
  ```

  NOTE: `format_nullable_ts` must be defined BEFORE rule_row_to_json. Add it first:

  ```mesh
  # Format nullable timestamp: empty string -> JSON null, otherwise quoted string.
  fn format_nullable_ts(ts :: String) -> String do
    if String.length(ts) > 0 do
      "\"" <> ts <> "\""
    else
      "null"
    end
  end
  ```

  Then add alert row serializer:

  ```mesh
  # Serialize a single alert Map row to JSON string.
  fn alert_row_to_json(row) -> String do
    "{\"id\":\"" <> Map.get(row, "id") <> "\",\"rule_id\":\"" <> Map.get(row, "rule_id") <> "\",\"project_id\":\"" <> Map.get(row, "project_id") <> "\",\"status\":\"" <> Map.get(row, "status") <> "\",\"message\":\"" <> Map.get(row, "message") <> "\",\"condition_snapshot\":" <> Map.get(row, "condition_snapshot") <> ",\"triggered_at\":\"" <> Map.get(row, "triggered_at") <> "\",\"acknowledged_at\":" <> format_nullable_ts(Map.get(row, "acknowledged_at")) <> ",\"resolved_at\":" <> format_nullable_ts(Map.get(row, "resolved_at")) <> ",\"rule_name\":\"" <> Map.get(row, "rule_name") <> "\"}"
  end
  ```

  Now add the route handlers (pub functions last, per define-before-use):

  **1. handle_create_alert_rule** -- POST /api/v1/projects/:project_id/alert-rules (ALERT-01):
  ```mesh
  pub fn handle_create_alert_rule(request) do
    let reg_pid = Process.whereis("mesher_registry")
    let pool = PipelineRegistry.get_pool(reg_pid)
    let project_id = require_param(request, "project_id")
    let body = Request.body(request)
    let result = create_alert_rule(pool, project_id, body)
    case result do
      Ok(id) -> HTTP.response(201, "{\"id\":\"" <> id <> "\"}")
      Err(e) -> HTTP.response(400, "{\"error\":\"" <> e <> "\"}")
    end
  end
  ```

  **2. handle_list_alert_rules** -- GET /api/v1/projects/:project_id/alert-rules (ALERT-01):
  ```mesh
  pub fn handle_list_alert_rules(request) do
    let reg_pid = Process.whereis("mesher_registry")
    let pool = PipelineRegistry.get_pool(reg_pid)
    let project_id = require_param(request, "project_id")
    let result = list_alert_rules(pool, project_id)
    case result do
      Ok(rows) -> HTTP.response(200, rows |> List.map(fn(row) do rule_row_to_json(row) end) |> to_json_array())
      Err(e) -> HTTP.response(500, "{\"error\":\"" <> e <> "\"}")
    end
  end
  ```

  **3. handle_toggle_alert_rule** -- POST /api/v1/alert-rules/:rule_id/toggle (ALERT-01):
  ```mesh
  pub fn handle_toggle_alert_rule(request) do
    let reg_pid = Process.whereis("mesher_registry")
    let pool = PipelineRegistry.get_pool(reg_pid)
    let rule_id = require_param(request, "rule_id")
    let body = Request.body(request)
    let rows_result = Pool.query(pool, "SELECT COALESCE($1::jsonb->>'enabled', 'true') AS enabled", [body])
    case rows_result do
      Ok(rows) -> toggle_from_rows(pool, rule_id, rows)
      Err(e) -> HTTP.response(400, "{\"error\":\"invalid json\"}")
    end
  end
  ```

  Add toggle_from_rows helper BEFORE handle_toggle_alert_rule:
  ```mesh
  fn toggle_from_rows(pool :: PoolHandle, rule_id :: String, rows) do
    if List.length(rows) > 0 do
      let enabled_str = Map.get(List.head(rows), "enabled")
      let result = toggle_alert_rule(pool, rule_id, enabled_str)
      case result do
        Ok(n) -> HTTP.response(200, "{\"status\":\"ok\",\"affected\":" <> String.from(n) <> "}")
        Err(e) -> HTTP.response(500, "{\"error\":\"" <> e <> "\"}")
      end
    else
      HTTP.response(400, "{\"error\":\"invalid body\"}")
    end
  end
  ```

  **4. handle_delete_alert_rule** -- POST /api/v1/alert-rules/:rule_id/delete (ALERT-01):
  ```mesh
  pub fn handle_delete_alert_rule(request) do
    let reg_pid = Process.whereis("mesher_registry")
    let pool = PipelineRegistry.get_pool(reg_pid)
    let rule_id = require_param(request, "rule_id")
    let result = delete_alert_rule(pool, rule_id)
    case result do
      Ok(n) -> HTTP.response(200, "{\"status\":\"ok\",\"affected\":" <> String.from(n) <> "}")
      Err(e) -> HTTP.response(500, "{\"error\":\"" <> e <> "\"}")
    end
  end
  ```

  **5. handle_list_alerts** -- GET /api/v1/projects/:project_id/alerts (ALERT-06):
  ```mesh
  pub fn handle_list_alerts(request) do
    let reg_pid = Process.whereis("mesher_registry")
    let pool = PipelineRegistry.get_pool(reg_pid)
    let project_id = require_param(request, "project_id")
    let status = query_or_default(request, "status", "")
    let result = list_alerts(pool, project_id, status)
    case result do
      Ok(rows) -> HTTP.response(200, rows |> List.map(fn(row) do alert_row_to_json(row) end) |> to_json_array())
      Err(e) -> HTTP.response(500, "{\"error\":\"" <> e <> "\"}")
    end
  end
  ```

  **6. handle_acknowledge_alert** -- POST /api/v1/alerts/:id/acknowledge (ALERT-06):
  ```mesh
  pub fn handle_acknowledge_alert(request) do
    let reg_pid = Process.whereis("mesher_registry")
    let pool = PipelineRegistry.get_pool(reg_pid)
    let alert_id = require_param(request, "id")
    let result = acknowledge_alert(pool, alert_id)
    case result do
      Ok(n) -> HTTP.response(200, "{\"status\":\"ok\",\"affected\":" <> String.from(n) <> "}")
      Err(e) -> HTTP.response(500, "{\"error\":\"" <> e <> "\"}")
    end
  end
  ```

  **7. handle_resolve_alert** -- POST /api/v1/alerts/:id/resolve (ALERT-06):
  ```mesh
  pub fn handle_resolve_alert(request) do
    let reg_pid = Process.whereis("mesher_registry")
    let pool = PipelineRegistry.get_pool(reg_pid)
    let alert_id = require_param(request, "id")
    let result = resolve_fired_alert(pool, alert_id)
    case result do
      Ok(n) -> HTTP.response(200, "{\"status\":\"ok\",\"affected\":" <> String.from(n) <> "}")
      Err(e) -> HTTP.response(500, "{\"error\":\"" <> e <> "\"}")
    end
  end
  ```

  COMPLETE FILE ORDER (top to bottom, define-before-use):
  1. Module comment
  2. Imports (PipelineRegistry, Storage.Queries functions, Api.Helpers)
  3. format_nullable_ts
  4. rule_row_to_json
  5. alert_row_to_json
  6. toggle_from_rows
  7. handle_create_alert_rule (pub)
  8. handle_list_alert_rules (pub)
  9. handle_toggle_alert_rule (pub)
  10. handle_delete_alert_rule (pub)
  11. handle_list_alerts (pub)
  12. handle_acknowledge_alert (pub)
  13. handle_resolve_alert (pub)

  IMPORTANT:
  - condition_json and action_json are JSONB stored as text -- embed raw (not double-quoted) in JSON response, same as DETAIL-02 pattern (decision [91-02])
  - enabled is boolean stored as text ("true"/"false") -- embed raw in JSON response
  - cooldown_minutes is integer stored as text -- embed raw in JSON response
  - Use pipe chain for list serialization (rows |> List.map(fn(row) do ... end) |> to_json_array()) per Phase 91.1 pattern
  </action>
  <verify>Run `meshc build mesher/` and confirm zero new compilation errors beyond the 7 pre-existing ones. Verify api/alerts.mpl exists with all 7 pub handler functions. Grep for "handle_create_alert_rule", "handle_acknowledge_alert", "handle_resolve_alert".</verify>
  <done>7 route handlers exist in api/alerts.mpl: create alert rule (POST, 201), list alert rules (GET), toggle alert rule (POST), delete alert rule (POST), list alerts (GET with optional status filter), acknowledge alert (POST), resolve alert (POST). All follow established patterns with PipelineRegistry lookup, require_param, single-expression case arms.</done>
</task>

<task type="auto">
  <name>Task 2: Register alert routes in main.mpl</name>
  <files>mesher/main.mpl</files>
  <action>
  Update main.mpl to import alert handlers and register all 7 alert routes in the HTTP router pipe chain.

  1. Add import line AFTER the existing Api.Team import:
     ```mesh
     from Api.Alerts import handle_create_alert_rule, handle_list_alert_rules, handle_toggle_alert_rule, handle_delete_alert_rule, handle_list_alerts, handle_acknowledge_alert, handle_resolve_alert
     ```

  2. Add 7 new routes to the HTTP.serve pipe chain, AFTER the existing api-keys/revoke route (line 93 area) and BEFORE the closing )), 8080):
     ```mesh
     |> HTTP.on_get("/api/v1/projects/:project_id/alert-rules", handle_list_alert_rules)
     |> HTTP.on_post("/api/v1/projects/:project_id/alert-rules", handle_create_alert_rule)
     |> HTTP.on_post("/api/v1/alert-rules/:rule_id/toggle", handle_toggle_alert_rule)
     |> HTTP.on_post("/api/v1/alert-rules/:rule_id/delete", handle_delete_alert_rule)
     |> HTTP.on_get("/api/v1/projects/:project_id/alerts", handle_list_alerts)
     |> HTTP.on_post("/api/v1/alerts/:id/acknowledge", handle_acknowledge_alert)
     |> HTTP.on_post("/api/v1/alerts/:id/resolve", handle_resolve_alert)
     ```

  IMPORTANT:
  - Follow the existing parenthesized pipe chain pattern (decision [91.1-02])
  - No comments between pipe steps (they break parsing, decision [91.1-02])
  - GET for listing (alert-rules, alerts), POST for all mutations (create, toggle, delete, acknowledge, resolve) per decision [89-02]
  - The router pipe chain is inlined into HTTP.serve() (decision [91.1-02])
  </action>
  <verify>Run `meshc build mesher/` and confirm zero new compilation errors beyond the 7 pre-existing ones. Grep main.mpl for "handle_create_alert_rule", "handle_acknowledge_alert", "Api.Alerts" to confirm imports and route registration.</verify>
  <done>main.mpl imports all 7 alert handlers from Api.Alerts and registers them in the HTTP router pipe chain with correct HTTP methods and URL patterns. Total routes: 33 (26 existing + 7 new).</done>
</task>

</tasks>

<verification>
1. `meshc build mesher/` compiles with no new errors (7 pre-existing max)
2. api/alerts.mpl exists as a new file with 7 pub handler functions
3. main.mpl imports from Api.Alerts
4. main.mpl router pipe chain contains all 7 alert routes
5. Alert rule CRUD: POST create (201), GET list, POST toggle, POST delete
6. Alert state management: GET list with status filter, POST acknowledge, POST resolve
7. JSON serialization: condition_json and action_json embedded raw (not double-quoted)
</verification>

<success_criteria>
All alert HTTP API routes are registered and handlers are implemented. Users can create, list, toggle, and delete alert rules (ALERT-01). Users can list, acknowledge, and resolve fired alerts (ALERT-06). All routes follow established Mesher patterns.
</success_criteria>

<output>
After completion, create `.planning/phases/92-alerting-system/92-03-SUMMARY.md`
</output>
