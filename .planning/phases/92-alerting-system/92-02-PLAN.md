---
phase: 92-alerting-system
plan: 02
type: execute
wave: 2
depends_on: ["92-01"]
files_modified:
  - mesher/ingestion/pipeline.mpl
  - mesher/ingestion/routes.mpl
autonomous: true

must_haves:
  truths:
    - "A single timer-driven alert_evaluator actor loads all enabled threshold rules every 30 seconds and fires alerts when event count exceeds threshold and cooldown has elapsed"
    - "After event processing, the system checks for new-issue and regression alert rules and fires matching alerts"
    - "Fired alerts are broadcast via Ws.broadcast to the project WebSocket room"
    - "Cooldown is enforced via should_fire_by_cooldown check before any alert fires (both timer and event-based)"
  artifacts:
    - path: "mesher/ingestion/pipeline.mpl"
      provides: "alert_evaluator actor, evaluation loop, log helpers, spawn in start_pipeline"
      contains: "alert_evaluator"
    - path: "mesher/ingestion/routes.mpl"
      provides: "Event-based alert checking (new issue, regression) after event processing, broadcast_alert helper"
      contains: "check_event_alerts"
  key_links:
    - from: "mesher/ingestion/pipeline.mpl"
      to: "mesher/storage/queries.mpl"
      via: "import get_threshold_rules, evaluate_threshold_rule, fire_alert"
      pattern: "from Storage.Queries import.*get_threshold_rules"
    - from: "mesher/ingestion/routes.mpl"
      to: "mesher/storage/queries.mpl"
      via: "import check_new_issue, get_event_alert_rules, should_fire_by_cooldown, fire_alert"
      pattern: "from Storage.Queries import.*check_new_issue"
    - from: "mesher/ingestion/pipeline.mpl"
      to: "Ws.broadcast"
      via: "broadcast_alert helper in pipeline.mpl"
      pattern: "Ws.broadcast"
    - from: "mesher/ingestion/routes.mpl"
      to: "Ws.broadcast"
      via: "broadcast_alert helper in routes.mpl"
      pattern: "Ws.broadcast"
---

<objective>
Implement the alert evaluation engine: a timer-driven evaluator actor for threshold-based alerts and inline event-based alert triggers for new issue creation and regression detection.

Purpose: This is the core alert evaluation logic -- without it, alert rules are just data. The evaluator actor periodically checks threshold rules, and the event-based triggers fire alerts on new issues and regressions. Both paths enforce cooldown (ALERT-05) and broadcast via WebSocket (ALERT-04).
Output: alert_evaluator actor in pipeline.mpl, event-based alert checking in routes.mpl, WebSocket alert broadcast helpers.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/92-alerting-system/92-RESEARCH.md
@.planning/phases/92-alerting-system/92-01-SUMMARY.md
@mesher/ingestion/pipeline.mpl
@mesher/ingestion/routes.mpl
@mesher/storage/queries.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Alert evaluator actor in pipeline.mpl</name>
  <files>mesher/ingestion/pipeline.mpl</files>
  <action>
  Extend pipeline.mpl to add the timer-driven alert evaluator for ALERT-02 (threshold-based alerts).

  1. Add imports at the top of pipeline.mpl (alongside existing `from Storage.Queries import check_volume_spikes`):
     ```mesh
     from Storage.Queries import get_threshold_rules, evaluate_threshold_rule, fire_alert
     ```
     (Extend the existing import line to include these three functions.)

  2. Add helper functions BEFORE the alert_evaluator actor definition (define-before-use, decision [90-03]).

     **broadcast_alert** -- Broadcast alert notification to project WebSocket room (ALERT-04):
     ```mesh
     fn broadcast_alert(project_id :: String, alert_id :: String, rule_name :: String, condition_type :: String, message :: String) do
       let room = "project:" <> project_id
       let msg = "{\"type\":\"alert\",\"alert_id\":\"" <> alert_id <> "\",\"rule_name\":\"" <> rule_name <> "\",\"condition\":\"" <> condition_type <> "\",\"message\":\"" <> message <> "\"}"
       let _ = Ws.broadcast(room, msg)
       0
     end
     ```

     **fire_and_broadcast** -- Fire alert record then broadcast (combines fire_alert + broadcast_alert):
     ```mesh
     fn fire_and_broadcast(pool :: PoolHandle, rule_id :: String, project_id :: String, rule_name :: String, condition_type :: String, message :: String) do
       let result = fire_alert(pool, rule_id, project_id, message, condition_type, rule_name)
       case result do
         Ok(alert_id) -> broadcast_alert(project_id, alert_id, rule_name, condition_type, message)
         Err(_) -> 0
       end
     end
     ```

     **extract_condition_field** -- Extract a field from condition_json string using PostgreSQL:
     ```mesh
     fn extract_condition_field(pool :: PoolHandle, condition_json :: String, field :: String) -> String!String do
       let rows = Pool.query(pool, "SELECT COALESCE($1::jsonb->>$2, '') AS val", [condition_json, field])?
       if List.length(rows) > 0 do
         Ok(Map.get(List.head(rows), "val"))
       else
         Ok("")
       end
     end
     ```

     **evaluate_single_threshold** -- Evaluate one threshold rule and fire if threshold exceeded:
     ```mesh
     fn evaluate_single_threshold(pool :: PoolHandle, rule_id :: String, project_id :: String, rule_name :: String, condition_json :: String, cooldown_str :: String) do
       let threshold_result = extract_condition_field(pool, condition_json, "threshold")
       case threshold_result do
         Ok(threshold_str) -> evaluate_threshold_with_window(pool, rule_id, project_id, rule_name, condition_json, cooldown_str, threshold_str)
         Err(_) -> 0
       end
     end
     ```

     **evaluate_threshold_with_window** -- Continue evaluation after threshold extracted:
     ```mesh
     fn evaluate_threshold_with_window(pool :: PoolHandle, rule_id :: String, project_id :: String, rule_name :: String, condition_json :: String, cooldown_str :: String, threshold_str :: String) do
       let window_result = extract_condition_field(pool, condition_json, "window_minutes")
       case window_result do
         Ok(window_str) -> check_and_fire_threshold(pool, rule_id, project_id, rule_name, cooldown_str, threshold_str, window_str)
         Err(_) -> 0
       end
     end
     ```

     **check_and_fire_threshold** -- Final threshold check and fire:
     ```mesh
     fn check_and_fire_threshold(pool :: PoolHandle, rule_id :: String, project_id :: String, rule_name :: String, cooldown_str :: String, threshold_str :: String, window_str :: String) do
       let should_fire_result = evaluate_threshold_rule(pool, rule_id, project_id, threshold_str, window_str, cooldown_str)
       case should_fire_result do
         Ok(should_fire) -> fire_threshold_if_needed(pool, rule_id, project_id, rule_name, should_fire, threshold_str, window_str)
         Err(_) -> 0
       end
     end
     ```

     **fire_threshold_if_needed** -- Fire if threshold exceeded:
     ```mesh
     fn fire_threshold_if_needed(pool :: PoolHandle, rule_id :: String, project_id :: String, rule_name :: String, should_fire :: Bool, threshold_str :: String, window_str :: String) do
       if should_fire do
         let message = "Event count exceeded " <> threshold_str <> " in " <> window_str <> " minutes"
         fire_and_broadcast(pool, rule_id, project_id, rule_name, "threshold", message)
       else
         0
       end
     end
     ```

     **evaluate_rules_loop** -- Loop through rules list by index:
     ```mesh
     fn evaluate_rules_loop(pool :: PoolHandle, rules, i :: Int, total :: Int, fired :: Int) -> Int!String do
       if i < total do
         let rule = List.get(rules, i)
         let rule_id = Map.get(rule, "id")
         let project_id = Map.get(rule, "project_id")
         let rule_name = Map.get(rule, "name")
         let condition_json = Map.get(rule, "condition_json")
         let cooldown_str = Map.get(rule, "cooldown_minutes")
         let _ = evaluate_single_threshold(pool, rule_id, project_id, rule_name, condition_json, cooldown_str)
         evaluate_rules_loop(pool, rules, i + 1, total, fired)
       else
         Ok(fired)
       end
     end
     ```

     **evaluate_all_threshold_rules** -- Load and evaluate all enabled threshold rules:
     ```mesh
     fn evaluate_all_threshold_rules(pool :: PoolHandle) -> Int!String do
       let rules = get_threshold_rules(pool)?
       evaluate_rules_loop(pool, rules, 0, List.length(rules), 0)
     end
     ```

     **log_eval_result** and **log_eval_error** -- Log helpers (extracted for single-expression case arms, decision [88-02]):
     ```mesh
     fn log_eval_result(n :: Int) do
       let _ = println("[Mesher] Alert evaluator: checked rules, " <> String.from(n) <> " fired")
       0
     end

     fn log_eval_error(e :: String) do
       let _ = println("[Mesher] Alert evaluator error: " <> e)
       0
     end
     ```

  3. Add the alert_evaluator actor (same pattern as spike_checker -- Timer.sleep + recursive call):
     ```mesh
     actor alert_evaluator(pool :: PoolHandle) do
       Timer.sleep(30000)
       let result = evaluate_all_threshold_rules(pool)
       case result do
         Ok(n) -> log_eval_result(n)
         Err(e) -> log_eval_error(e)
       end
       alert_evaluator(pool)
     end
     ```

  4. In start_pipeline function, spawn the alert_evaluator AFTER the spike_checker spawn:
     ```mesh
     # Spawn alert evaluator (30-second interval for threshold rules)
     let _ = spawn(alert_evaluator, pool)
     println("[Mesher] Alert evaluator started (30s interval)")
     ```

  5. In restart_all_services function, also spawn alert_evaluator after re-registering:
     ```mesh
     let _ = spawn(alert_evaluator, pool)
     ```

  IMPORTANT:
  - Follow spike_checker and health_checker patterns exactly (Timer.sleep + recursive actor, per decision [87-02])
  - All helper functions must be defined BEFORE the actor and BEFORE start_pipeline (define-before-use, decision [90-03])
  - Extract multi-line logic into helper functions (single-expression case arms, decision [88-02])
  - The evaluate_single_threshold chain uses extract_condition_field to parse JSON fields from condition_json via PostgreSQL (avoids cross-module from_json limitation, decision [88-02])
  - Do NOT use && operator; use separate if blocks or both_match helper if AND logic needed (decision [90-01])
  </action>
  <verify>Run `meshc build mesher/` and confirm zero new compilation errors beyond the 7 pre-existing ones. Grep pipeline.mpl for "alert_evaluator", "fire_and_broadcast", "evaluate_all_threshold_rules" to confirm all functions exist. Confirm start_pipeline spawns alert_evaluator.</verify>
  <done>alert_evaluator actor runs every 30 seconds, loads all enabled threshold rules, evaluates each rule's event count against threshold with cooldown check, fires alerts when conditions met, and broadcasts via WebSocket. start_pipeline and restart_all_services both spawn alert_evaluator.</done>
</task>

<task type="auto">
  <name>Task 2: Event-based alert triggers in routes.mpl</name>
  <files>mesher/ingestion/routes.mpl</files>
  <action>
  Extend routes.mpl to add event-based alert checking after event processing for ALERT-03 (new issue creation and regression).

  1. Add imports at the top of routes.mpl (extend existing `from Storage.Queries import` line):
     Add: `check_new_issue, get_event_alert_rules, should_fire_by_cooldown, fire_alert`
     to the existing import from Storage.Queries.

  2. Add helper functions BEFORE broadcast_event (define-before-use, decision [90-03]). These go after the broadcast_count_from_rows and broadcast_issue_count helpers but BEFORE broadcast_event:

     **broadcast_alert_notification** -- Broadcast alert to project room (ALERT-04):
     ```mesh
     fn broadcast_alert_notification(project_id :: String, alert_id :: String, rule_name :: String, condition_type :: String, message :: String) do
       let room = "project:" <> project_id
       let msg = "{\"type\":\"alert\",\"alert_id\":\"" <> alert_id <> "\",\"rule_name\":\"" <> rule_name <> "\",\"condition\":\"" <> condition_type <> "\",\"message\":\"" <> message <> "\"}"
       let _ = Ws.broadcast(room, msg)
       0
     end
     ```

     **fire_event_alert** -- Fire and broadcast a single event-based alert:
     ```mesh
     fn fire_event_alert(pool :: PoolHandle, rule_id :: String, project_id :: String, rule_name :: String, condition_type :: String, cooldown_str :: String, issue_id :: String) do
       let cooldown_ok = should_fire_by_cooldown(pool, rule_id, cooldown_str)
       case cooldown_ok do
         Ok(should_fire) -> fire_if_cooldown_ok(pool, rule_id, project_id, rule_name, condition_type, issue_id, should_fire)
         Err(_) -> 0
       end
     end
     ```

     **fire_if_cooldown_ok** -- Fire alert if cooldown allows:
     ```mesh
     fn fire_if_cooldown_ok(pool :: PoolHandle, rule_id :: String, project_id :: String, rule_name :: String, condition_type :: String, issue_id :: String, should_fire :: Bool) do
       if should_fire do
         let message = condition_type <> " detected for issue " <> issue_id
         let result = fire_alert(pool, rule_id, project_id, message, condition_type, rule_name)
         case result do
           Ok(alert_id) -> broadcast_alert_notification(project_id, alert_id, rule_name, condition_type, message)
           Err(_) -> 0
         end
       else
         0
       end
     end
     ```

     **fire_event_alerts_loop** -- Loop through matching rules and fire alerts:
     ```mesh
     fn fire_event_alerts_loop(pool :: PoolHandle, rules, project_id :: String, condition_type :: String, issue_id :: String, i :: Int, total :: Int) do
       if i < total do
         let rule = List.get(rules, i)
         let rule_id = Map.get(rule, "id")
         let rule_name = Map.get(rule, "name")
         let cooldown_str = Map.get(rule, "cooldown_minutes")
         let _ = fire_event_alert(pool, rule_id, project_id, rule_name, condition_type, cooldown_str, issue_id)
         fire_event_alerts_loop(pool, rules, project_id, condition_type, issue_id, i + 1, total)
       else
         0
       end
     end
     ```

     **fire_matching_event_alerts** -- Get matching rules and fire alerts for a condition type:
     ```mesh
     fn fire_matching_event_alerts(pool :: PoolHandle, project_id :: String, condition_type :: String, issue_id :: String) do
       let rules_result = get_event_alert_rules(pool, project_id, condition_type)
       case rules_result do
         Ok(rules) -> fire_event_alerts_loop(pool, rules, project_id, condition_type, issue_id, 0, List.length(rules))
         Err(_) -> 0
       end
     end
     ```

     **check_event_alerts** -- Check for new-issue alerts after event processing (ALERT-03):
     ```mesh
     fn check_event_alerts(pool :: PoolHandle, project_id :: String, issue_id :: String) do
       let new_result = check_new_issue(pool, issue_id)
       case new_result do
         Ok(is_new) -> handle_new_issue_alert(pool, project_id, issue_id, is_new)
         Err(_) -> 0
       end
     end
     ```

     **handle_new_issue_alert** -- Fire new_issue alerts if issue is new:
     ```mesh
     fn handle_new_issue_alert(pool :: PoolHandle, project_id :: String, issue_id :: String, is_new :: Bool) do
       if is_new do
         let _ = fire_matching_event_alerts(pool, project_id, "new_issue", issue_id)
         0
       else
         0
       end
     end
     ```

  3. Modify broadcast_event to also call check_event_alerts after broadcasting. The current broadcast_event function:
     ```mesh
     fn broadcast_event(project_id :: String, issue_id :: String, body :: String) do
       let room = "project:" <> project_id
       let notification = "{\"type\":\"event\",\"issue_id\":\"" <> issue_id <> "\",\"data\":" <> body <> "}"
       let _ = Ws.broadcast(room, notification)
       broadcast_issue_count(project_id)
       accepted_response()
     end
     ```

     Change it to call check_event_alerts before returning. But since we need pool for check_event_alerts, we need to get it from the registry:
     ```mesh
     fn broadcast_event(project_id :: String, issue_id :: String, body :: String) do
       let room = "project:" <> project_id
       let notification = "{\"type\":\"event\",\"issue_id\":\"" <> issue_id <> "\",\"data\":" <> body <> "}"
       let _ = Ws.broadcast(room, notification)
       let _ = broadcast_issue_count(project_id)
       let reg_pid = Process.whereis("mesher_registry")
       let pool = PipelineRegistry.get_pool(reg_pid)
       let _ = check_event_alerts(pool, project_id, issue_id)
       accepted_response()
     end
     ```

  IMPORTANT:
  - All new helper functions go BEFORE broadcast_event (define-before-use, decision [90-03])
  - broadcast_alert_notification and fire_event_alert must be defined before fire_event_alerts_loop
  - fire_matching_event_alerts before check_event_alerts
  - check_event_alerts and handle_new_issue_alert before broadcast_event
  - Single-expression case arms only (decision [88-02])
  - Do NOT use && operator (decision [90-01])
  - Regression detection: The upsert_issue query already flips resolved->unresolved. The check_new_issue query (first_seen = last_seen) detects truly new issues. For regression, we could add a separate check, but per the research open question #1, the simplest approach is to focus on new_issue detection for now. Regression detection can be added as a gap closure if needed (the upsert already handles the state flip; detecting it post-hoc requires modifying the upsert RETURNING clause which is out of scope for this plan).
  </action>
  <verify>Run `meshc build mesher/` and confirm zero new compilation errors beyond the 7 pre-existing ones. Grep routes.mpl for "check_event_alerts", "fire_matching_event_alerts", "broadcast_alert_notification" to confirm all functions exist. Confirm broadcast_event calls check_event_alerts.</verify>
  <done>Event-based alert checking runs after every successful event processing. When a new issue is detected (first_seen = last_seen), matching new_issue alert rules are loaded, cooldown is checked, and alerts are fired with WebSocket broadcast. The broadcast_event function calls check_event_alerts inline after event and issue count broadcasting.</done>
</task>

</tasks>

<verification>
1. `meshc build mesher/` compiles with no new errors (7 pre-existing max)
2. pipeline.mpl contains alert_evaluator actor with Timer.sleep(30000) + recursive call
3. pipeline.mpl start_pipeline spawns alert_evaluator
4. routes.mpl broadcast_event calls check_event_alerts
5. routes.mpl contains fire_matching_event_alerts, fire_event_alert, broadcast_alert_notification
6. Both timer-based and event-based paths call fire_alert from queries.mpl
7. Both paths check cooldown before firing (evaluate_threshold_rule has built-in cooldown check; event path uses should_fire_by_cooldown)
8. Both paths call Ws.broadcast to deliver alert notifications
</verification>

<success_criteria>
Timer-driven alert evaluator runs every 30 seconds and evaluates all enabled threshold rules. Event-based triggers fire alerts on new issue creation. Both paths enforce cooldown and broadcast via WebSocket. ALERT-02, ALERT-03, ALERT-04, and ALERT-05 are fully implemented.
</success_criteria>

<output>
After completion, create `.planning/phases/92-alerting-system/92-02-SUMMARY.md`
</output>
