---
phase: 92-alerting-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mesher/storage/schema.mpl
  - mesher/types/alert.mpl
  - mesher/storage/queries.mpl
autonomous: true

must_haves:
  truths:
    - "alerts table exists with id, rule_id, project_id, status, message, condition_snapshot, triggered_at, acknowledged_at, resolved_at columns"
    - "alert_rules table has cooldown_minutes and last_fired_at columns"
    - "Query helpers exist for alert rule CRUD, threshold evaluation, alert firing, cooldown check, alert state transitions, and alert listing"
  artifacts:
    - path: "mesher/storage/schema.mpl"
      provides: "alerts table DDL, alert_rules ALTER TABLE for cooldown_minutes and last_fired_at"
      contains: "alerts"
    - path: "mesher/types/alert.mpl"
      provides: "Alert fired record struct"
      contains: "pub struct Alert"
    - path: "mesher/storage/queries.mpl"
      provides: "Alert query functions: create_alert_rule, list_alert_rules, evaluate_threshold_rule, should_fire_alert, fire_alert, acknowledge_alert, resolve_alert, list_alerts"
      contains: "fire_alert"
  key_links:
    - from: "mesher/storage/queries.mpl"
      to: "mesher/types/alert.mpl"
      via: "import Alert struct"
      pattern: "from Types.Alert import"
    - from: "mesher/storage/schema.mpl"
      to: "PostgreSQL"
      via: "Pool.execute CREATE TABLE alerts"
      pattern: "CREATE TABLE IF NOT EXISTS alerts"
---

<objective>
Create the database schema, type definitions, and SQL query helpers for the alerting system.

Purpose: All alerting features (evaluation, firing, state management, CRUD) depend on the alerts table, extended alert_rules columns, and reusable query functions. This plan provides the data foundation.
Output: Extended schema.mpl with alerts table and alert_rules cooldown columns, extended types/alert.mpl with Alert fired record struct, extended queries.mpl with all alert query helpers.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/92-alerting-system/92-RESEARCH.md
@mesher/storage/schema.mpl
@mesher/types/alert.mpl
@mesher/storage/queries.mpl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend schema and types for alerting</name>
  <files>mesher/storage/schema.mpl, mesher/types/alert.mpl</files>
  <action>
  In schema.mpl, add the following AFTER the existing alert_rules CREATE TABLE statement (line 18) and BEFORE the indexes section:

  1. Add alerts table (new Pool.execute call):
     ```sql
     CREATE TABLE IF NOT EXISTS alerts (
       id UUID PRIMARY KEY DEFAULT uuidv7(),
       rule_id UUID NOT NULL REFERENCES alert_rules(id) ON DELETE CASCADE,
       project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
       status TEXT NOT NULL DEFAULT 'active',
       message TEXT NOT NULL,
       condition_snapshot JSONB NOT NULL,
       triggered_at TIMESTAMPTZ NOT NULL DEFAULT now(),
       acknowledged_at TIMESTAMPTZ,
       resolved_at TIMESTAMPTZ
     )
     ```

  2. Add cooldown_minutes and last_fired_at columns to alert_rules (two new Pool.execute calls):
     ```sql
     ALTER TABLE alert_rules ADD COLUMN IF NOT EXISTS cooldown_minutes INTEGER NOT NULL DEFAULT 60
     ALTER TABLE alert_rules ADD COLUMN IF NOT EXISTS last_fired_at TIMESTAMPTZ
     ```

  3. Add three indexes for alerts table (new Pool.execute calls in the indexes section):
     ```sql
     CREATE INDEX IF NOT EXISTS idx_alerts_project_status ON alerts(project_id, status)
     CREATE INDEX IF NOT EXISTS idx_alerts_rule ON alerts(rule_id)
     CREATE INDEX IF NOT EXISTS idx_alerts_triggered ON alerts(triggered_at DESC)
     ```

  In types/alert.mpl, add a new Alert struct (fired alert record) AFTER the existing AlertCondition struct:

  ```mesh
  pub struct Alert do
    id :: String
    rule_id :: String
    project_id :: String
    status :: String
    message :: String
    condition_snapshot :: String
    triggered_at :: String
    acknowledged_at :: String
    resolved_at :: String
  end deriving(Json, Row)
  ```

  IMPORTANT: Keep all existing types (AlertRule, AlertCondition) unchanged. The Alert struct uses all-String fields following the Row struct convention (decision [87-01]). JSONB fields stored as String. Nullable timestamps (acknowledged_at, resolved_at) will be COALESCE'd to empty string in queries.

  Follow the existing schema.mpl pattern: each DDL statement is a separate Pool.execute call with []? for error propagation.
  </action>
  <verify>Run `meshc build mesher/` and confirm zero new compilation errors beyond the 7 pre-existing ones. Verify schema.mpl contains "alerts" table DDL and "cooldown_minutes" ALTER. Verify types/alert.mpl contains `pub struct Alert`.</verify>
  <done>alerts table DDL exists in schema.mpl with all 9 columns. alert_rules has cooldown_minutes and last_fired_at ALTER statements. Three alerts indexes added. Alert struct defined in types/alert.mpl with deriving(Json, Row).</done>
</task>

<task type="auto">
  <name>Task 2: Add alert query helpers to queries.mpl</name>
  <files>mesher/storage/queries.mpl</files>
  <action>
  Add a new section at the END of queries.mpl (after the existing API token management section), with the header comment:

  ```
  # --- Alert system queries (Phase 92) ---
  ```

  Add the import for Alert at the top of the file alongside existing imports:
  ```mesh
  from Types.Alert import AlertRule, Alert
  ```
  (Update the existing `from Types.Alert import AlertRule` to also import Alert.)

  Add the following query functions, ordered bottom-up (leaf helpers first, per decision [90-03]):

  1. **create_alert_rule** -- ALERT-01: Insert alert rule from JSON body using PostgreSQL JSONB extraction.
     ```mesh
     pub fn create_alert_rule(pool :: PoolHandle, project_id :: String, body :: String) -> String!String do
       let sql = "INSERT INTO alert_rules (project_id, name, condition_json, action_json, cooldown_minutes) SELECT $1::uuid, COALESCE(j->>'name', 'Unnamed Rule'), COALESCE((j->'condition')::jsonb, '{}'::jsonb), COALESCE((j->'action')::jsonb, '{\"type\":\"websocket\"}'::jsonb), COALESCE((j->>'cooldown_minutes')::int, 60) FROM (SELECT $2::jsonb AS j) AS sub RETURNING id::text"
       let rows = Pool.query(pool, sql, [project_id, body])?
       if List.length(rows) > 0 do
         Ok(Map.get(List.head(rows), "id"))
       else
         Err("create_alert_rule: no id returned")
       end
     end
     ```

  2. **list_alert_rules** -- ALERT-01: List all alert rules for a project.
     ```mesh
     pub fn list_alert_rules(pool :: PoolHandle, project_id :: String) -> List<Map<String, String>>!String do
       let sql = "SELECT id::text, project_id::text, name, condition_json::text, action_json::text, enabled::text, cooldown_minutes::text, COALESCE(last_fired_at::text, '') AS last_fired_at, created_at::text FROM alert_rules WHERE project_id = $1::uuid ORDER BY created_at DESC"
       let rows = Pool.query(pool, sql, [project_id])?
       Ok(rows)
     end
     ```

  3. **toggle_alert_rule** -- Enable/disable an alert rule.
     ```mesh
     pub fn toggle_alert_rule(pool :: PoolHandle, rule_id :: String, enabled_str :: String) -> Int!String do
       Pool.execute(pool, "UPDATE alert_rules SET enabled = $2::boolean WHERE id = $1::uuid", [rule_id, enabled_str])
     end
     ```

  4. **delete_alert_rule** -- Delete an alert rule.
     ```mesh
     pub fn delete_alert_rule(pool :: PoolHandle, rule_id :: String) -> Int!String do
       Pool.execute(pool, "DELETE FROM alert_rules WHERE id = $1::uuid", [rule_id])
     end
     ```

  5. **evaluate_threshold_rule** -- ALERT-02: Count events in time window AND check cooldown, return true if should fire.
     ```mesh
     pub fn evaluate_threshold_rule(pool :: PoolHandle, rule_id :: String, project_id :: String, threshold_str :: String, window_str :: String, cooldown_str :: String) -> Bool!String do
       let sql = "SELECT CASE WHEN event_count > $3::int AND (last_fired IS NULL OR last_fired < now() - interval '1 minute' * $6::int) THEN 1 ELSE 0 END AS should_fire FROM (SELECT count(*) AS event_count FROM events WHERE project_id = $2::uuid AND received_at > now() - interval '1 minute' * $4::int) counts, (SELECT last_fired_at AS last_fired FROM alert_rules WHERE id = $1::uuid) cooldown"
       let rows = Pool.query(pool, sql, [rule_id, project_id, threshold_str, window_str, "", cooldown_str])?
       if List.length(rows) > 0 do
         let should_fire = Map.get(List.head(rows), "should_fire")
         Ok(should_fire == "1")
       else
         Ok(false)
       end
     end
     ```

  6. **fire_alert** -- ALERT-04/05: Insert alert record, update last_fired_at atomically, return alert_id.
     ```mesh
     pub fn fire_alert(pool :: PoolHandle, rule_id :: String, project_id :: String, message :: String, condition_type :: String, rule_name :: String) -> String!String do
       let sql = "INSERT INTO alerts (rule_id, project_id, status, message, condition_snapshot) VALUES ($1::uuid, $2::uuid, 'active', $3, jsonb_build_object('condition_type', $4, 'rule_name', $5)) RETURNING id::text"
       let rows = Pool.query(pool, sql, [rule_id, project_id, message, condition_type, rule_name])?
       if List.length(rows) > 0 do
         let alert_id = Map.get(List.head(rows), "id")
         let _ = Pool.execute(pool, "UPDATE alert_rules SET last_fired_at = now() WHERE id = $1::uuid", [rule_id])
         Ok(alert_id)
       else
         Err("fire_alert: no id returned")
       end
     end
     ```

  7. **check_new_issue** -- ALERT-03: Check if an issue was just created (first_seen = last_seen).
     ```mesh
     pub fn check_new_issue(pool :: PoolHandle, issue_id :: String) -> Bool!String do
       let rows = Pool.query(pool, "SELECT 1 AS is_new FROM issues WHERE id = $1::uuid AND first_seen = last_seen", [issue_id])?
       Ok(List.length(rows) > 0)
     end
     ```

  8. **get_event_alert_rules** -- ALERT-03: Get enabled alert rules for event-based conditions for a project.
     ```mesh
     pub fn get_event_alert_rules(pool :: PoolHandle, project_id :: String, condition_type :: String) -> List<Map<String, String>>!String do
       let sql = "SELECT id::text, name, cooldown_minutes::text FROM alert_rules WHERE project_id = $1::uuid AND enabled = true AND condition_json->>'condition_type' = $2"
       let rows = Pool.query(pool, sql, [project_id, condition_type])?
       Ok(rows)
     end
     ```

  9. **should_fire_by_cooldown** -- ALERT-05: Check cooldown before firing (for event-based triggers).
     ```mesh
     pub fn should_fire_by_cooldown(pool :: PoolHandle, rule_id :: String, cooldown_str :: String) -> Bool!String do
       let rows = Pool.query(pool, "SELECT 1 AS ok FROM alert_rules WHERE id = $1::uuid AND (last_fired_at IS NULL OR last_fired_at < now() - interval '1 minute' * $2::int)", [rule_id, cooldown_str])?
       Ok(List.length(rows) > 0)
     end
     ```

  10. **acknowledge_alert** -- ALERT-06: Transition alert to acknowledged.
      ```mesh
      pub fn acknowledge_alert(pool :: PoolHandle, alert_id :: String) -> Int!String do
        Pool.execute(pool, "UPDATE alerts SET status = 'acknowledged', acknowledged_at = now() WHERE id = $1::uuid AND status = 'active'", [alert_id])
      end
      ```

  11. **resolve_fired_alert** -- ALERT-06: Transition alert to resolved.
      ```mesh
      pub fn resolve_fired_alert(pool :: PoolHandle, alert_id :: String) -> Int!String do
        Pool.execute(pool, "UPDATE alerts SET status = 'resolved', resolved_at = now() WHERE id = $1::uuid AND status IN ('active', 'acknowledged')", [alert_id])
      end
      ```

  12. **list_alerts** -- ALERT-06: List alerts for a project filtered by status.
      ```mesh
      pub fn list_alerts(pool :: PoolHandle, project_id :: String, status :: String) -> List<Map<String, String>>!String do
        let sql = "SELECT a.id::text, a.rule_id::text, a.project_id::text, a.status, a.message, a.condition_snapshot::text, a.triggered_at::text, COALESCE(a.acknowledged_at::text, '') AS acknowledged_at, COALESCE(a.resolved_at::text, '') AS resolved_at, r.name AS rule_name FROM alerts a JOIN alert_rules r ON r.id = a.rule_id WHERE a.project_id = $1::uuid AND ($2 = '' OR a.status = $2) ORDER BY a.triggered_at DESC LIMIT 50"
        let rows = Pool.query(pool, sql, [project_id, status])?
        Ok(rows)
      end
      ```

  13. **get_threshold_rules** -- Load all enabled threshold rules for evaluation.
      ```mesh
      pub fn get_threshold_rules(pool :: PoolHandle) -> List<Map<String, String>>!String do
        let sql = "SELECT id::text, project_id::text, name, condition_json::text, cooldown_minutes::text FROM alert_rules WHERE enabled = true AND condition_json->>'condition_type' = 'threshold'"
        let rows = Pool.query(pool, sql, [])?
        Ok(rows)
      end
      ```

  IMPORTANT: All query functions follow existing patterns from queries.mpl:
  - Use Pool.query for SELECT (returns List<Map<String,String>>)
  - Use Pool.execute for UPDATE/DELETE (returns Int)
  - Use ? operator for error propagation
  - Cast UUID columns to ::text for Row compatibility (decision [87-01])
  - Use COALESCE for nullable timestamp fields (empty string when null)
  - Return raw Map rows (not typed structs) for list endpoints (decision [91-01])
  </action>
  <verify>Run `meshc build mesher/` and confirm zero new compilation errors beyond the 7 pre-existing ones. Grep queries.mpl for "fire_alert", "acknowledge_alert", "evaluate_threshold_rule", "create_alert_rule" to confirm all functions exist.</verify>
  <done>13 alert query functions exist in queries.mpl covering: alert rule CRUD (create, list, toggle, delete), threshold evaluation, alert firing with cooldown update, new issue detection, event-based rule lookup, cooldown check, alert state transitions (acknowledge, resolve), alert listing, and threshold rule loading.</done>
</task>

</tasks>

<verification>
1. `meshc build mesher/` compiles with no new errors (7 pre-existing max)
2. schema.mpl contains `CREATE TABLE IF NOT EXISTS alerts` with all 9 columns
3. schema.mpl contains `ALTER TABLE alert_rules ADD COLUMN IF NOT EXISTS cooldown_minutes`
4. schema.mpl contains `ALTER TABLE alert_rules ADD COLUMN IF NOT EXISTS last_fired_at`
5. schema.mpl contains 3 new indexes (idx_alerts_project_status, idx_alerts_rule, idx_alerts_triggered)
6. types/alert.mpl contains `pub struct Alert` with 9 fields and `deriving(Json, Row)`
7. queries.mpl contains all 13 new alert functions
</verification>

<success_criteria>
All alert schema DDL, type definitions, and query helpers exist and compile. Subsequent plans (92-02, 92-03) can import and use these query functions without modification.
</success_criteria>

<output>
After completion, create `.planning/phases/92-alerting-system/92-01-SUMMARY.md`
</output>
